const{entries:$}=Object,{fromEntries:et}=Object,st="ENTRIES",D="KEYS",W="VALUES",_="";class S{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=b(this._path);if(b(s)===_)return{done:!1,value:this.result()};const n=t.get(b(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=b(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>b(t)).filter(t=>t!==_).join("")}value(){return b(this._path).node.get(_)}result(){switch(this._type){case W:return this.value();case D:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const b=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,r=o+s,c=new Uint8Array(r*o).fill(s+1);for(let i=0;i<o;++i)c[i]=i;for(let i=1;i<r;++i)c[i*o]=i;return q(e,t,s,n,c,1,o,""),n},q=(e,t,s,n,o,r,c,i)=>{const h=r*c;t:for(const u of e.keys())if(u===_){const l=o[h-1];l<=s&&n.set(i,[e.get(u),l])}else{let l=r;for(let f=0;f<u.length;++f,++l){const m=u[f],g=c*l,y=g-c;let d=o[g];const a=Math.max(0,l-s-1),w=Math.min(c-1,l+s);for(let p=a;p<w;++p){const O=m!==t[p],C=o[y+p]+ +O,k=o[y+p+1]+1,x=o[g+p]+1,v=o[g+p+1]=Math.min(C,k,x);v<d&&(d=v)}if(d>s)continue t}q(e.get(u),t,s,n,o,l,c,i+u)}};class z{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=I(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,r]=L(n);for(const c of o.keys())if(c!==_&&c.startsWith(r)){const i=new Map;return i.set(c.slice(r.length),o.get(c)),new z(i,t)}}return new z(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new S(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=F(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){return F(this._tree,t)?.has(_)??!1}keys(){return new S(this,D)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,E(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=E(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=E(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new S(this,W)}[Symbol.iterator](){return this.entries()}static from(t){const s=new z;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return z.from(Object.entries(t))}}const I=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),I(e.get(n),t.slice(n.length),s);return s.push([e,t]),I(void 0,"",s)},F=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return F(e.get(s),t.slice(s.length))},E=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const r of e.keys())if(r!==_&&t[n]===r[0]){const c=Math.min(s-n,r.length);let i=1;for(;i<c&&t[n+i]===r[i];)++i;const h=e.get(r);if(i===r.length)e=h;else{const u=new Map;u.set(r.slice(i),h),e.set(t.slice(n,n+i),u),e.delete(r),e=u}n+=i;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=I(e,t);if(s!==void 0){if(s.delete(_),s.size===0)R(n);else if(s.size===1){const[o,r]=s.entries().next().value;A(n,o,r)}}},R=e=>{if(e.length===0)return;const[t,s]=L(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&A(e.slice(0,-1),n,o)}},A=(e,t,s)=>{if(e.length===0)return;const[n,o]=L(e);n.set(o+t,s),n.delete(o)},L=e=>e[e.length-1],rt=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r\p{Z}\p{P}]+/u,j="or",N="and",ct="and_not",ut=(e,t)=>{e.includes(t)||e.push(t)},B=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,M=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[j]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:r,match:c}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,c),B(n.terms,r)}}return e},[N]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:r,terms:c,match:i}=t.get(n);B(o.terms,c),s.set(n,{score:o.score+r,terms:o.terms,match:Object.assign(o.match,i)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,r)=>{const{k:c,b:i,d:h}=r;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(c+1)/(e+c*(1-i+i*n/o)))},at=e=>(t,s,n)=>({term:t,fuzzy:typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy??!1,prefix:typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0,termBoost:typeof e.boostTerm=="function"?e.boostTerm(t,s,n):1}),H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),r=o.get(t);r?.get(s)==null?H(e,s,t,n):r.get(s)<=1?r.size<=1?o.delete(t):r.delete(s):r.set(s,r.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},gt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:j,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},pt={combineWith:N,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},Y={minDirtFactor:.1,minDirtCount:20},yt={..._t,...Y},K=Symbol("*"),wt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,r]of e._documentIds){const c=n.boostDocument?n.boostDocument(r,"",e._storedFields.get(o)):1;s.set(o,{score:c,terms:[],match:{}})}return s},U=(e,t=j)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},T=(e,t,s,n,o,r,c,i,h,u=new Map)=>{if(r==null)return u;for(const l of Object.keys(c)){const f=c[l],m=e._fieldIds[l],g=r.get(m);if(g==null)continue;let y=g.size;const d=e._avgFieldLength[m];for(const a of g.keys()){if(!e._documentIds.has(a)){ft(e,m,a,s),y-=1;continue}const w=i?i(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!w)continue;const p=g.get(a),O=e._fieldLength.get(a)[m],C=dt(p,y,e._documentCount,O,d,h),k=n*o*f*w*C,x=u.get(a);if(x){x.score+=k,ut(x.terms,t);const v=G(x.match,s);v?v.push(l):x.match[s]=[l]}else u.set(a,{score:k,terms:[t],match:{[s]:[l]}})}}return u},xt=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields??e._options.fields).reduce((d,a)=>({...d,[a]:G(n.boost,a)||1}),{}),{boostDocument:r,weights:c,maxFuzzy:i,bm25:h}=n,{fuzzy:u,prefix:l}={...J.weights,...c},f=e._index.get(t.term),m=T(e,t.term,t.term,1,t.termBoost,f,o,r,h);let g,y;if(t.prefix&&(g=e._index.atPrefix(t.term)),t.fuzzy){const d=t.fuzzy===!0?.2:t.fuzzy,a=d<1?Math.min(i,Math.round(t.term.length*d)):d;a&&(y=e._index.fuzzyGet(t.term,a))}if(g)for(const[d,a]of g){const w=d.length-t.term.length;if(!w)continue;y?.delete(d);const p=l*d.length/(d.length+.3*w);T(e,t.term,d,p,t.termBoost,a,o,r,h,m)}if(y)for(const d of y.keys()){const[a,w]=y.get(d);if(!w)continue;const p=u*d.length/(d.length+w);T(e,t.term,d,p,t.termBoost,a,o,r,h,m)}return m},Q=(e,t,s={})=>{if(t===K)return wt(e,s);if(typeof t!="string"){const l={...s,...t,queries:void 0},f=t.queries.map(m=>Q(e,m,l));return U(f,l.combineWith)}const{tokenize:n,processTerm:o,searchOptions:r}=e._options,c={tokenize:n,processTerm:o,...r,...s},{tokenize:i,processTerm:h}=c,u=i(t).flatMap(l=>h(l)).filter(l=>!!l).map(at(c)).map(l=>xt(e,l,c));return U(u,c.combineWith)},X=(e,t,s={})=>{const n=Q(e,t,s),o=[];for(const[r,{score:c,terms:i,match:h}]of n){const u=i.length||1,l={id:e._documentIds.get(r),score:c*u,terms:Object.keys(h),queryTerms:i,match:h};Object.assign(l,e._storedFields.get(r)),(s.filter==null||s.filter(l))&&o.push(l)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},zt=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:r,terms:c}of X(e,t,s)){const i=c.join(" "),h=n.get(i);h!=null?(h.score+=r,h.count+=1):n.set(i,{score:r,terms:c,count:1})}const o=[];for(const[r,{score:c,terms:i,count:h}]of n)o.push({suggestion:r,terms:i,score:c/h});return o.sort(P),o};class bt{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...gt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions},autoSuggestOptions:{...pt,...t.autoSuggestOptions}},this._index=new z,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=Y,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[r,c]of n)o[r]=Object.fromEntries(c);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,version:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const vt=e=>new bt(e),kt=({documentCount:e,nextId:t,fieldIds:s,averageFieldLength:n,dirtCount:o,version:r},c)=>{if(r!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const i=vt(c);return i._documentCount=e,i._nextId=t,i._idToShortId=new Map,i._fieldIds=s,i._avgFieldLength=n,i._dirtCount=o??0,i._index=new z,i},It=(e,t)=>{const{index:s,documentIds:n,fieldLength:o,storedFields:r}=e,c=kt(e,t);c._documentIds=M(n),c._fieldLength=M(o),c._storedFields=M(r);for(const[i,h]of c._documentIds)c._idToShortId.set(h,i);for(const[i,h]of s){const u=new Map;for(const l of Object.keys(h))u.set(parseInt(l,10),M(h[l]));c._index.set(i,u)}return c},V=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let r=0,c=0;const i=(u,l=!1)=>{let f;c===0?f=u.length>20?`… ${u.slice(-20)}`:u:l?f=u.length+c>100?`${u.slice(0,100-c)}… `:u:f=u.length>20?`${u.slice(0,20)} … ${u.slice(-20)}`:u,f&&o.push(f),c+=f.length,l||(o.push(["mark",t]),c+=t.length,c>=100&&o.push(" …"))};let h=s.indexOf(n,r);if(h===-1)return null;for(;h>=0;){const u=h+n.length;if(i(e.slice(r,h)),r=u,c>100)break;h=s.indexOf(n,r)}return c<100&&i(e.slice(r),!0),o},Mt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),Ot=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return X(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:r,terms:c,score:i}=o,h=r.includes("@"),u=r.includes("#"),[l,f]=r.split(/[#@]/),m=Number(l),g=c.sort((d,a)=>d.length-a.length).filter((d,a)=>c.slice(a+1).every(w=>!w.includes(d))),{contents:y}=n[m]??={title:"",contents:[]};if(h)y.push([{type:"customField",id:m,index:f,display:g.map(d=>o.c.map(a=>V(a,d))).flat().filter(d=>d!==null)},i]);else{const d=g.map(a=>V(o.h,a)).filter(a=>a!==null);if(d.length&&y.push([{type:u?"heading":"title",id:m,...u&&{anchor:f},display:d},i]),"t"in o&&o.t)for(const a of o.t){const w=g.map(p=>V(a,p)).filter(p=>p!==null);w.length&&y.push([{type:"text",id:m,...u&&{anchor:f},display:w},i])}}}),$(n).sort(([,o],[,r])=>"max"==="total"?Mt(o,r):Ot(o,r)).map(([o,{title:r,contents:c}])=>{if(!r){const i=rt(t,o);i&&(r=i.h)}return{title:r,contents:c.map(([i])=>i)}})},tt=(e,t,s={})=>{const n=zt(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},Ct=et($(JSON.parse("{\"/\":{\"documentCount\":1276,\"nextId\":1276,\"documentIds\":{\"0\":\"0\",\"1\":\"0#前言\",\"2\":\"1\",\"3\":\"1#_0\",\"4\":\"1#数组\",\"5\":\"1#二分查找\",\"6\":\"1#移除元素\",\"7\":\"1#链表\",\"8\":\"1#栈与队列\",\"9\":\"1#二叉树\",\"10\":\"1#回溯\",\"11\":\"1#贪心\",\"12\":\"1#动态规划\",\"13\":\"2\",\"14\":\"2#_0-序\",\"15\":\"3\",\"16\":\"3#_0-序\",\"17\":\"4\",\"18\":\"4#_0-序\",\"19\":\"4#wine\",\"20\":\"5\",\"21\":\"5#_1-html\",\"22\":\"5#_2-css\",\"23\":\"5#_2-1-less\",\"24\":\"5#_2-2-scoped-和-deep\",\"25\":\"5#bem-命名规范\",\"26\":\"5#概念与用法\",\"27\":\"6\",\"28\":\"6#进程线程区别\",\"29\":\"6#一、多线程基础知识\",\"30\":\"6#为什么要使用多线程\",\"31\":\"6#创建线程的四种方式\",\"32\":\"6#runnable-和-thread\",\"33\":\"6#runnable-和-callable\",\"34\":\"6#start-run\",\"35\":\"6#sleep-yiled-wait-join\",\"36\":\"6#为什么-wait-和-notify-属于-object-类\",\"37\":\"6#sleep-和-wait-的异同\",\"38\":\"6#线程、\",\"39\":\"6#threadlocal\",\"40\":\"6#threadlocal-和-synchronized-的对比\",\"41\":\"6#threadlocal-的内部结构-设计过程\",\"42\":\"6#threadlocalmap-的结构\",\"43\":\"6#threadlocal-在-spring-中的使用\",\"44\":\"6#threadlocal-的应用\",\"45\":\"6#threadlocal-内存泄露问题\",\"46\":\"6#threadlocal-key-为什么使用弱引用\",\"47\":\"6#threadlocal-hash-冲突的解决\",\"48\":\"6#如何判断是否线程安全\",\"49\":\"6#fork-join-框架\",\"50\":\"6#生产者消费者模式\",\"51\":\"6#如何控制线程执行顺序\",\"52\":\"6#二、线程池\",\"53\":\"6#线程池的好处\",\"54\":\"6#线程池处理任务的流程\",\"55\":\"6#_4-种常见线程池及选择\",\"56\":\"6#executors-有四种线程池的实现方式\",\"57\":\"6#线程池创建多少线程合适\",\"58\":\"6#threadpoolexecutor-的参数\",\"59\":\"6#创建、关闭线程池\",\"60\":\"6#handler-拒绝策略\",\"61\":\"6#execute-submit-的区别\",\"62\":\"6#阻塞队列\",\"63\":\"6#线程池的生命周期、状态\",\"64\":\"6#线程池中的线程数一般怎么设置\",\"65\":\"6#三、jmm-java-内存模型-⭐\",\"66\":\"6#主存与工作内存\",\"67\":\"6#原子性、可见性、有序性\",\"68\":\"6#如何保证原子性\",\"69\":\"6#如何保证可见性\",\"70\":\"6#如何保证有序性\",\"71\":\"6#打破有序性的三种重排序\",\"72\":\"6#jmm-中缓存一致性-cpu-层级下\",\"73\":\"6#jmm-的内存交互-变量如何从主内存到本地内存以及从本地内存到主内存\",\"74\":\"6#jmm-的作用是什么\",\"75\":\"6#happens-before-是什么\",\"76\":\"6#as-if-serial-是什么\",\"77\":\"6#as-if-serial-和-happens-before-有什么区别\",\"78\":\"6#volatile-关键字\",\"79\":\"6#volatile-和-synchronized-的区别-⭐\",\"80\":\"6#四、锁\",\"81\":\"6#锁设计-锁分类\",\"82\":\"6#synchronized\",\"83\":\"6#synchronized-修饰方法\",\"84\":\"6#mark-word-结构\",\"85\":\"6#monitor-原理\",\"86\":\"6#synchronized-锁升级\",\"87\":\"6#轻量级锁\",\"88\":\"6#偏向锁-用来优化轻量级锁的锁重入问题\",\"89\":\"6#锁膨胀-轻量级锁变重量级锁\",\"90\":\"6#synchronized-锁优化\",\"91\":\"6#自旋优化\",\"92\":\"6#锁清除\",\"93\":\"6#锁粗化\",\"94\":\"6#synchronized-和-lock\",\"95\":\"6#reentrantlock\",\"96\":\"6#reentrantlock-可重入实现\",\"97\":\"6#死锁、活锁、饥饿\",\"98\":\"6#死锁\",\"99\":\"6#活锁\",\"100\":\"6#饥饿\",\"101\":\"6#单例-双重校验锁-dcl\",\"102\":\"6#happens-before\",\"103\":\"6#乐观锁-cas-版本号\",\"104\":\"6#为什么要用-cas\",\"105\":\"6#cas-compare-and-swap\",\"106\":\"6#cas-的问题-aba\",\"107\":\"6#五、juc\",\"108\":\"6#jdk-中提供了哪些并发容器\",\"109\":\"6#aqs-抽象队列式同步器\",\"110\":\"6#aqs-原理\",\"111\":\"6#aqs-源码分析\",\"112\":\"6#aqs-对资源的共享方式\",\"113\":\"6#exclusive\",\"114\":\"6#公平锁与非公平锁\",\"115\":\"6#share\",\"116\":\"6#aqs-组件\",\"117\":\"6#semaphore-信号量\",\"118\":\"6#countdownlatch-倒计时器\",\"119\":\"6#countdownlatch-的不足\",\"120\":\"6#cyclicbarrier-循环栅栏\",\"121\":\"6#cyclicbarrier-和-countdownlatch-的区别\",\"122\":\"6#为什么只有前驱节点是头节点时才能尝试获取同步状态\",\"123\":\"6#共享式获取-释放锁的原理\",\"124\":\"6#独占式获取锁的流程\",\"125\":\"6#reentrantreadwritelock\",\"126\":\"6#condition-接口\",\"127\":\"6#exchanger-线程间交换数据\",\"128\":\"6#concurrenthashmap-是如何保证线程安全的\",\"129\":\"6#jdk7-的-concurrenthashmap-原理\",\"130\":\"6#jdk8-的-concurrenthashmap-原理\",\"131\":\"6#jdk1-8-弃用分段锁的原因-而使用-cas-synchronized\",\"132\":\"6#操作系统的特征\",\"133\":\"6#大内核-微内核\",\"134\":\"6#内核态和用户态\",\"135\":\"6#系统调用\",\"136\":\"6#pcb-和-tcb\",\"137\":\"6#i-o\",\"138\":\"6#零拷贝\",\"139\":\"6#程序、进程、线程、协程\",\"140\":\"6#线程相关\",\"141\":\"6#线程间通信方式\",\"142\":\"6#线程同步\",\"143\":\"6#用户线程、守护线程\",\"144\":\"6#线程上下文切换\",\"145\":\"6#为什么进程上下文切换代价更高\",\"146\":\"6#进程相关\",\"147\":\"6#进程切换\",\"148\":\"6#进程的状态转换\",\"149\":\"6#进程间通信方式\",\"150\":\"6#进程调度算法\",\"151\":\"6#僵尸进程、孤儿进程\",\"152\":\"6#内存管理机制\",\"153\":\"6#内存管理主要是做什么的\",\"154\":\"6#内存碎片\",\"155\":\"6#分页与分段的区别\",\"156\":\"6#虚拟地址和物理地址之间的映射\",\"157\":\"6#虚拟内存-页面置换\",\"158\":\"6#局部性原理\",\"159\":\"6#缺页中断-缺页异常\",\"160\":\"6#页面置换算法\",\"161\":\"6#动态链接库和静态链接库\",\"162\":\"6#编译系统\",\"163\":\"6#磁盘调度算法\",\"164\":\"7\",\"165\":\"7#一、类加载机制\",\"166\":\"7#判断两个类是否相同\",\"167\":\"7#类加载过程\",\"168\":\"7#step1-加载\",\"169\":\"7#step2-连接\",\"170\":\"7#验证\",\"171\":\"7#准备\",\"172\":\"7#解析\",\"173\":\"7#step3-初始化\",\"174\":\"7#主动初始化\",\"175\":\"7#类加载器的分类\",\"176\":\"7#启动类加载器-引导类加载器\",\"177\":\"7#扩展类加载器\",\"178\":\"7#应用程序类加载器-系统类加载器\",\"179\":\"7#线程上下文类加载器\",\"180\":\"7#自定义类加载器\",\"181\":\"7#jdk9新特性\",\"182\":\"7#classloader类\",\"183\":\"7#class-forname-与classloader-loadclass-的区别\",\"184\":\"7#双亲委派机制\",\"185\":\"7#破坏双亲委派模型\",\"186\":\"7#沙箱安全机制\",\"187\":\"7#热替换的实现\",\"188\":\"7#二、运行时数据区\",\"189\":\"7#程序计数器\",\"190\":\"7#java虚拟机栈\",\"191\":\"7#运行时栈帧结构\",\"192\":\"7#局部变量表\",\"193\":\"7#操作数栈\",\"194\":\"7#动态连接\",\"195\":\"7#方法返回地址\",\"196\":\"7#附加信息\",\"197\":\"7#本地方法栈\",\"198\":\"7#java堆和栈的区别-为什么要这么设计-为什么要堆栈分离\",\"199\":\"7#java堆\",\"200\":\"7#将年轻代划分出survivor区的作用\",\"201\":\"7#cpu100-问题如何快速定位\",\"202\":\"7#逃逸分析\",\"203\":\"7#方法区\",\"204\":\"7#方法区的演进细节\",\"205\":\"7#方法区的实现从永久代变成元空间有什么区别\",\"206\":\"7#永久代为何被元空间替代\",\"207\":\"7#stringtable为什么要调整\",\"208\":\"7#运行时常量池\",\"209\":\"7#直接内存\",\"210\":\"7#直接内存使用场景\",\"211\":\"7#三、对象的实例化\",\"212\":\"7#创建对象的方式\",\"213\":\"7#创建对象的步骤-过程\",\"214\":\"7#step1-类加载检查-判断对象对应的类是否加载、连接、初始化\",\"215\":\"7#step2-分配内存\",\"216\":\"7#指针碰撞\",\"217\":\"7#空闲列表\",\"218\":\"7#如何选择分配方式\",\"219\":\"7#内存分配的并发问题\",\"220\":\"7#内存分配策略-对象promotion策略\",\"221\":\"7#step3-初始化零值\",\"222\":\"7#step4-设置对象头\",\"223\":\"7#step5-执行init-方法\",\"224\":\"7#对象的内存布局\",\"225\":\"7#_1、对象头\",\"226\":\"7#_2、实例数据\",\"227\":\"7#_3、对齐填充\",\"228\":\"7#对象的访问定位\",\"229\":\"7#_1、使用句柄\",\"230\":\"7#_2、直接指针\",\"231\":\"7#四、垃圾收集\",\"232\":\"7#对象是否需要回收\",\"233\":\"7#引用计数法\",\"234\":\"7#可达性分析算法\",\"235\":\"7#引用强度分类\",\"236\":\"7#不可达对象不是非死不可\",\"237\":\"7#方法区的gc、如何判断类没用了\",\"238\":\"7#垃圾收集算法\",\"239\":\"7#分代收集理论\",\"240\":\"7#为什么需要分代\",\"241\":\"7#新生代什么时候会变成老年代\",\"242\":\"7#什么时候触发minor-gc\",\"243\":\"7#什么时候触发major-gc\",\"244\":\"7#标记-清除算法\",\"245\":\"7#标记-复制算法-young区用\",\"246\":\"7#标记-整理-压缩-算法-old区用\",\"247\":\"7#card-table\",\"248\":\"7#hotspot的算法细节\",\"249\":\"7#记忆集与卡表\",\"250\":\"7#写屏障\",\"251\":\"7#并发的可达性分析-增量更新、satb\",\"252\":\"7#经典垃圾收集器\",\"253\":\"7#查看默认的垃圾回收器\",\"254\":\"7#serial收集器\",\"255\":\"7#parnew收集器\",\"256\":\"7#serial-old收集器\",\"257\":\"7#parallel-scavenge-收集器-jdk8\",\"258\":\"7#parallel-old收集器-jdk8\",\"259\":\"7#cms收集器\",\"260\":\"7#g1收集器-jdk9\",\"261\":\"7#应用场景\",\"262\":\"7#相对cms的缺点\",\"263\":\"7#g1调优\",\"264\":\"7#g1垃圾回收过程\",\"265\":\"7#g1的记忆集\",\"266\":\"7#低延迟垃圾收集器\",\"267\":\"7#shenandoah\",\"268\":\"7#zgc\",\"269\":\"7#gc的日志分析\",\"270\":\"7#内存分配与垃圾回收参数列表\",\"271\":\"7#日志分析工具\",\"272\":\"7#五、其他\",\"273\":\"7#方法调用\",\"274\":\"7#解析-1\",\"275\":\"7#虚方法\",\"276\":\"7#分派\",\"277\":\"7#_1、静态分派\",\"278\":\"7#_2、动态分派\",\"279\":\"7#类文件概述\",\"280\":\"7#字节码文件、字节码指令\",\"281\":\"7#如何查看字节码文件\",\"282\":\"7#前端编译器\",\"283\":\"7#jvm是怎么运行class文件的\",\"284\":\"7#class文件结构\",\"285\":\"7#魔数与class文件的版本\",\"286\":\"7#常量池\",\"287\":\"7#访问标志\",\"288\":\"7#类索引、-父类索引与接口索引集合\",\"289\":\"7#字段表集合\",\"290\":\"7#方法表集合\",\"291\":\"7#属性表集合\",\"292\":\"7#code属性\",\"293\":\"7#内存模型jmm\",\"294\":\"7#主内存与工作内存\",\"295\":\"7#内存模型三大特性\",\"296\":\"7#volatile关键字\",\"297\":\"7#oom-与-stackoverflow-场景\",\"298\":\"7#排查oom\",\"299\":\"7#threadlocal\",\"300\":\"7#threadlocal导致的oom\",\"301\":\"7#remove-方法\",\"302\":\"7#内存泄漏\",\"303\":\"7#泄漏的分类\",\"304\":\"7#泄漏的8种情况\",\"305\":\"7#六、性能监控与调优\",\"306\":\"7#性能优化的步骤\",\"307\":\"7#_1、性能监控\",\"308\":\"7#_2、性能分析\",\"309\":\"7#_3、性能调优\",\"310\":\"7#性能评测的指标\",\"311\":\"7#工具\",\"312\":\"7#命令行篇\",\"313\":\"7#gui篇\",\"314\":\"7#jvm选项参数\",\"315\":\"7#x\",\"316\":\"7#xx\",\"317\":\"7#添加jvm参数\",\"318\":\"7#常用参数\",\"319\":\"7#打印设置的xx选项及值\",\"320\":\"7#堆、栈、方法区等内存大小的设置\",\"321\":\"7#栈\",\"322\":\"7#堆\",\"323\":\"7#方法区-1\",\"324\":\"7#oom相关的选项\",\"325\":\"7#gc日志参数选项\",\"326\":\"7#其他\",\"327\":\"7#使用java代码获取jvm参数\",\"328\":\"7#gc日志剖析\",\"329\":\"7#minor-gc\",\"330\":\"7#full-gc\",\"331\":\"7#gc时间\",\"332\":\"7#gc日志分析工具\",\"333\":\"8\",\"334\":\"8#一、语言特性\",\"335\":\"8#jdk、jre、jvm\",\"336\":\"8#java-和-c-区别\",\"337\":\"8#java-的平台无关性\",\"338\":\"8#什么是注解-什么是元注解\",\"339\":\"8#class-类、class-对象\",\"340\":\"8#和-equals-的区别\",\"341\":\"8#两个对象的-hashcode-相同-则-equals-也一定为-true-吗\",\"342\":\"8#为什么重写-equals-就一定要重写-hashcode-方法\",\"343\":\"8#深拷贝和浅拷贝\",\"344\":\"8#序列化与反序列化\",\"345\":\"8#泛型、类型擦除\",\"346\":\"8#final、finally、finalize-的区别\",\"347\":\"8#大端模式和小端模式\",\"348\":\"8#反射及其应用场景\",\"349\":\"8#动态代理\",\"350\":\"8#object-包含哪些方法\",\"351\":\"8#值传递与引用传递的区别\",\"352\":\"8#关键字-static-的作用\",\"353\":\"8#二、面向对象\",\"354\":\"8#vs-面向过程\",\"355\":\"8#面向对象的三大特性\",\"356\":\"8#java-中创建对象的方式\",\"357\":\"8#访问权限控制符有哪些\",\"358\":\"8#子类是否可以重写-覆盖-父类-private-或-static-方法\",\"359\":\"8#重写与重载的区别\",\"360\":\"8#static-可以修饰类么\",\"361\":\"8#什么时候会使用静态内部类\",\"362\":\"8#接口-vs-抽象类\",\"363\":\"8#子类初始化的顺序\",\"364\":\"8#super-、transient\",\"365\":\"8#三、数据类型\",\"366\":\"8#java-都有哪些基本数据类型\",\"367\":\"8#char-和-string-的区别\",\"368\":\"8#integer-int、包装类的缓存\",\"369\":\"8#string-为什么要设计成不可变类\",\"370\":\"8#string-类可以被继承么\",\"371\":\"8#final-修饰-stringbuffer-后还可以-append-吗\",\"372\":\"8#数组和链表的区别\",\"373\":\"8#数组和链表的应用场景\",\"374\":\"8#消息队列可以用数组实现吗\",\"375\":\"8#四、java-io\",\"376\":\"8#_1、io-分类\",\"377\":\"8#_2、io-与-nio-区别-讲讲-nio\",\"378\":\"8#直接缓冲区与非直接缓冲区\",\"379\":\"8#通道-channel\",\"380\":\"8#_3、bio-nio-aio-区别\",\"381\":\"8#_4、io-多路复用\",\"382\":\"8#五、java-异常\",\"383\":\"8#_1、finally-必须执行\",\"384\":\"8#_2、error-和-exception-的区别\",\"385\":\"8#_3、运行时异常与受检异常\",\"386\":\"8#_4、throw-vs-throws\",\"387\":\"8#六、java-集合\",\"388\":\"8#_1、collection-vs-collections\",\"389\":\"8#_2、iterable-vs-iterator\",\"390\":\"8#_3、comparable-vs-comparator\",\"391\":\"8#_4、集合的遍历\",\"392\":\"8#_5、arraylist、linkedlist、vector\",\"393\":\"8#arraylist-与-linkedlist-的区别\",\"394\":\"8#_6、deque、queue、stack\",\"395\":\"8#_7、hashmap\",\"396\":\"8#hashmap-底层原理\",\"397\":\"8#put-过程\",\"398\":\"8#get-过程\",\"399\":\"8#初始化过程-new-一个-hashmap\",\"400\":\"8#hashmap-中怎样判断一个元素是否相同\",\"401\":\"8#什么情况下才会用到红黑树\",\"402\":\"8#resize\",\"403\":\"8#为什么-jdk8-之后要改成尾插法\",\"404\":\"8#hashmap-的-size-为什么必须是-2-的整数次方\",\"405\":\"8#为什么不直接通过-key-hashcode-计算-hash-值\",\"406\":\"8#hash-扩容机制\",\"407\":\"8#hashmap-vs-hashtable\",\"408\":\"8#hashmap-vs-treemap\",\"409\":\"8#hashmap-的线程安全问题\",\"410\":\"8#concurrenthashmap\",\"411\":\"8#copyonwritearraylist\",\"412\":\"8#_8、linkedhashmap、treemap\",\"413\":\"8#_9、hashset-的实现原理\",\"414\":\"8#_10、linkedhashmap-源码分析\",\"415\":\"9\",\"416\":\"9#系统目录结构\",\"417\":\"9#命令行中的-ctrl-组合键\",\"418\":\"9#文件与目录管理\",\"419\":\"9#ls-列出目录\",\"420\":\"9#cd-切换目录\",\"421\":\"9#pwd-显示目前所在的目录\",\"422\":\"9#mkdir-创建新目录\",\"423\":\"9#cp-复制文件或目录\",\"424\":\"9#rm-移除文件或目录\",\"425\":\"9#mv-移动或修改名称\",\"426\":\"9#查看进程杀死进程启动进程\",\"427\":\"9#linux-链接\",\"428\":\"9#文件内容查看\",\"429\":\"9#more-less\",\"430\":\"9#文件属性与权限\",\"431\":\"9#chgrp-更改文件属组\",\"432\":\"9#chown-更改文件属主和属组\",\"433\":\"9#chmod-修改文件权限\",\"434\":\"9#查找、搜索命令\",\"435\":\"9#网络命令\",\"436\":\"9#进程管理\",\"437\":\"9#压缩解压命令\",\"438\":\"9#linux-管道命令\",\"439\":\"9#统计命令-wc\",\"440\":\"9#监控系统性能\",\"441\":\"9#linux-磁盘管理\",\"442\":\"9#du-和-ls-区别\",\"443\":\"9#统计-var-log-下所有文件个数\",\"444\":\"9#git-基础理论\",\"445\":\"9#新建仓库\",\"446\":\"9#配置\",\"447\":\"9#增加-删除文件\",\"448\":\"9#代码提交\",\"449\":\"9#查看信息\",\"450\":\"9#tag\",\"451\":\"9#分支\",\"452\":\"9#远程同步\",\"453\":\"9#撤销\",\"454\":\"10\",\"455\":\"10#数据库的三大范式\",\"456\":\"10#关系型数据库介绍\",\"457\":\"10#sql、dbms、dbs、db\",\"458\":\"10#mysql-权限表\",\"459\":\"10#常用命令\",\"460\":\"10#sql约束有哪几种\",\"461\":\"10#和-区别\",\"462\":\"10#主键、外键和唯一的区别\",\"463\":\"10#外键的作用\",\"464\":\"10#为什么一张表只能有一个主键\",\"465\":\"10#自增id\",\"466\":\"10#为什么建表使用自增-id-作为主键\",\"467\":\"10#自增id与uuid的区别\",\"468\":\"10#自增id用完了怎么办\",\"469\":\"10#主从复制的原理⭐\",\"470\":\"10#主从复制涉及的线程\",\"471\":\"10#数据类型\",\"472\":\"10#整型\",\"473\":\"10#浮点数\",\"474\":\"10#字符型\",\"475\":\"10#时间和日期\",\"476\":\"10#int-10-中-10-指什么\",\"477\":\"10#char、varchar和text的区别\",\"478\":\"10#varchar-10-和-varchar-20-的区别\",\"479\":\"10#关键字\",\"480\":\"10#union-与-union-all-的区别\",\"481\":\"10#where-与-having-的区别\",\"482\":\"10#in-和-exists\",\"483\":\"10#drop、delete-与-truncate-的区别\",\"484\":\"10#order-by-是怎么工作的\",\"485\":\"10#关联查询-连接查询-join\",\"486\":\"10#分页查询-limit\",\"487\":\"10#mysql-关键字执行顺序\",\"488\":\"10#mysql基础架构⭐\",\"489\":\"10#sql-语句的执行流程\",\"490\":\"10#server-层基本组件介绍\",\"491\":\"10#innodb\",\"492\":\"10#myisam\",\"493\":\"10#myisam-和-innodb-的区别\",\"494\":\"10#memory\",\"495\":\"10#buffer-pool-缓冲池\",\"496\":\"10#innodb引擎的关键特性\",\"497\":\"10#innodb索引的后台线程\",\"498\":\"10#innodb的逻辑存储结构\",\"499\":\"10#mvcc多版本并发控制⭐\",\"500\":\"10#锁的分类\",\"501\":\"10#不同sql语句对加锁的影响\",\"502\":\"10#innodb-的三种行级锁⭐\",\"503\":\"10#record-lock-记录锁\",\"504\":\"10#gap-lock-间隙锁\",\"505\":\"10#next-key-lock-行锁和间隙锁组合起来\",\"506\":\"10#行锁的选择\",\"507\":\"10#按锁粒度划分\",\"508\":\"10#全局锁\",\"509\":\"10#行锁-会出现死锁\",\"510\":\"10#表锁\",\"511\":\"10#元数据锁-mdl-表级锁\",\"512\":\"10#页锁\",\"513\":\"10#悲观锁与乐观锁\",\"514\":\"10#意向锁\",\"515\":\"10#innodb加锁规则\",\"516\":\"10#死锁⭐\",\"517\":\"10#分布式锁\",\"518\":\"10#何为数据库事务\",\"519\":\"10#事务的-acid-特性\",\"520\":\"10#事务状态\",\"521\":\"10#并发事务的问题⭐\",\"522\":\"10#事务的四个隔离级别⭐\",\"523\":\"10#rr-级别下如何解决幻读\",\"524\":\"10#事务的隔离级别都是如何实现的\",\"525\":\"10#为什么尽量不要使用长事务\",\"526\":\"10#事务的启动方式\",\"527\":\"10#索引相关语法\",\"528\":\"10#何为索引\",\"529\":\"10#为啥加了索引-查询会变快\",\"530\":\"10#索引应该何时使用\",\"531\":\"10#需要创建索引的情况\",\"532\":\"10#避免创建索引的情况\",\"533\":\"10#建立索引的几大原则⭐\",\"534\":\"10#不走索引-索引失效\",\"535\":\"10#索引优化\",\"536\":\"10#选错索引\",\"537\":\"10#哈希索引\",\"538\":\"10#b-tree索引\",\"539\":\"10#b-树能存多少数据\",\"540\":\"10#b-树和其它的比较\",\"541\":\"10#为什么使用b-树\",\"542\":\"10#b-树叶子结点数目是确定的吗\",\"543\":\"10#磁盘io与预读-局部性原理\",\"544\":\"10#索引分类\",\"545\":\"10#主索引和辅助索引\",\"546\":\"10#聚簇索引和非聚簇索引\",\"547\":\"10#索引类型-按物理分类\",\"548\":\"10#索引类型-按常规功能-逻辑分类\",\"549\":\"10#回表查询\",\"550\":\"10#覆盖索引\",\"551\":\"10#联合索引\",\"552\":\"10#最左前缀原则\",\"553\":\"10#索引下推\",\"554\":\"10#前缀索引\",\"555\":\"10#唯一索引与普通索引的速度比较\",\"556\":\"10#explain-查看执行计划⭐\",\"557\":\"10#mysql-问题排查的手段\",\"558\":\"10#show-profiles\",\"559\":\"10#慢查询\",\"560\":\"10#sql-优化\",\"561\":\"10#千万级大表的优化\",\"562\":\"10#cpu-使用率飙升\",\"563\":\"10#io性能瓶颈怎么解决\",\"564\":\"10#批量导入1000万数据\",\"565\":\"10#怎么加快插入速度\",\"566\":\"10#mysql-普通日志\",\"567\":\"10#mysql-事务日志⭐\",\"568\":\"10#redo-log\",\"569\":\"10#wal\",\"570\":\"10#undo-log\",\"571\":\"10#bin-log\",\"572\":\"10#bin-log的三种格式\",\"573\":\"10#redo-log-与-bin-log-的区别\",\"574\":\"10#change-buffer\",\"575\":\"10#区分redo-log和change-buffer\",\"576\":\"10#怎样让数据库恢复某时刻状态\",\"577\":\"10#为什么同时需要binlog-redo-log\",\"578\":\"10#为什么日志需要-两二阶段提交\",\"579\":\"10#主从复制、读写分离的优点\",\"580\":\"10#主从复制的原理\",\"581\":\"10#涉及的线程\",\"582\":\"10#主从同步的延迟原因\",\"583\":\"10#分库分表\",\"584\":\"10#分库与分表的选择\",\"585\":\"10#水平切分和垂直切分\",\"586\":\"10#数据库分片的两种常见方案\",\"587\":\"10#常见的分库分表的策略\",\"588\":\"10#数据库分片常用的分片的方法\",\"589\":\"10#分库分表后带来的问题\",\"590\":\"10#页面\",\"591\":\"10#页\",\"592\":\"10#脏页与干净页\",\"593\":\"10#刷页-两次写\",\"594\":\"10#什么时候会引发数据库刷页\",\"595\":\"10#sql注入\",\"596\":\"10#和-区别-1\",\"597\":\"10#sql预编译\",\"598\":\"10#查询语句\",\"599\":\"10#创建表-插入语句\",\"600\":\"10#分支结构中的case-when\",\"601\":\"10#一、评论系统设计\",\"602\":\"12\",\"603\":\"12#redis-应用场景\",\"604\":\"12#redis-为什么这么快-⭐\",\"605\":\"12#为什么要用-redis\",\"606\":\"12#为什么要用-redis-为什么要用缓存\",\"607\":\"12#说说有哪些本地缓存解决方案\",\"608\":\"12#redis-和-guava-cache-的缓存是深拷贝还是浅拷贝\",\"609\":\"12#为什么不用本地缓存\",\"610\":\"12#redis-和-memcached-比较\",\"611\":\"12#多路-io-复用-redis-线程模型\",\"612\":\"12#epoll\",\"613\":\"12#边缘触发和水平触发\",\"614\":\"12#redis-键值对结构组织-全局哈希表\",\"615\":\"12#哈希-hash-冲突-渐进式-rehash\",\"616\":\"12#redis5-种基本数据类型-数据结构\",\"617\":\"12#string\",\"618\":\"12#list\",\"619\":\"12#set\",\"620\":\"12#zset-sorted-set\",\"621\":\"12#底层数据结构\",\"622\":\"12#hash\",\"623\":\"12#字典-dict\",\"624\":\"12#sds-动态字符串\",\"625\":\"12#intset-基于整数数组实现\",\"626\":\"12#链表\",\"627\":\"12#ziplist-压缩列表-ziplist-内存空间连续\",\"628\":\"12#ziplist-的连锁更新问题\",\"629\":\"12#quicklist\",\"630\":\"12#跳表-skiplist\",\"631\":\"12#redisobject\",\"632\":\"12#redis-过期键的删除策略\",\"633\":\"12#redis-内存淘汰机制\",\"634\":\"12#内存相关\",\"635\":\"12#怎么保证-redis-中的数据都是热点数据\",\"636\":\"12#redis-的内存淘汰策略有哪些\",\"637\":\"12#redis-如何做内存优化\",\"638\":\"12#redis-怎么扩容\",\"639\":\"12#缓存异常\",\"640\":\"12#缓存预热\",\"641\":\"12#缓存穿透\",\"642\":\"12#缓存雪崩\",\"643\":\"12#缓存击穿\",\"644\":\"12#缓存降级\",\"645\":\"12#布隆过滤器\",\"646\":\"12#redis-的持久化\",\"647\":\"12#rdb-redis-database\",\"648\":\"12#rdb-的优缺点\",\"649\":\"12#aof-append-only-file\",\"650\":\"12#aof-的三种写回策略\",\"651\":\"12#aof-文件过大-重写机制\",\"652\":\"12#rdb-和-aof-的区别\",\"653\":\"12#持久化方式的选择\",\"654\":\"12#redis-如何保证高可用高并发性-主从-哨兵-集群-⭐\",\"655\":\"12#主从复制\",\"656\":\"12#主从复制的优缺点\",\"657\":\"12#哨兵模式\",\"658\":\"12#哨兵模式的优缺点\",\"659\":\"12#集群模式\",\"660\":\"12#集群模式的优缺点\",\"661\":\"12#redis-的主从复制\",\"662\":\"12#复制过程\",\"663\":\"12#复制期间网络断了咋办\",\"664\":\"12#由于主从延迟导致读取到过期数据怎么处理\",\"665\":\"12#redis-事务\",\"666\":\"12#分布式\",\"667\":\"12#什么是分布式锁\",\"668\":\"12#常见的分布式锁有哪些解决方案\",\"669\":\"12#redis-实现分布式锁\",\"670\":\"12#redis-的分布式锁有什么缺陷\",\"671\":\"12#分布式-redis-是前期做还是后期规模上来了再做好-为什么\",\"672\":\"12#redlock\",\"673\":\"12#发布及订阅消息\",\"674\":\"12#redis-单副本\",\"675\":\"12#redis-多副本-主从\",\"676\":\"12#redis-sentinel-哨兵\",\"677\":\"12#哨兵的作用和原理\",\"678\":\"12#redis-cluster\",\"679\":\"12#数据分片-节点数据分配问题\",\"680\":\"12#哈希槽是如何映射到-redis-实例上呢\",\"681\":\"12#一致性哈希\",\"682\":\"12#集群如何扩容\",\"683\":\"12#复制与故障转移\",\"684\":\"12#节点间通信\",\"685\":\"12#netty-的线程模型\",\"686\":\"13\",\"687\":\"13#自我介绍\",\"688\":\"13#宝洁八大问\",\"689\":\"13#问题一-考察目的性\",\"690\":\"13#问题二-考察领导力\",\"691\":\"13#问题三-考察计划性\",\"692\":\"13#问题四-考察说服力\",\"693\":\"13#问题五-考察协作力\",\"694\":\"13#问题六-考察创新性\",\"695\":\"13#问题七-考察前瞻性\",\"696\":\"13#问题八-考察学习能力\",\"697\":\"13#职业生涯规划\",\"698\":\"14\",\"699\":\"14#mysql\",\"700\":\"14#发生死锁调试命令\",\"701\":\"14#慢-sql-查询\",\"702\":\"14#查看执行计划\",\"703\":\"14#sql-题\",\"704\":\"14#redis\",\"705\":\"14#常用命令\",\"706\":\"14#_8-种缓存淘汰策略\",\"707\":\"14#aof-刷盘机制\",\"708\":\"14#混合持久化\",\"709\":\"14#rocketmq\",\"710\":\"15\",\"711\":\"15#spring中用到了哪些设计模式\",\"712\":\"15#工厂模式\",\"713\":\"15#单例模式\",\"714\":\"15#dcl-单例-双重校验锁\",\"715\":\"15#代理设计模式\",\"716\":\"15#代理模式与装饰器模式的区别\",\"717\":\"15#spring框架的优势\",\"718\":\"15#ioc-aop\",\"719\":\"15#解释下aop\",\"720\":\"15#springaop与aspectj-aop的区别\",\"721\":\"15#aop的基本概念\",\"722\":\"15#aop-通知类型\",\"723\":\"15#动态代理与静态代理\",\"724\":\"15#aop代理的两种方式\",\"725\":\"15#jdk动态代理\",\"726\":\"15#cglib动态代理\",\"727\":\"15#两种代理的区别\",\"728\":\"15#aop实现的四种方式\",\"729\":\"15#解释下ioc\",\"730\":\"15#常用注入bean的方式-怎么定义bean\",\"731\":\"15#ioc与工厂模式区别\",\"732\":\"15#bean相关\",\"733\":\"15#bean的生命周期\",\"734\":\"15#bean的作用域\",\"735\":\"15#bean-线程安全问题\",\"736\":\"15#获取bean的方式\",\"737\":\"15#beanfactory实现原理\",\"738\":\"15#spring的事务\",\"739\":\"15#事务的实现方式\",\"740\":\"15#事务的传播机制\",\"741\":\"15#事务的隔离级别\",\"742\":\"15#spring-框架中用到了哪些设计模式\",\"743\":\"15#相关注解\",\"744\":\"15#jdbc-连接数据库步骤\",\"745\":\"15#statement-和-preparestatement-区别\",\"746\":\"15#什么是mybatis-优缺点\",\"747\":\"15#什么是-orm\",\"748\":\"15#为什么要做持久化和orm设计\",\"749\":\"15#mybatis-与-hibernate-的区别\",\"750\":\"15#和-区别\",\"751\":\"15#resultmap和resulttype的区别\",\"752\":\"15#mybatis-的缓存\",\"753\":\"15#mybatis-分页\",\"754\":\"15#三层架构与mvc\",\"755\":\"15#springmvc-工作流程\",\"756\":\"15#springmvc-的核心组件\",\"757\":\"15#springmvc-的控制器是不是单例模式-如果是会有什么问题-怎么解决\",\"758\":\"15#springmvc-怎么样设定重定向和转发的\",\"759\":\"15#过滤器-拦截器-监听器\",\"760\":\"15#ssm框架\",\"761\":\"15#什么是ssm框架\",\"762\":\"15#持久层-dao层-mapper-层\",\"763\":\"15#业务层-service层\",\"764\":\"15#表现层-controller层\",\"765\":\"15#view层\",\"766\":\"15#各层之间的联系\",\"767\":\"15#什么是springboot\",\"768\":\"15#springboot有哪些优点\",\"769\":\"15#如何重新加载spring-boot上的更改-而无需重新启动服务器\",\"770\":\"15#spring-boot、spring-mvc-和-spring-有什么区别\",\"771\":\"15#spring-boot-的自动配置是如何实现的\",\"772\":\"15#什么是-spring-boot-stater\",\"773\":\"15#怎么开发starter\",\"774\":\"15#为什么我们需要-spring-boot-maven-plugin\",\"775\":\"15#springboot读取配置文件的方式\",\"776\":\"15#springboot集成mybatis的过程\",\"777\":\"15#spring-boot-的核心注解是哪个\",\"778\":\"15#开启-spring-boot-特性有哪几种方式\",\"779\":\"15#spring-boot-starter-parent有什么作用\",\"780\":\"15#spring-boot-需要独立的容器运行吗\",\"781\":\"15#启动-spring-boot-的方式\",\"782\":\"15#springboot-实现热部署有哪几种方式\",\"783\":\"15#spring-boot-的核心配置文件有哪几个-它们的区别是什么\",\"784\":\"15#springboot的配置加载顺序\",\"785\":\"15#yml相对于properties配置的优势\",\"786\":\"15#怎么在自定义端口上运行springboot应用程序\",\"787\":\"15#spingboot是否可以使用xml配置\",\"788\":\"15#spring-boot-可以兼容老-spring-项目吗-如何做\",\"789\":\"15#如何实现springboot的安全性\",\"790\":\"15#springboot打成的jar和普通的jar有什么区别\",\"791\":\"15#如何使用springboot实现异常处理\",\"792\":\"15#maven的目录结构\",\"793\":\"15#maven基本命令\",\"794\":\"15#什么是maven仓库\",\"795\":\"15#什么是-坐标\",\"796\":\"15#传递依赖-与-排除依赖\",\"797\":\"15#依赖范围scope\",\"798\":\"15#依赖冲突\",\"799\":\"15#聚合\",\"800\":\"15#继承\",\"801\":\"15#rpc\",\"802\":\"15#如果服务提供者挂了-注册中心如何知道服务不可用了呢\",\"803\":\"15#如果注册中心挂了-那服务之间还能相互调用吗\",\"804\":\"15#能否自己写一个-rpc-框架-rpc的技术重点\",\"805\":\"15#已经有-http-协议接口-或者说-restful-接口-为什么还要使用-rpc-技术\",\"806\":\"15#rpc-和-http-区别\",\"807\":\"15#rpc-接口如何保证幂等性\",\"808\":\"15#集群和分布式区别\",\"809\":\"15#什么是-dubbo-关键功能\",\"810\":\"15#dubbo-服务关键节点\",\"811\":\"15#rpc-dubbo-的服务注册流程\",\"812\":\"15#dubbo-负载均衡策略\",\"813\":\"15#集群容错几种方法\",\"814\":\"15#dubbo-使用什么通信框架\",\"815\":\"15#dubbo-和-springcloud-对比\",\"816\":\"15#zookeeper是什么\",\"817\":\"15#监听通知机制\",\"818\":\"15#文件系统-znode\",\"819\":\"15#zookeeper-的部署方式有哪几种\",\"820\":\"15#zookeeper-选举机制\",\"821\":\"15#分布式锁\",\"822\":\"15#zookeeper-的监听原理是什么\",\"823\":\"15#zookeeper-常用命令\",\"824\":\"15#什么是-nginx\",\"825\":\"15#nginx与tomcat的区别\",\"826\":\"15#正向代理-反向代理\",\"827\":\"15#nginx的主要特征\",\"828\":\"15#nginx高性能原因\",\"829\":\"15#_1、epoll多路复用\",\"830\":\"15#_2、master-worker进程模型\",\"831\":\"15#_3、协程机制\",\"832\":\"15#nginx-负载均衡算法\",\"833\":\"15#mater-workers机制-nginx原理\",\"834\":\"15#master-workers-机制的好处\",\"835\":\"15#设置多少个-worker\",\"836\":\"15#发送请求-占用了-worker-的几个连接数\",\"837\":\"15#nginx重启之后-为什么master不会挂\",\"838\":\"15#为什么worker内部不使用多线程\",\"839\":\"15#mq\",\"840\":\"15#什么是-mq-作用\",\"841\":\"15#mq的缺点\",\"842\":\"15#常用的mq\",\"843\":\"15#push、pull\",\"844\":\"15#kafka的消费模式\",\"845\":\"15#kafka基础架构\",\"846\":\"15#kafka的文件存储\",\"847\":\"15#partition的数据文件-offffset-messagesize-data\",\"848\":\"15#数据文件分段-segment\",\"849\":\"15#负载均衡\",\"850\":\"15#kafka为什么这么快\",\"851\":\"15#生产者\",\"852\":\"15#生产者分区分配策略\",\"853\":\"15#ar、isr\",\"854\":\"15#ack机制-生产者消息可靠性保证\",\"855\":\"15#数据一致性-leo、hw-高水位\",\"856\":\"15#exactlyonce-幂等性-重复数据\",\"857\":\"15#消费者\",\"858\":\"15#消费者消费方式\",\"859\":\"15#消费者分区分配策略\",\"860\":\"15#consumer-group-的-offset-放在哪儿\",\"861\":\"15#kafka中zookeeper的作用\",\"862\":\"15#事务\",\"863\":\"15#producer事务\",\"864\":\"15#consumer事务\",\"865\":\"15#消息顺序性的体现\",\"866\":\"15#消息重复消费和消息漏掉的场景\",\"867\":\"15#分区器、序列化器、拦截器\",\"868\":\"15#如何判断一个节点是否还活着\",\"869\":\"15#负载均衡算法\",\"870\":\"15#cap理论\",\"871\":\"15#base理论\",\"872\":\"15#paxos算法\",\"873\":\"15#raft-算法\",\"874\":\"15#节点类型\",\"875\":\"15#日志\",\"876\":\"15#任期\",\"877\":\"15#leader选举\",\"878\":\"15#日志复制\",\"879\":\"15#时间与可用性\",\"880\":\"15#一致性哈希\",\"881\":\"16\",\"882\":\"16#布隆过滤器\",\"883\":\"16#bitmap\",\"884\":\"16#hash\",\"885\":\"16#堆\",\"886\":\"16#双层桶划分-其实本质上就是【分而治之】的思想-重在-分-的技巧上\",\"887\":\"16#数据库索引\",\"888\":\"16#倒排索引\",\"889\":\"16#外排序\",\"890\":\"16#trie树\",\"891\":\"16#分布式处理-mapreduce\",\"892\":\"16#_1-海量日志数据-提取出某日访问百度次数最多的那个ip\",\"893\":\"16#_2-百度-搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来-每个查询串的长度为1-255字节。\",\"894\":\"16#_3-有一个1g大小的一个文件-里面每一行是一个词-词的大小不超过16字节-内存限制大小是1m。返回频数最高的100个词。\",\"895\":\"16#_4-有10个文件-每个文件1g-每个文件的每一行存放的都是用户的query-每个文件的query都可能重复。要求你按照query的频度排序。\",\"896\":\"16#_5-给定a、b两个文件-各存放50亿个url-每个url各占64字节-内存限制是4g-让你找出a、b文件共同的url\",\"897\":\"16#_6-怎么在海量数据中找出重复次数最多的一个\",\"898\":\"16#_7-上千万或上亿数据-有重复-统计其中出现次数最多的前n个数据。\",\"899\":\"16#_8-一个文本文件-大约有一万行-每行一个词-要求统计出其中最频繁出现的前10个词-请给出思想-给出时间复杂度分析。\",\"900\":\"16#_1-在2-5亿个整数中找出不重复的整数-注-内存不足以容纳这2-5亿个整数。\",\"901\":\"16#_2-腾讯面试题-给40亿个不重复的unsigned-int的整数-没排过序的-然后再给一个数-如何快速判断这个数是否在那40亿个数当中\",\"902\":\"16#_1-给2000千万高考学生排序-要求要能根据分数找到该学生的排名\",\"903\":\"16#_2-给2亿个不重复的正整数进行排序-范围0-2亿\",\"904\":\"16#_3-给你一个超大的文件-找出出现频率最高的5个\",\"905\":\"17\",\"906\":\"17#二叉树\",\"907\":\"17#遍历\",\"908\":\"17#非递归实现前、中、后序遍历\",\"909\":\"17#查找\",\"910\":\"17#二分查找\",\"911\":\"17#普通二分\",\"912\":\"17#搜索左边界\",\"913\":\"17#搜索右边界\",\"914\":\"17#查找树\",\"915\":\"17#二叉排序树\",\"916\":\"17#二叉平衡树-avl-树\",\"917\":\"17#多路查找树\",\"918\":\"17#_2-3-树-2-3-4-树\",\"919\":\"17#b-树\",\"920\":\"17#b-树-1\",\"921\":\"17#红黑树\",\"922\":\"17#哈希表查找\",\"923\":\"17#散列函数的构造方法\",\"924\":\"17#处理散列冲突的方法\",\"925\":\"17#散列表查找的性能分析\",\"926\":\"17#链表\",\"927\":\"17#找单向链表的倒数第-k-个结点\",\"928\":\"17#常见数据结构的时间复杂度\",\"929\":\"17#排序\",\"930\":\"17#冒泡排序-n-2\",\"931\":\"17#选择排序-n-2\",\"932\":\"17#插入排序-n-2\",\"933\":\"17#希尔排序-o-n-2\",\"934\":\"17#归并排序-分治-n-logn\",\"935\":\"17#快速排序-n-logn\",\"936\":\"17#寻找第-k-大的数-基于快速排序\",\"937\":\"17#堆排序-n-logn\",\"938\":\"17#arrays-sort\",\"939\":\"17#栈、队列\",\"940\":\"17#栈\",\"941\":\"17#队列\",\"942\":\"17#栈和队列的应用场景\",\"943\":\"17#位运算符\",\"944\":\"17#左移-和-右移\",\"945\":\"17#位运算的常见使用\",\"946\":\"17#_1-判断一个数的奇偶性\",\"947\":\"17#_2-交换两个数\",\"948\":\"17#_3-n-n-1\",\"949\":\"17#_4-快速幂\",\"950\":\"17#acm-模式代码\",\"951\":\"17#多行输入\",\"952\":\"17#一次读取一行数据\",\"953\":\"17#一维数组输入\",\"954\":\"17#二维数组输入\",\"955\":\"17#链表输入\",\"956\":\"17#树的输入\",\"957\":\"17#hashmap-抛出第一个-key\",\"958\":\"18\",\"959\":\"18#在浏览器中输入-url-地址到显示主页的过程\",\"960\":\"18#互联网的组成\",\"961\":\"18#五-七-层协议的体系结构\",\"962\":\"18#每一层对应的网络协议有哪些\",\"963\":\"18#数据传递过程\",\"964\":\"18#tcp-ip的体系结构\",\"965\":\"18#各层中间设备的名称\",\"966\":\"18#基本概念\",\"967\":\"18#信道复用技术\",\"968\":\"18#宽带接入技术\",\"969\":\"18#crc校验\",\"970\":\"18#使用点对点信道的数据链路层\",\"971\":\"18#数据链路和帧\",\"972\":\"18#封装成帧\",\"973\":\"18#透明传输\",\"974\":\"18#差错检测\",\"975\":\"18#点对点协议ppp\",\"976\":\"18#使用广播信道的数据链路层\",\"977\":\"18#局域网的数据链路层\",\"978\":\"18#以太网的信道利用率\",\"979\":\"18#以太网的mac层\",\"980\":\"18#mac帧的格式\",\"981\":\"18#mac-硬件地址-vs-ip地址\",\"982\":\"18#mss-vs-mtu\",\"983\":\"18#网际协议ip\",\"984\":\"18#分类的ip地址\",\"985\":\"18#将ip地址分类的好处\",\"986\":\"18#地址解析协议arp\",\"987\":\"18#ip数据报的格式\",\"988\":\"18#划分子网和构造超网\",\"989\":\"18#划分子网\",\"990\":\"18#使用子网时分组的转发\",\"991\":\"18#无分类编址cidr-构造超网\",\"992\":\"18#网际控制报文协议icmp\",\"993\":\"18#icmp报文的种类\",\"994\":\"18#应用-ping、traceroute\",\"995\":\"18#vpn、nat\",\"996\":\"18#ipv4-vs-ipv6\",\"997\":\"18#存ip地址-用什么数据类型\",\"998\":\"18#传输层作用\",\"999\":\"18#传输层与网络层的区别\",\"1000\":\"18#端口\",\"1001\":\"18#udp-tcp-区别与应用场景\",\"1002\":\"18#udp\",\"1003\":\"18#udp可以建立连接么\",\"1004\":\"18#udp-如何保证可靠传输\",\"1005\":\"18#tcp\",\"1006\":\"18#粘包\",\"1007\":\"18#tcp的首部格式\",\"1008\":\"18#tcp的可靠传输\",\"1009\":\"18#如何保证\",\"1010\":\"18#停止等待协议\",\"1011\":\"18#arq-自动重传请求\",\"1012\":\"18#超时重传时间的选择\",\"1013\":\"18#选择确认sack\",\"1014\":\"18#tcp的流量控制-点\",\"1015\":\"18#滑动窗口\",\"1016\":\"18#tcp的传输效率\",\"1017\":\"18#nagle算法\",\"1018\":\"18#糊涂窗口综合征\",\"1019\":\"18#tcp的拥塞控制-总\",\"1020\":\"18#超时事件就一定是网络拥塞么\",\"1021\":\"18#主动队列管理aqm\",\"1022\":\"18#三次握手\",\"1023\":\"18#为什么不能两-二-次握手\",\"1024\":\"18#为什么连接的时候是三次握手-关闭的时候却是四次握手\",\"1025\":\"18#半连接队列和全连接队列\",\"1026\":\"18#四次挥手\",\"1027\":\"18#为什么需要等待2msl\",\"1028\":\"18#保活计时器的作用\",\"1029\":\"18#在浏览器中输入-url-地址到显示主页的过程-1\",\"1030\":\"18#域名系统dns\",\"1031\":\"18#域名到ip地址的解析过程\",\"1032\":\"18#域名缓存\",\"1033\":\"18#dns使用udp还是tcp\",\"1034\":\"18#万维网www\",\"1035\":\"18#html、xml、json\",\"1036\":\"18#统一资源定位符url\",\"1037\":\"18#http\",\"1038\":\"18#http的报文结构\",\"1039\":\"18#http的首部字段\",\"1040\":\"18#http方法与状态码\",\"1041\":\"18#post和get的区别与应用场景\",\"1042\":\"18#http-1-0-1-1-2-0-3-0\",\"1043\":\"18#https\",\"1044\":\"18#原理\",\"1045\":\"18#https-一定安全吗\",\"1046\":\"18#使用-https-会被抓包吗\",\"1047\":\"18#ssl\",\"1048\":\"18#http-和-https-的区别\",\"1049\":\"18#动态主机配置协议dhcp\",\"1050\":\"18#cookie、session、token\",\"1051\":\"18#cookie-保存在客户端\",\"1052\":\"18#session-保存在服务端\",\"1053\":\"18#token\",\"1054\":\"18#被动攻击和主动攻击\",\"1055\":\"18#什么是安全的计算机网络\",\"1056\":\"18#对称加密-非对称加密\",\"1057\":\"18#数字签名-数字证书\",\"1058\":\"18#网络攻击\",\"1059\":\"18#dns劫持\",\"1060\":\"18#syn攻击\",\"1061\":\"18#如何防止-cookie-被盗用\",\"1062\":\"18#ssl、tls\",\"1063\":\"19\",\"1064\":\"19#设计模式六大原则\",\"1065\":\"19#单例模式\",\"1066\":\"19#饿汉式\",\"1067\":\"19#懒汉式\",\"1068\":\"19#双重检测锁-推荐使用\",\"1069\":\"19#静态内部类-推荐使用\",\"1070\":\"19#枚举实现-推荐使用\",\"1071\":\"19#单例模式的优点\",\"1072\":\"19#单例模式的缺点\",\"1073\":\"19#单例模式的适用场景\",\"1074\":\"19#单例模式注意事项\",\"1075\":\"19#单例模式常见问题\",\"1076\":\"19#工厂模式\",\"1077\":\"19#简单工厂模式\",\"1078\":\"19#工厂方法模式\",\"1079\":\"19#抽象工厂模式\",\"1080\":\"19#工厂模式的退化\",\"1081\":\"19#代理模式\",\"1082\":\"19#静态代理\",\"1083\":\"19#动态代理\",\"1084\":\"19#cglib-代理\",\"1085\":\"19#装饰器模式\",\"1086\":\"19#建造者模式\",\"1087\":\"19#模板方法模式\",\"1088\":\"19#策略模式\",\"1089\":\"19#策略模式在-jdk-中的应用\",\"1090\":\"19#外观模式\",\"1091\":\"19#享元模式\",\"1092\":\"19#适配器模式\",\"1093\":\"19#事物\",\"1094\":\"19#图\",\"1095\":\"19#类间关系\",\"1096\":\"19#_1-依赖关系-dependency\",\"1097\":\"19#_2-关联关系-association\",\"1098\":\"19#_3-聚合关系-aggregation\",\"1099\":\"19#_4-组合关系-composition\",\"1100\":\"19#_5-泛化关系-generalization\",\"1101\":\"19#_6-实现关系-realization\",\"1102\":\"20\",\"1103\":\"20#_0\",\"1104\":\"21\",\"1105\":\"21#_0-序\",\"1106\":\"22\",\"1107\":\"23\",\"1108\":\"23#_0-序\",\"1109\":\"23#_1-环境搭建\",\"1110\":\"23#_1-1-anaconda\",\"1111\":\"23#_1-1-1-conda-常用指令\",\"1112\":\"24\",\"1113\":\"24#服务端学习笔记\",\"1114\":\"25\",\"1115\":\"25#_0-序\",\"1116\":\"26\",\"1117\":\"26#常见问题\",\"1118\":\"27\",\"1119\":\"27#语法\",\"1120\":\"28\",\"1121\":\"28#_0-intro\",\"1122\":\"28#_1-github\",\"1123\":\"28#建立电脑和-github-之间的-ssh-连接\",\"1124\":\"28#ssh-connect-to-host-github-com-port-22-connection-refused\",\"1125\":\"28#_2-开发分支和主分支之间的合并\",\"1126\":\"28#早间操作-同步主分支到本地开发分支\",\"1127\":\"28#晚间操作-推送开发分支并合并到主分支\",\"1128\":\"29\",\"1129\":\"29#_0-序\",\"1130\":\"29#_1-faststone-capture\",\"1131\":\"29#_2-沉浸式翻译\",\"1132\":\"30\",\"1133\":\"30#_0-序\",\"1134\":\"30#_1-进阶\",\"1135\":\"31\",\"1136\":\"31#_0-序\",\"1137\":\"32\",\"1138\":\"32#_0-intro\",\"1139\":\"32#_1-package-json\",\"1140\":\"32#_1-1-软件包版本\",\"1141\":\"32#_2-镜像源地址配置\",\"1142\":\"33\",\"1143\":\"33#镜像源配置\",\"1144\":\"33#环境搭建\",\"1145\":\"33#使用-gpu-进行预测\",\"1146\":\"34\",\"1147\":\"34#_1-项目搭建\",\"1148\":\"34#_1-1-文档地址\",\"1149\":\"34#_1-2-visual-studio-code-plugins\",\"1150\":\"34#_1-2-1-volar\",\"1151\":\"34#_1-2-2-prettier\",\"1152\":\"34#_1-2-3-copilot\",\"1153\":\"35\",\"1154\":\"35#_1-基础\",\"1155\":\"35#元素的-ref-引用\",\"1156\":\"35#计算属性\",\"1157\":\"35#监听\",\"1158\":\"35#_2-深入组件\",\"1159\":\"35#依赖注入\",\"1160\":\"35#_3-风格指南\",\"1161\":\"35#hooks-风格封装\",\"1162\":\"35#script-setup-风格代码组织顺序\",\"1163\":\"35#组织项目的注意事项\",\"1164\":\"35#_4-常见问题\",\"1165\":\"35#import-watch-from-less\",\"1166\":\"36\",\"1167\":\"36#常用指令\",\"1168\":\"36#安装-cmake\",\"1169\":\"36#建一个用户\",\"1170\":\"36#装一个-redis\",\"1171\":\"37\",\"1172\":\"37#安装部署\",\"1173\":\"38\",\"1174\":\"39\",\"1175\":\"39#docker\",\"1176\":\"39#docker-部署-mysql\",\"1177\":\"39#部署过程\",\"1178\":\"39#常见问题\",\"1179\":\"39#docker-部署-rocketmq\",\"1180\":\"40\",\"1181\":\"40#_1-环境搭建\",\"1182\":\"40#_1-1-conda-指令\",\"1183\":\"40#_1-2-依赖库安装\",\"1184\":\"40#_1-2-1-临时指定镜像源下载依赖库\",\"1185\":\"40#_1-2-2-配置全局镜像源\",\"1186\":\"40#_1-3-环境迁移\",\"1187\":\"40#_2-python-正则表达式\",\"1188\":\"40#_2-1-re-match-函数\",\"1189\":\"40#_2-2-re-search-函数\",\"1190\":\"40#_2-3-正则表达式修饰符-可选标志\",\"1191\":\"41\",\"1192\":\"41#redis-window-部署运行\",\"1193\":\"42\",\"1194\":\"42#参考菜鸟教程正则表达式\",\"1195\":\"43\",\"1196\":\"43#_1-github-配置\",\"1197\":\"43#_1-1-设置正确的-base-选项\",\"1198\":\"43#_1-2-选择你想要使用的-ci-工具\",\"1199\":\"43#_1-3-github-action-权限配置\",\"1200\":\"43#_1-4-github-page-配置\",\"1201\":\"43#_2-github-push-不上去的问题\",\"1202\":\"43#_2-1-配置本地-github-ssh-彻底解决-git-push-不上去的问题\",\"1203\":\"43#_2-2-参考博文\",\"1204\":\"43#_3-vs-code-开发-github-page-技巧\",\"1205\":\"43#_5-f-q\",\"1206\":\"43#_20250106-文件夹下的-readme-md-无法在-github-bot-上编译出-index-html\",\"1207\":\"44\",\"1208\":\"44#_0-intro\",\"1209\":\"44#_1-插件\",\"1210\":\"44#_2-样式\",\"1211\":\"44#_3-f-q\",\"1212\":\"44#cannot-find-node-modules-nodejs-jieba-build-release-jieba-node\",\"1213\":\"45\",\"1214\":\"46\",\"1215\":\"46#_1-战略设计\",\"1216\":\"46#_1-1-业务分析\",\"1217\":\"46#_1-2-领域建模\",\"1218\":\"46#_1-2-1-发散阶段-领域对象分析\",\"1219\":\"46#_1-2-2-收敛阶段-构建业务聚合\",\"1220\":\"46#_1-3-划分边界上下文\",\"1221\":\"46#_1-3-1-域的拆分\",\"1222\":\"46#_1-3-2-防腐\",\"1223\":\"46#_1-3-3-限界上下文之间的映射关系\",\"1224\":\"46#_2-战略设计\",\"1225\":\"46#_2-1-领域服务设计\",\"1226\":\"46#_2-2-领域分层\",\"1227\":\"46#_2-3-代码结构\",\"1228\":\"46#_3-ddd-基本概念\",\"1229\":\"46#_3-2-事件\",\"1230\":\"46#_3-3-实体-entity\",\"1231\":\"46#_3-4-值对象-value-object\",\"1232\":\"46#_3-5-聚合和聚合根\",\"1233\":\"46#_3-6-限界上下文-域-聚合-实体-值对象的关系\",\"1234\":\"46#_3-7-实体和事件的关系\",\"1235\":\"46#_4-ddd-代码实践\",\"1236\":\"46#_4-1-ddd-规范\",\"1237\":\"46#_4-2-工程结构\",\"1238\":\"46#_4-2-1-application-模块\",\"1239\":\"46#_4-2-2-domain-模块\",\"1240\":\"46#_4-2-2-1-聚合根\",\"1241\":\"46#_4-3-代码示例\",\"1242\":\"46#_4-3-1-domainservice-示例\",\"1243\":\"46#_4-3-2-aggregate-entity-示例\",\"1244\":\"46#_5-f-q\",\"1245\":\"46#_5-1\",\"1246\":\"46#_5-2\",\"1247\":\"47\",\"1248\":\"48\",\"1249\":\"48#_0-intro\",\"1250\":\"48#_1-基础语法\",\"1251\":\"48#_1-1-java-表达式\",\"1252\":\"48#_1-2-不同变量类型的映射\",\"1253\":\"48#_1-3-枚举映射\",\"1254\":\"48#_1-4-多对一映射\",\"1255\":\"48#_1-4-1-基本多对一映射\",\"1256\":\"48#_1-4-2-服务类传入\",\"1257\":\"48#_1-5-before-after-mapping\",\"1258\":\"48#_2-项目应用\",\"1259\":\"48#_2-1-ut2-与-sp11-之间枚举值的映射\",\"1260\":\"48#_2-1-1-枚举接口\",\"1261\":\"48#_2-1-2-枚举类\",\"1262\":\"49\",\"1263\":\"49#spring-cloud\",\"1264\":\"49#编码规范\",\"1265\":\"49#maven-pom\",\"1266\":\"49#常见问题\",\"1267\":\"50\",\"1268\":\"50#_1-安装部署\",\"1269\":\"50#_1-1-下载-plantuml-和-graphviz\",\"1270\":\"50#_1-2-配置-plantuml-integration\",\"1271\":\"50#_2-plantuml-文档\",\"1272\":\"50#_3-plantuml-应用\",\"1273\":\"50#_3-1-为文件夹生成类图\",\"1274\":\"50#_3-2-生成时序图\",\"1275\":\"51\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,10],\"2\":[1],\"3\":[1,1],\"4\":[1],\"5\":[1,3],\"6\":[1,11],\"7\":[1],\"8\":[1],\"9\":[1],\"10\":[1],\"11\":[1],\"12\":[1],\"13\":[1],\"14\":[2],\"15\":[1],\"16\":[2,1],\"17\":[1],\"18\":[2,37],\"19\":[1],\"20\":[1],\"21\":[2],\"22\":[2],\"23\":[3,4],\"24\":[4,18],\"25\":[2],\"26\":[1,45],\"27\":[1],\"28\":[1,25],\"29\":[2],\"30\":[1,12],\"31\":[1,63],\"32\":[3,24],\"33\":[3,16],\"34\":[2,19],\"35\":[4,65],\"36\":[7,25],\"37\":[4,29],\"38\":[2,68],\"39\":[1,104],\"40\":[4,24],\"41\":[4,25],\"42\":[2,26],\"43\":[4,21],\"44\":[2,13],\"45\":[2,57],\"46\":[4,38],\"47\":[3,11],\"48\":[1,13],\"49\":[3,12],\"50\":[1,22],\"51\":[1,12],\"52\":[2],\"53\":[1,14],\"54\":[1],\"55\":[2],\"56\":[2,47],\"57\":[1,24],\"58\":[2,68],\"59\":[2,44],\"60\":[2,16],\"61\":[3,22],\"62\":[1,76],\"63\":[2,16],\"64\":[2,37],\"65\":[5,23],\"66\":[1,21],\"67\":[3,15],\"68\":[2,7],\"69\":[2,14],\"70\":[2,7],\"71\":[1,51],\"72\":[5,152],\"73\":[4,30],\"74\":[3,60],\"75\":[4,71],\"76\":[5,33],\"77\":[8,10],\"78\":[2,35],\"79\":[5,25],\"80\":[2],\"81\":[2,100],\"82\":[1,51],\"83\":[3,16],\"84\":[3,17],\"85\":[2,68],\"86\":[2,36],\"87\":[1,51],\"88\":[3,87],\"89\":[3,50],\"90\":[2],\"91\":[1,28],\"92\":[1,6],\"93\":[1,6],\"94\":[3,58],\"95\":[1,9],\"96\":[2,117],\"97\":[3],\"98\":[1,116],\"99\":[1,8],\"100\":[1,12],\"101\":[4,80],\"102\":[2,83],\"103\":[2,25],\"104\":[2,24],\"105\":[5,39],\"106\":[3,27],\"107\":[2],\"108\":[3,32],\"109\":[3,50],\"110\":[2,65],\"111\":[2,45],\"112\":[2,2],\"113\":[1,18],\"114\":[1,39],\"115\":[1,31],\"116\":[2],\"117\":[3,35],\"118\":[3,44],\"119\":[2,9],\"120\":[3,38],\"121\":[4,34],\"122\":[2,13],\"123\":[3,27],\"124\":[1,5],\"125\":[1,49],\"126\":[2,53],\"127\":[2,16],\"128\":[3,30],\"129\":[5,69],\"130\":[5,39],\"131\":[6,63],\"132\":[2],\"133\":[2,15],\"134\":[1,70],\"135\":[1,31],\"136\":[3,43],\"137\":[2,22],\"138\":[1,12],\"139\":[4,46],\"140\":[1],\"141\":[1,14],\"142\":[1,44],\"143\":[2,14],\"144\":[1,82],\"145\":[1,7],\"146\":[1],\"147\":[1,16],\"148\":[1,62],\"149\":[2,83],\"150\":[1,48],\"151\":[2,18],\"152\":[1],\"153\":[2,32],\"154\":[1,14],\"155\":[2,29],\"156\":[1,41],\"157\":[2,20],\"158\":[1,10],\"159\":[2,20],\"160\":[2,54],\"161\":[1,17],\"162\":[1,14],\"163\":[1,45],\"164\":[1],\"165\":[2,12],\"166\":[2,20],\"167\":[1],\"168\":[2,48],\"169\":[2],\"170\":[1,34],\"171\":[1,16],\"172\":[1,35],\"173\":[2,37],\"174\":[1,62],\"175\":[1,13],\"176\":[3,26],\"177\":[1,15],\"178\":[3,12],\"179\":[1,14],\"180\":[1,34],\"181\":[1,30],\"182\":[1,37],\"183\":[5,26],\"184\":[1,57],\"185\":[1,83],\"186\":[1,13],\"187\":[1,9],\"188\":[2,10],\"189\":[1,17],\"190\":[1,42],\"191\":[1,23],\"192\":[1,44],\"193\":[1,41],\"194\":[1,42],\"195\":[1,21],\"196\":[1,9],\"197\":[1,32],\"198\":[4,55],\"199\":[1,36],\"200\":[1,35],\"201\":[2,30],\"202\":[1,70],\"203\":[1,64],\"204\":[1,19],\"205\":[2,8],\"206\":[2,6],\"207\":[2,14],\"208\":[1,34],\"209\":[1,36],\"210\":[1,4],\"211\":[2],\"212\":[1,19],\"213\":[3,1],\"214\":[6,8],\"215\":[2,11],\"216\":[1,11],\"217\":[1,12],\"218\":[2,11],\"219\":[1,38],\"220\":[3,27],\"221\":[2,12],\"222\":[2,15],\"223\":[3,21],\"224\":[1,9],\"225\":[2,13],\"226\":[2,6],\"227\":[2,44],\"228\":[1,9],\"229\":[2,9],\"230\":[2,21],\"231\":[2,9],\"232\":[2,8],\"233\":[1,14],\"234\":[1,50],\"235\":[1,76],\"236\":[1,42],\"237\":[3,16],\"238\":[1],\"239\":[1,16],\"240\":[1,34],\"241\":[1,10],\"242\":[2,16],\"243\":[2,11],\"244\":[2,22],\"245\":[4,21],\"246\":[6,32],\"247\":[2,28],\"248\":[1],\"249\":[1,63],\"250\":[1,24],\"251\":[4,26],\"252\":[1,13],\"253\":[1,13],\"254\":[1,27],\"255\":[1,20],\"256\":[2,17],\"257\":[5,15],\"258\":[4,10],\"259\":[1,56],\"260\":[3,36],\"261\":[1,64],\"262\":[1,59],\"263\":[1,17],\"264\":[1,37],\"265\":[1,21],\"266\":[1],\"267\":[1,15],\"268\":[1,24],\"269\":[1],\"270\":[1,20],\"271\":[1,8],\"272\":[2],\"273\":[1,5],\"274\":[1,36],\"275\":[1,22],\"276\":[1],\"277\":[2,58],\"278\":[2,26],\"279\":[1],\"280\":[2,9],\"281\":[1,11],\"282\":[1,21],\"283\":[2,26],\"284\":[1,35],\"285\":[1,11],\"286\":[1,33],\"287\":[1,11],\"288\":[2,25],\"289\":[1,25],\"290\":[1,43],\"291\":[1,15],\"292\":[1,51],\"293\":[1,11],\"294\":[1,51],\"295\":[1,77],\"296\":[1,47],\"297\":[4,37],\"298\":[1,23],\"299\":[1,46],\"300\":[1,35],\"301\":[2,32],\"302\":[1,9],\"303\":[1,16],\"304\":[1,107],\"305\":[2],\"306\":[1],\"307\":[2,7],\"308\":[2,13],\"309\":[2,21],\"310\":[1,14],\"311\":[1],\"312\":[1,34],\"313\":[1,38],\"314\":[1],\"315\":[2,18],\"316\":[2,24],\"317\":[1,26],\"318\":[1],\"319\":[1,10],\"320\":[3],\"321\":[1,6],\"322\":[1,33],\"323\":[1,19],\"324\":[1,16],\"325\":[1,22],\"326\":[1,15],\"327\":[1,4],\"328\":[1],\"329\":[2],\"330\":[2],\"331\":[1,15],\"332\":[1,13],\"333\":[1],\"334\":[2],\"335\":[3,33],\"336\":[4,28],\"337\":[2,31],\"338\":[3,39],\"339\":[3,20],\"340\":[4,21],\"341\":[9,23],\"342\":[6,48],\"343\":[2,25],\"344\":[1,28],\"345\":[2,55],\"346\":[4,34],\"347\":[1,11],\"348\":[1,78],\"349\":[1,98],\"350\":[3,81],\"351\":[1,22],\"352\":[3,11],\"353\":[2],\"354\":[2,35],\"355\":[1,67],\"356\":[2,42],\"357\":[2,11],\"358\":[7,21],\"359\":[1,45],\"360\":[2,8],\"361\":[1,24],\"362\":[3,56],\"363\":[1,10],\"364\":[2,35],\"365\":[2],\"366\":[3],\"367\":[4,20],\"368\":[3,84],\"369\":[2,39],\"370\":[3,19],\"371\":[7,6],\"372\":[1,17],\"373\":[1,9],\"374\":[1,6],\"375\":[3],\"376\":[3],\"377\":[6,48],\"378\":[1,28],\"379\":[3,48],\"380\":[6,85],\"381\":[3,148],\"382\":[3],\"383\":[4,48],\"384\":[6,23],\"385\":[2,25],\"386\":[5,8],\"387\":[3],\"388\":[4,13],\"389\":[4,19],\"390\":[4,37],\"391\":[2,77],\"392\":[4,60],\"393\":[4,55],\"394\":[4,47],\"395\":[2,9],\"396\":[2,32],\"397\":[2,23],\"398\":[2,48],\"399\":[5,61],\"400\":[3,15],\"401\":[1,18],\"402\":[2,11],\"403\":[4,7],\"404\":[7,36],\"405\":[6,79],\"406\":[2,59],\"407\":[3,37],\"408\":[3,45],\"409\":[2,51],\"410\":[1,52],\"411\":[1,67],\"412\":[3,61],\"413\":[3,40],\"414\":[3,27],\"415\":[2],\"416\":[1,93],\"417\":[3,36],\"418\":[1,50],\"419\":[3,19],\"420\":[3,17],\"421\":[3,7],\"422\":[3,16],\"423\":[3,27],\"424\":[3,22],\"425\":[3,25],\"426\":[1,67],\"427\":[2,78],\"428\":[1,34],\"429\":[2,41],\"430\":[1,44],\"431\":[2,6],\"432\":[2,6],\"433\":[2,38],\"434\":[2,26],\"435\":[1,21],\"436\":[1,18],\"437\":[1,13],\"438\":[3,6],\"439\":[2,14],\"440\":[1,13],\"441\":[2,29],\"442\":[5,47],\"443\":[4,23],\"444\":[2,31],\"445\":[1,12],\"446\":[1,14],\"447\":[2,35],\"448\":[1,22],\"449\":[1,69],\"450\":[1,43],\"451\":[1,40],\"452\":[1,57],\"453\":[1,32],\"454\":[1],\"455\":[1,31],\"456\":[1,19],\"457\":[4,23],\"458\":[2,24],\"459\":[1,26],\"460\":[1,5],\"461\":[4,17],\"462\":[2,33],\"463\":[1,20],\"464\":[1,28],\"465\":[1],\"466\":[4,22],\"467\":[1,27],\"468\":[2,33],\"469\":[1,39],\"470\":[1,16],\"471\":[1],\"472\":[1,18],\"473\":[1,25],\"474\":[1],\"475\":[1,60],\"476\":[5,22],\"477\":[3,43],\"478\":[6,29],\"479\":[1],\"480\":[5,11],\"481\":[4,20],\"482\":[3,28],\"483\":[6,20],\"484\":[3,82],\"485\":[3,52],\"486\":[2,63],\"487\":[2,43],\"488\":[1,40],\"489\":[3,102],\"490\":[2,104],\"491\":[1,28],\"492\":[1,34],\"493\":[4,42],\"494\":[1,29],\"495\":[3,26],\"496\":[1,58],\"497\":[1],\"498\":[1,37],\"499\":[1,104],\"500\":[1,30],\"501\":[1,135],\"502\":[2],\"503\":[4,19],\"504\":[4,14],\"505\":[5,33],\"506\":[1,27],\"507\":[1],\"508\":[1,27],\"509\":[3,44],\"510\":[1,26],\"511\":[4,33],\"512\":[1,4],\"513\":[1,55],\"514\":[1,55],\"515\":[1,23],\"516\":[1,67],\"517\":[1,33],\"518\":[2,16],\"519\":[3,57],\"520\":[1,23],\"521\":[1,40],\"522\":[1,47],\"523\":[2,60],\"524\":[1,16],\"525\":[2,29],\"526\":[1,24],\"527\":[1,26],\"528\":[1,31],\"529\":[2,6],\"530\":[1],\"531\":[2,12],\"532\":[2,20],\"533\":[1,60],\"534\":[3,19],\"535\":[1,46],\"536\":[1,52],\"537\":[1,58],\"538\":[2,34],\"539\":[2,65],\"540\":[1],\"541\":[1,66],\"542\":[2,11],\"543\":[2,45],\"544\":[1],\"545\":[1,11],\"546\":[1,28],\"547\":[3,49],\"548\":[4,44],\"549\":[1,35],\"550\":[1,31],\"551\":[1,16],\"552\":[1],\"553\":[1,35],\"554\":[1,20],\"555\":[1,38],\"556\":[2,92],\"557\":[2,35],\"558\":[2,41],\"559\":[1,142],\"560\":[2,41],\"561\":[1,29],\"562\":[2,40],\"563\":[1,36],\"564\":[2,6],\"565\":[1,26],\"566\":[2,50],\"567\":[2,9],\"568\":[2,113],\"569\":[1,21],\"570\":[2,20],\"571\":[2,80],\"572\":[2,42],\"573\":[5,22],\"574\":[2,80],\"575\":[3,14],\"576\":[1,31],\"577\":[3,34],\"578\":[3,67],\"579\":[2,22],\"580\":[1,39],\"581\":[1,16],\"582\":[1,58],\"583\":[1,34],\"584\":[1,43],\"585\":[2,127],\"586\":[1,15],\"587\":[1,80],\"588\":[1,17],\"589\":[1,27],\"590\":[1],\"591\":[1,16],\"592\":[1,18],\"593\":[3,18],\"594\":[1,48],\"595\":[1,6],\"596\":[4,26],\"597\":[1,29],\"598\":[1],\"599\":[3],\"600\":[2],\"601\":[2,63],\"602\":[1],\"603\":[2,61],\"604\":[3,61],\"605\":[2],\"606\":[3,67],\"607\":[1,63],\"608\":[5,21],\"609\":[2,21],\"610\":[4,59],\"611\":[5,28],\"612\":[1,59],\"613\":[1,37],\"614\":[4,27],\"615\":[6,37],\"616\":[4,11],\"617\":[1,40],\"618\":[1,20],\"619\":[1,31],\"620\":[4,21],\"621\":[1],\"622\":[1,81],\"623\":[3,160],\"624\":[3,115],\"625\":[3,16],\"626\":[1,33],\"627\":[4,51],\"628\":[1,32],\"629\":[1,10],\"630\":[3,109],\"631\":[1,8],\"632\":[2,68],\"633\":[2,8],\"634\":[1],\"635\":[4,6],\"636\":[3,27],\"637\":[2,55],\"638\":[2,18],\"639\":[1],\"640\":[1,28],\"641\":[1,61],\"642\":[1,83],\"643\":[1,53],\"644\":[1,32],\"645\":[1,84],\"646\":[2,18],\"647\":[4,134],\"648\":[2,30],\"649\":[5,45],\"650\":[2,44],\"651\":[4,75],\"652\":[4,15],\"653\":[2,52],\"654\":[4,5],\"655\":[1,90],\"656\":[1,57],\"657\":[1,144],\"658\":[1,16],\"659\":[1,97],\"660\":[2,78],\"661\":[2,53],\"662\":[1,41],\"663\":[1,14],\"664\":[2,15],\"665\":[2,63],\"666\":[1],\"667\":[2,16],\"668\":[1,93],\"669\":[2,33],\"670\":[2,5],\"671\":[5,34],\"672\":[1,74],\"673\":[1,43],\"674\":[2,42],\"675\":[4,53],\"676\":[4,67],\"677\":[1,83],\"678\":[2,102],\"679\":[3,35],\"680\":[4,26],\"681\":[1,68],\"682\":[2,7],\"683\":[1,49],\"684\":[1,28],\"685\":[2,31],\"686\":[1],\"687\":[1,44],\"688\":[1,6],\"689\":[2,19],\"690\":[2,11],\"691\":[2,13],\"692\":[2,8],\"693\":[2,7],\"694\":[2,8],\"695\":[2,7],\"696\":[2,16],\"697\":[1,9],\"698\":[1],\"699\":[1],\"700\":[1,8],\"701\":[3,23],\"702\":[1,27],\"703\":[2,20],\"704\":[1],\"705\":[1,8],\"706\":[2,11],\"707\":[2,16],\"708\":[1,33],\"709\":[1],\"710\":[1],\"711\":[1],\"712\":[1,62],\"713\":[1,64],\"714\":[4,44],\"715\":[1,56],\"716\":[1,21],\"717\":[2,37],\"718\":[2,139],\"719\":[2,31],\"720\":[2,27],\"721\":[1,27],\"722\":[2,16],\"723\":[1,13],\"724\":[1,19],\"725\":[1,73],\"726\":[1,35],\"727\":[2,19],\"728\":[1,19],\"729\":[2,31],\"730\":[3,20],\"731\":[1,29],\"732\":[1],\"733\":[1,50],\"734\":[1,51],\"735\":[3,44],\"736\":[1,91],\"737\":[1,32],\"738\":[1],\"739\":[1,28],\"740\":[1,36],\"741\":[1,33],\"742\":[3,37],\"743\":[1,38],\"744\":[3,12],\"745\":[5,52],\"746\":[2,69],\"747\":[3,12],\"748\":[2,35],\"749\":[5,34],\"750\":[4,17],\"751\":[1,33],\"752\":[3,35],\"753\":[3,30],\"754\":[1,68],\"755\":[3,119],\"756\":[3,26],\"757\":[5,6],\"758\":[3,6],\"759\":[4,108],\"760\":[1],\"761\":[1,14],\"762\":[4,9],\"763\":[2,13],\"764\":[2,9],\"765\":[1,5],\"766\":[1,15],\"767\":[1,17],\"768\":[1,14],\"769\":[1,25],\"770\":[1,36],\"771\":[1,34],\"772\":[1,26],\"773\":[1,13],\"774\":[6,32],\"775\":[1,3],\"776\":[1,23],\"777\":[4,25],\"778\":[5,8],\"779\":[4,15],\"780\":[4,6],\"781\":[4,11],\"782\":[3,7],\"783\":[5,18],\"784\":[1,8],\"785\":[1,12],\"786\":[1,3],\"787\":[1,5],\"788\":[6,7],\"789\":[1,7],\"790\":[1,52],\"791\":[1,3],\"792\":[1],\"793\":[1,23],\"794\":[2,12],\"795\":[3,27],\"796\":[3,29],\"797\":[1,21],\"798\":[1,26],\"799\":[1,13],\"800\":[1,34],\"801\":[1,78],\"802\":[3,31],\"803\":[3,29],\"804\":[4,131],\"805\":[10,44],\"806\":[5,19],\"807\":[3,86],\"808\":[2,6],\"809\":[4,20],\"810\":[3,15],\"811\":[3,22],\"812\":[3,15],\"813\":[2,25],\"814\":[3,10],\"815\":[5,16],\"816\":[2,23],\"817\":[1,24],\"818\":[2,39],\"819\":[3,19],\"820\":[3,149],\"821\":[1,12],\"822\":[3,21],\"823\":[3,28],\"824\":[3,29],\"825\":[2,72],\"826\":[2,19],\"827\":[1,17],\"828\":[1],\"829\":[2,43],\"830\":[3,31],\"831\":[2,13],\"832\":[3,18],\"833\":[4,13],\"834\":[3,18],\"835\":[3,23],\"836\":[5,21],\"837\":[3,17],\"838\":[2,12],\"839\":[1],\"840\":[4,53],\"841\":[1,21],\"842\":[1],\"843\":[2,65],\"844\":[1,27],\"845\":[1,51],\"846\":[1,23],\"847\":[5,13],\"848\":[2,10],\"849\":[1,10],\"850\":[1,40],\"851\":[1],\"852\":[1,25],\"853\":[2,39],\"854\":[3,32],\"855\":[5,30],\"856\":[4,59],\"857\":[1],\"858\":[1,18],\"859\":[1,33],\"860\":[5,25],\"861\":[1,49],\"862\":[1],\"863\":[1,34],\"864\":[1,9],\"865\":[1,42],\"866\":[1,37],\"867\":[3,28],\"868\":[1,7],\"869\":[1,39],\"870\":[1,52],\"871\":[1,34],\"872\":[1,16],\"873\":[2,40],\"874\":[1,31],\"875\":[1,31],\"876\":[1,36],\"877\":[1,48],\"878\":[1,52],\"879\":[1,36],\"880\":[1,105],\"881\":[1,19],\"882\":[1,108],\"883\":[1,35],\"884\":[1,56],\"885\":[1,26],\"886\":[8,47],\"887\":[1,6],\"888\":[1,37],\"889\":[1,19],\"890\":[1,28],\"891\":[2,109],\"892\":[3,58],\"893\":[6,68],\"894\":[7,31],\"895\":[7,60],\"896\":[9,58],\"897\":[3,16],\"898\":[5,9],\"899\":[8,16],\"900\":[7,39],\"901\":[8,46],\"902\":[4,22],\"903\":[1,23],\"904\":[1,18],\"905\":[1],\"906\":[1],\"907\":[1,5],\"908\":[3,69],\"909\":[1],\"910\":[1],\"911\":[1,24],\"912\":[1,39],\"913\":[1,32],\"914\":[1],\"915\":[1,9],\"916\":[4,27],\"917\":[1],\"918\":[4,16],\"919\":[2,85],\"920\":[1,16],\"921\":[1,34],\"922\":[1,27],\"923\":[1,32],\"924\":[1,15],\"925\":[1,7],\"926\":[1],\"927\":[3,28],\"928\":[1],\"929\":[1],\"930\":[3,73],\"931\":[3,43],\"932\":[3,48],\"933\":[5,46],\"934\":[5,74],\"935\":[4,104],\"936\":[5,43],\"937\":[4,81],\"938\":[3,39],\"939\":[2],\"940\":[1,14],\"941\":[1,19],\"942\":[1,13],\"943\":[1,29],\"944\":[4],\"945\":[1],\"946\":[2,9],\"947\":[2,10],\"948\":[4,12],\"949\":[2,26],\"950\":[2],\"951\":[1,50],\"952\":[1,49],\"953\":[1,54],\"954\":[1,34],\"955\":[1,73],\"956\":[1,62],\"957\":[3,5],\"958\":[1],\"959\":[4,49],\"960\":[1,32],\"961\":[3,118],\"962\":[2,22],\"963\":[1,11],\"964\":[2,30],\"965\":[1,13],\"966\":[1,22],\"967\":[1,17],\"968\":[1,22],\"969\":[1,1],\"970\":[1],\"971\":[1,10],\"972\":[1,13],\"973\":[1,33],\"974\":[1,16],\"975\":[1,53],\"976\":[1],\"977\":[1,13],\"978\":[1,12],\"979\":[1,23],\"980\":[1,21],\"981\":[4,38],\"982\":[3,50],\"983\":[1,13],\"984\":[1,19],\"985\":[1,5],\"986\":[1,71],\"987\":[1,22],\"988\":[1],\"989\":[1,31],\"990\":[1,23],\"991\":[3,38],\"992\":[1,18],\"993\":[1,70],\"994\":[3,14],\"995\":[2,13],\"996\":[3,30],\"997\":[2,46],\"998\":[2,10],\"999\":[1,22],\"1000\":[1,20],\"1001\":[3,57],\"1002\":[1,53],\"1003\":[1,26],\"1004\":[3,47],\"1005\":[1],\"1006\":[1,68],\"1007\":[1,39],\"1008\":[1],\"1009\":[2,38],\"1010\":[1,15],\"1011\":[3,18],\"1012\":[1,34],\"1013\":[1,27],\"1014\":[3],\"1015\":[2,42],\"1016\":[1,13],\"1017\":[1,20],\"1018\":[1,31],\"1019\":[3,76],\"1020\":[2,6],\"1021\":[1,13],\"1022\":[1,75],\"1023\":[3,24],\"1024\":[3,16],\"1025\":[2,15],\"1026\":[1,78],\"1027\":[1,44],\"1028\":[1,20],\"1029\":[4,49],\"1030\":[1,13],\"1031\":[1,34],\"1032\":[1,29],\"1033\":[1,32],\"1034\":[1,9],\"1035\":[3,63],\"1036\":[1,13],\"1037\":[1,22],\"1038\":[1,100],\"1039\":[1,36],\"1040\":[1,80],\"1041\":[1,46],\"1042\":[5,190],\"1043\":[1],\"1044\":[1,45],\"1045\":[3,17],\"1046\":[4,10],\"1047\":[1,20],\"1048\":[5,26],\"1049\":[1,74],\"1050\":[3,3],\"1051\":[3,20],\"1052\":[3,32],\"1053\":[1,10],\"1054\":[1,46],\"1055\":[2,12],\"1056\":[2,19],\"1057\":[2,55],\"1058\":[1],\"1059\":[1,2],\"1060\":[1,69],\"1061\":[4,38],\"1062\":[2,38],\"1063\":[1],\"1064\":[1,61],\"1065\":[1,18],\"1066\":[1,25],\"1067\":[1,31],\"1068\":[3,50],\"1069\":[3,24],\"1070\":[3,27],\"1071\":[1,7],\"1072\":[1,9],\"1073\":[1,8],\"1074\":[1,7],\"1075\":[1,44],\"1076\":[1,10],\"1077\":[1,73],\"1078\":[1,15],\"1079\":[1,67],\"1080\":[1,8],\"1081\":[1,11],\"1082\":[1,40],\"1083\":[1,47],\"1084\":[2,14],\"1085\":[1,35],\"1086\":[1,72],\"1087\":[1,72],\"1088\":[1,40],\"1089\":[3,21],\"1090\":[1,74],\"1091\":[1,34],\"1092\":[1,30],\"1093\":[1,9],\"1094\":[1,27],\"1095\":[1,16],\"1096\":[4,12],\"1097\":[4,25],\"1098\":[4,22],\"1099\":[4,23],\"1100\":[4,25],\"1101\":[4,14],\"1102\":[1],\"1103\":[1,1],\"1104\":[1],\"1105\":[2],\"1106\":[2,1],\"1107\":[1],\"1108\":[2,16],\"1109\":[2],\"1110\":[2],\"1111\":[3],\"1112\":[1],\"1113\":[1],\"1114\":[1],\"1115\":[2,6],\"1116\":[1],\"1117\":[1,28],\"1118\":[1],\"1119\":[1,8],\"1120\":[1],\"1121\":[2,19],\"1122\":[2],\"1123\":[5,4],\"1124\":[10,29],\"1125\":[2],\"1126\":[2,30],\"1127\":[2,43],\"1128\":[1],\"1129\":[2,2],\"1130\":[3,8],\"1131\":[2],\"1132\":[1],\"1133\":[2,3],\"1134\":[2,22],\"1135\":[1],\"1136\":[2,12],\"1137\":[1],\"1138\":[2,5],\"1139\":[3,45],\"1140\":[2,31],\"1141\":[2],\"1142\":[1],\"1143\":[1,50],\"1144\":[1,110],\"1145\":[3,12],\"1146\":[1],\"1147\":[2],\"1148\":[2,33],\"1149\":[6,2],\"1150\":[3,13],\"1151\":[3,11],\"1152\":[4,4],\"1153\":[1],\"1154\":[2],\"1155\":[3,20],\"1156\":[1,11],\"1157\":[1,29],\"1158\":[2],\"1159\":[1,20],\"1160\":[2],\"1161\":[2,10],\"1162\":[3,31],\"1163\":[1,23],\"1164\":[2],\"1165\":[5,4],\"1166\":[1],\"1167\":[1,17],\"1168\":[2,26],\"1169\":[1],\"1170\":[2,26],\"1171\":[1],\"1172\":[1],\"1173\":[1,1],\"1174\":[1],\"1175\":[1],\"1176\":[3],\"1177\":[1,134],\"1178\":[1,29],\"1179\":[3,12],\"1180\":[2],\"1181\":[2],\"1182\":[3,8],\"1183\":[3],\"1184\":[3,19],\"1185\":[3],\"1186\":[3,7],\"1187\":[3],\"1188\":[5,29],\"1189\":[4,2],\"1190\":[4,60],\"1191\":[1],\"1192\":[3,11],\"1193\":[2],\"1194\":[1],\"1195\":[3],\"1196\":[3],\"1197\":[4,15],\"1198\":[5,11],\"1199\":[5,10],\"1200\":[5,16],\"1201\":[4,13],\"1202\":[9,51],\"1203\":[3,4],\"1204\":[7,5],\"1205\":[3],\"1206\":[10,24],\"1207\":[1],\"1208\":[3,14],\"1209\":[2,13],\"1210\":[2,19],\"1211\":[3],\"1212\":[8,33],\"1213\":[1,5],\"1214\":[2],\"1215\":[2,4],\"1216\":[2,19],\"1217\":[3,21],\"1218\":[4,10],\"1219\":[4,16],\"1220\":[3,2],\"1221\":[3,29],\"1222\":[4,4],\"1223\":[3],\"1224\":[2,9],\"1225\":[3,6],\"1226\":[2,7],\"1227\":[3,4],\"1228\":[3],\"1229\":[3,6],\"1230\":[4,12],\"1231\":[6,8],\"1232\":[3,10],\"1233\":[7,5],\"1234\":[3,5],\"1235\":[3],\"1236\":[4,11],\"1237\":[3],\"1238\":[5,8],\"1239\":[4,11],\"1240\":[4,19],\"1241\":[3],\"1242\":[5,39],\"1243\":[6,10],\"1244\":[3],\"1245\":[2,23],\"1246\":[2,4],\"1247\":[1,25],\"1248\":[1],\"1249\":[2,16],\"1250\":[2],\"1251\":[3],\"1252\":[3],\"1253\":[3],\"1254\":[3],\"1255\":[3,23],\"1256\":[4,19],\"1257\":[5,14],\"1258\":[2],\"1259\":[6,19],\"1260\":[3,51],\"1261\":[3,56],\"1262\":[2],\"1263\":[2,3],\"1264\":[1,3],\"1265\":[2],\"1266\":[1,46],\"1267\":[2],\"1268\":[2],\"1269\":[5,11],\"1270\":[5,6],\"1271\":[3,21],\"1272\":[3],\"1273\":[3,7],\"1274\":[3,5],\"1275\":[1,3]},\"averageFieldLength\":[2.090125391849527,32.13035059979638],\"storedFields\":{\"0\":{\"h\":\"\"},\"1\":{\"h\":\"前言\",\"t\":[\"采用 VuePress2.0.0 + Github Pages 搭建的个人笔记网站，以在不同的地点在线编辑/查阅笔记。\"]},\"2\":{\"h\":\"\"},\"3\":{\"h\":\"0\",\"t\":[\"代码随想录\"]},\"4\":{\"h\":\"数组\"},\"5\":{\"h\":\"二分查找\",\"t\":[\"难点在于边界。左闭右开，左闭右闭二选一\"]},\"6\":{\"h\":\"移除元素\",\"t\":[\"给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\",\"方法：双指针\"]},\"7\":{\"h\":\"链表\"},\"8\":{\"h\":\"栈与队列\"},\"9\":{\"h\":\"二叉树\"},\"10\":{\"h\":\"回溯\"},\"11\":{\"h\":\"贪心\"},\"12\":{\"h\":\"动态规划\"},\"13\":{\"h\":\"Sql\"},\"14\":{\"h\":\"0 序\"},\"15\":{\"h\":\"\"},\"16\":{\"h\":\"0 序\",\"t\":[\"介绍一些常用开发工具\"]},\"17\":{\"h\":\"\"},\"18\":{\"h\":\"0 序\",\"t\":[\"对于 dotnet 的认知大都来自于“信创适配”。项目 A 使用.netframework 4.8 进行编写，无法在国产操作系统（UOS、kylinOS...，大多基于 debian>>deepin）。为了使其能够在信创设备上运行，在国产操作系统上安装了 wine(wine is not an emulator)🍷。结果项目 A 并不能直接在 wine 中运行，于是对项目 A 的 C#源码进行了一些修改（主要是替换掉项目名对于 ADODB 的依赖）。替换后，项目得以成功运行。\"]},\"19\":{\"h\":\"wine\"},\"20\":{\"h\":\"\"},\"21\":{\"h\":\"1 HTML\"},\"22\":{\"h\":\"2 CSS\"},\"23\":{\"h\":\"2.1 less\",\"t\":[\"less 的优点是支持嵌套，官网的教程很简短易读，这里就不多介绍了\"]},\"24\":{\"h\":\"2.2 scoped 和 :deep\",\"t\":[\"就是在 vue 文件中，<style>标签加上 scoped 变成<style scoped>，就意味着标签内的样式只对当前组件生效，不会穿透到当前组件的后代组件上去。:deep 与其作用刚好相反，选择器 selector 外面包裹一层:deep(selector)，样式就会穿透到选择器的所有后代组件，有可能会发生局部的样式污染，但不会发生全局的样式污染。\"]},\"25\":{\"h\":\"BEM 命名规范\"},\"26\":{\"h\":\"概念与用法\",\"t\":[\"block（块）：可以独立使用的 HTML 元素（比如：<nav>），可以不包含 element。\",\"element（元素）：依附于 block 的 HTML 元素，无法独立存在（比如：<li>），前面要加上双下划线__。\",\"modifier（修饰符）：表示 block 或者 element 的状态和外观，前面要加上双连字符--。\",\"用单连字符 - 连接单词，比如：search-form。\",\"element 只属于 block，而不是另一个 element。错误写法：block__element1__element2，正确写法：block__element2。\",\"使用 modifier 时，同时保留不含 modifier 的类名，比如：<a class=\\\"menu__link menu__link--active\\\" href=\\\"/zh-cn/\\\">主页</a>。\"]},\"27\":{\"h\":\"Java并发\"},\"28\":{\"h\":\"进程线程区别\",\"t\":[\"进程：是程序运行和系统资源分配的基本单位（与线程的根本区别）。\",\"**线程：**是进程的一个实体，是 cpu 调度和分派的基本单位，是比进程更小的能独立运行的单元。\",\"进程与线程的区别\",\"资源拥有：进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。\",\"地址空间：进程有自己独立的地址空间，线程没有自己独立的地址空间。\",\"资源开销：进程间切换有较大的开销，线程间切换开销较小。因为进程切换要切换页目录以使用新的地址空间，把原进程的数据段代码换出去，把要执行的进程内容换进来。\"]},\"29\":{\"h\":\"一、多线程基础知识\"},\"30\":{\"h\":\"为什么要使用多线程\",\"t\":[\"线程可以看作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度成本远远小于进程。\",\"多核 CPU 时代意味着多个线程可以通过运行，减少了线程上下文切换的开销，且提高了 CPU 的利用率。\",\"现在的系统要求百万级甚至千万级的并发量，合理利用多线程机制可以大大提高系统整体的并发能力以及性能。\"]},\"31\":{\"h\":\"创建线程的四种方式\",\"t\":[\"方法一 继承 Thread 类，重写 run 方法\",\"// 构造方法的参数是给线程指定名字，，推荐给线程起个名字 Thread t1 = new Thread(\\\"t1\\\") { @Override // run 方法内实现了要执行的任务 public void run() { log.debug(\\\"hello\\\"); } }; t1.start(); \",\"方法二 实现 Runnable 接口\",\"// 创建任务对象 Runnable task2 = new Runnable() { @Override public void run() { log.debug(\\\"hello\\\"); } }; // 参数1 是任务对象; 参数2 是线程名字，推荐给线程起个名字 Thread t2 = new Thread(task2, \\\"t2\\\"); t2.start(); \",\"方法三 通过 Callable 和 Future 创建线程\",\"public class MyCallable implements Callable<Integer> { public Integer call() { return 123; } } public static void main(String[] args) throws ExecutionException, InterruptedException { MyCallable mc = new MyCallable(); FutureTask<Integer> ft = new FutureTask<>(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get()); } \",\"方法四 通过线程池创建线程\"]},\"32\":{\"h\":\"Runnable 和 Thread\",\"t\":[\"实现接口会更好一些，因为：\",\"Java 不支持多继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；\",\"继承整个 Thread 类开销过大。\",\"Thread 是把线程和任务合并在了一起，Runnable 是把线程和任务分开了，用 Runnable 更容易与线程池等高级 API 配合，用 Runnable 让任务类脱离了 Thread 继承体系，更灵活。通过查看源码可以发现，Runnable 其实到底还是通过 Thread 执行的！\"]},\"33\":{\"h\":\"Runnable 和 Callable\",\"t\":[\"Runnable 接口中的 run() 方法的返回值是 void，它做的事情只是纯粹地去执行 run() 方法中的代码而已；\",\"Callable 接口中的 call() 方法是有返回值的，是一个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果。\"]},\"34\":{\"h\":\"start，run\",\"t\":[\"​ 线程 run()方法是由 java 虚拟机直接调用的，如果我们没有启动线程(没有调用线程的 start()方法)而是在应用代码中直接调用 run()方法，那么这个线程的 run()方法其实运行在当前线程(即 run()方法的调用在调用方所在的线程)之中，而不是运行在其自身的线程中，从而违背了创建线程的初衷。\"]},\"35\":{\"h\":\"sleep，yiled，wait，join\",\"t\":[\"sleep 属于Thread 类 ：不释放锁、释放 cpu；不会释放锁，只会阻塞线程，让出 cpu 给其它线程，但是它的监控状态依然保持着，当指定时间到了又会自动恢复可运行状态，可中断，sleep 给其他线程机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会。\",\"join 属于 Thread 类：释放锁、抢占 cpu；t.join：暂停主线程，等到线程 t 执行完。一般用于等待异步线程执行完结果之后才能继续运行的场景。例如：主线程创建并启动了子线程，如果子线程中要进行大量耗时运算计算某个数据值，而主线程要取得这个数据值才能运行，这时就要用到 join 方法了\",\"yield 属于Thread类：不释放锁、释放 cpu；与 sleep 不同的是 yield 不会让线程进入阻塞状态，而是让线程重回就绪状态，他只需要等待重新获取 CPU 时间，所以执行 yield()的线程有可能在进入到可执行状态后马上又被执行。还有一点和 sleep 不同的是 yield 方法只能使同优先级或更高优先级的线程有执行的机会。\",\"wait 属于Object类：释放锁、释放 cpu。wait 的过程中线程会释放锁，只有当其他线程调用notify才能唤醒此线程。wait 使用时必须先获取对象锁，即必须在 synchronized 修饰的代码块中使用，那么相应的 notify 方法同样必须在 synchronized 修饰的代码块中使用，如果没有在 synchronized 修饰的代码块中使用时运行时会抛出 IllegalMonitorStateException的异常。\",\"补充：\",\"sleep，join，yield，interrupted 是 Thread 类中的方法；\",\"wait/notify 是 object 中的方法。\"]},\"36\":{\"h\":\"为什么 wait()和 notify()属于 Object 类\",\"t\":[\"简单说：因为 synchronized 中的这把锁可以是任意对象，所以任意对象都可以调用 wait()和 notify()；所以 wait 和 notify 属于 Object。\",\"专业说：因为这些方法在操作同步线程时，都必须要标识它们操作线程的锁，只有同一个锁上的等待线程，可以被同一个锁上的 notify 唤醒，不可以对不同锁中的线程进行唤醒。\",\"也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在 object 类中。\"]},\"37\":{\"h\":\"sleep()和 wait()的异同\",\"t\":[\"sleep() 是 Thread 类的方法，调用会暂停此线程，但监控依然保持，不会释放对象锁，到时间自动恢复；wait() 是 Object 的方法，调用会放弃对象锁，进入 WaitSet 等待队列，待调用 notify()/notifyAll() 唤醒指定的线程或者所有线程，才会进入 EntryList 队列竞争锁。\",\"它们都可以被 interrupted 方法中断。\",\"sleep() 方法可以在任何地方使用，而 wait() 方法则只能在同步方法或同步块中使用。\"]},\"38\":{\"h\":\"线程、\",\"t\":[\"Thread 的源码中定义了 6 种状态：\",\"new（新建）：创建后尚未启动。\",\"runnnable（可运行）：正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。\",\"blocked（阻塞）：请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以处于阻塞状态。要结束该状态进入 runnable 需要其他线程释放 monitor lock。\",\"waiting（等待）：等待其它线程显式地唤醒。阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 wait() 等方法进入。\",\"进入方法\",\"退出方法\",\"没有设置 Timeout 参数的 Object.wait() 方法\",\"Object.notify() / Object.notifyAll()\",\"没有设置 Timeout 参数的 Thread.join() 方法\",\"被调用的线程执行完毕\",\"LockSupport.park() 方法\",\"LockSupport.unpark(Thread)\",\"time waiting （定时等待）：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。\",\"进入方法\",\"退出方法\",\"Thread.sleep() 方法\",\"时间结束\",\"设置了 Timeout 参数的 Object.wait() 方法\",\"时间结束 / Object.notify() / Object.notifyAll()\",\"设置了 Timeout 参数的 Thread.join() 方法\",\"时间结束 / 被调用的线程执行完毕\",\"LockSupport.parkNanos() 方法\",\"LockSupport.unpark(Thread)\",\"LockSupport.parkUntil() 方法\",\"LockSupport.unpark(Thread)\",\"terminated（终止）：可以是线程结束任务之后自己结束，或者产生了异常而结束。\",\"状态转换\"]},\"39\":{\"h\":\"ThreadLocal\",\"t\":[\"​ ThreadLocal 类用来提供线程内部的局部变量，这种变量在多线程环境下访问时能保证各个线程的变量相对独立于其它线程内的变量。(线程隔离)\",\"​ 每个 Thread 线程内部都有一个 ThreadLocalMap，Map 里面存储ThreadLocal 对象(key)和线程变量副本(value)，Thread 内部的 Map 是由ThreadLocal 维护的，由 ThreadLocal 负责向 map 获取和设置线程的变量值；对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。\",\"使用场景\",\"​ 每个线程需要有自己单独的实例；实例需要在多个方法中共享，但不希望被多线程共享。例如存储用户的 Session，因为 Session 在当前会话周期内有效，会话结束便销毁。还有像线程内上下文管理器、数据库连接等可以用到 ThreadLocal;\",\"​ 向 ThreadLocal 里面存东西就是向他里面的 map 存东西，然后 ThreadLocal 把这个 Map 挂到当前线程的底下，这样 Map 就只属于这个线程了。\",\"使用方式\",\"//接口方法 public T get() {...} //该方法返回当前线程所对应的线程局部变量(先获取当前线程的ThreadLocalMap变量，如果存在则返回值，不存在则创建并返回初始值) public void set(T value) {...} //设置当前线程的线程局部变量的值(先获取当前线程，并获取当前线程的ThreadLocalMap若不为空，则将参数设置到map中去(当前的ThreadLoca的引用作为key)，如果为空则为该线程创建map并设置初始值) public void remove() {...} //获取当前线程，并获取其ThreadLocalMap，如果map不为空移除当前ThreadLocal对象对应的entry protected T initialValue() {...} //返回该线程局部变量的初始值，该方法是一个protected(同包或者不同包的子类)的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在set方法还没调用而先调用了get方法时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。 \",\"ThreadLocal<String> mLocal = new ThreadLocal<>(); //创建 // 创建并赋初始值 private static ThreadLocal<String> mLocal = new ThreadLocal<String>(){ @Override protected String initialValue(){ return \\\"init value\\\"; } }; System.out.println(mLocal.get()); mLocal.set(\\\"hello\\\"); // 设置值 mLocal.get() //获取值 \",\"原理 ThreadLocal 原理\",\"​ 每一个线程维护一个 ThreadLocalMap（所以一个线程内可以存在多个 ThreadLocal），key 为使用弱引用的 ThreadLocal 实例，value 为强引用的线程变量副本。\"]},\"40\":{\"h\":\"ThreadLocal 和 synchronized 的对比\",\"t\":[\"synchronized\",\"ThreadLocal\",\"原理\",\"采用 \\\"以时间换空间\\\" 的方式， 只提供了一份变量，让不同的线程排队访问\",\"采用 \\\"以空间换时间\\\" 的方式，为每一个线程都提供了一份变量副本，从而实现同时访问而相不干扰\",\"侧重点\",\"多个线程之间访问资源的同步，用于线程间的数据共享\",\"多线程中让每个线程间数据隔离问题；用于线程间数据隔离\",\"​ 虽然二者都能解决问题，但是 ThreadLocal 拥有更高的并发性。\",\"Spring 使用 ThreadLocal 解决线程安全问题。\"]},\"41\":{\"h\":\"ThreadLocal 的内部结构(设计过程)\",\"t\":[\"​ 每个 Thread 线程内部都有一个 ThreadLocalMap，Map 里面存储ThreadLocal 对象(key)和线程变量副本(value)，Thread 内部的 Map 是由 ThreadLocal 维护的，由 ThreadLocal 负责向 map 获取和设置线程的变量值；对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。\"]},\"42\":{\"h\":\"ThreadLocalMap 的结构\",\"t\":[\"​ ThreadLocalMap 是 ThreadLocal 的内部类，没有实现 Map 接口，用独立的方法实现了 Map 功能，其内部 Entry 也是独立实现的。\",\"JDK8 中 ThreadLocal 设计方案的好处：\",\"每个 map 存储的 Entry 数量变少\",\"当 Thread 销毁时，ThreadLocalMap 也会随之销毁，减少内存的使用。\"]},\"43\":{\"h\":\"ThreadLocal 在 Spring 中的使用\",\"t\":[\"​ Spring 提供了事务相关的操作，而事务得保证一组操作同时成功或失败，这也就意味着所有操作需要在同一个数据库连接上，Spring 就是用 ThreadLocal 来实现的，ThreadLocal 存储类型是一个 Map，Map 中的 key 是 DataSource，value 是 Connection 对象。用了 ThreadLocal 保证了同一个线程获取一个 Connection 对象，从而保证一次事务的所有操作都在同一个数据库连接上。\"]},\"44\":{\"h\":\"ThreadLocal 的应用\",\"t\":[\"​ 每个线程需要有自己单独的实例；实例需要在多个方法中共享，但不希望被多线程共享。例如存储用户的 Session，因为 Session 在当前会话周期内有效，会话结束便销毁。还有像线程内上下文管理器、数据库连接等可以用到 ThreadLocal;\"]},\"45\":{\"h\":\"ThreadLocal 内存泄露问题\",\"t\":[\"​ ThreadLocal 内存泄漏的根源是：由于 ThreadLocalMap 的生命周期跟 Thread 一样长（在没有手动删除这个 Entry 的前提下，始终有 ThreadRef->currentThread->ThreadLocalMap->enrty(entry 中包含了 ThreadLocal 实例和 value)导致内存泄漏），如果没有手动删除对应 key(Entry)就会导致内存泄漏，而不是因为弱引用。\",\"：\",\"使用完 ThreadLocal 后，执行 remove() 操作，手动删除 Entry，避免出现内存泄露。(主要)\",\"使用完 ThreadLocal 后，当前 Thread 也随之结束。\",\"内存泄漏相关概念：\",\"Memory Overflow：内存溢出，没有足够的内存提供给申请者使用\",\"Memory leak：内存泄漏是指程序中已动态分配的堆内存由于某种原因程序未释放或者无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果，内存泄漏的堆积终将导致内存溢出。\",\"弱引用相关概念：\",\"强引用：就是常见的普通对象的引用，只要还有强引用指向一个对象，就能表明对象还”活着‘’垃圾回收器就不会回收这种对象\",\"弱引用：垃圾回收器一旦发现弱引用的对象，不管内存空间足够与否，都会回收它的的内存。\"]},\"46\":{\"h\":\"ThreadLocal(key) 为什么使用弱引用？\",\"t\":[\"​ ThreadLocalMap 调用set/get/remove 方法时，会对 key 为 null 进行判断，如果为 null 的话，那么会对 value 置为 null。\",\"​ 这就意味着使用完 ThreadLocal，线程依然运行的前提下，就算忘记调用 remove 方法，弱引用比强引用可以多一层保障，弱引用的 ThreadLocal 会被回收，对应的 value 在下一次 ThreadLocalMap 调用 set，get，remove 的任一方法时会被清除，从而避免内存泄漏，但不能 100% 保证内存不泄露。(没有调用这些方法时，此时 value 中的还是有值，且当线程运行时无法被垃圾回收)。\"]},\"47\":{\"h\":\"ThreadLocal hash 冲突的解决\",\"t\":[\"​ ThreadLocal 使用线性探测法来解决哈希冲突，该方法探测下一个空余地址插入，若整个空间都找不到空余地址，则产生溢出。我们可以把 Entry[ ] table 看作一个环形数组。\"]},\"48\":{\"h\":\"如何判断是否线程安全\",\"t\":[\"判断一个程序是否存在线程安全问题\",\"是否是多线程环境；\",\"是否存在多个线程修改一个共享资源；\",\"线程安全的实现方式\",\"不可变\",\"互斥同步：synchronized 和 ReentrantLock\",\"非阻塞同步：CAS\",\"建立副本：ThreadLocal\"]},\"49\":{\"h\":\"Fork/Join 框架\",\"t\":[\"​ Fork/Join 框架是 Java 7 提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。\",\"Fork 把大任务切分成若干个子任务并行的执行。\",\"Join 就是合并这些子任务的执行结果。\"]},\"50\":{\"h\":\"生产者消费者模式\",\"t\":[\"​ 在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序整体处理数据的速度。\",\"​ 为了平衡生产和消费速度不一致的问题，生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。\",\"​ 这个阻塞队列就是用来给生产者和消费者解耦的。纵观大多数设计模式，都会找一个第三者出来进行解耦，如工厂模式的第三者是工厂类，模板模式的第三者是模板类。在学习一些设计模式的过程中，先找到这个模式的第三者，能帮助我们快速熟悉一个设计模式。\"]},\"51\":{\"h\":\"如何控制线程执行顺序\",\"t\":[\"使用 join：每执行一个线程 t，就调用t.join()，这样可以使得 main 线程暂停，等到 t 执行完之后再继续调用其他线程。\",\"使用单线程线程池。\"]},\"52\":{\"h\":\"二、线程池\"},\"53\":{\"h\":\"线程池的好处\",\"t\":[\"降低资源消耗：通过线程复用，降低线程创建和销毁造成的消耗。\",\"提高响应速度：当任务到达时，任务可以不需要的等到线程创建就能立即执行。\",\"提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\"]},\"54\":{\"h\":\"线程池处理任务的流程\"},\"55\":{\"h\":\"4 种常见线程池及选择\"},\"56\":{\"h\":\"的实现方式：\",\"t\":[\"// 快速创建线程池，但是创建的细节未知。不要通过这种方法创建，通过 ThreadPoolExecutor 创建。 ExecutorService executorService = Executors.newCachedThreadPool(); \",\"4 种常见线程池\",\"特点\",\"应用场景\",\"对应的阻塞队列\",\"固定大小线程池（newFixedThreadPool）\",\"核心线程数 = 最大线程数，且有限多\",\"适用于任务量已知，相对耗时的任务\",\"LinkedBlockingQueue\",\"带缓冲线程池（newCachedThreadPool）\",\"核心线程数是 0，最大线程数 INTEGER.MAX_VALUE。意味着全部是救急线程，且可近似认为任务线程数可以无限多\",\"任务数比较密集，但每个任务执行时间较短的情况\",\"SynchronousQueue\",\"单线程线程池（newSingleThreadExecutor）\",\"核心线程数 = 最大线程数 = 1\",\"适用于需要保证顺序执行各个任务\",\"LinkedBlockingQueue\",\"任务调度线程池（newScheduledThreadPool）\",\"延时执行 + 定时周期性执行\",\"适用于延时执行或者周期性任务\",\"DelayQueue\"]},\"57\":{\"h\":\"线程池创建多少线程合适\",\"t\":[\"线程的 CPU 耗时所占比例越高，就需要越少的线程\",\"线程的 IO 耗时所占比例越高，就需要越多的线程\",\"针对不同的程序，进行对应的实际测试就可以得到最合适的选择\",\"线程数 >= CPU 核心数\",\"CPU 密集型：最佳线程数= cpu 核心数的 1-2 倍\",\"通用公式(IO 密集型也能用)\",\"线程数 = CPU 核心数 * (1+ IO 耗时/CPU 耗时)\"]},\"58\":{\"h\":\"ThreadPoolExecutor 的参数\",\"t\":[\"① corePoolSize：常驻核心线程数。即使本地任务执行完，核心线程也不会被销毁。\",\"② maximumPoolSize：线程池能够容纳同时执行的线程最大数， maximumPoolSize ≥ 1 。\",\"③ keepAliveTime：线程空闲时间，线程空闲的时间达到该值后会被销毁，直到只剩下 corePoolSize 个线程为止，避免浪费内存资源。\",\"④ unit：keepAliveTime 的时间单位。\",\"⑤ workQueue：工作队列，当线程请求数 ≥ corePoolSize 时，线程会进入阻塞队列。\",\"⑥ threadFactory：线程工厂，用来生产一组相同任务的线程。可以给线程命名，有利于分析错误。\",\"⑦ handler：拒绝策略。如果创建线程数达到 maximumPoolSize 仍然有新任务这时会执行拒绝策略。\",\"// ThreadPoolExecutor 的构造方法 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize < 0 || maximumPoolSize <= 0 || maximumPoolSize < corePoolSize || keepAliveTime < 0) throw new IllegalArgumentException(); if (workQueue <span style=\\\"background-color: yellow\\\"> null || threadFactory </span> null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } \"]},\"59\":{\"h\":\"创建、关闭线程池\",\"t\":[\"创建：\",\"// 《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险 ThreadPoolExecutor executor = new ThreadPoolExecutor(7, 8, 5, TimeUnit.SECONDS, new LinkedBlockingDeque<Runnable>()); \",\"关闭：\",\"​ shutdown 或 shutdownNow 。原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法中断线程，无法响应中断的任务可能永远无法终止。\",\"shutdownNow 首先将线程池的状态设为 STOP，然后尝试停止正在执行或暂停任务的线程，并返回等待执行任务的列表。\",\"shutdown 只是将线程池的状态设为 SHUTDOWN，然后中断没有正在执行任务的线程，不接受新任务，继续处理现有任务。\",\"​ 通常调用 shutdown 来关闭线程池，如果任务不一定要执行完可调用 shutdownNow。\"]},\"60\":{\"h\":\"handler 拒绝策略\",\"t\":[\"拒绝策略 JDK 提供了 4 种实现：\",\"JDK 提供的拒绝策略\",\"说明\",\"AbortPolicy\",\"直接抛出异常，\",\"CallerRunsPolicy\",\"用调用者所在的线程来执行任务\",\"DiscardOldestPolicy\",\"丢弃阻塞队列中靠最前的任务，将新的任务添加\",\"DiscardPolicy\",\"直接丢弃任务\"]},\"61\":{\"h\":\"execute() / submit() 的区别\",\"t\":[\"execute() 用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；\",\"submit() 用于提交需要返回值的任务。\",\"​ 线程池会返回一个 Future 类型的对象，可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get(long timeout，TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。\"]},\"62\":{\"h\":\"阻塞队列\",\"t\":[\"​ 阻塞队列相比普通队列，支持阻塞的插入和移除。阻塞队列常用于生产者和消费者的场景，阻塞队列就是生产者用来存放元素，消费者用来获取元素的容器。\",\"当队列满时，会阻塞插入元素的线程，直到队列不满。\",\"当队列为空时，获取元素的线程会被阻塞，直到队列非空。\",\"Java 中的阻塞队列\",\"ArrayBlockingQueue，由数组组成的有界阻塞队列，默认情况下不保证线程公平，有可能先阻塞的线程最后才访问队列。\",\"LinkedBlockingQueue，由链表结构组成的有界阻塞队列，队列的默认和最大长度为 Integer 最大值。\",\"PriorityBlockingQueue，支持优先级排序的无界阻塞队列，默认情况下元素按照升序排序。可自定义 compareTo 方法指定排序规则，或者初始化时指定 Comparator 排序，不能保证同优先级元素的顺序。\",\"DelayQueue，支持延时获取元素的无界阻塞队列，使用优先级队列实现。创建元素时可以指定多久才能从队列中获取当前元素，只有延迟期满时才能从队列中获取元素，适用于缓存和定时调度。\",\"SynchronousQueue，不存储元素的阻塞队列，每一个 put 必须等待一个 take。默认使用非公平策略，也支持公平策略，适用于传递性场景，吞吐量高。\",\"LinkedTransferQueue，链表组成的无界阻塞队列。\",\"LinkedBlockingDeque，链表组成的双向阻塞队列，可从队列的两端插入和移出元素，多线程同时入队时减少了竞争。\",\"实现原理\",\"​ 使用通知模式实现：生产者往满的队列里添加元素时会阻塞，当消费者消费后，会通知生产者当前队列可用。当往队列里插入一个元素时，如果队列不可用，主要通过 LockSupport 的 park() 方法阻塞生产者，不同操作系统中实现方式不同，在 Linux 下使用的是系统方法 pthread_cond_wait 实现。\"]},\"63\":{\"h\":\"线程池的生命周期、状态\",\"t\":[\"RUNNING：接收新的任务并处理队列中的任务。\",\"SHUTDOWN：不接受新任务，处理队列中剩余任务\",\"STOP：不接受新任务，不处理队列中的任务，同时中断处理中的任务\",\"TIDYING：所有任务处理完成，执行函数 terminated() 进入 TERMINATED 状态\",\"TERMINATED：线程池彻底终止\"]},\"64\":{\"h\":\"线程池中的线程数一般怎么设置？\",\"t\":[\"**线程池中线程执行任务的性质：**计算密集型的任务比较占 cpu，所以一般线程数设置的大小等于或者略微大于 cpu 的核数；但 IO 型任务主要时间消耗在 IO 等待上，cpu 压力并不大，所以线程数一般设置较大。\",\"**cpu 使用率：**当线程数设置较大时，线程的初始化，切换，销毁等操作会消耗不小的 cpu 资源，使得 cpu 利用率一直维持在较高水平。\",\"**内存使用率：**线程数过多和队列的大小都会影响此项数据，队列的大小应该通过前期计算线程池任务的条数，来合理的设置队列的大小，不宜过小，让其不会溢出，因为溢出会走拒绝策略，多少会影响性能，也会增加复杂度。\",\"**下游系统抗并发能力：**多线程给下游系统造成的并发等于你设置的线程数，例如：如果是多线程访问数据库，你就考虑数据库的连接池大小设置，数据库并发太多影响其 QPS，会把数据库打挂等问题。\"]},\"65\":{\"h\":\"三、JMM(JAVA 内存模型)⭐\",\"t\":[\"并发问题产生的三大根源：可见性、有序性和原子性。\",\"​ JMM(Java 内存模型)规定了虚拟机和计算机内存之间是如何协同工作的，也就是一个线程何时可以看到由其他线程修改的变量，以及如何同步访问的共享变量。JMM 中的几点规定：JMM 规定所有变量都存储在主内存；。\",\"​ java 为了屏蔽硬件和操作系统访问内存的各种差异，提出了 JAVA 内存模型的规范，保证了 JAVA 程序在各种平台下对内存的访问都能得到一致效果。Java 内存模型是一种规范(规则)，Java 虚拟机会实现这种规范。\"]},\"66\":{\"h\":\"主存与工作内存\",\"t\":[\"​ 主内存：主内存是虚拟机内存的部分(java 内存模型(JMM)规定了所有的变量都存储在主内存中)。\",\"​ 工作内存：每条线程还有自己的工作内存(working memory)，可以比作高速缓存。\",\"​ 线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值)都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。\"]},\"67\":{\"h\":\"原子性、可见性、有序性\",\"t\":[\"原子性：同一时刻只能有一个线程对数据进行操作。\",\"可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized、volatile、final）；\",\"有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序。(happens-before 原则)\"]},\"68\":{\"h\":\"如何保证原子性？\",\"t\":[\"通过互斥同步方式保证原子性，如：synchronized、ReentrantLock、Atomic、CAS。\"]},\"69\":{\"h\":\"如何保证可见性？\",\"t\":[\"synchronized\",\"加锁时，必须清空工作内存中共享变量值，从主内存获取最新共享变量值\",\"解锁时，将工作内存修改的共享变量刷新到主内存中\",\"volatile\",\"当一个变量被声明为 volatile 时，：\",\"线程读取共享变量时，会先清空工作内存中变量值，再从主内存中获取最新值\",\"线程写入共享变量时，直接把值刷新回主内存\"]},\"70\":{\"h\":\"如何保证有序性？\",\"t\":[\"​ 由于处理器为了提高程序运行效率，可能会对代码进行指令重排，它不保证程序中各语句执行先后顺序同代码中顺序一致，但它在进行重排序时会考虑指令之间的数据依赖性，保证程序最终执行结果和代码顺序执行的结果一致。\"]},\"71\":{\"h\":\"打破有序性的三种重排序\",\"t\":[\"编译器优化的重排序：编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序\",\"指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应的机器指令的执行顺序，也就是CPU 原生就有可能将指令进行重排。\",\"内存系统的重排序：CPU 架构下很有可能有 store buffer/invalid queue 缓冲区，这种异步很可能会导致指令重排。\",\"synchronized\",\"被 synchronized 修饰的代码是单线程执行的，单线程执行内部无论指令是否重排序，结果一致。(但是 synchronized 无法阻止指令重排，并且 synchronized 的有序性也是在其保护的代码块中，例如 dcl 双重校验锁不加 volatile 时出现的问题，就是因为 INSTANCE 不止在 synchronized 代码块中有，在第一个 if 中也出现了(没有在 synchronized 中)，因此出现了安全问题，但这个安全问题不是因为其有序性，而是因为这个对象在代码块也有)。synchronized 可以保证共享变量的原子、有序、可见性但是要保证共享变量都在 synchronized 代码块中。\",\"volatile\",\"volatile 修饰的变量，可以禁止指令重排。\"]},\"72\":{\"h\":\"JMM 中缓存一致性(CPU 层级下)\",\"t\":[\"总线锁，就是锁总线，对共享变量的修改在相同时刻只允许一个 CPU 操作。\",\"缓存锁是锁缓存行(cache line)，其中较出名的是 MESI 协议，对缓存行标记状态，通过“同步通知”的方式，来实现(缓存行)数据的可见性和有序性。(MESI 大概的原理就是当每个 CPU 读取共享变量之前，会先识别数据的对象状态(是修改、还是共享、还是独占、还是无效)如果是独占，说明当前 CPU 将要得到的变量数据是最新的，没有被其他 CPU 同时读取；如果是共享，说明当前 CPU 将要得到的变量还是最新的，有其他的 CPU 在同时读取，但还没被修改；如果是修改，说明当前 CPU 正在修改该变量的值，同时会向其他 CPU 发送该数据状态为 invalid 的通知，得到其他 CPU 的响应后(其他 CPU 将数据状态从共享变为 invalid)，当前 CPU 将高速缓存的数据写到主存，并把自己的状态从修改变成独占；如果是无效，说明当前数据时被改过了，需要从主从重新读取最新的数据)。\",\"但“同步通知”会影响性能，所以会有内存缓冲区(store buffer/invalid queue)来实现异步进而提高 CPU 的工作效率。(异步原理：之前在修改的同时会告诉其他 CPU，而现在则把最新修改值写到store buffer，并通知其他 cpu 记得要修改状态，随后 CPU 便可返回干其他事了，等到其他 cpu 发过来响应消息，再将(store buffer 中的)数据更新到高速缓存以及主存中。其他 CPU 接收到 invalid 通知时，也会把接收到的消息放入 invalid queue 中，只要写到 invalid queue 就会直接返回告诉修改数据的 CPU，自己已将状态设置为 invalid)。\",\"但引入内存缓冲区后(异步)，又会存在可见性和有序性的问题(后面的指令查不到前面指令的执行结果(指令的执行顺序并非代码执行顺序)例如当 CPU 修改完 A 值，写到 store buffer 了，CPU 就可以干其他事了，但如果 CPU 指令又接收指令需要修改 A 值，但上一次修改的值还在 store buffer 中，没修改至高速缓存)，因此当需要强可见性和有序性时，只能“禁用”缓存的优化。(“禁止“缓存优化：(同核心)在 CPU 读取的时候，首先要去 store buffer 看看存不存在，存在则直接取，不存在才读取主存的数据；(不同核心)CPU1 修改了 A 值，已把修改后值写到了 store buffer，并通知 CPU2 对该值进行 invalid 操作，但是 CPU2 可能还没接收到 invalid 通知，就去做了其他操作导致 CPU2 读到的还是旧值，即便 CPU2 接收到了 invalid 通知，但 CPU1 的值还没写到主存，那么 CPU2 再次向主存读取的时候，还是旧值)\",\"“禁用”缓存优化在 CPU 层面下有内存屏障，读屏障/写屏障/全能屏障，本质上是插入一条“屏障指令”，只要遇到这条指令，那前面的操作都得完成，使得缓冲区(store buffer/invalid queue)在屏障指令之前的操作均已被处理，进而达到读写在 CPU 层面上是可见和有序的。(写屏障：CPU 当发现写屏障的指令时，会把该指令之前的存在于 store buffer 所有写指令刷入高速缓存，通过这种方式就可以让 CPU 修改的数据可以马上暴露给其他 CPU，达到写操作可见性的效果；读屏障：CPU 当发现读屏障的指令时，就会把该指令之前存在于 invalid queue 所有的指令处理掉，通过这种方式就可以确保当前 cpu 的缓存状态是正确的，读操作读取的一定是最新效果)\"]},\"73\":{\"h\":\"JMM 的内存交互(变量如何从主内存到本地内存以及从本地内存到主内存)\",\"t\":[\"​ 内存交互操作一共有 8 种，lock，read，load，use，assign，store，write，unlock\",\"​ 线程读写数据的流程：\",\"读数据：lock 加锁从主内存中 read 数据，然后把数据 load 到工作内存中，线程 use 数据(把工作内存中的数据传给执行引擎 use)\",\"写数据：使用完成后，线程 assign 数据到工作内存(把从执行引擎收到的值赋给工作内存中的变量)，把数据从工作内存中 store 到主内存，并把数据 write 到主内存汇总，unlock 释放锁。\"]},\"74\":{\"h\":\"JMM 的作用是什么？\",\"t\":[\"​ Java 内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的。\",\"​ Java 线程的通信由 JMM 控制，其主要目的是定义程序中各种变量的访问规则，即关注在 JVM 中把变量值存储到内存和从内存中取出变量值这样的细节。这里的变量与 Java 编程中的变量不同，包括实例字段、静态字段，但不包括局部变量与方法参数，因为它们是线程私有的，不存在多线程竞争。\",\"​ JMM 遵循一个基本原则：只要不改变程序执行结果，编译器和处理器怎么优化都行。例如编译器分析某个锁只会单线程访问就消除锁，某个 volatile 变量只会单线程访问就把它当作普通变量。\",\"​ JMM 规定所有变量都存储在主内存，每条线程有自己的工作内存，工作内存中保存被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。不同线程间无法直接访问对方工作内存中的变量，线程通信必须经过主内存。\",\"​ 关于主内存与工作内存的交互，即变量如何从主内存拷贝到工作内存、从工作内存同步回主内存，JMM 定义了 8 种原子操作：\",\"操作\",\"作用变量范围\",\"作用\",\"lock\",\"主内存\",\"把变量标识为线程独占状态\",\"unlock\",\"主内存\",\"释放处于锁定状态的变量\",\"read\",\"主内存\",\"把变量值从主内存传到工作内存\",\"load\",\"工作内存\",\"把 read 得到的值放入工作内存的变量副本\",\"use\",\"工作内存\",\"把工作内存中的变量值传给执行引擎\",\"assign\",\"工作内存\",\"把从执行引擎接收的值赋给工作内存变量\",\"store\",\"工作内存\",\"把工作内存的变量值传到主内存\",\"write\",\"主内存\",\"把 store 取到的变量值放入主内存变量中\"]},\"75\":{\"h\":\"happens-before 是什么？\",\"t\":[\"​ happens-before 并不是说前一个操作发生在后一个操作前面，而是说前一个写操作结果对后续操作是可见的(且前一个操作按顺序排在第二个操作之前)，如：A happens-before B（规定了对共享变量的写操作对其他线程的读操作可见。）\",\"​ 在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。happens-before 原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据。\",\"​ 如果 JMM 中所有的有序性（编译优化）都仅靠 volatile 和 synchronized 来完成，那么很多操作都将会变得非常啰嗦。所以使用 happens-before 规则定义一些禁止编译优化的场景，保证并发编程的正确性。\",\"happens-before\",\"说明\",\"程序次序规则\",\"对于单独线程中的每个操作，按照程序的顺序，前面的操作 happens-before 后续的任何操作。\",\"管程锁定规则\",\"一个 unlock 解锁操作(例如 synchronized 执行完)先行发生于后面对同一个锁的 lock 操作。\",\"volatile 规则\",\"对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作\",\"传递规则\",\"如果 A happens-before B，B happens-before C，那么 A happens-before C\",\"线程启动规则\",\"Thread 对象的 start() 方法先行发生于此线程的每一个动作。\",\"线程终止规则\",\"对线程 interrupt( ) 方法的调用先行发生于被中断线程的代码检测到中断事件的发生\",\"线程终止规则\",\"线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。\",\"对象终结规则\",\"一个对象的初始化完成先行发生于他的 finalize()方法的开始\"]},\"76\":{\"h\":\"as-if-serial 是什么？\",\"t\":[\"​ as-if-serial语义的意思是：不管怎么重排序，单线程程序的执行结果不能改变。编译器和处理器必须遵循 as-if-serial 语义。\",\"​ 为了遵循 as-if-serial，编译器和处理器不会对存在数据依赖关系的操作重排序，因为这种重排序会改变执行结果。但是如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序，if-serial 把单线程程序保护起来，给程序员一种幻觉：单线程程序是按程序的顺序执行的。\",\"​ 数据依赖性(关系)：仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。\",\"​ 在单线程程序中，对存在控制依赖的操作重排序(有数据依赖的不会重排序，没有数据依赖的才会重排序)，不会改变执行结果。\",\"​ 在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。（因为在单个线程中两个操作没有依赖性，随便重排序，但另一个线程中的操作可能与这个线程的操作有数据依赖关系，因此由其重排序可能会改变数据结果）\"]},\"77\":{\"h\":\"as-if-serial 和 happens-before 有什么区别？\",\"t\":[\"​ as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。\",\"这两种语义的目的都是为了在不改变程序执行结果的前提下尽可能提高程序执行并行度。\"]},\"78\":{\"h\":\"volatile 关键字\",\"t\":[\"​ 把变量声明为 volatile ，是在告诉 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\",\"作用：就是在 volatile 前后加上内存屏障，使得编译器和 CPU 无法进行重排序，致使有序，并且写 volatile 变量对其他线程可见。\",\"在 AQS 的 state、JDK1.7 的 ConcurrentHashMap 里面使用了。\",\"volatile 原理\",\"读写 volatile 变量时会加入内存屏障保证可见性和有序性。\",\"对 volatile 变量的写指令后会加入写屏障，保证在该屏障之前对共享变量的改动，都同步到主存中；\",\"对 volatile 变量的读指令前会加入读屏障，保证在该屏障之后对共享变量的读取，加载的是主存中的数据。\"]},\"79\":{\"h\":\"volatile 和 synchronized 的区别 ⭐\",\"t\":[\"volatile 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，每次使用都需要从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。\",\"volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法和类级别。\",\"volatile 能保证可见性、有序性，不能保证原子性；而 synchronized 则可以保证有序性、可见性和原子性。\",\"volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。\",\"volatile 标记的变量不会被编译器优化；synchronized 标记的变量会被编译器优化。\"]},\"80\":{\"h\":\"四、锁\"},\"81\":{\"h\":\"锁设计 & 锁分类\",\"t\":[\"​ Java 中我们最常用的锁应该就是 Synchronized 以及 ReentrantLock，一个是 JVM 关键字，依赖于操作系统的系统调用实现的锁，一个是 J.U.C 包下基于 AQS 实现一种可重入锁，其原理主要是利用 cas 修改一个 volatile 修饰的 int 变量来标识是否获取到锁的， 如果 state 变量不为 0 则证明当前有线程正在持有锁。\",\"根据默认是否有其它线程修改数据划分可以分为乐观锁和悲观锁\",\"乐观锁的概念认为当前线程在操作数据的过程中不会有其他线程修改数据，操作数据过程中不加锁，CAS 是乐观锁的一种实现。CAS 即比较并交换，即比较内存中的值和期望的值是否相同，相同才将新的值更新。\",\"悲观锁认为共享变量一定会有其他线程来修改，所以操作共享变量的时候一定要先加锁。Java 中的 Synchronized 以及 ReentrantLock 都是悲观锁。\",\"根据获取不到锁的线程如何处理划分可以分为轻量级锁和重量级锁\",\"重量级锁的概念是如果锁已经被持有了，当前线程获取不到锁，当前线程挂起，等待锁的释放以及被唤醒。\",\"轻量级锁的概念是如果锁已经被持有了，当前线程获取不到锁，那么将自旋一段时间，等待锁的释放。这样设计的原因是大部分情况下我们占用锁的线程很快就执行完了，在很短的时间内就释放了锁，如果是重量级锁，那么下一个线程想获取锁继续执行的话需要经历挂起以及唤醒，这个过程需要 CPU 上下文切换，这个时间开销甚至大于用户代码执行的时间，所以轻量级锁让线程等一会，锁一旦释放，当前线程可以立马获取到，省去了不必要的上下文切换的开销。\",\"根据抢锁规则的设计划分可以分为公平锁和非公平锁\",\"公平锁的概念是如果当前一个线程已经获取到锁了，其他线程如果再想获取到锁的话需要排队。\",\"非公平锁的概念是如果当前一个线程已经获取到锁了，那么新来的线程如果再想获取到锁先 CAS 抢一下，如果抢到了就执行代码，抢不到再去排队。\",\"JDK 中的 ReentrantLock 既支持非公平锁又支持公平锁，默认非公平锁。用通过final ReentrantLock lock = new ReentrantLock(true);设置公平锁。\",\"重入锁与非重入锁\",\"所谓重入锁，即一个线程如果获取到了锁，那么这个线程下一次进入同步代码中的时候可以直接进入，不用重新获取锁，我们最熟悉的 sychronized 和 ReentrantLock 都是可重入锁。\",\"独占锁与共享锁\",\"独占锁的概念是如果有一个线程已经获取到了锁，其他线程不可以继续获取锁，锁只能有此线程独占。\",\"共享锁的概念是一个锁可以有多个线程共享，即一个线程获取到了锁，其他线程还可以继续获取锁。\",\"基于 AQS 实现的 ReentrantLock 就是独占锁，而 AQS 也提供了实现共享锁的模版方法 tryAcquireShared。\"]},\"82\":{\"h\":\"synchronized\",\"t\":[\"JDK6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。\",\"synchronized 底层原理属于 JVM 层面，Java 对象头和 Monitor 是实现 synchronized 的基础。\",\"从字节码角度来看，执行同步代码块时首先要执行 monitorenter 指令，退出时执行 monitorexit 指令。 \",\"当执行 monitorenter 指令时，线程试图获取锁也就是对象监视器Monitor的持有权。在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1(锁计数器+1)。\",\"对象锁的的拥有者线程才可以执行 monitorexit 指令来释放锁。在执行 monitorexit 指令后，将锁计数器设为 0 (锁计数器-1)，表明锁被释放，其他线程可以尝试获取锁。\",\"synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。不过本质都是对Monitor的获取。\"]},\"83\":{\"h\":\"synchronized 修饰方法：\",\"t\":[\"修饰非静态方法(成员方法)，锁是当前的实例对象，俗称“对象锁”。\",\"修饰静态方法，锁是类的 class 对象，俗称“类锁”。\",\"修饰代码块，锁是 Synchronized 括号里的对象。\",\"不能修饰变量。\"]},\"84\":{\"h\":\"Mark Word 结构\",\"t\":[\"32 位系统的对象头(运行时元数据和类型指针)中 Mark Word 结构：\",\"锁标志位：\",\"00 轻量级锁\",\"01 偏向锁\",\"10 重量级锁\",\"11 GC 标志\"]},\"85\":{\"h\":\"Monitor 原理\",\"t\":[\"​ Monitor被翻译为监视器或者说管程，由 C++实现。是操作系统提出的一种高级原语，在 Java 中看不到它的存在。另外，由于wait/notify方法也依赖于monitor对象，所以只有在 synchronized 修饰代码块或者方法里才能调用wait() / notify()方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。\",\"​ 每个 java 对象都内置了一个 Monitor，如果使用 synchronized 给对象上锁（重量级），该对象头(对象头包含两个部分：运行时元数据(Mark Word)和类型指针(Klass Word))的Mark Word就会指向Monitor对象。\",\"执行流程：\",\"当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2。\",\"在 Thread-2 获取 Monitor 之后，如果其他线程也来执行 synchronized(obj)，就会进入 EntryList，处于阻塞态。\",\"解锁：Thread-2 执行完同步代码块的内容后，将 Owner 设置为 null，然后唤醒 EntryList 中所有等待线程来同时竞争锁。\",\"图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但没有获得锁而进入 WAITING 状态的线程。\"]},\"86\":{\"h\":\"Synchronized 锁升级\",\"t\":[\"目的：减少获得锁和释放锁带来的性能消耗。\",\"锁存在四种状态，分别是无锁、偏向锁、轻量级锁、重量级锁，这几个状态会随着竞争情况逐渐升级，锁可以升级但不可以降级。\",\"偏向锁默认是延迟的，所以 synchronized 一般使用的是轻量级锁，只有在关闭延迟后，才会使用偏向锁。\",\"锁\",\"优点\",\"缺点\",\"偏向锁\",\"加锁和解锁不需要额外的消耗\",\"如果线程间存在锁竞争，会带来额外的锁撤销的消耗\",\"轻量级锁\",\"锁重入不阻塞，程序响应速度快\",\"线程一直不能获取锁的时候会自旋消耗 CPU\",\"重量级锁\",\"线程竞争不使用自旋，不会消耗 CPU\",\"线程阻塞，响应时间缓慢\",\"对象头包含两个部分：运行时元数据(Mark Word)和类型指针(Klass Word)。\"]},\"87\":{\"h\":\"轻量级锁\",\"t\":[\"​ 轻量级锁的使用场景是：如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有线程产生实际竞争），那么可以使用轻量级锁来进行优化。\",\"执行原理\",\"加锁\",\"​ 轻量级锁对使用者是透明的，即语法仍是 synchronized。\",\"​ 每次指向到synchronized代码块时，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间(锁记录对象)，并将对象头中的 Mark Word 复制到锁记录中。然后线程尝试使用 CAS 将锁对象头中的 Mark Word 替换为指向锁记录的指针。如果替换成功，表示当前线程加轻量级锁成功；如果替换失败，有两种情况：\",\"如果是其它线程获取本对象上的锁，表明有竞争，进入锁膨胀。\",\"如果是当前线程再次获取本对象上的锁，那么在当前栈帧中再添加一条锁记录作为锁重入的计数。\",\"解锁\",\"当线程退出 synchronized 代码块的时候，有两种情况：\",\"如果有取值为 null 的锁记录，表示有锁重入，这时重置锁记录，让重入计数减 1。\",\"如果取值不为 null，使用 CAS 将 Mark Word 的值恢复给对象头：\",\"成功则代表解锁成功。\",\"失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程。\"]},\"88\":{\"h\":\"偏向锁(用来优化轻量级锁的锁重入问题)\",\"t\":[\"HotSpot 的作者发现：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此有了偏向锁。由于轻量级锁在没有竞争时，每次重入仍然需要执行 CAS 操作，引入偏向锁，用来优化轻量级锁的锁重入问题。\",\"第一次使用时，通过 CAS 将线程 ID 设置到锁对象头的 Mark Word， 之后如果再次执行锁重入时，发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS，以后只要不发生竞争，这个对象锁就归该线程所有。\",\"如何撤销偏向锁 - 调用 wait/notify\",\"其他线程使用该对象\",\"调用 wait/notify，会使对象的锁变成重量级锁，因为wait() / notify()方法之后重量级锁才支持。\",\"调用对象的 hashcode(如果一个对象的 hashCode()方法已经被调用过一次之后，这个对象还能被设置偏向锁么？答案是不能。因为如果可以的化，那 Mark Word 中的 identity hash code 必然会被偏向线程Id 给覆盖(导致 hashcode 没有地方放，此时锁会膨胀为重量级)，这就会造成同一个对象前后两次调用 hashCode()方法得到的结果不一致。)\",\"批量重偏向\",\"​ 如果对象被多个线程访问，但是没有竞争，这时候偏向了线程 t1 的对象又有机会重新偏向线程 t2，即可以不用升级为轻量级锁，要实现重新偏向是要有条件的：当撤销偏向锁达到阈值 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至 t2。因为前 19 次是轻量，释放之后为无锁不可偏向，但是 20 次后面的是偏向 t2，释放之后依然是偏向 t2。\",\"批量撤销\",\"​ 当一个偏向锁如果撤销次数到达 40 的时候，JVM 就认为这个对象设计的有问题；那么 JVM 会把这个对象所对应的类所有的对象都撤销偏向锁；并且新实例化的对象也是不可偏向的。\"]},\"89\":{\"h\":\"锁膨胀(轻量级锁变重量级锁)\",\"t\":[\"​ 如果在尝试加轻量级锁的过程中，CAS 操作无法成功，有一种情况就是其它线程已经为这个对象加上了轻量级锁，此时就要进行锁膨胀，将轻量级锁变成重量级锁。\",\"当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁\",\"这时 Thread-1 加轻量级锁失败，进入锁膨胀：即为对象申请 Monitor 锁，让 Object 指向重量级锁地址，然后自己进入 Monitor 的 EntryList 变成 BLOCKED 状态\",\"当 Thread-0 退出 synchronized 同步块时，使用 CAS 将 Mark Word 的值恢复给对象头，失败(因为那是轻量级锁的解锁方式，现在已经是重量级锁了)。那么会进入重量级锁的解锁过程，即按照 Monitor 的地址找到 Monitor 对象，将 Owner 设置为 null，唤醒 EntryList 中的 Thread-1 线程。\"]},\"90\":{\"h\":\"Synchronized 锁优化\"},\"91\":{\"h\":\"自旋优化\",\"t\":[\"重量级锁竞争的时候，还可以使用自旋来进行优化，即当一个线程正在执行时另一个线程访问同步块获取锁时，不直接进入阻塞状态进行等待，而是进行自旋重试等待如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以不用进行上下文切换就获得了锁。\",\"自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。在JDK 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。JDK 7 之后不能控制是否开启自旋功能。\"]},\"92\":{\"h\":\"锁清除\",\"t\":[\"​ 锁清除是发生在编译器级别的一种锁优化方式，有时候我们写的代码完全不需要加锁，但却执行了加锁操作，编译器会进行锁清除。\"]},\"93\":{\"h\":\"锁粗化\",\"t\":[\"​ 如果很多次锁的请求都是对同一对象加锁，可以有效地合并多个相邻的加锁代码块，将加锁同步的范围扩大，因此可以减少加锁带来的性能损耗。\"]},\"94\":{\"h\":\"Synchronized 和 Lock\",\"t\":[\"Synchronized 是 Java 的一个关键字，在JVM 层面实现加锁和释放锁；\",\"Lock 是一个接口，在代码层面实现加锁和释放锁；ReenTrantLock 是 Lock 的实现类。\",\"Synchronized 不需要用户去手动释放锁，在线程代码执行完或出现异常时自动释放锁；\",\"Lock 不会自动释放锁，需要在 finally { } 代码块中显式释放锁；\",\"Lock 可以设置获取锁的超时时间，且可以查看锁是否获取成功，实现公平锁，可实现选择性通知（借助于 Condition 接口）。\",\"Lock 功能性更全面， ReentrantLock 主要增加了三个高级功能：等待可中断、可实现公平锁及锁可以绑定多个条件。\",\"不过性能已经不是二者的选择标准。\",\"fs 吃，vV/f'.‘。\",\"ReentrantLock & Synchronized\",\"ReentrantLock\",\"Synchronized\",\"锁实现机制\",\"依赖 AQS\",\"依赖于\",\"灵活性\",\"支持响应中断、超时、尝试获取锁\",\"不灵活\",\"释放形式\",\"必须显示调用unlock()释放锁\",\"自动释放监视器\",\"锁类型\",\"公平锁 & 非公平锁\",\"非公平锁\",\"条件队列\",\"可关联多个条件队列（多个 WaitSet）\",\"关联一个条件队列wait()、notify()\",\"可重入性\",\"可重入\",\"可重入\"]},\"95\":{\"h\":\"ReentrantLock\",\"t\":[\"​ ReentrantLock实现了Lock接口，Lock接口是Java中对锁操作行为的统一规范。ReentrantLock内部定义了专门的组件Sync， Sync继承AQS提供释放资源的实现，NonfairSync和FairSync是基于Sync扩展的子类，即ReentrantLock的非公平模式与公平模式，它们作为Lock接口功能的基本实现。\"]},\"96\":{\"h\":\"ReentrantLock 可重入实现\",\"t\":[\"可重入指的是，该锁能够支持一个线程对资源的重复加锁。该特性需要解决两个问题：\",\"线程再次获取锁：锁需要去识别获取锁的线程是否是当前持有锁的线程，如果是，则再次获取锁。\",\"锁的最终释放：该锁被获取了 n 次，那么前（n-1）次tryRelease(int releases)方法必须返回 false。\",\"​ Synchronized 关键字隐式的支持重进入，比如一个 synchronized 修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁 。ReentrantLock 虽然没能像 synchronized 关键字一样支持隐式的重进入，但是在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。\",\"ReentrantLock的实现tryAcquire方法里面不管是公平锁还是非公平锁，都有下面的代码，以非公平锁为例：\",\"final boolean nonfairTryAcquire(int acquires) { ... int c = getState(); //获取当前状态 if (c <span style=\\\"background-color: yellow\\\"> 0){...} // state</span>0 代表资源可获取 // 如果state!=0,但是当前线程是持有锁线程，直接重入 else if (current == getExclusiveOwnerThread()) { //state状态 + 1 int nextc = c + acquires; //避免int值累计过大溢出 if (nextc < 0) throw new Error(\\\"Maximum lock count exceeded\\\"); //将state变量替换成新的值，此处不需要 CAS，因为持有锁的线程只有一个 setState(nextc); //返回true，实现可重入 return true; } ... } \",\"​ 对于非公平锁只要 CAS 设置同步状态成功则表示当前线程获取了锁，而公平锁则不同。公平锁使用 tryAcquire 方法，该方法与nonfairTryAcquire 的唯一区别就是判断条件中多了对同步队列中当前节点是否有前驱节点的判断，如果该方法返回 true 表示有线程比当前线程更早请求锁，因此需要等待前驱线程获取并释放锁后才能获取锁。\",\"// 释放锁 protected final boolean tryRelease(int releases) { int c = getState() - releases; // getExclusiveOwnerThread() 获取占有线程 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); return free; } \",\"可以看到，该方法将 state 是否为 0 作为最终释放的条件，当同步状态为 0 时，将占有线程设置为 null，并返回 true，表示释放成功。\"]},\"97\":{\"h\":\"死锁、活锁、饥饿\"},\"98\":{\"h\":\"死锁\",\"t\":[\"​ 当前线程拥有其他线程需要的资源，当前线程等待其他线程已拥有的资源，都不放弃自己拥有的资源。\",\"​ 多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况称为 死锁。\",\"产生死锁的四个必要条件是什么?\",\"互斥：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。\",\"占有并等待：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。\",\"非抢占：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。\",\"循环等待：有一组等待进程 {P0, P1,..., Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，......，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。\",\"检测（定位）死锁\",\"检测死锁可以使用 jconsole工具（有直接监测死锁的按钮）；或者使用jps定位进程 id，再用 jstack 定位死锁。\",\"以jps为例：\",\"解决死锁方案\",\"顺序加锁\",\"​ 当多个线程需要相同的锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。但这种方式需要你事先知道所有可能会用到的锁，然而总有些时候是无法预知的。通过使用 Hash 值的大小确定加锁的先后。\",\"加锁时限\",\"​ 获取锁时加上一个超时时间，若一个线程没有在给定的时限内成功获得锁，则会放弃争抢锁，如：ReentrantLock 锁超时机制。\",\"锁打断\",\"​ 被动的解决死锁方式，由其它线程调用 interrupt 来打断死锁，如：ReentrantLock 的锁打断机制。\",\"尽可能缩减加锁的范围，等到操作共享变量的时候才加锁。\",\"死锁的 Demo\",\"public class DeadLockDemo { private static Object resource1 = new Object();//资源 1 private static Object resource2 = new Object();//资源 2 public static void main(String[] args) { new DeadLockDemo().deadLock(); } private void deadLock () { Thread t1 = new Thread(new Runnable() { @Override public void run() { synchronized (resource1) { try { Thread.currentThread().sleep(2000); }catch (InterruptedException e) { e.printStackTrance(); } synchronized (resource2) { System.out.println(\\\"need resource\\\" + 2); } } } }); Thread t2 = new Thread(new Runnable() { @Override public void run() { synchronized (resource2) { synchronized (resource1) { System.out.println(\\\"need resource\\\" + 1); } } } }); t1.start(); t2.start(); } } \"]},\"99\":{\"h\":\"活锁\",\"t\":[\"。（一个++，一个--，永远执行不完）\",\"解决活锁方案\",\"​ 让两个线程执行时间有交错，实际开发中可以增加随机睡眠时间来解决活锁。\"]},\"100\":{\"h\":\"饥饿\",\"t\":[\"​ 一个线程由于 CPU 被其它线程抢走而长时间得不到运行，这种情况一般发生的原因是这个线程优先级低。\",\"​ 在哲学家就餐问题中，使用顺序加锁的方式解决的话，会产生饥饿。使用 Reentrantlock 来解决能避免饥饿。\"]},\"101\":{\"h\":\"单例：双重校验锁（DCL）\",\"t\":[\"为什么两次 if 判断？\",\"​ 外层判断提高效率，内层判断为了防止多次实例化对象。\",\"使用 volatile 的目的是：避免指令重排序\",\"​ 双重校验锁存在一个问题：INSTANCE = new Singleton();该语句非原子操作，实际是三个步骤：\",\" 1. 给singleton分配内存； 2. 调用 Singleton 的构造函数来初始化成员变量； 3. 将给单例对象指向分配的内存空间（此时singleton才不为null）。 \",\"​ 编译器有可能进行指令重排优化，可能分配内存并修改指针后未初始化 ，导致其它人拿到的对象就可能是个不完整的对象。举个例子，第一个线程初始化对象到一半，第二个线程来发现已经不是 null 了就直接返回了 实际上该对象此时还没有完全初始化 可能会出现这个问题。\",\"​ 例子：线程 1 此时创建了 singleton 对象(分配了内存空间，也就是完成了第一个步骤)，但是 2,3 步骤乱序了，先执行了 3，后执行 2，也就是先将引用了指向了对象(由于对象还没有初始化，此时的对象是没有初始化的对象，而引用仅仅是一个地址)，这时如果线程 2 走到第一个 if(没有在synchronized的代码块中，没有受到保护)的位置进行判断时此时 INSTANCE 不为空，他现在只是一个指向还没有初始化对象的一个地址，也就是 t2 线程拿到了一个未初始化完毕的单例。但也与原本的单例模式初衷违背，因此需要 volatile 来避免指令重排序，以防出问题。\",\"public final class Singleton{ private Singleton() {} private static volatile Singleton INSTANCE = null; public static Singleton getInstance() { //实例没创建(完成)，才会进入内部的synchronized代码块 if (INSTANCE == null) { synchronized (Singleton.class) { //或许用其他的线程在你第一次判断的期间，正在创建实例，现在已经创建完成 if (INSTANCE == null) { INSTANCE = new Singleton(); } } } return INSTANCE; } } \"]},\"102\":{\"h\":\"happens-before\",\"t\":[\"​ happens-before 规定了对共享变量的写操作对其它线程的读操作可见，特是可见性与有序性的一套规则总结。happens-before 保证正确同步的多线程程序的执行结果不变。\",\"happens-before\",\"说明\",\"程序次序规则\",\"一个线程中，按照程序的顺序，前面的操作 happens-before 后续的任何操作。\",\"管程锁定规则\",\"一个 unlock 解锁操作(例如 synchronized 执行完)先行发生于后面对同一个锁的 lock 操作。线程解锁 m 之前对变量的写，对于接下来 m 加锁的其他线程对该变量读可见。\",\"volatile 规则\",\"对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。线程对 volatile 变量的写，对接下来其他线程对该变量的读可见。\",\"传递规则\",\"如果 A happens-before B，B happens-before C，那么 A happens-before C\",\"线程启动规则\",\"Thread 对象的 start() 方法先行发生于此线程的每一个动作。线程 start 前对变量的写，对该线程开时候对该变量读可见。\",\"线程终止规则\",\"对线程 interrupt( ) 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。线程 t1 打断线程 t2(interrupt)前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见(通过 t2.interrupted 或 t2.isInterrupted)\",\"线程终止规则\",\"线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。线程结束前对变量的写，对其他线程得知它结束后的读可见(比如其他线程调用 t1.isAlive()或 t1.join()等待它结束)\",\"对象终结规则\",\"一个对象的初始化完成先行发生于他的 finalize()方法的开始\",\"对变量默认值(o,false,null)的写(只是定义了没赋值 )，对其他变量的读可见。\"]},\"103\":{\"h\":\"乐观锁：CAS+版本号\",\"t\":[\"​ 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和 CAS 算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。\"]},\"104\":{\"h\":\"为什么要用 CAS\",\"t\":[\"​ 因为 synchronized 锁每次只会让一个线程去操作共享资源，而 CAS 相当于没有加锁，多个线程都可以去直接操作共享资源，在实际去修改的时候才去判断能否修改成功，在很多情况下会比 synchronized 锁高效。\",\"乐观锁一定比悲观锁效率高么？\",\"​ 乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行 retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。\"]},\"105\":{\"h\":\"CAS(compare and swap)\",\"t\":[\"​ CAS 操作又称为 “无锁操作”，是一种乐观锁策略，它假设所有线程访问共享资源时不会出现冲突，因此线程不会出现阻塞停顿状态。如果出现了冲突怎么办？。\",\"对于内存中的某个值 V，提供一个旧值 A 和一个新值 B 。如果提供的旧值 A 和 V 相等就把 B 写入 V，这个过程是原子性的。\",\"CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果，因为每次 CAS 意味着需要获取共享变量最新结果，将最新结果与 prev 比较。\",\"CAS 体现的是无锁并发、无阻塞并发，即使重试失败，线程也不会陷入阻塞，始终在高速运行，使得效率提升，而 synchronized 会让线程在没有获取锁时，发生上下文切换，进入阻塞。\"]},\"106\":{\"h\":\"CAS 的问题：ABA\",\"t\":[\"​ CAS 从语义上来说存在一个逻辑漏洞：如果 V 初次读取时是 A，并且在准备赋值时仍为 A，这依旧不能说明它没有被其他线程更改过，因为这段时间内假设它的值先改为 B 又改回 A，那么 CAS 操作就会误认为它从来没有被改变过。\",\"​ 这个漏洞称为 ABA 问题，juc 包提供了一个 AtomicStampedReference，原子更新带有版本号的引用类型，通过控制变量值的版本来解决 ABA 问题。大部分情况下 ABA 不会影响程序并发的正确性，如果需要解决，传统的互斥同步可能会比原子类更高效。\"]},\"107\":{\"h\":\"五、JUC\"},\"108\":{\"h\":\"JDK 中提供了哪些并发容器？\",\"t\":[\"JDK 提供的这些容器大部分在 java.util.concurrent 包中。\",\"ConcurrentHashMap：线程安全的 HashMap；\",\"CopyOnWriteArrayList：线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector；\",\"ConcurrentLinkedQueue：高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列；\",\"BlockingQueue：这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道；\",\"ConcurrentSkipListMap：跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。\"]},\"109\":{\"h\":\"AQS(抽象队列式同步器）\",\"t\":[\"AQS（AbstractQueuedSynchronizer，抽象队列同步器），，许多同步类的实现都依赖于它，如：ReentrantLock、Semaphore、CountDownLacth 等。\",\"​ AQS 是 JDK 提供的一个同步框架，内部维护这 FIFO 双向队列即 CLH 双向队列。\",\"public abstract class AbstractQueuedSynchronizer \",\"特点：\",\"用 state 属性来表示同步状态（独占或共享），子类需要定义如何维护这个状态，，控制如何获取锁和释放锁\",\"提供了基于 FIFO 的阻塞队列，AQS 内部使用双向链表将等待线程链接起来，类似 Monitor 的 EntryList\",\"条件变量来实现等待、唤醒机制，支持多个条件变量，类似 Monitor 的 WaitSet\",\"子类主要实现这样一些方法：\",\"tryAcquire：尝试获取独占锁\",\"tryRelease：尝试释放独占锁\",\"tryAcquireShared：尝试获取共享锁\",\"tryReleaseShared：尝试释放共享锁\",\"isHeldExclusively：判断是否持有独占锁\"]},\"110\":{\"h\":\"AQS 原理\",\"t\":[\"​ AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。\",\"​ CLH 队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。\",\"​ AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。\",\"private volatile int state;//共享变量(用于判断共享资源是否被占用的标记位)，使用volatile修饰保证线程可见性，之所以用int而不是boolean是因为共享模式时，一旦被占用，其他共享模式下的线程也能占用，state可用于记录共享线程的数量。 \",\"​ 状态信息通过 protected 类型的getState，setState，compareAndSetState进行操作\",\"//返回同步状态的当前值 protected final int getState() { return state; } // 设置同步状态的值 protected final void setState(int newState) { state = newState; } //原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值） protected final boolean compareAndSetState(int expect, int update) { return unsafe.compareAndSwapInt(this, stateOffset, expect, update); } \"]},\"111\":{\"h\":\"AQS 源码分析\",\"t\":[\"AQS 的成员变量\",\"private volatile int state;//共享变量(用于判断共享资源是否被占用的标记位)，使用volatile修饰保证线程可见性，之所以用int而不是boolean是因为共享模式时，一旦被占用，其他共享模式下的线程也能占用，state可用于记录共享线程的数量。 \",\"CANCELLED：1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该 Node 的结点。\",\"SIGNAL：-1，处于唤醒状态，只要前继结点释放锁，就会通知标识为 SIGNAL 状态的后继结点的线程执行。\",\"CONDITION：-2，与 Condition 相关，该标识的结点处于等待队列中，结点的线程等待在 Condition 上，当其他线程调用了 Condition 的 signal()方法后，CONDITION 状态的结点将从等待队列转移到同步队列中，等待获取同步锁。\",\"PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。\"]},\"112\":{\"h\":\"AQS 对资源的共享方式\",\"t\":[\"AQS 定义两种资源共享方式\"]},\"113\":{\"h\":\"Exclusive\",\"t\":[\"只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁,ReentrantLock 同时支持两种锁,下面以 ReentrantLock 对这两种锁的定义做介绍：\",\"公平锁：按照线程在队列中的排队顺序，先到者先拿到锁\",\"非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。\"]},\"114\":{\"h\":\"公平锁与非公平锁\",\"t\":[\"总结：公平锁和非公平锁只有两处不同：\",\"非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。\",\"非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。\",\"​ 公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。\",\"​ 相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。\"]},\"115\":{\"h\":\"Share\",\"t\":[\"​ 多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock。\",\"ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。\",\"​ 不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在上层已经帮我们实现好了。\",\"AQS 有哪两种模式？\",\"独占模式：表示锁只会被一个线程占用，其他线程必须等到持有锁的线程释放锁后才能获取锁，同一时间只能有一个线程获取到锁。ReentrantLock\",\"共享模式：表示多个线程获取同一个锁有可能成功，ReadLock 就采用共享模式。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock。\"]},\"116\":{\"h\":\"AQS 组件\"},\"117\":{\"h\":\"Semaphore(信号量)\",\"t\":[\"synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。\",\"执行 acquire 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 release 方法增加一个许可证，这可能会释放一个阻塞的 acquire 方法。然而，其实并没有实际的许可证这个对象，Semaphore 只是维持了一个可获得许可证的数量。 Semaphore 经常用于限制获取某种资源的线程数量。\",\"除了 acquire方法之外，另一个比较常用的与之对应的方法是tryAcquire方法，该方法如果获取不到许可就立即返回 false。\",\"Semaphore 有两种模式，公平模式和非公平模式。\",\"公平模式： 调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO；\",\"非公平模式： 抢占式的。\"]},\"118\":{\"h\":\"CountDownLatch（倒计时器）\",\"t\":[\"CountDownLatch 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。\",\"CountDownLatch 是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。当线程使用 countDown() 方法时,其实使用了tryReleaseShared方法以 CAS 的操作来减少 state,直至 state 为 0 。当调用 await() 方法的时候，如果 state 不为 0，那就证明任务还没有执行完毕，await() 方法就会一直阻塞，也就是说 await() 方法之后的语句不会被执行。然后，CountDownLatch 会自旋 CAS 判断 state <span style=\\\"background-color: yellow\\\"> 0，如果 state </span> 0 的话，就会释放所有等待的线程，await() 方法之后的语句得到执行。\"]},\"119\":{\"h\":\"CountDownLatch 的不足\",\"t\":[\"​ CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。\"]},\"120\":{\"h\":\"CyclicBarrier(循环栅栏)\",\"t\":[\"CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。\",\"CountDownLatch 的实现是基于 AQS 的，而 CycliBarrier 是基于 ReentrantLock(ReentrantLock 也属于 AQS 同步器)和 Condition 的.\",\"CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。\"]},\"121\":{\"h\":\"CyclicBarrier 和 CountDownLatch 的区别\",\"t\":[\"CountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用。但是我不那么认为它们之间的区别仅仅就是这么简单的一点。\",\"对于 CountDownLatch 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。\",\"CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。\"]},\"122\":{\"h\":\"为什么只有前驱节点是头节点时才能尝试获取同步状态？\",\"t\":[\"头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点。后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。\",\"为了维护同步队列的 FIFO 原则，节点和节点在循环检查的过程中基本不通信，而是简单判断自己的前驱是否为头节点，这样就使节点的释放规则符合 FIFO，并且也便于对过早通知的处理（过早通知指前驱节点不是头节点的线程由于中断被唤醒）。\"]},\"123\":{\"h\":\"共享式获取/释放锁的原理？\",\"t\":[\"​ 获取同步状态时，调用 acquireShared 方法，该方法调用 tryAcquireShared 方法尝试获取同步状态，返回值为 int 类型，返回值不小于于 0 表示能获取同步状态。因此在共享式获取锁的自旋过程中，成功获取同步状态并退出自旋的条件就是该方法的返回值不小于 0。\",\"​ 释放同步状态时，调用 releaseShared 方法，释放后会唤醒后续处于等待状态的节点。它和独占式的区别在于 tryReleaseShared 方法必须确保同步状态安全释放，通过循环 CAS 保证，因为释放同步状态的操作会同时来自多个线程。\"]},\"124\":{\"h\":\"独占式获取锁的流程\",\"t\":[\"也就是acquire(int age)方法调用流程：\"]},\"125\":{\"h\":\"ReentrantReadWriteLock\",\"t\":[\"​ 读写锁在同一时刻允许多个读线程访问，在写线程访问时，所有的读写线程均阻塞。读写锁维护了一个读锁和一个写锁，通过分离读锁和写锁使并发性相比排他锁有了很大提升。\",\"​ 读写锁机制是基于 AQS 的一种实现，保证读读共享、读写互斥、写写互斥。它的自定义同步器需要在同步状态 state 上维护多个读线程和一个写线程，该状态的设计成为实现读写锁的关键。ReentrantReadWriteLock 很好的利用了高低位。来实现一个整型控制两种状态的功能，读写锁将变量切分成了两个部分，高 16 位表示读，低 16 位表示写。\",\"特点\",\"读锁和写锁都支持锁中断，因为它们都有 lockInterruptibly() 方法；\",\"写锁支持条件变量，读写不支持条件变量，如果读锁调用 newCondition 会抛出异常;\",\"默认构造方法为非公平模式 ，也可以通过指定 fair 为 true 设置为公平模式 。\",\"读写锁的升降级策略？\",\"不支持锁升级，不能从读锁升级到写锁，持有读锁的情况下去获取写锁，会导致写锁永久等待。\",\"支持锁降级，在释放写锁之前可以获取读锁来达到锁的降级。\"]},\"126\":{\"h\":\"Condition 接口\",\"t\":[\"​ 任意一个 Java 对象，都拥有一组监视器方法（定义在 java.lang.Object 上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与 synchronized 同步关键字配合，可以实现等待/通知模式。Condition 接口也提供了类似 Object 的监视器方法，与 Lock 配合可以实现等待/通知模式。\",\"Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); public void conditionalWait() throws InterruptedException { lock.lock(); try { conditon.await(); // 释放锁，并在此等待 }finally { lock.unlock(); } } public void conditionSignal() throws InterruptedException { lock.lock(); try { conditon.signal(); // 调用 signal 之后，通知线程从 await 返回 }finally { lock.unlock(); } } \"]},\"127\":{\"h\":\"Exchanger 线程间交换数据\",\"t\":[\"​ Exchanger 是用于线程间协作的工具类，用于进行线程间的数据交换。它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。\",\"​ 两个线程通过 exchange 方法交换数据，第一个线程执行 exchange 方法后会阻塞等待第二个线程执行该方法，当两个线程都到达同步点时这两个线程就可以交换数据，将本线程生产出的数据传递给对方。应用场景包括遗传算法、校对工作等。\"]},\"128\":{\"h\":\"ConcurrentHashMap 是如何保证线程安全的？\",\"t\":[\"1.7 中，ConcurrentHashMap 采用了分段锁策略，将一个 HashMap 切割成 Segment 数组，其中 Segment 可以看成一个 HashMap， 不同点是 Segment 继承自 ReentrantLock，在操作的时候给 Segment 赋予了一个对象锁，从而保证多线程环境下并发操作安全 1.8 中，与此对应的 ConcurrentHashMap 也是采用了与 HashMap 类似的存储结构，但是 JDK1.8 中 ConcurrentHashMap 并没有采用分段锁的策略，而是在元素的节点上采用 CAS + synchronized 操作来保证并发的安全性\"]},\"129\":{\"h\":\"JDK7 的 ConcurrentHashMap 原理？\",\"t\":[\"​ ConcurrentHashMap 用于解决 HashMap 的线程不安全和 HashTable 的并发效率低，HashTable 之所以效率低是因为所有线程都必须竞争同一把锁。ConcurrentHashMap 首先将数据分成 Segment 数据段，然后给每一个数据段配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。\",\"结构： Segment + HashEntry（与 HashMap 类似，但是其中的value与next变量由volatile修饰）\",\"Segment 继承自 ReentrantLock，一个 ConcurrentHashMap 里包含一个Segment数组。Segment 的结构和 HashMap 类似，是一种数组和链表结构。\",\"一个 Segment 里包含一个 HashEntry 数组，当对 HashEntry 数组的数据进行修改时，必须首先获得与它对应的 Segment 锁 。\",\"​ get 实现简单高效，先经过一次再散列（为了减少散列冲突），再用这个哈希值通过哈希运算定位到 Segment，最后通过散列算法定位到元素。get 的高效在于不需要加锁，除非读到空值才会加锁重读。get 方法中将共享变量定义为 volatile，在 get 操作里只需要读所以不用加锁。\",\"​ put 必须加锁，首先定位到 Segment，然后进行插入操作。第一步判断是否需要对 Segment 里的 HashEntry 数组进行扩容，第二步定位添加元素的位置，然后将其放入数组。\",\"​ size 操作用于统计元素的数量，必须统计每个 Segment 的大小然后求和，在统计结果累加的过程中，之前累加过的 count 变化几率很小，因此先尝试两次通过不加锁的方式统计结果，如果统计过程中容器大小发生了变化，再加锁统计所有 Segment 大小。判断容器是否发生变化根据 modCount 确定。\"]},\"130\":{\"h\":\"JDK8 的 ConcurrentHashMap 原理？\",\"t\":[\"​ 将锁的级别控制在更细粒度的哈希桶数组元素级别，也就是说只要锁住这个链表的头结点(红黑树的根节点)，就不会影响其他的哈希桶数组的读写，大大提高了并发度。\",\"主要对 JDK7 做了三点改造：\",\"JDK1.7 采用 Segment 的分段锁机制实现线程安全，JDK1.8 采用CAS+synchronized保证线程安全。\",\"将 1.7 中的 HashEntry 改为了 Node，但作用都是相同的。其中的val、next都由 volatile 修饰。\",\"锁的粒度：JDK1.7 是对需要进行数据操作的 Segment 加锁，JDK1.8 调整为对每个数组元素加锁（Node）。\",\"查询时间复杂度：从 JDK1.7 的遍历链表 O(n)， JDK1.8 变成遍历红黑树 O(logN)。\"]},\"131\":{\"h\":\"JDK1.8 弃用分段锁的原因(而使用 cas+synchronized)\",\"t\":[\"JDK1.8 中为什么使用内置锁 synchronized 替换 可重入锁 ReentrantLock？\",\"在 JDK1.6 中，对 synchronized 锁的实现引入了大量的优化，并且 synchronized 会有多种锁状态，会从无锁 ->轻量级锁 -> 偏向锁 -> 重量级锁一步步转换。\",\"减少内存开销 。假设使用 ReentrantLock 来获得同步支持，那么每个节点都需要通过继承 AQS 来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。\",\"put\",\"根据 key 计算出 hashcode 。\",\"判断是否需要进行初始化。\",\"f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。\",\"如果当前位置的 hashcode <span style=\\\"background-color: yellow\\\"> MOVED </span> -1,则需要进行扩容。\",\"如果都不满足，则利用 synchronized 锁写入数据。\",\"如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。\"]},\"132\":{\"h\":\"操作系统的特征？\"},\"133\":{\"h\":\"大内核 & 微内核\",\"t\":[\"内核：计算机上配置的底层软件，是操作系统最基本，最核心的部分。\",\"分类：\",\"大内核：变态次数少，性能高。但是内核代码庞大，难以维护\",\"微内核：变态次数多，性能低。但是内核代码少，方便维护\"]},\"134\":{\"h\":\"内核态和用户态\",\"t\":[\"​ 内核态和用户态是操作系统运行的两种级别，目的是为了保证系统程序不被应用程序有意或无意的破坏。操作系统在内核态运行，应用程序只能在用户态运行。\",\"内核态：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。\",\"用户态：处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。\",\"用户态和内核态的切换？\",\"​ 用户程序的访问能力有限，一些比较重要的比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做的事情，而这些数据却又对用户程序来说非常重要。所以就涉及到两种模式下的转换， 此时就需要进行系统调用，能够执行系统调用的就只有 操作系统。\",\"用户态 -> 内核态\",\"系统调用：用户态进程主动切换到内核态的一种方式，用户态执行陷入指令 int（软中断指令），引发一个内中断，从而 CPU 进入内核态，所以说系统调用本质也是中断。陷入指令是唯一一个只能在用户态，而不能在内核态执行的指令。\",\"异常（也叫内中断）：当 CPU 正在执行用户态程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从用户态执行的进程转向内核态执行相关的异常事件，如：缺页异常，int i = 1/0。\",\"外围设备的中断：当外围设备完成用户的请求操作后，会向 CPU 发出中断信号，此时 CPU 就会暂停执行下一条即将要执行的指令，转而切换成内核态去执行中断信号对应的处理程序。\",\"内核态 -> 用户态\",\"通过执行特权指令，将程序状态字（PSW）标志位设置为 ”用户态“。\"]},\"135\":{\"h\":\"系统调用\",\"t\":[\"​ 我们运行的程序基本都是运行在用户态，如果我们想要调用操作系统提供的内核态级别的子功能咋办呢？那就需要系统调用了。也就是说我们的用户程序，凡是与内核态有关的操作（如文件管理、进程控制、内存管理、I/O 等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。\",\"关于各种相关指令 \",\"系统调用指令 = 广义指令：在用户态下调用，在核心态执行\",\"陷入指令 = trap 指令 = 访管指令：在用户态下执行\",\"系统调用过程\",\"传递系统调用参数\",\"执行陷入指令，操作系统来选择具体运行哪个处理函数\",\"执行系统调用相应服务程序\",\"返回用户程序继续执行\"]},\"136\":{\"h\":\"PCB 和 TCB\",\"t\":[\"进程的组成：PCB + 数据段 + 程序段\",\"PCB：进程存在的唯一标识，是给操作系统用的，程序段、数据段是给进程自己用的。\",\"数据段：运行过程产生的各种数据（如：程序中定义的变量）\",\"程序段：程序的代码（指令序列）\",\"PCB\",\"​ 操作系统要记录 PID、进程所属用户（UID），还有记录给进程分配了哪些资源（如：分配了多少内存，正在使用哪些 IO 设备、正在使用哪些文件），还要记录进程运行情况（如：CPU 使用时间、磁盘使用情况等）。\",\"​ 这些信息都被保存在一个数据结构 PCB 中，即进程控制块，但凡进程管理所需要的信息，都会被放在 PCB 中。\",\"TCB\",\"每个线程都是一个线程 ID、线程控制块 TCB。TCB 与 PCB 相似，只是 TCB 保存的线程状态比 PCB 中保存的少。\"]},\"137\":{\"h\":\"I/O\",\"t\":[\"IO 分为两个过程：\",\"数据准备的过程\",\"数据从内核空间拷贝到用户进程缓冲区的过程\",\"​ 阻塞 I/O 会阻塞在「过程 1 」和「过程 2」，⽽⾮阻塞 I/O 和基于⾮阻塞 I/O 的多路复⽤只会阻塞在「过程 2」，所以这三个都可以认为是同步 I/O。 异步 IO 则不同，过程 1 和过程 2 都不阻塞。\"]},\"138\":{\"h\":\"零拷贝\",\"t\":[\"​ 避免在用户态与内核态之间来回拷贝数据的技术。\",\"​ 而 NIO 的零拷贝与传统的文件 IO 操作最大的不同之处就在于它虽然也是要从磁盘读取数据，但是它并不需要将数据读取到操作系统的内核缓冲区，而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系，这样直接从内存中读写文件，速度大幅度提升。\"]},\"139\":{\"h\":\"程序、进程、线程、协程\",\"t\":[\"**程序：**程序由静态的指令和数据组成，进程是是动态的,是程序的一次执行过程。（指令加载到 CPU，数据加载到内存）\",\"进程：是程序运行和系统资源分配的基本单位（与线程的根本区别）。\",\"**线程：**是进程的一个实体，是 cpu 调度和分派的基本单位，是比进程更小的能独立运行的单元。\",\"进程与线程的区别\",\"资源拥有：进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。\",\"地址空间：进程有自己独立的地址空间，线程没有自己独立的地址空间。\",\"资源开销：进程间切换有较大的开销，线程间切换开销较小。因为进程切换要切换页目录以使用新的地址空间，把原进程的数据段代码换出去，把要执行的进程内容换进来。\",\"协程\",\"​ ，一个线程可以拥有多个协程。协程调度由用户自己执行，每个协程拥有自己的执行栈，可以保存自己的执行现场。协程主动让出执行权时，会保存执行现场，然后切换到其它协程；协程恢复执行时，会根据之前保存的执行现场，恢复到中断前的状态继续执行，这样就通过协程实现了即轻量又灵活的，由用户态进行调度的多任务模型。\"]},\"140\":{\"h\":\"线程相关\"},\"141\":{\"h\":\"线程间通信方式\",\"t\":[\"使用全局变量：由于多个线程可能更改全局变量，因此全局变量最好声明为 volatile。\",\"使用消息实现通信：每个线程都可以拥有自己的消息队列，因此可以采用消息进行线程间通信。\",\"Java 中使用wait()和notify、ReentrantLock 结合 Condition。\"]},\"142\":{\"h\":\"线程同步\",\"t\":[\"，其实也就是线程安全。\",\"互斥同步\",\"​ 是一种最常见也是最主要的并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是常见的互斥实现方式。\",\"在 Java 里面，最基本的互斥同步手段就是 synchronized 关键字，以及 Reentrantlock。\",\"信号量：它允许同一时刻多个线程访问同一资源，并且可以限制同一时刻访问此资源的最大线程数量。\",\"非阻塞同步\",\"​ 互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销，因此这种同步也被称为阻塞同步。互斥同步属于一种悲观的并发策略，无论共享的数据是否真的会出现竞争，它都会进行加锁。这必然导致用户态到核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开销。随着硬件指令集的发展（CAS 指令），我们已经有了另外一个选择：基于冲突检测的乐观并发策略。也就是乐观锁。\"]},\"143\":{\"h\":\"用户线程、守护线程\",\"t\":[\"用户线程：用户线程指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。\",\"守护线程：是一种运行时在后台提供通用服务的线程（也就是个服务线程），当程序中只剩下守护线程时，程序就会退出。如：垃圾回收线程就是守护线程。\"]},\"144\":{\"h\":\"线程上下文切换\",\"t\":[\"​ Thread Context Switch 是存储和恢复 CPU 状态的过程，它使得线程能够从中断点恢复执行。当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器，它的作用是记住下一条 jvm 指令的执行地址，是线程私有的。\",\"线程上下文切换的时机\",\"因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码：\",\"线程的 cpu 时间片用完(每个线程轮流执行，看前面并行的概念)\",\"垃圾回收\",\"有更高优先级的线程需要运行\",\"线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法\",\"线程上下文切换过程？\",\"​ 先把前一个任务（线程/进程）的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来，以恢复任务的执行。\",\"如何减少上下文切换？\",\"无锁并发编程：多线程竞争时，会引起上下文切换，可以用一些办法来避免使用锁，如：将数据的 ID 按照 hash 取模分段，不同的线程处理不同段的数据。\",\"CAS 算法：JDK 的 Atomic 包使用 CAS 算法来更新数据，不需要加锁。\",\"使用最少线程：避免创建不需要的线程，如：任务很少，但创建了很多线程来处理，这样会造成大量线程都处于等待状态。\",\"协程：在单线程里实现多任务的调度，并在单线程中维持多个任务间的切换。\"]},\"145\":{\"h\":\"为什么进程上下文切换代价更高\",\"t\":[\"线程上下文切换和进程上下文切换最主要的区别：线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。\",\"进程切换分两步：\",\"切换页目录以使用新的地址空间（线程切换不需要）\",\"切换内核栈和硬件上下文\"]},\"146\":{\"h\":\"进程相关\"},\"147\":{\"h\":\"进程切换\",\"t\":[\"从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：\",\"保存进程上下文，包括程序计数器和其他寄存器。\",\"更新 PCB 信息。\",\"把进程的 PCB 移入相应的队列，如就绪、在某事件阻塞等队列。\",\"选择另一个进程执行，并更新其 PCB。\",\"更新内存管理的数据结构。\",\"恢复进程上下文。\"]},\"148\":{\"h\":\"进程的状态转换\",\"t\":[\"创建状态(new) ：进程正在被创建，尚未到就绪状态。\",\"就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。\",\"运行状态(running) ：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。\",\"阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行。如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。\",\"结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。\",\"就绪 —> 运行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；\",\"运行 —> 阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等；\",\"阻塞 —> 就绪：处于阻塞状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；\",\"运行—> 就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。\"]},\"149\":{\"h\":\"进程间通信方式 ？\",\"t\":[\"​ 进程间通信（IPC，InterProcess Communication），大概有 7 种常见的进程间的通信方式：\",\"管道/匿名管道：半双工的，具有固定的读端和写端；只能用于父子进程或者兄弟进程之间的进程的通信；可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。\",\"命名管道：遵循 FIFO，以磁盘文件的方式存在，可以实现本机任意两个进程通信。\",\"信号(Signal) ：信号是一种比较复杂的通信方式，用于通知、接收进程某个事件已经发生；\",\"消息队列：消息队列是消息的链表,具有特定的格式,存放在内存中，并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是，消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。\",\"信号量(Semaphore) ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题，并避免竞争条件。\",\"共享内存：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。\",\"套接字：利用网络进行通信，能够用于不同计算机之间的进程间通信。\",\"通信方式的选择\",\"管道用来实现进程间相互发送非常短小的、频率很高的消息，适用于两个进程间的通信。\",\"共享内存用来实现进程间共享的、非常庞大的、读写操作频率很高的数据，适用于多进程间的通信。\",\"其他考虑用 socket，主要应用在分布式开发中。\"]},\"150\":{\"h\":\"进程调度算法\",\"t\":[\"为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率：\",\"先来先服务 FCFS：按照进程到达的先后顺序执行。非抢占式算法，只能由当前的进程主动放弃 CPU。不会导致饥饿。适合于长作业（进程），而不利于短作业（进程）。\",\"短作业优先 SJF：每次调度时选择当前已经到达就绪队列且运行时间最短的进程。默认非抢占式，也有抢占式的。减少了平均周转时间，会导致长进程饥饿。\",\"高响应比优先 HRRN：调度时选择响应比最高的进程服务。响应比=(等待时间+运行时间)/运行时间。非抢占式，不会导致饥饿，响应比计算增加开销。\",\"时间片轮转 RR：按照各进程到达就绪队列的顺序，轮流执行一个时间片。抢占式，不会导致饥饿，但是高频率的进程上下文切换增加开销。\",\"优先级调度算法：调度时选择优先级最高的进程。抢占式、非抢占式都有，会导致低优先级进程饥饿。适用于实时操作系统。\",\"多级反馈队列调度算法：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。\"]},\"151\":{\"h\":\"僵尸进程、孤儿进程\",\"t\":[\"僵尸进程\",\"僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。\",\"孤儿进程\",\"一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。\"]},\"152\":{\"h\":\"内存管理机制\"},\"153\":{\"h\":\"内存管理主要是做什么的？\",\"t\":[\"负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存）\",\"地址转换：逻辑地址 <---> 物理地址。操作系统引入了虚拟内存，，来转换变成物理地址，然后再通过物理地址访问内存。\",\"​\",\"内存管理主要有 3 种方式：分段、分页、段页式。\",\"分段：将程序的地址空间按照程序自身的逻辑关系划分为若干个段。\",\"分页：将内存空间分为一个个大小相等的页区。通过页表对应逻辑地址和物理地址。\",\"段页式：将进程按逻辑分段，再将各段分页（如：每个页面 4KB），再将内存空间分为大小相同的内存块，将各页面分别装入内存块中。\"]},\"154\":{\"h\":\"内存碎片\",\"t\":[\"​ 分为内部碎片和外部碎片。内部碎片和外部碎片最明显的区别就是内部碎片能够明确指出这部分内存属于哪个进程，而外部碎片不属于任何进程。\",\"内部碎片：指已经被分配给某个进程，但是该进程却使用不到的内存空间，只有当该进程运行完毕后才能释放这块内存空间。\",\"外部碎片：指内存分配过程中产生的不可被利用的、已申请内存之外的内存空间，外部碎片往往比较多，而且每块碎片都很小。\"]},\"155\":{\"h\":\"分页与分段的区别？\",\"t\":[\"段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的；\",\"段的大小不固定，由它所完成的功能决定；页大小固定，由系统决定；\",\"段向用户提供二维地址空间（段名+段内地址）；页向用户提供的是一维地址空间；\",\"分页会产生内碎片，但不会产生外碎片，分段会产生外碎片，但不会产生内碎片。\",\"优点\",\"缺点\",\"分页\",\"内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片\",\"不方便按照逻辑模块实现信息的共享和保护\",\"分段\",\"很方便按照逻辑模块实现信息的共享和保护\",\"如果段长过大，则不容易分配连续空间；会产生外部碎片\"]},\"156\":{\"h\":\"虚拟地址和物理地址之间的映射\",\"t\":[\"虚拟地址和物理地址之间的映射是以页（4kb）为单位进行映射的。\",\"每一个进程都有一个 PCB 进程控制块，里面包含了一些进程的信息（页目录、状态、ID、PID）\",\"映射过程（32 位系统下）：\",\"​ 首先 PCB 中有一个指向一级分页表的指针，每一个页表的大小均为 4096B（4KB），可以存储 1024 个地址。其中一级页表中每一个地址对应着一个二级页表的首地址，二级页表中也存储着 1024 个地址，其中每个地址分别对应着物理内存上面的每一个页的首地址。这样一来，虚拟地址空间所能够访问的地址有 1024 _ 1024 _ 4096B = 2^32B = 4GB；正好是 4G。 我们知道进程的虚拟地址称为线性地址，每一个线性地址都由第一级页表、第二级页表以及该地址相对于该页首地址的偏移量三部分组成，即 10-10-12 的形式：\"]},\"157\":{\"h\":\"虚拟内存 & 页面置换\",\"t\":[\"​ 这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。\",\"​ 原因就是因为使用了虚拟内存，它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个页，部分页暂时存储在外部磁盘上，在需要时进行数据交换。\",\"实现虚拟技术的两个关键点：\",\"：访问的信息不在内存时，由操作系统负责将所需信息从磁盘调入内存。\",\"：内存空间不够时，将内存中暂时用不到的信息换出到 磁盘。\"]},\"158\":{\"h\":\"局部性原理\",\"t\":[\"​ 局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。具体是指，我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。\"]},\"159\":{\"h\":\"缺页中断/缺页异常\",\"t\":[\"​ 进程线性地址空间里的页面不必常驻内存，在执行一条指令时，如果发现它要访问的页不在内存时，那么停止该指令的执行，，对应的故障处理程序可通过从磁盘加载该页的方法来排除故障，之后，原先引起异常的指令就可以继续执行，而不再产生异常。\",\"​ 缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的， 因此。一条指令在执行期间， 可能产生多次缺页中断。\",\"请求分页存储管理与基本分页存储管理的主要区别：\",\"在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序\",\"若内存空间不够， 由操作系统负责将内存中暂时用不到的信息换出到外存\"]},\"160\":{\"h\":\"页面置换算法？\",\"t\":[\"​ 内存中给页面留的位置是有限的，在内存中以帧为单位放置页面。为了防止请求调页的过程出现过多的内存页面错误而使得程序执行效率下降，我们需要设计一些页面置换算法：常见前 4 个\",\"先进先出置换算法（FIFO）：先进先出，即淘汰最早调入的页面。\",\"最佳置换算法（OPT）：选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。理论最优，但无法实现\",\"最近最久未使用（LRU）：即选择最近最久未使用的页面予以淘汰。\",\"最少使用页面置换算法（LFU） : 该置换算法选择在之前时期使用最少的页面作为淘汰页。\",\"时钟（Clock）置换算法：时钟置换算法也叫最近未用算法 NRU（Not RecentlyUsed）。该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个循环队列。循环扫描各页面，第一轮淘汰访问位=0 的，并将扫描过的页面置为 1。若第一轮没选中，则进行第二轮扫描。\",\"改进型 CLOCK（改进型 NRU）：若用（访问位，修改位）来表示，则第一轮淘汰（0,0），第二轮淘汰（0,1），并将扫描过的页面访问位都置为 0，第三轮淘汰（0,0），第四轮淘汰（0,1）。\"]},\"161\":{\"h\":\"动态链接库和静态链接库\",\"t\":[\"静态链接就是在编译链接时直接将需要的执行代码拷贝到调用处，优点就是在程序发布的时候就不需要的依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大一些。\",\"动态链接就是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的前期执行性能。\"]},\"162\":{\"h\":\"编译系统\",\"t\":[\"预处理阶段：处理以 # 开头的预处理命令；\",\"编译阶段：翻译成汇编文件；\",\"汇编阶段：将汇编文件翻译成可重定位目标文件；\",\"链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。\"]},\"163\":{\"h\":\"磁盘调度算法\",\"t\":[\"为了提高磁盘的访问性能，一般是通过优化磁盘的访问请求顺序来做到，常用的磁盘调度算法有以下 4 种：\",\"先来先服务（FCFS）：根据进程请求访问磁盘的先后顺序进行调度。不会饥饿，但如果大量进程竞争使用磁盘，这种算法性能低，请求访问的磁道可能会很分散，导致寻道时间过长。\",\"最短寻道时间优先算法（SSTF）：要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短。性能较好，平均寻道时间短，克服了先来先服务（FCFS）调度算法中磁臂移动过大的问题，可能导致饥饿。\",\"扫描算法（SCAN）（电梯调度算法）：磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向。由于磁头移动规律与电梯运行相似，故又称为电梯调度算法。性能较好，平均寻道时间短，不会导致 “饥饿”，但局部性访问方面性能差，不利于远端磁头一端的访问请求\",\"循环扫描算法（CSCAN）：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至起始端，并且返回中途不处理任何请求，该算法的特点：磁道只响应一个方向上的请求。消除了对两端磁道请求的不公平，不会导致 “饥饿”。\"]},\"164\":{\"h\":\"JVM\"},\"165\":{\"h\":\"一、类加载机制\",\"t\":[\"概述\",\"虚拟机的类加载机制：把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以直接被虚拟机使用的Java类型。\",\"在Java语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的，虽然会让提前编译面临困难以及加载类增加一些开销，但为Java应用提供了极高的拓展性和灵活性。\"]},\"166\":{\"h\":\"判断两个类是否相同？\",\"t\":[\"类的完整类名必须一致，包括包名。\",\"加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。\",\"​ 也就是说，在JVM中，即使两个类对象是源于同一个Class文件，只要加载它们的ClassLoader不同，那么这两个对象也是不相等的。这里所指的“相等”， 包括代表类的Class对象的equals()方法、 isAssignableFrom()方法、 isInstance()方法的返回结果， 也包括了使用instanceof关键字做对象所属关系判定等各种情况。\"]},\"167\":{\"h\":\"类加载过程\"},\"168\":{\"h\":\"Step1：加载\",\"t\":[\"在加载阶段，Java虚拟机要完成：\",\"通过一个类的全限定名来获取定义此类的二进制字节流。\",\"将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构(拿到内存)。\",\"在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。\",\"​ 一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。\",\"注：第一条“通过类的全限定名来获取二进制流”的规则，并没有指定字节流从哪里、如何获取，这就可以在加载阶段构建了一个广阔的舞台：\",\"本地系统直接加载。\",\"从ZIP压缩包中提取：是日后JAR、EAR、WAR格式的基础。\",\"从网络中获取：典型应用是Web Applet。\",\"运行时计算生成，使用最多的是动态代理技术。\",\"有其他文件生成，典型场景JSP。\",\"从数据库中读取、从加密文件中获取...\",\"​ 加载阶段完成后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中。类型数据安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class对象，作为程序访问方法区中类型数据的外部接口。\"]},\"169\":{\"h\":\"Step2：连接\"},\"170\":{\"h\":\"验证\",\"t\":[\"目的：确保Class文件的字节流包含的信息符合《Java虚拟机规范》的全部约束要求，保证被加载类的正确性，确保不会威胁虚拟机的安全。\",\"验证阶段会完成四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。 \",\"文件格式校验：验证字节流是否符合 class 文件的规范，并且能被当前版本的虚拟机处理。只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面的3个阶段的全部是基于方法区的存储结构进行的，不会再直接操作字节流；\",\"元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。目的是保证不存在不符合 Java 语言规范的元数据信息；\",\"字节码验证：该阶段主要工作是进行数据流和控制流分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为；\",\"符号引用验证：最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证的目的是确保解析动作能正常执行。\"]},\"171\":{\"h\":\"准备\",\"t\":[\"​ 准备阶段是正式为类中定义的变量（即静态变量， 被static修饰的变量） 分配内存并设置类变量初始值的阶段。\",\"为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置该类变量的默认初始值（零值）。\",\"这时候进行内存分配的仅包括类变量（static），不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。\",\"这里不包含被final修饰的static，因为final在编译阶段就会分配了，准备阶段会显式初始化。\"]},\"172\":{\"h\":\"解析\",\"t\":[\"​ 解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。\",\"是Java虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。\",\"解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。\",\"符号引用：符号引用以一组符号来描述所引用的目标，其字面量形式定义在《Java虚拟机规范》中的Class文件格式中。与JVM实现的内存布局无关。\",\"直接引用：直接引用是可以直接指向目标的指针、 相对偏移量或者是一个能间接定位到目标的句柄。和虚拟机实现的内存布局直接相关的。\",\"解析阶段发生的具体时间没有被要求，常在初始化之后才发生。\",\"在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。\"]},\"173\":{\"h\":\"Step3：初始化\",\"t\":[\"概述\",\"初始化阶段就是执行类构造器<clinit>()方法的过程。直到初始化阶段，JVM才真正开始执行类中编写的Java代码（字节码），将主导权移交给应用程序。\",\"<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块） 中的语句合并产生的 ，编译器收集的顺序是由语句在源文件中出现的顺序决定的 。\",\"<clinit>()方法与类的构造函数（即在虚拟机视角中的实例构造器<init>()方法）不同， 它不需要显式地调用父类构造器， Java虚拟机会保证在子类的<clinit>()方法执行前， 父类的<clinit>()方法已经执行完毕。 因此在Java虚拟机中第一个被执行的<clinit>()方法的类型肯定是java.lang.Object。\",\"<clinit>()方法对于类或接口来说并不是必需的， 如果一个类中没有静态语句块， 也没有对变量的赋值操作， 那么编译器可以不为这个类生成<clinit>()方法 。\",\"JVM必须保证一个类的<clinit>()方法在多线程下被同步加锁。因为 <clinit>() 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。\"]},\"174\":{\"h\":\"主动初始化\",\"t\":[\"有且只有六种情况必须立刻对类进行初始化：\",\"当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。 \",\"当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。\",\"当jvm执行getstatic指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。\",\"当jvm执行putstatic指令时会初始化类。即程序给类的静态变量赋值。\",\"当jvm执行invokestatic指令时会初始化类。即程序调用类的静态方法。\",\"使用 java.lang.reflect 包的方法对类进行反射调用时。如：Class.forname(\\\"...\\\"), newInstance()等等。如果类没初始化，需要触发其初始化。\",\"初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。\",\"当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。\",\"当使用JDK 7新加入的动态语言支持时， 如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、 REF_putStatic、REF_invokeStatic、 REF_newInvokeSpecial四种类型的方法句柄， 并且这个方法句柄对应的类没有进行过初始化， 则需要先触发其初始化。\",\"当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初化。\"]},\"175\":{\"h\":\"类加载器的分类\",\"t\":[\"**启动类加载器、引导类加载器(Bootstrap Class Loader)<——扩展类加载器(Extension Class Loader)<——应用程序类加载器(Application Class Loader)<——用户自定义类加载器(User Class Loader) **\"]},\"176\":{\"h\":\"启动类加载器(引导类加载器)\",\"t\":[\"概述\",\"这个类加载器使用C++语言实现，是JVM自身的一部分。（其他所有的类加载器都继承于java.lang.ClassLoader）\",\"负责加载存放在<JAVA_HOME>\\\\lib目录， 或者被-Xbootclasspath参数所指定的路径中存放的， 而且是Java虚拟机能够识别的库到虚拟机的内存中。 （JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容）。\",\"没有父加载器，加载拓展类和应用程序加载器。\"]},\"177\":{\"h\":\"扩展类加载器\",\"t\":[\"概述\",\"这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的，父类加载器为启动类加载器。\",\"它负责加载<JAVA_HOME>\\\\lib\\\\ext目录中， 或者被java.ext.dirs系统变量所指定的路径中所有的类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。\"]},\"178\":{\"h\":\"应用程序类加载器(系统类加载器)\",\"t\":[\"概述\",\"这个类加载器由sun.misc.Launcher$AppClassLoader来实现。\",\"是ClassLoader类中的getSystemClassLoader()方法的返回值，也称**“系统类加载器”**。\",\"负责加载环境变量classpath或系统属性java.class.path指定路径下的类库。\"]},\"179\":{\"h\":\"线程上下文类加载器\",\"t\":[\"概述\",\"这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个。\",\"如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。\",\"通过这个类加载器可以实现逆向访问类，即父类到子类的一个访问。\",\"本质默认为application classloader。\"]},\"180\":{\"h\":\"自定义类加载器\",\"t\":[\"为什么要自定义类加载器？\",\"隔离加载类。在某些框架内进行中间件与应用的模块隔离。在某个应用中需要使用中间件，这个中间件有自己的依赖的jar包，在同一个工程里面，如果引用多个框架的话，有可能会出现某些类的路径一样、类名也相同，这样就会出现类的冲突了，这个时候就需要做一个类的仲裁，像现在主流的容器类的框架一样，它们都会自定义类的加载器，实现不同的中间件隔离，避免类的冲突\",\"修改类加载方式。\",\"扩展加载源。加载的类除了可以在网络、本地物理磁盘、jar包去加载之外，还可以从数据库、网络甚至机顶盒进行加载。\",\"防止源码泄露。Java代码容易被反编译，可以进行编译加密。当有了字节码文件或者没有反编译的手段，java代码是很容易被编译和篡改，所以，为了防止编译和篡改，我们可以对字节码文件进行加密，当我们需要运行这个字节码文件时候，我们需要解密来还原成内存中的类，而这个解密的操作，就需要自定义类的加载器来实现\"]},\"181\":{\"h\":\"JDK9新特性\",\"t\":[\"扩展机制被移除（jdk9基于模块化构建，Java类库天然满足扩展需求，无需保留ext目录了），扩展类加载器重命名为平台加载器（Platform ClassLoader），可以通过ClassLoader的新方法getPlatformClassLoader()来获取。\",\"平台类加载器和应用程序类加载器不在继承自java.net.URLClassLoader。现在启动类加载器、平台类加载器、应用程序类加载器都继承自jdk.internal.loader.BulitinClassLoader。\",\"双亲委派：在委派给父加载器之前，先判断类是否能够归属到某一个系统模块中，如果可以找到归属关系，优先委派给负责那个模块的加载器完成加载。\",\"类加载器有了名称，可以在构造方法中指定，通过getName()来获取。平台类是platform，应用类是app。\",\"启动类加载器现在在JVM内部和Java类库共同协作实现的类加载器。\"]},\"182\":{\"h\":\"ClassLoader类\",\"t\":[\"​ 是一个抽象类，其后所有的类加载器都继承于ClassLoader（不包括启动类加载器）。\",\"​ Java程序在运行的时候,JVM通过**类加载机制(ClassLoader)**把class文件加载到内存中,只有class文件被载入内存,才能被其他class引用,使程序正确运行起来.\",\"方法\",\"getParent()：返回该类加载器的超类加载器。\",\"loadClass(String name)：加载名称为name的类，返回结果为java.lang.Class的实例。\",\"findClass(String name)：查找名称为name的类，返回结果为java.lang.Class的实例。\",\"获取ClassLoader的途径\",\"clazz.getClassLoader()：获取当前类的ClassLoader。\",\"Thread.currentThread().getContextClassLoader()：获取当前线程上下文的ClassLoader。\",\"ClassLoader.getSystemClassLoader()：获取系统的ClassLoader\",\"DriverManager.getCallerClassLoader()：获取调用者的ClassLoader\"]},\"183\":{\"h\":\"Class.forName()与ClassLoader.loadClass()的区别\",\"t\":[\"class.forname()：是一个静态方法，最常用的是Class.forName(String classname)；根据传入的类的全限定名返回一个Class对象。该方法将Class文件加载到内存的同时，会执行类的初始化。\",\"ClassLoader.loadClass()：这是一个实例方法，需要一个CLassLoader对象来调用该方法。该方法将CLass文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才初始化。因为该方法需要得到一个ClassLoader对象，所以可以根据需要指定使用哪个类的加载器。ClassLoader cl = ....; cl.loadClass(com.myj.jvm.HelloWorld);\"]},\"184\":{\"h\":\"双亲委派机制\",\"t\":[\"概述\",\"各种类加载器之间的层次关系被称为类加载器的“双亲委派模型”。\",\"双亲委派模型要求除了顶层的启动类加载器外， 其余的类加载器都应有自己的父类加载器。\",\"这里类加载器之间的父子关系一般不是以继承（Inheritance） 的关系来实现的， 而是通常使用组合（Composition） 关系来复用父加载器的代码。\",\"并不是一个具有强制性约束力的模型。\",\"在java.lang.ClassLoader.loadClass(String,boolean)接口中体现。\",\"工作过程（原理）\",\"​ 当一个类加载器收到类加载的请求时，系统会首先判断当前类是否被加载过，已经被加载的类会直接返回，否则才会尝试加载。加载的时候，它首先不会自己去尝试加载这个类， 而是把这个请求委派给父类加载器的loadClass()去完成， 每一个层次的类加载器都是如此， 因此所有的加载请求最终都应该传送到最顶层的启动类加载器中， 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。\",\"好处\",\"​ 双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。\"]},\"185\":{\"h\":\"破坏双亲委派模型\",\"t\":[\"破坏的诉求：有基础类型又要调用回用户的代码\",\"一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？\",\"自定义加载器的话，需要继承 ClassLoader 。重写 loadClass() 方法会打破双亲委派机制。如果我们不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法(JDK1.2加入)即可，无法被父类加载器加载的类最终会通过这个方法被加载。\",\"为实现SPI服务，引入Thread Context ClassLoader 。Java中涉及SPI的服务使用这个线程上下文类加载器去加载所需的SPI服务代码， 这是一种父类加载器去请求子类加载器完成类加载的行为， 这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器， 已经违背了双亲委派模型的一般性原则。\",\"用户追求程序动态性：代码热替换、热部署...\",\"双亲委派的逆向调用\",\"SPI ，全称为 Service Provider Interface，是一种服务发现机制。它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类。\",\"SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。\",\"Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。\",\"​ Java中涉及SPI的加载基本上都采用这种方式来完成， 例如JNDI、JDBC、 JCE、 JAXB和JBI等。 不过， 当SPI的服务提供者多于一个的时候， 代码就只能根据具体提供者的类型来硬编码判断， 为了消除这种极不优雅的实现方式， 在JDK 6时， JDK提供了java.util.ServiceLoader类， 以META-INF/services中的配置信息， 辅以责任链模式， 这才算是给SPI的加载提供了一种相对合理的解决方案。\"]},\"186\":{\"h\":\"沙箱安全机制\",\"t\":[\"沙箱机制就是将Java代码限定在JVM特定的运行范围内，并且严格限制代码对本地系统资源的访问。通过这样的措施来保证对代码的有限隔离，防止对本地系统的破坏。\",\"沙箱主要限制系统资源访问，包括CPU、内存、文件系统、网络等。\",\"当前最新的安全机制实现，引入了域的概念。JVM会把所有代码加载到不同的系统域和应用域。\"]},\"187\":{\"h\":\"热替换的实现\",\"t\":[\"​ 对Java来说，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。一个可行实现热替换的方法是灵活运用ClassLoader。（对JVM来说，不同ClassLoader加载的同名类属于不同的类型）\"]},\"188\":{\"h\":\"二、运行时数据区\",\"t\":[\"线程私有：程序计数器、虚拟机栈、本地方法栈。\",\"线程间共享：堆、堆外内存（元空间、代码缓存）。\"]},\"189\":{\"h\":\"程序计数器\",\"t\":[\"线程私有，可以看作是当前线程所执行的字节码的行号指示器，占用内存极小，字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。\",\"在多线程的情况下，程序计数器记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\",\"如果线程正在执行一个Java方法，计数器记录正在执行字节码指令的地址。如果线程正在执行一个Native方法，计数器的值为空。\"]},\"190\":{\"h\":\"Java虚拟机栈\",\"t\":[\"概述\",\"线程私有，生命周期与线程相同。栈是运行时的单位，堆是存储的单位。\",\"每个方法被执行时，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。方法从调用到执行完毕，对应一个栈帧入栈到出栈。JVM对Java栈的操作只有：入栈、出栈。\",\"由于跨平台设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。\",\"优点是跨平台，指令集小，编译器容易实现。缺点是性能下降，实现同样的功能需要更多的指令。\",\"栈是一种快速有效的分配存储的方式，访问速度仅次于程序计数器。对栈来说，不存在GC的问题。\",\"栈可能会出现的异常\",\"《Java虚拟机规范》允许Java栈的大小是动态的或者是固定不变的。\",\"如果采用固定大小的JVM栈，那每一个线程的JVM栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过JVM栈允许的最大容量，JVM会抛出一个StackOverflowError异常。\",\"如果JVM栈是可以动态扩展的，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的JVM栈，那么JVM会抛出一个OutOfMemoryError异常。\",\"其他\",\"设置栈大小的指令：-Xss\"]},\"191\":{\"h\":\"运行时栈帧结构\",\"t\":[\"概述\",\"JVM以方法作为最基本的执行单元，栈帧则是用于支持JVM进行方法调用和方法执行背后的数据结构。\",\"每个栈帧都包括了局部变量表、操作数栈、动态连接（或指向运行时常量池的方法引用）、方法返回地址和一些额外的附加信息。\",\"在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。换言之，一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。\",\"同一时刻、 同一条线程里面 只会有一个活动的栈帧，称为当前栈帧，对应当前方法以及当前类。执行引擎运行的所有字节码指令只针对当前栈帧进行操作。\"]},\"192\":{\"h\":\"局部变量表\",\"t\":[\"是一组变量值的存储空间， 用于存放方法参数和方法内部定义的局部变量。 由数组实现。\",\"在Java程序被编译为Class文件时， 就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量，即局部变量表所需的容量大小是在编译期确定下来的。\",\"局部变量表的容量以变量槽（Slot）为最小单位，变量槽的长度可以随着处理器、 操作系统或虚拟机实现的不同而发生变化。\",\"对于64位的数据类型（long、double），Java虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间。由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，无论读写两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题。\",\"Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。如果访问的是32位数据类型的变量， 索引N就代表了使用第N个变量槽， 如果访问的是64位数据类型的变量， 则说明会同时使用第N和N+1两个变量槽，同时不允许以任何方式单独访问其中一个。\",\"当一个方法被调用时，JVM使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。如果执行实例方法，那第0位索引的变量槽默认是用于传递方法所属对象实例的引用，可以通过this来访问到这个隐含的参数。\",\"变量槽是可以重用的，如果当前字节码PC计数器的值已经超出了某个变量的作用域， 那这个变量对应的变量槽就可以交给其他变量来重用。不过，会直接影响到GC（slot被复用之前，就算代码已经该变量的作用域，也不会被回收）。\",\"局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。\"]},\"193\":{\"h\":\"操作数栈\",\"t\":[\"操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。Javac编译器的数据流分析工作保证了在方法执行的任何时候， 操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。\",\"操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。\",\"操作数栈中元素的数据类型必须与字节码指令的序列严格匹配， 在编译程序代码的时候， 编译器必须要严格保证这一点， 在类校验阶段的数据流分析中还要再次验证这一点。\",\"Java虚拟机的解释执行引擎被称为“基于栈的执行引擎”， 里面的“栈”就是操作数栈。\",\"栈顶缓存\",\"​ 由于基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着需要更多的指令分派（instruction dispatch）次数和内存读/写次数。 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术（ToS，Top-of-Stack Cashing），将栈顶元素全部缓存在物理的CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。\"]},\"194\":{\"h\":\"动态连接\",\"t\":[\"每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。\",\"Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。（类加载的解析阶段）\",\"如果被调用的方法在编译期无法被确定下来（如多态），将在每一次运行期间都转化为直接引用，这部分就称为动态连接。\",\"方法的绑定机制\",\"绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。\",\"早期绑定：对应静态解析，即被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定。\",\"晚期绑定：对应动态连接，即被调用的目标方法无法在编译期被确定，只能在程序运行期根据实际的类型绑定相关的方法。\",\"非虚方法\",\"如果方法在编译期就确定了具体的调用版本，且此版本在运行时不可变，这样的方法称为非虚方法。\",\"非虚方法：静态方法、私有方法、final方法、实例构造器、父类方法。\",\"其他方法为虚方法。\",\"动态、静态类型语言\",\"二者区别在于对类型的检查是在编译期还是在运行期。\",\"静态：Java...\",\"动态：JS、Python...\"]},\"195\":{\"h\":\"方法返回地址\",\"t\":[\"当一个方法开始执行后，有两种退出方式：\",\"正常调用完成：执行引擎遇到任何一个方法返回的字节码指令。\",\"异常调用完成：遇到异常。\",\"​ 无论哪种退出方式，在方法退出之后，都必须返回到最初方法被调用时的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。一般来说，方法正常退出时，主调方法的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息。\"]},\"196\":{\"h\":\"附加信息\",\"t\":[\"《Java虚拟机规范》 允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现。\",\"一般会把动态连接、 方法返回地址与其他附加信息全部归为一类， 称为栈帧信息。\"]},\"197\":{\"h\":\"本地方法栈\",\"t\":[\"​ 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。\",\"线程私有。\",\"具体做法：在Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。\",\"当某个线程调用本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界，它和虚拟机拥有相同的权限。\",\"为什么需要使用本地方法？\",\"与Java环境外的交互。\",\"与操作系统交互。通过使用本地方法，我们得以用Java实现了jre与底层系统的交互，甚至JVM的某些部分就是用C写的。\",\"Sun's Java。Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。\"]},\"198\":{\"h\":\"Java堆和栈的区别，为什么要这么设计(为什么要堆栈分离)\",\"t\":[\"区别：\",\"栈内存存储的是局部变量而堆内存存储的是实体\",\"栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短\",\"栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时回收。\",\"为什么要这么设计(堆栈分离)：\",\"（1）从软件设计的角度来看，栈代表了处理逻辑，而堆代表了数据，这样分离使得处理逻辑更为清晰。这种隔离、模块化的思想在软件设计的方方面面都有体现。\",\"（2）堆与栈的分离，使得堆中的内容可以被多个栈共享。这种共享有很多好处，一方面提供了一种有效的数据交互方式（如内存共享），另一方面，节省了内存空间。\",\"（3）栈因为运行时的需要（如保存系统运行的上下文），需要进行址段的划分。由于栈只能向上增长，因此会限制住栈存储内容的能力。而堆不同，堆的大小可以根据需要动态增长。因此，堆与栈的分离，使得动态增长成为可能，相应栈中只需要记录堆中的一个地址即可。\",\"（4）堆和栈的完美结合就是面向对象的一个实例。其实，面向对象的程序与以前结构化的程序在执行上没有任何区别，但是面向对象的引入使得对待问题的思考方式发生了改变，是更接近于自然的思考方式。当把对象拆开会发现，对象的属性其实就是数据，存放在堆中，而对象的方法就是处理逻辑，存放在栈中。我们编写对象的时候，其实即编写了数据结构，也编写了处理数据的逻辑。\",\"​ 总结：栈主要用来执行程序，堆主要用来存放对象，为栈提供数据存储服务。也正是因为堆与栈分离的思想才使得JVM的垃圾回收成为可能。\"]},\"199\":{\"h\":\"Java堆\",\"t\":[\"概述\",\"Java堆是虚拟机所管理的内存中最大的一块，线程共享。唯一目的：存放对象实例。\",\"几乎所有的对象实例以及数组都应当在堆上分配 ，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从JDK 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。\",\"Java堆可以处于物理上不连续的内存空间中， 但在逻辑上它应该被视为连续的。\",\"Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xms // memory start用来设置堆空间的初始内存大小和-Xmx //设置最大内存大小设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。\",\"在堆中new的对象几乎都在Eden区，但是超大对象直接放Old区。\"]},\"200\":{\"h\":\"将年轻代划分出survivor区的作用\",\"t\":[\"​ 所以在「堆内存」划分中，将年轻代划分出Survivor区（Survivor From 和Survivor To），⽬的就是为了有⼀块完整的内存空间供垃圾回收器进⾏拷⻉(移动) ，而新的对象则放入eden区。\",\"出现的错误\",\"堆这里最容易出现的就是 OutOfMemoryError错误，并且出现这种错误之后的表现形式还会有几种，比如：\",\"OutOfMemoryError: GC Overhead Limit Exceeded ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。\",\"java.lang.OutOfMemoryError: Java heap space ：假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发该错误。(和本机物理内存无关，和你配置的内存大小有关！)\"]},\"201\":{\"h\":\"CPU100%问题如何快速定位\",\"t\":[\"找到最耗CPU的进程； \",\"执行top -c ，显示进程运行信息列表\",\"键入P (大写p)，进程按照CPU使用率排序\",\"找到最耗CPU的线程； \",\"top -Hp ，显示一个进程的线程运行信息列表\",\"键入P (大写p)，线程按照CPU使用率排序\",\"查看堆栈，定位线程在干嘛，定位对应代码 \",\"首先，将线程PID转化为16进制。工具：printf方法：printf \\\"%xn\",\"查看堆栈，找到线程在干嘛。工具：jstack方法：jstack 10765 | grep '0x2a34' -C5 --color\"]},\"202\":{\"h\":\"逃逸分析\",\"t\":[\"概述\",\"逃逸分析(Escape Analysis)是即时编译器优化技术中一个十分重要的手段。这是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围，从而决定是否要将这个对象分配到堆上。\",\"逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。\",\"this逃逸：this逃逸是指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完成的对象的方法可能引起奇怪的问题。\",\"HotSpot并未使用，目前所有的对象实例还是在堆上分配的。\",\"例如：\",\"public static StringBuffer craeteStringBuffer(String s1, String s2) { StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb; } \",\"StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。\",\"public static String createStringBuffer(String s1, String s2) { StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb.toString(); } \",\"不直接返回 StringBuffer，那么StringBuffer将不会逃逸出方法。\",\"使用逃逸分析，编译器可以对代码做如下优化：\",\"同步省略。JIT编译器借助逃逸分析后发现，如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步，叫做同步省略，也成锁消除。因为线程同步的代价很高，会降低并发性和性能。\",\"栈上分配。如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。\",\"分离对象或标量替换。标量是指一个无法再分解成更小数据的数据，与之对应的是聚合量。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。\"]},\"203\":{\"h\":\"方法区\",\"t\":[\"概述\",\"​ ⽅法区主要是⽤来存放已被虚拟机加载的「类相关信息」：包括类信息、常量池 ，类信息⼜包括了类的版本、字段、⽅法、接⼝和⽗类等信息。 常量池⼜可以分「静态常量池」和「运⾏时常量池」，静态常量池主要存储的是「字⾯量」以及「符号引⽤」等信息，静态常量池也包括了我们说的「字符串常量池」。 运⾏时常量池」存储的是「类加载」时⽣成的「直接引⽤」等信息。\",\"​ 但⾃从在「JDK7」以后，就已经把「运⾏时常量池」和「静态常量池」转移到了「堆」内存中进⾏存储（对于「物理分区」来说「运⾏时常量池」和「静态常量池』就属于堆）\",\"线程共享，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。\",\"虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。\",\"JDK6有了放弃永久代，逐步采用本地内存的计划——>JDK7，已经把原本放在永久代的字符串常量池、静态变量等移出——>JDK8，完全废弃了永久代，采用在本地内存中实现的元空间（Metaspace）来代替。\",\"-XX:MetaspaceSize、-XX:MaxMetaspaceSize：设置初始和最大的元空间大小。\"]},\"204\":{\"h\":\"方法区的演进细节\",\"t\":[\"JDK1.6及之前：有永久代，静态变量存放在永久代上。\",\"JDK1.7：有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中。\",\"JDK1.8及之后：无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中。\"]},\"205\":{\"h\":\"方法区的实现从永久代变成元空间有什么区别？\",\"t\":[\"​ 最主要的区别就是：元空间存储不在虚拟机中，而是使用本地内存，JVM不会再出现方法区的内存溢出，以往永久代经常因为内存不够，导致抛出OOM异常。\"]},\"206\":{\"h\":\"永久代为何被元空间替代？\",\"t\":[\"为永久代设置空间大小比较困难：比如在某些场景下，动态加载类过多，容易产生Prem区的OOM。\",\"对永久代进行调优比较困难。\"]},\"207\":{\"h\":\"StringTable为什么要调整？\",\"t\":[\"​ JDK1.7中，将StringTable放到了堆空间中，因为永久代的回收效率很低，只有在full gc的时候才会触发。而full gc是老年代、永久代不足的时候才会触发。但是实际开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。\"]},\"208\":{\"h\":\"运行时常量池\",\"t\":[\"运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。\",\"Java虚拟机对于Class文件每一部分（自然也包括常量池） 的格式都有严格规定，如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池，《Java虚拟机规范》 并没有做任何细节的要求。不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。\",\"运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。\",\"常量池与运行时常量池\",\"常量池是Class文件的一部分，用于存放编译期生成的各种字面量和符号引用，在加载类型到JVM后，就会创建对应的运行时常量池。\",\"运行时常量池除了包含编译期已经明确的量，也包括运行期解析之后才能获得的方法或者字段引用。此时不再是常量池中的符号引用了，而是真实地址。\"]},\"209\":{\"h\":\"直接内存\",\"t\":[\"直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁使用，而且也可能导致OutOfMemoryError异常出现。\",\"其大小不受-Xmx指定的最大堆大小，不受JVM内存回收管理。可以通过MaxDirectMemorySize设置，默认与堆的最大值一致。\",\"来源于NIO：在JDK 1.4中新加入了NIO（New I/O）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式（传统的IO基于流），它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。 这样能在一些场景中显著提高性能， 因为避免了在Java堆和Native堆中来回复制数据。\",\"通常访问直接内存的速度会优于Java堆，即读写性能高。\"]},\"210\":{\"h\":\"直接内存使用场景\",\"t\":[\"有很大的数据需要存储，它的生命周期很长\",\"适合频繁的io操作，例如网络并发场景\"]},\"211\":{\"h\":\"三、对象的实例化\"},\"212\":{\"h\":\"创建对象的方式\",\"t\":[\"new\",\"Class的newInstance()：反射的方式，只能调用空参构造器，权限必须是public，在JDK9已经过时，改成了下面这个。\",\"Constructor的newInstance(xxx)：反射的方式，可以调用带参构造器，权限没有要求。\",\"使用clone：不调用任何构造器，当前类需要事先Cloneable接口，事先clone()。\",\"使用反序列化：从文件、网络等中获取对象的二进制流。\",\"第三方库Objenesis\"]},\"213\":{\"h\":\"创建对象的步骤(过程)\",\"t\":[\"对象创建的过程\"]},\"214\":{\"h\":\"Step1：类加载检查(判断对象对应的类是否加载、连接、初始化)\",\"t\":[\"​ 当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程 。\"]},\"215\":{\"h\":\"Step2：分配内存\",\"t\":[\"​ 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种：\"]},\"216\":{\"h\":\"指针碰撞\",\"t\":[\"​ GC收集器：Serial、ParNew\",\"​ 假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式就叫做指针碰撞。\"]},\"217\":{\"h\":\"空闲列表\",\"t\":[\"​ GC收集器：CMS\",\"​ 如果Java堆中的内存并不是规整的， 已被使用的内存和空闲的内存相互交错在一起， 那就没有办法简单地进行指针碰撞了， 虚拟机就必须维护一个列表， 记录上哪些内存块是可用的， 在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录， 这种分配方式称为空闲列表。\"]},\"218\":{\"h\":\"如何选择分配方式？\",\"t\":[\"​ 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理的能力决定。\",\"​ 因此，当使用Serial、 ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞， 既简单又高效；而当使用CMS这种基于清除算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。\"]},\"219\":{\"h\":\"内存分配的并发问题\",\"t\":[\"​ 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据。由于在实际开发过程中，对象实例的创建在JVM中十分频繁，因此在并发环境下从堆区中划分空间是线程不安全的。所以为了避免多个线程操作同一地址，需要使用加锁等机制（但是会影响速度，所以有了TLAB）：\",\"CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。\",\"TLAB（本地线程分配缓冲 ）： 预先在 Eden 区为每一个线程分配一小块私有缓存区域，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定（即采用上述方式）。 虚拟机是否使用TLAB， 可以通过-XX： +/-UseTLAB参数来设定，默认只占Eden的1%。\"]},\"220\":{\"h\":\"内存分配策略（对象Promotion策略）\",\"t\":[\"优先分配到Eden。\",\"大对象直接分配到Old，为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。（应避免程序中出现过多的大对象）\",\"长期存活的对象分配到Old。\",\"动态对象年龄判断。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。\",\"空间分配担保。-XX:HandlePromotionFailure（已失效） \",\"在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。\",\"如果不成立的话虚拟机会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于就要进行一次 Full GC。\"]},\"221\":{\"h\":\"Step3：初始化零值\",\"t\":[\"​ 内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头） 都初始化为零值 。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\",\"​ 如果使用了TLAB的话， 这一项工作也可以提前至TLAB分配时顺便进行。\"]},\"222\":{\"h\":\"Step4：设置对象头\",\"t\":[\"​ 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\"]},\"223\":{\"h\":\"Step5：执行init()方法\",\"t\":[\"​ 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始：构造函数，即Class文件中的<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\"]},\"224\":{\"h\":\"对象的内存布局\",\"t\":[\"在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。\"]},\"225\":{\"h\":\"1、对象头\",\"t\":[\"​ 包括两类信息**，第一类用于存储对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向时间戳...），另一类是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\"]},\"226\":{\"h\":\"2、实例数据\",\"t\":[\"​ 实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。\"]},\"227\":{\"h\":\"3、对齐填充\",\"t\":[\"​ 对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。\",\"例子：\",\"public class Customer{ int id = 1001; String name; Account acct; { name = \\\"匿名客户\\\"; } public Customer(){ acct = new Account(); } } public class Test{ public static void main(String[] args){ Customer cust = new Customer(); } } //局部变量表不用放this，因为是静态的，第一个就放args \"]},\"228\":{\"h\":\"对象的访问定位\",\"t\":[\"​ 创建对象是为了使用对象，Java程序会通过栈上的reference数据来操作堆上的具体对象。由于reference类型在《Java虚拟机规范》 里面只规定了它是一个指向对象的引用，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种：\"]},\"229\":{\"h\":\"1、使用句柄\",\"t\":[\"​ 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。\"]},\"230\":{\"h\":\"2、直接指针\",\"t\":[\"​ 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。\",\"两种方式的优劣\",\"​ 这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为） 时只会改变句柄中的实例数据指针，而reference本身不需要被修改。\",\"​ 使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。\",\"​ HotSpot主要使用第二种方式进行对象访问。\"]},\"231\":{\"h\":\"四、垃圾收集\",\"t\":[\"​ Java垃圾回收是Java程序执行自动内存管理的过程。当Java程序在JVM上运行时，将在堆上创建对象，当这些对象不再使用时，垃圾收集器找到这些需要回收的对象(垃圾)将其删除以释放内存。\"]},\"232\":{\"h\":\"对象是否需要回收？\",\"t\":[\"​ 堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象就是垃圾，对象所占用的空间就可以被回收）。\",\"判断对象不再被使用的算法：引用计数法、可达性分析法\"]},\"233\":{\"h\":\"引用计数法\",\"t\":[\"给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。\",\"这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。\"]},\"234\":{\"h\":\"可达性分析算法\",\"t\":[\"这个算法的基本思想：通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。\",\"可作为 GC Roots 的对象包括下面几种：\",\"虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、 局部变量、 临时变量等。\",\"本地方法栈(Native 方法)中引用的对象。\",\"方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量 。\",\"方法区中常量引用的对象，譬如字符串常量池（String Table） 里的引用。\",\"所有被同步锁持有的对象。\",\"Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（如NullPointExcepiton、 OutOfMemoryError）等，还有系统类加载器。\",\"反映Java虚拟机内部情况的JMXBean、 JVMTI中注册的回调、 本地代码缓存等。\",\"​ 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。（跨Region）\"]},\"235\":{\"h\":\"引用强度分类\",\"t\":[\"1．强引用（StrongReference）\",\"以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。 当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\",\"2．软引用（SoftReference）\",\"用来描述还有用，但非必须的对象。在系统将要发生内存溢出异常前， 会把这些对象列进回收范围之中进行第二次回收。软引用可用来实现内存敏感的高速缓存。\",\"软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JVM就会把这个软引用加入到与之关联的引用队列中。\",\"3．弱引用（WeakReference）\",\"比如软引用更弱。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\",\"弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，JVM就会把这个弱引用加入到与之关联的引用队列中。\",\"4．虚引用（PhantomReference）\",\"\\\"虚引用\\\"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。\",\"虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\",\"特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。\"]},\"236\":{\"h\":\"不可达对象不是非死不可\",\"t\":[\"要真正宣告一个对象死亡，至少要经历两次标记过程：\",\"如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记。\",\"随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。 假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。\",\"是否被执行死刑：\",\"如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。\",\"finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。\",\"当然，不建议使用finalize()方法去拯救对象，finalize()能做的所有工作， 使用try-finally或者其他方式都可以做得更好、更及时。\"]},\"237\":{\"h\":\"方法区的GC、如何判断类没用了？\",\"t\":[\"方法区的GC主要涉及：常量池中废弃的常量、不再使用的类型。\",\"常量能否被回收的判定：只要不被使用，就可以回收了。\",\"类型能否被回收的判定：1、该类所有的实例都已经被回收。2、该类的类加载器已经被回收。3、该类对应的java.lang.Class对象没有在任何地方被引用。\"]},\"238\":{\"h\":\"垃圾收集算法\"},\"239\":{\"h\":\"分代收集理论\",\"t\":[\"基于三个假说：\",\"弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。\",\"强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。\",\"跨代引用假说（ Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。（存在互相引用关系的两个对象， 是应该倾向于同时生存或者同时消亡的 ）\"]},\"240\":{\"h\":\"为什么需要分代\",\"t\":[\"​ 大部分对象都死得早，只有少部分对象会存活很长时间，在堆内存上都会物理或逻辑上进行分代，为了使stop the world持续的时间尽可能短以及提高并发式GC所能应付的内存分配速率。\",\"分类\",\"部分收集（Partial GC）\",\"新生代收集（Minor GC/Young GC）：通常能单独发生收集行为的只是新生代 。\",\"老年代收集（Major GC/Old GC）：目前只有CMS收集器会有单独收集老年代的行为。有些资料Major GC与Full GC同义。\",\"混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。 目前只有G1收集器会有这种行为。\",\"整堆收集（Full GC）\",\"​ 分代收集理论也有其缺陷，最新出现（ 或在实验中）的几款垃圾收集器都展现出了面向全区域收集设计的思想，或者可以支持全区域不分代的收集的工作模式。\"]},\"241\":{\"h\":\"新生代什么时候会变成老年代\",\"t\":[\"如果对象太大了，就会直接进入老年代(对象创建很大或者Survivor区没法存下该对象)\",\"如果对象太老了，就会晋升老年代(每发生一次Minor GC，存活的对象年龄+1，达到默认值15则晋升老年代)\"]},\"242\":{\"h\":\"什么时候触发Minor GC\",\"t\":[\"​ 当Eden空间不足时，就会触发Minor GC。存活下来的对象，则会被送到Survivor区，当放生Minor GC时，Eden区和from survivor区的存活对象会被复制到to Survivor区，然后交换from和to指针，以保证下一次Minor GC时to指向的Survivor区还是空的。年轻代GC不关心老年代对象。\"]},\"243\":{\"h\":\"什么时候触发major gc\",\"t\":[\"Major GC触发：老年代空间不足时，会尝试触发Minor GC。如果之后空间还不足，则触发Major GC。如果Major GC后内存还不足，就报OOM了。\"]},\"244\":{\"h\":\"标记-清除算法\",\"t\":[\"算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。\",\"它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题： \",\"执行效率不稳定：如果有大量对象需要回收，需要进行大量的标记和清除动作，导致效率随对象数量增长而降低 。\",\"内存空间的碎片化：标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\"]},\"245\":{\"h\":\"标记-复制算法（Young区用）\",\"t\":[\"目的：为了解决标记-清除算法面对大量可回收对象时执行效率低的问题。\",\"将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。\",\"现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代，HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1 (不是最初的1:1)。\",\"当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。\"]},\"246\":{\"h\":\"标记-整理(压缩)算法（Old区用）\",\"t\":[\"​ 分为标记和整理两个阶段：首先标记出所有需要回收的对象，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。不会产生空间碎片，但是整理会花一定的时间。\",\"除了浪费空间，标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。\",\"标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法， 而后者是移动式的。移动则内存回收时会更复杂， 不移动则内存分配时会更复杂。\",\"HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的（当空间碎片过多，CMS会进行一次标记-整理）。\"]},\"247\":{\"h\":\"card table\",\"t\":[\"​ HotSpot虚拟机下 有「card table」（卡表）来避免全局扫描「⽼年代」对象，堆内存」的每⼀⼩块区域形成「卡⻚」，卡表实际上就是卡⻚的集合。当判断⼀个卡⻚中有存在对象的跨代引⽤时，将这个⻚标记为脏⻚，那知道了「卡表」之后，就很好办了。每次Minor GC 的时候只需要去「卡表」找到「脏⻚」，找到后加⼊⾄GC Root，⽽不⽤去遍历整个「⽼年代」的对象了。\"]},\"248\":{\"h\":\"HotSpot的算法细节\"},\"249\":{\"h\":\"记忆集与卡表\",\"t\":[\"​ 为解决对象跨代引用的问题，垃圾收集器在新生代中建立了记忆集数据结构，用以避免把整个老年代加进GC Roots扫描范围。除了Old和Young之间，所有涉及部分区域收集行为的垃圾收集器，如G1、ZGC、Shenandoah，都会面临相同的问题。\",\"​ RSet的价值在于使得垃圾回收不需要扫描整个堆，能够快速定位到真正引用它的堆对象地址。\",\"RSet（记忆集）\",\"记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。\",\"若用非收集区域所有含跨代引用的对象数组来实现RSet的话，空间占用和维护成本都很高。而在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了。那设计者在实现记忆集的时候，便可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本，下面列举了一些可供选择的记录精度：\",\"字长精度：每个记录精确到一个机器字长，这个精度决定了机器访问物理内存地址的指针长度，该字含跨代指针。\",\"对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。\",\"卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。“卡精度”所指的是用一种称为“卡表”的方式去实现记忆集，这也是目前最常用的一种记忆集实现形式。\",\"卡表（Card Table）\",\"卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。\",\"卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这样做的。字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页” 。一般来说，卡页大小都是以2的N次幂的字节数。\",\"一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏，没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。\"]},\"250\":{\"h\":\"写屏障\",\"t\":[\"在Hotspot虚拟机中通过写屏障（Write Barrier）技术维护卡表状态。\",\"写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。 在赋值前的部分的写屏障叫作写前屏障，在赋值后的则叫作写后屏障。HotSpot虚拟机的许多收集器中都有使用到写屏障，但直至G1收集器出现之前，其他收集器都只用到了写后屏障。\",\"应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。\"]},\"251\":{\"h\":\"并发的可达性分析（增量更新、SATB）\",\"t\":[\"可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能进行分析。如果用户线程与收集器并发工作会产生一个严重问题：把原本存活的对象错误标记为已消亡，这会导致程序的错误。\",\"为了解决并发扫描时的对象消失问题，有两种解决方案：增量更新、原始快照。\",\"增量更新：当插入新的引用关系时，将这个引用记录下来，等并发扫描结束后，再将这个记录过引用关系的对象为根，再次扫描一次。\",\"原始快照：当要删除引用关系时，将这个要删除的引用记录下来，等并发扫描结束后，再将这个记录过引用关系的对象为根。也可以理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。\",\"CMS是基于增量更新来做并发标记，G1、Shenandoah采用原始快照的方式。\",\"相比起增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。\"]},\"252\":{\"h\":\"经典垃圾收集器\",\"t\":[\"JDK9开始：两根红线的搭配remove了。\",\"JDK14开始：绿线被deprecated了。\",\"JDK14开始：CMSremove了。\",\"JDK8默认：Parallel Scavenge + Parallel Old。\",\"JDK9开始默认：G1。\"]},\"253\":{\"h\":\"查看默认的垃圾回收器\",\"t\":[\"​ -XX:+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾回收器）。\",\"​ 使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID。\",\"手动选择垃圾回收器：\",\"​ 例：-XX:+UseParNewGC\"]},\"254\":{\"h\":\"Serial收集器\",\"t\":[\"单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。\",\"虚拟机的设计者们当然知道 Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。\",\"优点：简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境， 它是所有收集器里额外内存消耗最小的；对于单核处理器环境中，Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。\"]},\"255\":{\"h\":\"ParNew收集器\",\"t\":[\"ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。\",\"它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器配合工作。\"]},\"256\":{\"h\":\"Serial Old收集器\",\"t\":[\"Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。（原理与Serial相同）\",\"这个收集器的主要意义是供客户端模式下的HotSpot虚拟机使用。\",\"在服务端模式下， 它有两种用途： \",\"在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用 。\",\"作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。\"]},\"257\":{\"h\":\"Parallel Scavenge 收集器（JDK8）\",\"t\":[\"特点：与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。\",\"Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量：\",\"控制最大垃圾收集停顿时间：-XX： MaxGCPauseMillis\",\"直接设置吞吐量大小：-XX： GCTimeRatio\",\"这是JDK1.8的默认收集器。\"]},\"258\":{\"h\":\"Parallel Old收集器（JDK8）\",\"t\":[\"是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。\",\"在注重吞吐量或者处理器资源较为稀缺的场合， 都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。\"]},\"259\":{\"h\":\"CMS收集器\",\"t\":[\"CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。\",\"目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上， 这类应用通常都会较为关注服务的响应速度， 希望系统停顿时间尽可能短， 以给用户带来良好的交互体验。 CMS收集器就非常符合这类应用的需求。\",\"目前已不推荐使用。\",\"基于标记-清除，整个过程分为：\",\"初始标记：只是标记GC Roots能直接关联到的对象，速度很快。\",\"并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。\",\"重新标记：为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间比初始标记略长。\",\"并发清除：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。\",\"优缺点：\",\"优点：并发收集、 低停顿。\",\"缺点： \",\"对CPU资源敏感：默认启动的回收线程数是（处理器核心数量+3）/4，处理器小于4核时，负载较大。\",\"无法处理浮动垃圾：有可能出现“Con-current ModeFailure”失败进而导致另一次完全“Stop The World”的Full GC的产生。\",\"收集结束时会有大量空间碎片产生。\"]},\"260\":{\"h\":\"G1收集器（JDK9）\",\"t\":[\"G1开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量。\",\"G1收集器是一个并行回收器，它把堆内存分割为很多不相关的region（物理上不连续）。使用不同的region来表示Eden、Survivor0/1、Old等。Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过1.5region的对象即可判定为大对象。\",\"G1 GC将region作为单次回收的最小单元，有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的region。（可预测停顿时间模型的基础）\",\"优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。\",\"HotSpot的垃圾收集器，除了G1，其他均使用内置的JVM线程执行GC的多线程操作，而G1可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序帮助加速垃圾回收过程。\",\"G1跨Region引用对象主要靠记忆集解决。（下面再详细写）\"]},\"261\":{\"h\":\"应用场景\",\"t\":[\"面向服务端应用，主要针对配备多核CPU及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。\",\"最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案。\",\"在下列情况下，G1可能比CMS好： \",\"超过50%的Java堆被活动数据占用。\",\"对象分配频率或年代提升频率变化很大。\",\"GC停顿时间过长（>0.5~1s）\",\"优势\",\"并行与并发： \",\"并行性：G1能充分利用 CPU多核环境下的硬件优势，使用多个GC线程同时工作，此时用户线程STW。\",\"并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般不会在整个回收阶段发生STW的情况。\",\"分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。\",\"空间整合： \",\"CMS：标记-清除，若干次之后进行一次碎片整理。\",\"G1：从整体可以看做标记-整理；从局部上来看是基于标记-复制算法实现的（Region之间是复制算法）。当Java堆非常大时，G1的优势更加明显。\",\"可预测的停顿时间模型：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。相比CMS GC，G1未必能做到CMS在最好情况下的停顿时间，但是最差的情况要好很多。\"]},\"262\":{\"h\":\"相对CMS的缺点\",\"t\":[\"相较于CMS，G1不具备全方位的优势。如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS要高。\",\"就内存占用来说，虽然G1和CMS都使用卡表来处理跨代指针，但G1的卡表实现更为复杂，而且堆中每个Region都必须有一份卡表，这导致G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间。\",\"从执行负载的角度，G1除了使用写后屏障来进行同样的（由于G1的卡表结构复杂，其实是更烦琐的）卡表维护操作外，为了实现STAB算法，还需要使用写前屏障来跟踪并发时的指针变化情况。由于G1对写屏障的复杂操作要比CMS消耗更多的运算资源，所以CMS的写屏障实现是直接的同步操作，而G1就不得不将其实现为类似于消息队列的结构，把写前屏障和写后屏障中要做的事情都放到队列里，然后再异步处理。\",\"从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存的应用上在发挥优势。平衡点大概在6-8GB之间。当然，随着HotSpot的开发者对G1的不断优化，也会让对比结果继续向G1倾斜。\",\"参数设置\",\"-XX:+UserG1GC：手动指定G1收集器。\",\"-XX:G1HeapRegionSize：设置每个region的大小，值是2的幂，1~32MB之间。默认是堆内存的1/2000。\",\"-XX:MaxGCPauseMillis：设置期望达到的最大GC停顿时间（JVM会尽力但不保证达到），默认200ms。\",\"-XX:ParallelGCThread：设置STW工作线程数的值，最多设置8。\",\"-XX:ConcGCThreads：设置并发标记的线程数。设置为ParallelGCThread的1/4左右。\",\"-XX:InitiatingHeapOccupancyPercent：设置触发并发GC周期的Java堆的占用率阈值。超过此值，触发GC，默认值45%。\"]},\"263\":{\"h\":\"G1调优\",\"t\":[\"G1的设计原则是简化JVM性能调优，通常只需要设置：\",\"确保开启G1。\",\"设置堆的最大内存。\",\"设置最大的停顿时间。设置的不要过于严苛，G1的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间，设置过低会直接影响吞吐量。\",\"G1提供了三种垃圾回收模式：Young GC、Mixed GC、Full GC，在不同的条件下被触发。\"]},\"264\":{\"h\":\"G1垃圾回收过程\",\"t\":[\"初始标记：标记GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。\",\"并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB（原始快照）记录下的在并发时有引用变动的对象。\",\"最终标记：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。\",\"筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。\",\"除了并发标记外， 其余阶段也是要完全暂停用户线程的\"]},\"265\":{\"h\":\"G1的记忆集\",\"t\":[\"G1存在跨Region引用的问题，使用记忆集来避免全堆作为GC Roots扫描。\",\"它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。\",\"G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。\",\"一方面这是一种“双向”的卡表结构，更复杂；同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。 根据经验，G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。\"]},\"266\":{\"h\":\"低延迟垃圾收集器\"},\"267\":{\"h\":\"Shenandoah\",\"t\":[\"Shenandoah是第一款不由Oracle开发的，收到了官方的排挤。\",\"Shenandoah像是G1的下一代继承者，也是使用基于Region的堆内存布局， 同样有着用于存放大对象的Humongous Region， 默认的回收策略也同样是优先处理回收价值最大的Region。\",\"但在管理堆内存方面，与G1至少有着三处不同：\",\"回收阶段可以与用户线程并发。\",\"默认不使用分代收集。\",\"摒弃了Rset，改为使用连接矩阵来记录跨Region的引用关系。\",\"Shenandoah使用转发指针和读屏障来实现并发整理。\"]},\"268\":{\"h\":\"ZGC\",\"t\":[\"ZGC和Shenandoah的目标是高度相似的， 都希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。 ZGC几乎在所有地方并发执行，除了初始标记是STW，所以停顿时间几乎就耗费在初始标记上，这部分的实际时间很少。\",\"ZGC也采用基于Region的堆内存布局，但其Region具有动态性——动态创建和销毁， 以及动态的区域容量大小。（暂时不设分代）\",\"使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法。\",\"工作过程可分为4个阶段：并发标记——并发预备重分配——并发重分配——并发重映射。\",\"未来将在服务端、大内存、低延迟应用的首选垃圾收集器。\"]},\"269\":{\"h\":\"GC的日志分析\"},\"270\":{\"h\":\"内存分配与垃圾回收参数列表\",\"t\":[\"-XX:+PrintGC：输出GC日志，类似：-verbose:gc\",\"-XX:+PrintGCDetials：输出GC详细日志\",\"-XX:+PrintGCTimeStamps：输出GC的时间戳（以基准时间的形式）\",\"-XX:+PrintGCDataStamps：输出GC的时间戳（以日期的形式）\",\"-XX:+PrintHeapAtGC：在进行GC的前后打印出堆的信息\",\"-Xloggc:./logs/gc.log：日志文件的输出路径\"]},\"271\":{\"h\":\"日志分析工具\",\"t\":[\"常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等。\"]},\"272\":{\"h\":\"五、其他\"},\"273\":{\"h\":\"方法调用\",\"t\":[\"​ 方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法）。\"]},\"274\":{\"h\":\"解析\",\"t\":[\"​ 所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。这种解析能够成立的前提：编译器可知，运行期不可变。\",\"​ 这类方法的调用被称为“解析”，主要有静态方法和私有方法两大类。前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析。\",\"​ 调用不同类型的方法，字节码指令集设计了不同的指令，JVM支持以下5条：\",\"invokestatic：用于调用静态方法。\",\"invokesprecial：用于调用实例构造器<init>()方法、私有方法、父类中的方法。\",\"invokevirtual：用于调用所有的虚方法。\",\"invokeinterface：用于调用接口方法，会在运行时再确定一个实现该接口的对象。\",\"invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4条调用指令，分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。\"]},\"275\":{\"h\":\"虚方法\",\"t\":[\"​ 只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，Java语言里符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法4种，再加上被final修饰的方法（尽管它使用invokevirtual指令调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“非虚方法” ，与之相反，其他方法就被称为“虚方法”。\",\"​ 在动态分派里面有个注意点（动态分派的那个例子里有体现）：在父类中添加虚函数，父类中调用这个虚函数，子类继承父类后，子类实现的虚函数就会在父类调用的时候自动响应。\"]},\"276\":{\"h\":\"分派\"},\"277\":{\"h\":\"1、静态分派\",\"t\":[\"所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。\",\"典型应用：方法重载。\",\"发生在编译阶段，即确定静态分派的动作实际上不是由JVM来执行的，因此也有些资料将其归为“解析”。\",\"/** * 输出结果： * hello,guy! * hello,guy! */ public class StaticDispatch{ static class Man extends Human{} static class Woman extends Human{} public void sayHello(Human guy){ System.out.println(\\\"hello,guy!\\\"); } public void sayHello(Man guy){ System.out.println(\\\"hello,man!\\\"); } public void sayHello(Woman guy){ System.out.println(\\\"hello,woman!\\\"); } public static void main(String[] args){ Human man = new Man(); //“Human”称为变量的“静态类型”，或者叫“外观类型”。 Human woman = new Woman(); //后面的“Man”、“Woman”则称为变量的“实际类型”或“运行时类型” StaticDispatch sr = new StaticDispatch(); sr.sayHello(man); sr.sayHello(woman); } } \",\"​ 静态类型和实际类型在程序中都可能会发生变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。\",\"​ JVM（准确来说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。由于静态类型在编译期可知，所以在编译阶段Javac编译器就根据参数的静态类型决定了会使用哪个重载版本，因此选择了sayHello(Human)作为调用目标，并把这个方法的符号引用写到main()方法里的两条invokevirtual指令的参数中。\"]},\"278\":{\"h\":\"2、动态分派\",\"t\":[\"在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。\",\"动态分派与重写有关，其根源在于虚方法调用指令invokevirtual的执行逻辑 。\",\"只对方法有效，对字段无效。（深入理解JVM，P421例子；尚硅谷JVM视频，P209）\",\"invokevirtual指令的运行时解析过程大致分为以下几步：\",\"找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。（方法重写的本质）\",\"如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常。\",\"否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。\",\"如果始终没有找到合适的方法， 则抛出java.lang.AbstractMethodError异常。\"]},\"279\":{\"h\":\"类文件概述\"},\"280\":{\"h\":\"字节码文件、字节码指令\",\"t\":[\"源代码经过编译器编译之后便会生成一个字节码文件，Class文件是一组以8个字节为基础单位的二进制流，内容是JVM的指令。\",\"字节码指令：由一个字节长度的、代表着某种特定操作含义的操作码以及跟随其后的零至多个代表此操作所需参数的操作数所构成。Class文件中许多指令不包含操作数，只有一个操作码。\"]},\"281\":{\"h\":\"如何查看字节码文件\",\"t\":[\"通过Binary Viewer等阅读器一个一个二进制的看。\",\"使用-javap：jdk自带的反解析工具。\",\"使用IDEA插件：jclasslib或jclasslib bytecode viewer客户端工具（可视化更好）。\"]},\"282\":{\"h\":\"前端编译器\",\"t\":[\"主要有javac与ECJ：\",\"Java源代码编译的结果是字节码，那么肯定有一种编译器能够将Java源码编译为字节码，这就是前端编译器。\",\"javac编译器：配置在path环境中的，是一种能够将Java源码编译成字节码的全量式编译的前端编译器。不过Hotspot并没有强制要求使用javac来编译。\",\"ECJ（Eclipse Compiler for Java）：内置在Eclipse中，开源，是一种增量式编译器（每次使用Ctrl+S时，把为编译部分的源码逐行编译，所以效率比javac高）。Tomcat中使用ECJ编译器来编译jsp文件。\"]},\"283\":{\"h\":\"JVM是怎么运行Class文件的？\",\"t\":[\"通过解释器解释执行，逐行将字节码翻译成机器码并执行。效率较差。\",\"即时编译JIT，将一个方法中包含的所有字节码编译成机器码后再执行（热点代码），编译后的机器码会被缓存下来。 \",\"被多次调用的方法。\",\"被多次执行的循环体。\",\"JIT 的编译器 \",\"C1编译器：是一个简单快速的编译器，主要的关注点在于局部性的优化，适用于执行时间较短或对启动性能有要求的程序，例如，GUI应用对界面启动速度就有一定要求，C1也被称为Client Compiler。\",\"C2编译器：是为长期运行的服务器端应用程序做性能调优的编译器，适用于执行时间较长或对峰值性能有要求的程序，C2也被称为Server Compiler。\",\"HotSpot默认采用混合模式，综合了解释执行和即时编译两者的优点。\"]},\"284\":{\"h\":\"Class文件结构\",\"t\":[\"注意：任何一个Class文件都对应着唯一的一个类或接口的定义信息，但是反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。\",\"Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。\",\"Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。\",\"无符号数：属于基本数据类型，以u1、u2、u4、u8来分别代表1/2/4/8个字节的无符号数。可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。\",\"表：由多个无符号数或者其他表作为数据项构成的复合数据类型，用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表。\",\"无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式。\"]},\"285\":{\"h\":\"魔数与Class文件的版本\",\"t\":[\"每个Class文件的头4个字节被称为魔数，唯一作用：确定这个文件是否为一个能被虚拟机接受的Class文件。\",\"紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号，第7和第8个字节是主版本号（jdk每个大版本，主版本号+1）。高版本的JDK能兼容低版本，反之不行。\"]},\"286\":{\"h\":\"常量池\",\"t\":[\"紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一。另外，它还是在Class文件中第一个出现的表类型数据项目。\",\"由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的常量池容量计数值，计数从1开始（只有它从1开始）。\",\"将第0项常量空出来目的在于：如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。\",\"常量池中主要存放两大类常量：字面量和符号引用。\",\"字面量与Java语言层面的常量含义类似，包括文本字符串、被声明为final的常量值等。\",\"符号引用则属于编译原理方面的概念，主要包括下面几类常量：\",\"被模块导出或者开放的包\",\"类和接口的全限定名\",\"字段的名称和描述符\",\"方法的名称和描述符\",\"方法句柄和方法类型\",\"动态调用点和动态常量\",\"常量池中每一项常量都是一个表，有17种不同类型的常量。（书P304）\"]},\"287\":{\"h\":\"访问标志\",\"t\":[\"在常量池结束之后，紧接着的2个字节代表访问标志。\",\"作用：识别一些类或者接口层次的访问信息，包括： 这个Class是类还是接口、是否定义为public类型、 是否定义为abstract类型、如果是类的话、是否被声明为final等等。\"]},\"288\":{\"h\":\"类索引、 父类索引与接口索引集合\",\"t\":[\"类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。\",\"类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。\",\"接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是 extends关键字）后的接口顺序从左到右排列在接口索引集合中。\",\"查找过程：\",\"类索引和父类索引各自指向一个类型CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。\",\"接口索引入口的第一项u2类型的数据为接口计数器，表示索引表的容量。若该类没有实现任何接口，则计数器值为0，后面接口的索引表不再占用任何字节。\"]},\"289\":{\"h\":\"字段表集合\",\"t\":[\"用于描述接口或者类中声明的变量。描述结构：依次包括访问标志（access_flag）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。\",\"字段表集合中不会列出从父类或者父接口中继承而来的字段，但有可能出现原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。\",\"在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于Class文件格式来讲，只要两个字段的描述符不是完全相同，那字段重名就是合法的。\"]},\"290\":{\"h\":\"方法表集合\",\"t\":[\"Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志（access_flag）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。\",\"方法里面的代码哪里去了？：方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目。\",\"与字段表集合相对应地，如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。 但同样地，有可能会出现由编译器自动添加的方法，最常见的便是类构造器<clinit>()方法和实例构造器<init>()方法。\",\"在Java语言中，重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。\"]},\"291\":{\"h\":\"属性表集合\",\"t\":[\"Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。与Class文件中其他的数据项目要求严格的顺序、长度和内容不同， 属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序。\",\"对于每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。\"]},\"292\":{\"h\":\"Code属性\",\"t\":[\"Java程序方法体里面的代码经过Javac编译器处理之后， 最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性。\",\"Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code， 方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件里，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。\",\"Exceptions属性\",\"作用：列举出方法中可能抛出的受查异常，也就是方法描述时在throws关键字后面列举的异常。\",\"LineNumberTable属性\",\"作用：描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。\",\"**LocalVariableTable及LocalVariableTypeTable属性 **\",\"作用：用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系。\",\"**SourceFile及SourceDebugExtension属性 **\",\"作用：SourceFile属性用于记录生成这个Class文件的源码文件名称。\",\"**ConstantValue属性 **\",\"作用：通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性。\",\"**MethodParameters属性 **\",\"在JDK8时新加入到Class文件格式中的，它是一个用在方法表中的变长属性。作用：记录方法的各个形参名称和信息。\",\"**模块化相关属性 **\",\"JDK 9的一个重量级功能是Java的模块化功能，因为模块描述文件（module-info.java）最终是要编译成一个独立的Class文件来存储的，所以，Class文件格式也扩展了Module、ModulePackages和ModuleMainClass三个属性用于支持Java模块化相关功能。\"]},\"293\":{\"h\":\"内存模型JMM\",\"t\":[\"《Java虚拟机规范》中曾试图定义一种“Java内存模型” 来屏蔽各种硬件和操作系统的内存访问差异，让 Java 程序在各种平台下都能达到一致的内存访问效果。主要目的：定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。\"]},\"294\":{\"h\":\"主内存与工作内存\",\"t\":[\"所有的变量都存储在主内存（Main Memory）中。\",\"每个线程都有一个私有的工作内存，存储了该线程以读/写共享变量的主内存副本。\",\"线程对变量的所有操作（读取、 赋值等） 都必须在工作内存中进行，而不能直接读写主内存中的数据。\",\"不同的线程之间无法直接访问对方本地内存中的变量，线程间变量值的传递均需要通过主内存来完成 。\",\"JMM定义了 8 个操作来完成主内存和工作内存的交互操作：\",\"lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。\",\"unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。\",\"read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。\",\"load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。\",\"use（使用） ： 作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。\",\"assign（赋值）： 作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。\",\"store（存储）： 作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。\",\"write（写入）： 作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。\",\"注意：上述的每一个操作都是原子的、不可再分的。\"]},\"295\":{\"h\":\"内存模型三大特性\",\"t\":[\"原子性\",\"Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性。\",\"如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作。这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。\",\"可见性\",\"可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的， 无论是普通变量还是volatile变量都是如此。\",\"主要有3个关键字能够实现可见性：\",\"volatile：volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。\",\"synchronized：对一个变量执行 unlock 操作之前，必须把变量值同步回主内存（执行store、write操作）。\",\"final：被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（this逃逸很危险，其它线程有可能通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。\",\"volatile 并不能保证操作的原子性。\",\"有序性\",\"在本线程内观察，所有操作都是有序的（线程内似表现为串行的语义）。在一个线程观察另一个线程，所有操作都是无序的（“指令重排序”现象和“工作内存与主内存同步延迟”现象）。\",\"在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。\",\"Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的， 这个规则决定了持有同一个锁的两个同步块只能串行地进入。\",\"可以看到，synchronized可以同时满足JMM的三大特性，间接造就了它被程序员滥用的局面。不过越“万能”，通常会伴随更大的性能影响。\"]},\"296\":{\"h\":\"volatile关键字\",\"t\":[\"当一个变量被定义成volatile后，将具备两项特性：\",\"保证此变量对所有线程时可见的，虽然volatile变量在各个线程的工作内存中是不存在一致性问题的，但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的。\",\"禁止指令重排序优化，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。\",\"如果对声明了 volatile 的变量执行写操作，JVM 会向处理器发送一条 Lock 前缀指令，该指令在多核处理器下会引发两件事情：\",\"将当前处理器缓存行的数据写回到系统内存。\",\"这个写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。\",\"下面我们来详细说明一下 Lock 前缀指令引发的两件事情。\",\"Lock 前缀指令会引起处理器缓存回写到内存中。Lock 前缀指令在执行指令期间，会声言处理器的 LOCK# 信号，在多处理器环境中，LOCK# 信号会确保在声言该信号期间，处理器可以独占任何共享内存。比较老的处理器通过 LOCK# 信号锁总线来达到独占共享内存的目的；但现在的处理器不会声言 LOCK# 信号，而是会锁定这块内存区域的缓存并回写到内存，同时使用缓存一致性机制来确保修改的原子性，这一操作被称为缓存锁定，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域。\",\"一个处理器的缓存回写到内存会导致其他处理器的缓存无效。处理器通过 MESI（修改、独占、共享、无效）缓存一致性协议去维护内部缓存和其他处理器缓存的一致性。\"]},\"297\":{\"h\":\"OOM 与 StackOverFlow 场景\",\"t\":[\"OOM： \",\"java heap size 超过大小。堆内存溢出(不停创建对象，且保证GC roots与对象之间有路径避免垃圾回收，当对象们所占内存超过最大堆的大小限制就能出现这个异常)\",\"GC overhead limit exceeded：超过98%的时间用来做GC并且回收 了不到2%的堆内存。用来避免内存过小造成应用不能正常工作。\",\"直接内存溢出Direct buffer memory：常见的比如在 NIO 中可以使用 native 函数直接分配堆外内存就容易导致 OOM 的问题。\",\"如果虚拟机栈可以动态扩展，并且扩展时无法申请到足够的内存，抛出 OutOfMemoryError 异常\",\"SOF： \",\"递归调用，超过栈的大小。\"]},\"298\":{\"h\":\"排查OOM\",\"t\":[\"​ 一般手段是：先通过内存映像工具对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。\",\"​ 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。这样就能够找到泄漏的对象是通过怎么样的路径与GC Roots相关联的导致垃圾回收机制无法将其回收。掌握了泄漏对象的类信息和GC Roots引用链的信息，就可以比较准确地定位泄漏代码的位置。\",\"​ 如果不存在泄漏，那么就是内存中的对象确实必须存活着，那么此时就需要通过虚拟机的堆参数（ -Xmx和-Xms）来适当调大参数；从代码上检查是否存在某些对象存活时间过长、持有时间过长的情况，尝试减少运行时内存的消耗。\"]},\"299\":{\"h\":\"ThreadLocal\",\"t\":[\"概述\",\"通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK中提供的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。\",\"如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。\",\"原理\",\"最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。\",\"每个Thread中都具备一个ThreadLocalMap（ThreadLocalMap是ThreadLocal的静态内部类，只是挂在Thread下面而已，而ThreadLocalMap可以存储以ThreadLocal为key的键值对。比如我们在同一个线程中声明了两个 ThreadLocal 对象的话，会使用 Thread内部都是使用仅有那个ThreadLocalMap 存放数据的，ThreadLocalMap的 key 就是 ThreadLocal对象，value 就是 ThreadLocal 对象调用set方法设置的值。ThreadLocal 是 map结构是为了让每个线程可以关联多个 ThreadLocal变量。这也就解释了ThreadLocal声明的变量为什么在每一个线程都有自己的专属本地变量。\"]},\"300\":{\"h\":\"ThreadLocal导致的OOM\",\"t\":[\"**ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。**所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会 key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法。\"]},\"301\":{\"h\":\"remove 方法\",\"t\":[\"remove方法中调用了 clear 和 expungeStaleEntry 方法。\",\"clear 方法作用是清除对象的引用\",\"expungeStaleEntry 是核心清理函数，从 slateSlot 开始遍历，清理无效的 entry 并且将此 entry 置为 null，直到扫到空 entry，另外，在遍历过程中还会对非空的 entry 做 rehash。 \",\"删除 staleSlot 处的 value 和 entry。\",\"对从 staleSlot 位置到下一个为空的 slot 之间碰撞的 entry 进行 rehash。\",\"删除从 staleSlot 位置到下一个为空的 slot 之间所有无效的 entry。\"]},\"302\":{\"h\":\"内存泄漏\",\"t\":[\"概述：严格来说，只要对象不会再被程序使用，但是GC又不能回收的情况，叫做内存泄漏。但是在广义上讲，因为一些原因导致对象的生命周期变得很长甚至导致OOM，也叫内存泄漏。\"]},\"303\":{\"h\":\"泄漏的分类\",\"t\":[\"经常发生：发生泄漏的代码会被多次执行，每次执行，泄漏一块内存。\",\"偶然发生：在某些特定情况下才会发生。\",\"一次性：发生内存泄漏的方法只会执行一次。\",\"隐式泄漏：一直占着内存不释放，直到执行结束；严格的说这个不算内存泄漏，因为最终释放掉了，但是如果执行时间特别长，也可能会导致内存耗尽。\"]},\"304\":{\"h\":\"泄漏的8种情况\",\"t\":[\"1、静态集合类\",\"静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为还被持有它的引用而不能被回收。\",\"public class MemoryLeak{ Static List list = new ArrayList(); public void oomTest(){ Object obj = new Object(); //局部变量，但是一直不能被回收 list.add(obj); } } \",\"2、单例模式\",\"与静态集合类类似，因为单例的静态性，其生命周期和JVM的生命周期相同，所以如果单例对象持有外部对象的引用，那么这个外部对象也不会被回收，那么就会OOM。\",\"3、内部类持有外部类\",\"如果一个外部类的实例对象的方法返回了一个内部类的实例对象。如果这个内部类对象被长期引用了，即使那个外部类不再被使用，也不会被回收，造成OOM。\",\"4、各种连接，如数据库连接、网络连接和IO连接等\",\"比如数据库，不再使用时，需要调用close方法来释放与数据库的连接。如果不对Connection、Statement和ResultSet进行显式关闭，会造成大量对象无法回收，从而引起内存泄漏。\",\"5、变量不合理的作用域\",\"一般而言，一个变量定义的作用域大于其适用范围，就很有可能造成内存泄漏。另一方面，如果没有即使地把对象设置成null，有很可能导致内存泄漏的发生。\",\"//伪代码，一般来说，msg使用完之后就没用了，但是msg的生命周期与对象的生命周期相同，此时msg还不能被回收，所以造成内存泄漏；另一种解决方法，使用完设置null public class UsingRandom{ private String msg; public void receiveMsg(){ //一般情况下msg是要定义在这个里面的 readFromNet();//从网络接收数据保存到msg中 saveDB();//把msg保存到数据库中 } } \",\"6、改变哈希值\",\"当一个对象被存储进HashSet之后，就不能修改这个对象中那些参与计算哈希值的字段了。否则，对象修改后的哈希值与最初的不同，这样就会找不到对象，也会导致无法单独删除该对象，从而造成内存泄漏。\",\"7、缓存泄漏\",\"内存泄漏的另一个常见来源是缓存，一旦把对象引用放入到缓存中，就很容易遗忘。对于这个问题，可以使用WeakHashMap代表缓存，该Map的特点是当除了自身对Key的引用外，此key没有其他引用，那么此Map就会丢弃该值。\",\"8、监听器与回调\",\"内存泄漏的第三个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显式取消，那么就会聚集。需要确保回调立即被当做垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存称为WeakHashMap中的键。\"]},\"305\":{\"h\":\"六、性能监控与调优\"},\"306\":{\"h\":\"性能优化的步骤\"},\"307\":{\"h\":\"1、性能监控\",\"t\":[\"GC频繁\",\"cpu load过高\",\"OOM\",\"内存泄漏\",\"死锁\",\"程序响应时间较长\"]},\"308\":{\"h\":\"2、性能分析\",\"t\":[\"打印GC日志，通过GCViewer等工具来分析日志信息。\",\"灵活运用命令行工具，jstack、jmap、jinfo等。\",\"dump出堆文件，使用内存分析工具来实时查看JVM状态。\",\"使用阿里的Arthas，或jconsole，jVisualVM来实时查看JVM状态。\",\"jstack查看堆栈信息。\"]},\"309\":{\"h\":\"3、性能调优\",\"t\":[\"适当增加内存，根据业务背景选择垃圾回收器\",\"优化代码，控制内存使用\",\"增加机器，分散节点压力\",\"合理设置线程池线程数量\",\"使用中间件提高程序效率，比如缓存、消息队列等\",\"其他的优化方法\",\"目的：\",\"​ 通过更改参数、源代码、属性配置等，减少GC、Full GC的次数，从而改善应用的响应速度和吞吐量。\"]},\"310\":{\"h\":\"性能评测的指标\",\"t\":[\"停顿时间（响应时间）\",\"吞吐量（对单位时间内完成的工作量的量度）：GC中的吞吐量=1-1/(1+n)，-XX:GCTimeRatio = n\",\"并发量\",\"内存占用\",\"相互间的关系\"]},\"311\":{\"h\":\"工具\"},\"312\":{\"h\":\"命令行篇\",\"t\":[\"-jps：查看正在运行的Java进程；语法：jps [-q] [-mlvV] [<hostid>] -q(只显示本地虚拟机id)、-l（输出全类名）、-m（输出虚拟机进程启动时传递给 main的参数）、-v（列出虚拟机进程启动时的JVM参数）\",\"-jstat：查看JVM统计信息，语法：jstat -<option> [-t] [-h<lines>] <vmid> [<interval>] [<count>]\",\"-jinfo：实时查看和修改JVM配置参数\",\"-jmap：导出内存映像文件&内存使用情况\",\"-jhat：打印JVM中线程快照\",\"-jcmd：多功能命令行\",\"-jstatd：远程主机信息收集\"]},\"313\":{\"h\":\"GUI篇\",\"t\":[\"JDK自带的工具\",\"jconsole：查看Java应用程序的运行状况、监控堆信息、元空间使用情况、类加载器情况等。位置：jdk\\\\bin\\\\jconsole.exe\",\"Visual VM：用于查看JVM上运行的基于Java的应用程序的详细信息。位置：jdk\\\\bin\\\\jvisualvm.exe\",\"JMC：能够以极低的性能开销收集JVM的性能数据。\",\"第三方\",\"MAT：基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，可以帮我们查找内存泄漏和减少内存消耗。\",\"Arthas：阿里开源的Java诊断工具。可以在线排查问题，无需重启：动态跟踪代码。\",\"Btrace：Java运行时追踪工具，可以在不停机的情况下，跟踪指定的方法调用、构造函数调用和系统内存等信息。\",\"IDEA中也有一个插件，JProfiler（收费，很强大）。\"]},\"314\":{\"h\":\"JVM选项参数\"},\"315\":{\"h\":\"-X\",\"t\":[\"非标准化参数，还算稳定，不过后续可能会删改。\",\"特别地： \",\"-Xms<size>=-XX:InitialHeapSize（设置初始Java堆大小，默认为物理内存的1/64）\",\"-Xmx<size>=-XX:MaxHeapSize（设置对打Java堆大小，默认为物理内存的1/4）\",\"-Xss<size>=-XX:ThreadStackSize（设置Java线程堆栈大小）\"]},\"316\":{\"h\":\"-XX\",\"t\":[\"非标准化参数，属于实验性的，不稳定，用于开发和调试JVM。\",\"分类：\",\"Boolean：-XX:+<opyion>表示启动option属性；+XX:-<option>表示禁用option属性。\",\"key-value：数值型-XX:<option>=<number>；非数值型-XX:<name>=<string>\",\"特别地-XX:+PrintFlagsFinal：\",\"输出所有参数的名称和默认值。\",\"默认不包括Diagnostic和Experimental的参数。\",\"可以配合-XX:+UnlockDiagnosticVMOptions和-XX:+UnlockExperimentalVMOptions使用。\"]},\"317\":{\"h\":\"添加JVM参数\",\"t\":[\"运行jar包\",\"java -Xms50m -Xmx50m -XX:+PrintGCDetails -jar demo.jar\",\"通过Tomcat运行war包\",\"linux系统下可以在tomcat/bin/catalina.sh中添加类似如下配置：JAVA_OPTS=-Xms512M -Xmx1024M\",\"Windows系统下在catalina.bat中添加类似如下配置：set \\\"JAVA_OPTS=-Xms512M -Xmx1024M\\\"\",\"程序运行过程中\",\"使用jinfo -flag<name>=<value><pid>设置非Boolean类型参数\",\"使用jinfo -flag[+|-]<name><pid>设置Boolean类型参数\"]},\"318\":{\"h\":\"常用参数\"},\"319\":{\"h\":\"打印设置的XX选项及值\",\"t\":[\"-XX:+PrintCommandLineFlags：可以在程序运行前打印出用户手动设置或者JVM自动设置的XX选项。\",\"-XX:+PrintFlagsInitial：表示打印出所有XX选项的默认值。\",\"-XX:+PrintFlagsFinal：打印出所有XX选项运行时的值\",\"-XX:+PrintVMOptions：打印JVM参数\"]},\"320\":{\"h\":\"堆、栈、方法区等内存大小的设置\"},\"321\":{\"h\":\"栈\",\"t\":[\"-Xss128k ：设置每个线程的栈大小为128k，等价于-XX:ThreadStackSize=128k\"]},\"322\":{\"h\":\"堆\",\"t\":[\"-Xmx<size>=-XX:MaxHeapSize（设置对打Java堆大小，默认为物理内存的1/4）\",\"-Xmn2g：设置年轻代大小为2G，推荐设置为整个堆大小的3/8\",\"-XX:NewSize=1024m：设置年轻代初始值为1024m\",\"-XX:MaxNewSize=1024m：设置年轻代最大值为1024m\",\"-XX:SurvivorRatio=8：设置Eden与一个Survivor区大小的比例\",\"-XX:+UseAdaptiveSizePolicy：自动选择各区大小比例\",\"-XX:NewRatio=4：设置老年代与年轻代的比值\",\"-XX:PretenureSizeThreadshold=1024：设置大于此阈值的对象直接分配在Old区，单位是字节。只对Serial、ParNew收集器有效\",\"-XX:MaxTenuringThreshold=15：进入Old区的年龄，默认为15\",\"-XX:+PrintTenuringDistribution：让JVM在每次MinorGC后打印出当前使用的Survivor中对象的年龄分布\",\"-XX:TargetSurvivorRatio：表示MinorGC结束后Survivor区域中占用空间的期望比例。\"]},\"323\":{\"h\":\"方法区\",\"t\":[\"-XX:MetaspaceSize：初始空间大小\",\"-XX:MaxMetaspaceSize：最大空间，默认没有限制\",\"-XX:+UseCompressedOops：压缩对象指针\",\"-XX:+UseCompressedClassPointers：压缩类指针\",\"-XX:CompressedClassSpaceSize：设置klass Metaspace的大小，默认为1G。\",\"直接内存：-XX:MaxDirectMemorySize：指定直接内存容量，默认与Java堆大小一样。\"]},\"324\":{\"h\":\"OOM相关的选项\",\"t\":[\"-XX:+HeapDumpOnOutOfMemoryError：表示在内存出现OOM的时候，把heap转存（Dump）到文件以便后续分析\",\"-XX:+HeapDumpBeforeFullGC：表示在出现FullGC之前，生成Heap转储文件\",\"-XX:HeapDumpPath=<path>：指定heap转存文件的存储路径\",\"-XX:OnOutOfMemoryError：指定一个可行性程序或者脚本的路径，当发生OOM的时候，去执行这个脚本\"]},\"325\":{\"h\":\"GC日志参数选项\",\"t\":[\"-verbose:gc：输出gc日志信息，默认输出到标准输出，等同于-XX:+PrintGC\",\"-XX:+PrintGCDetails：在发生GC时打印内存回收详细的日志，并在进程退出时输出当前内存各区域分配情况\",\"-XX:+PrintGCTimeStamps：输出GC发生的时间戳\",\"-XX:+PrintGCDataStamps：以日期格式输出GC发生的时间戳\",\"-XX:+PrintHeapAtGC：每一次GC前和GC后，都打印堆信息。\",\"-Xloggc:<file>：把GC日志写入到每一个文件中去，而不是打印到标准输出中。\"]},\"326\":{\"h\":\"其他\",\"t\":[\"-XX:+DisableExplicitGC：禁止HotSpot执行system.gc()，默认禁用\",\"-XX:+DoEscapeAnalysis：开启逃逸分析\",\"-XX:+UseTLAB：使用TLAB，默认打开\",\"-XX:+PrintTLAB：打印TLAB的使用情况\",\"-XX:TLABSize：设置TLAB大小\"]},\"327\":{\"h\":\"使用Java代码获取JVM参数\",\"t\":[\"通过使用Runtime和ManagementFactory。\",\"通过这些api可以监控我们的应用程序服务器的堆内存使用情况，设置一些阈值进行报警等处理。\"]},\"328\":{\"h\":\"GC日志剖析\"},\"329\":{\"h\":\"Minor GC\"},\"330\":{\"h\":\"Full GC\"},\"331\":{\"h\":\"GC时间\",\"t\":[\"user：进程执行用户态代码所使用的的时间，这是执行此进程所使用的实际CPU时间。\",\"sys：进程在内核态消耗的时间，即在内核执行系统调用或等待系统事件所使用的CPU时间。\",\"real：程序从开始到结束所用的时钟时间。\",\"由于多核的原因，一般的GC时间中，real time是小于sys+user time的。假如大于，则可能是IO负载非常重或者CPU不够用。\"]},\"332\":{\"h\":\"GC日志分析工具\",\"t\":[\"GCeasy\",\"GCViewer\",\"GCHisto、GCLogViewer、Hpjmeter、garbagecat等。\",\"想把GC日志保存到文件的话，使用-Xloggc:/path/to/gc.log\"]},\"333\":{\"h\":\"Java并发\"},\"334\":{\"h\":\"一、语言特性\"},\"335\":{\"h\":\"JDK、JRE、JVM\",\"t\":[\"JVM（Java Virtual Machine）：整个 Java 实现跨平台的最核心的部分，将 A.class 字节码文件解释成二进制 1010101010 这样的数据。\",\"JRE（ Java Runtime Environment）：Java 运行时环境，包含 JVM、Java 类库、java 命令等\",\"JDK（Java Development Kit）： Java 开发工具包，拥有 JRE 所拥有的一切，还有编译器（javac）和工具（javadoc 和 jdb）。\"]},\"336\":{\"h\":\"Java 和 C++ 区别\",\"t\":[\"​ 一次编译，到处(前提是装有 JVM)运行\",\"都是面向对象语言，都支持封装、继承、多态；\",\"Java 不提供指针来直接访问内存；\",\"Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不支持多继承，但接口可以多继承；\",\"Java 有自动内存管理机制，不需要程序员手动释放无用内存；\",\"C 语言中字符串或字符数组最后都会有一个额外的字符 ‘\\\\0’ 来表示结束，而在 java 语言中没有结束符这一概念。\"]},\"337\":{\"h\":\"Java 的平台无关性\",\"t\":[\"JVM：运行在虚拟机之上，屏蔽掉了硬件和操作系统的差异。\",\"JMM：JMM 的初衷就是来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。 JMM 规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝， 线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile 变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定， 所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。\",\" volatile保证可见性 不保证原子性 禁止指令重排（保证有序性） \"]},\"338\":{\"h\":\"什么是注解？什么是元注解？\",\"t\":[\"注解是一种标记，使类或接口附加额外信息，帮助编译器和 JVM 完成一些特定功能，例如 @Override 标识一个方法是重写方法。就是代码中的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相对应的处理。\",\"​ 开发中用到的：框架中@controller @param，java 原生的@overrided，@deprecated 等(原生的注解多用于标记和检查)。\",\"元注解是自定义注解的注解，例如：\",\"Retention：指定其所修饰的注解的保留策略\",\"@Document：该注解是一个标记注解，用于指示一个注解将被文档化\",\"@Target：用来限制注解的使用范围\",\"@Inherited：该注解使父类的注解能被其子类继承\",\"@Repeatable：该注解是 Java8 新增的注解，用于开发重复注解\"]},\"339\":{\"h\":\"Class 类、Class 对象\",\"t\":[\"​ 在程序运行期间，系统为所有对象维护一个运行时类型标识，这个信息会跟踪每个对象所属的类，虚拟机利用运行时类型信息选择要执行的正确方法，保存这些信息的类就是 Class，这是一个泛型类。\",\"获取 Class 对象：① 类名.class 。② 对象的 getClass方法。③ Class.forName(类的全限定名)。\"]},\"340\":{\"h\":\"== 和 equals 的区别\",\"t\":[\"==：如果比较的对象是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是对象的地址值是否相等。\",\"equals：判断两个对象是否相等（比的是内存中存放的内容是否相等 ）， 但它一般有两种使用情况：\",\"类没有重写 equals 方法，调用的是 Object 超类的 equals 方法，则通过 equals 比较该类的两个对象时，等价于通过 \\\"==\\\" 比较内存地址。\",\"类重写了 equals 方法来比较两个对象的内容是否相等。\"]},\"341\":{\"h\":\"两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗？\",\"t\":[\"​ 两个对象的 hashCode() 相同，equals() 不一定为 true。因为在哈希(散列)表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等，因为会发生散列冲突。\",\"​ 只有 hash 值相同，那说明该元素哈希冲突了，如果 hash 值和 equals()或者==都相同，那就说明元素还是同一个了。\"]},\"342\":{\"h\":\"为什么重写 equals() 就一定要重写 hashCode() 方法？\",\"t\":[\"​ 这个问题应该是有个前提，就是你需要用到 HashMap、HashSet 等 Java 集合，用不到哈希表的话，其实仅仅重写 equals() 方法也可以。而工作中的场景是常常用到 Java 集合，所以 Java 官方建议重写 equals() 就一定要重写 hashCode() 方法。\",\"​ 为了支持基于 hash 机制的 Java 集合类，如：Set、Map，在确定元素插入位置和判断元素是否相等时，都需要先根据 key.hashCode() 计算出 hash 值。当发生 hash 冲突时，才需要调用 equals 来比较 key 值是否相同。\",\"重写 hashcode 的原因是为了将“为我们需要认定为相同的两个对象返回相同的哈希值，这么做的原因是集合中比较两个对象时，先比对了他们的哈希值，以此来排除哈希值不同的两个对象一定不等，这样做对集合的效率是有利的。”\",\"(用 hashcode 跟 equals 方法配合，都重写好配合。)\"]},\"343\":{\"h\":\"深拷贝和浅拷贝？\",\"t\":[\"，对于对象中的基本数据类型，直接简单复制一份；对象中的引用数据类型，分两种情况：\",\"浅拷贝：引用传递。（默认），只是把指向对象实例的地址复制一份到引用上。\",\"深拷贝：创建一个新的对象，并复制其内容。\",\"实现方式：\",\"浅拷贝：类实现 Cloneable 接口，直接调用 Object 类中的 clone() 方法。\",\"深拷贝：类实现 Cloneable 接口，重写 Object 类中的 clone() 方法，依次克隆各个可变的引用类型。也可以序列化，但是效率不理想。\"]},\"344\":{\"h\":\"序列化与反序列化\",\"t\":[\"创建的字节流是与平台无关的，在一个平台上序列化的对象可以在不同的平台上反序列化。\",\"序列化是为了解决在对象流进行读写操作时所引发的问题。\",\"什么情况下需要序列化？\",\"把内存中的对象状态保存到一个文件中或者数据库中时候；\",\"想用套接字在网络上传递对象的时候；\",\"序列化的实现\",\"​ 将需要被序列化的类实现 Serializable 接口，该接口没有需要实现的方法，只是用于标注该对象是可被序列化的，然后使用一个输出流（如：FileOutputStream）来构造一个 ObjectOutputStream 对象，接着使用 ObjectOutputStream 对象的 writeObject(Object obj) 方法可以将参数为 obj 的对象写出，要恢复的话则使用输入流。\"]},\"345\":{\"h\":\"泛型、类型擦除\",\"t\":[\"在创建对象或调用方法的时候才明确下具体的类型，使用泛型的好处是使代码更加简洁(不在需要强制转换)，程序更加健壮(在编译期间没有警告，在运行期间就不会出现 ClassCastException 类型转换异常)。\",\"我们常用泛型机制来统一集合中存储的元素，这样集合中取出的元素是泛型指定的类型，不需要进行大量向下转型。强化类型安全，提高代码复用。\",\"泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。这样做的目的，是确保能和 Java 5 之前的版本开发二进制类库进行兼容。\",\"类型擦除\",\"​ 泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如< T >则会被转译成普通的 Object 类型，如果指定了上限如 < T extends String > 则类型参数就被替换成类型上限。\",\"​ 利用类型擦除的原理，用反射的手段就绕过了正常开发中编译器不允许的操作限制。\",\"List< ? extends T > 和 List < ? super T > 之间有什么区别 ?\",\"​ List< ? extends T > 可以接受任何继承自 T 的类型的 List，而List < ? super T >可以接受任何 T 的父类构成的 List。\"]},\"346\":{\"h\":\"final、finally、finalize 的区别\",\"t\":[\"final：是个关键字，代表最终。 \",\"修饰一个变量：变量必须初始化，且不能被重新赋值\",\"修饰一个引用：引用地址不能变，但是指向的对象可以改变\",\"修饰一个方法：无法被重写，但可以被继承\",\"修饰一个类：无法被继承\",\"finally：一般作用在 try...catch 代码块中，将一定要执行的代码放在 finally 代码块中，无论是否出现异常，该代码块都会被执行，一般用来存放一些关闭资源的操作。\",\"finalize：Object 类的一个方法，GC 回收对象前会先调用这个对象的 finalize( ) 方法，这个方法允许在子类中被重写，常用来进行一些资源释放工作，如：关闭文件或数据库连接等。\"]},\"347\":{\"h\":\"大端模式和小端模式\",\"t\":[\"大端模式：高数据位保存在内存的低地址位中，低数据位保存在内存的高地址位中\",\"小端模式：高数据位保存在内存的高地址位中，低数据位保存在内存的低地址位中\",\"C 语言中，默认是小端存储；默认是大端存储；在网络上传输数据普遍采用的都是大端模式\"]},\"348\":{\"h\":\"反射及其应用场景\",\"t\":[\"​ 每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。\",\"​ 也可以使用Class.forName(“com.mysql.jdbc.Driver”)这种方式来控制类的加载，该方法会返回一个 Class 对象。\",\"​ **反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。**Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：\",\"Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；\",\"Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；\",\"Constructor ：可以用 Constructor 创建新的对象。\",\"应用举例：工厂模式，使用反射机制，根据全限定类名获得某个类的 Class 实例。\",\"优缺点\",\"优点：\",\"运行期类型的判断，class.forName() 动态加载类，提高代码的灵活度；\",\"缺点：\",\"性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。\",\"安全限制：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，那么这就是个问题了。\",\"内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如：访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。\"]},\"349\":{\"h\":\"动态代理\",\"t\":[\"​ 当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新功能。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。\",\"动态代理的应用：Spring 的 AOP 、加事务、加权限、加日志。\",\"怎么实现动态代理\",\"​ 首先必须定义一个接口，还要有一个 InvocationHandler（将实现接口的类的对象传递给它）处理类。再有一个工具类 Proxy（习惯性将其称为代理类，因为调用它的 newInstance() 可以产生代理对象，其实它只是一个产生代理对象的工具类）。利用到 InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。\",\"​ 每一个动态代理类都必须要实现 InvocationHandler 这个接口，并且每个代理类的实例都关联到了一个 handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 InvocationHandler 这个接口的 invoke 方法来进行调用。我们来看看 InvocationHandler 这个接口的唯一一个方法 invoke 方法：\",\"Object invoke(Object proxy, Method method, Object[] args) throws Throwable \",\"proxy: 指代我们所代理的那个真实对象\",\"method: 指代的是我们所要调用真实对象的某个方法的 Method 对象\",\"args: 指代的是调用真实对象某个方法时接受的参数\",\"Proxy 类的作用是动态创建一个代理对象的类。它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法：\",\"public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler handler) throws IllegalArgumentException \",\"loader：一个 ClassLoader 对象，定义了由哪个 ClassLoader 对象来对生成的代理对象进行加载；\",\"interfaces：一个 Interface 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了；\",\"handler：一个 InvocationHandler 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 InvocationHandler 对象上。\",\"​ 通过 Proxy.newProxyInstance 创建的代理对象是在 Jvm 运行时动态生成的一个对象，它并不是我们的 InvocationHandler 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象。\"]},\"350\":{\"h\":\"Object 包含哪些方法？\",\"t\":[\"clone( )、equals(Object)、finalize( )、hashCode( )、wait( )、wait(long)、notify( )、notifyAll( )、toString( )、getClass( )\",\"1．clone 方法 保护方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出 CloneNotSupportedException 异常。\",\"2．getClass 方法 final 方法，获得运行时类型。\",\"3．toString 方法 该方法用得比较多，一般子类都有覆盖。\",\"4．finalize 方法 该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。\",\"5．equals 方法 该方法是非常重要的一个方法。一般 equals 和==是不一样的，但是在 Object 中两者是一样的。子类一般都要重写这个方法。\",\"6．hashCode 方法 该方法用于哈希查找，重写了 equals 方法一般都要重写 hashCode 方法。这个方法在一些具有哈希功能的 Collection 中用到。\",\"一般必须满足 obj1.equals(obj2)==true。可以推出 obj1.hash- Code()==obj2.hashCode()，但是 hashCode 相等不一定就满足 equals。不过为了提高效率，应该尽量使上面两个条件接近等价。\",\"7．wait 方法 wait 方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。\",\"调用该方法后当前线程进入睡眠状态，直到以下事件发生。\",\"（1）其他线程调用了该对象的 notify 方法。\",\"（2）其他线程调用了该对象的 notifyAll 方法。\",\"（3）其他线程调用了 interrupt 中断该线程。\",\"（4）时间间隔到了。\",\"此时该线程就可以被调度了，如果是被中断的话就抛出一个 InterruptedException 异常。\",\"8．notify 方法 该方法唤醒在该对象上等待的某个线程。\",\"9．notifyAll 方法 该方法唤醒在该对象上等待的所有线程。\"]},\"351\":{\"h\":\"值传递与引用传递的区别\",\"t\":[\"​ java 中基础类型数据传递都是值传递，java 中实例对象的传递是引用传递。值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\",\"​ 值传递和引用传递都是传递的栈空间中的内容，因为栈空间存的是基本数据类型的值（所以表现为值传递），而栈空间存的引用类型的地址（所以表现为引用传递）。\",\"​ 值传递是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量的值。而引用传递一般是对于对象型变量而言的，传递的是对象地址的一个副本，并不是对象本身。\"]},\"352\":{\"h\":\"关键字 static 的作用\",\"t\":[\"为特定数据类型或对象分配单一的存储空间，与创建对象的个数无关\",\"在不创建对象的情况下就可以用来直接调用方法或使用类的属性\",\"JVM 在类加载的连接阶段的准备过程中对其进行初始化也就是分配内存空间，的初始化时会执行 static 代码块，static 代码块经常会被用来初始化静态变量，需要注意的是 static 代码块只会被执行一次\"]},\"353\":{\"h\":\"二、面向对象\"},\"354\":{\"h\":\"vs 面向过程\",\"t\":[\"面向对象 OOP：把数据及对数据的操作方法放在一起，作为一个相互依存的整体——对象。对同类对象抽象出其共性，形成类。\",\"面向过程：以事件为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。\",\"面向过程性能比面向对象高，所以当性能是重要的考量因素时，如：单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。\",\"面向对象：在日常生活或编程中，简单的问题可以用面向过程的思路来解决，直接有效，但是当问题的规模变得更大时，用面向过程的思想是远远不够的。所以慢慢就出现了面向对象的编程思想。\",\"更符合人类的思维方式。易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统。\"]},\"355\":{\"h\":\"面向对象的三大特性\",\"t\":[\"封装：把数据和操作数据的方法封装（使用 private 修饰）起来，对数据的访问只能通过定义的方法（getter & setter 方法），提高了安全性。\",\"继承：从已有类得到继承信息创建新类的过程。通过继承使得子类具有父类的属性和方法，同时子类也可以新增新的属性和方法。提高代码复用性，并且继承是多态的前提。注意点：\",\"子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有，例如私有属性，只能通过 public 的 get 和 set 方法访问到，但私有方法不行。\",\"构造器私有化的类不能被继承，因为如果 A 类构造函数私有化了，类 B extend A 的话会报错，因为子类会调用 super( )，会因为私有化无法访问。\",\"被 final 修饰，当用 final 修饰一个类时，表明这个类不能被继承，这主要是防止任何继承类改变它的本来含义。\",\"多态：(多态实现的前提：继承；要有方法重写；父类引用指向子类对象)只有在程序运行期间才能确定引用变量到底会指向哪个类的实例对象。当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。降低程序耦合度，使程序易扩展。(属性不具有多态性，方法具有。子类覆盖父类的方法或属性后，只有新方法才能被调用，属性则继续调用父类本身的旧属性)\"]},\"356\":{\"h\":\"Java 中创建对象的方式\",\"t\":[\"使用new关键字。\",\"使用Class 类的newInstance()方法，该方法调用无参的构造器创建对象（反射）：Class.forName.newInstance()。\",\"直接调用 Class 对象的 newInstance()方法创建，使用的默认构造器来创建该类的实例\",\"若想使用指定的构造器来创建实例，先获得该 class 对象，利用该 class 对象的 getConstructor 方法获取指定构造器，再调用 Constructor 方法创建 Java 对象。\",\"getDeclareMethod 获取的是类自身声明的所有方法，包含 public、protected 和 private 方法，getMethod 获取的是类的所有共有方法，这就包括自身的所有 public 方法，和从基继承的、从接口实现的所有 public 方法。\",\"使用clone()方法。\",\"反序列化，比如调用 ObjectInputStream 类的 readObject() 方法。\"]},\"357\":{\"h\":\"访问权限控制符有哪些？\",\"t\":[\"访问权限控制符\",\"本类\",\"包内\",\"包外子类\",\"任何地方\",\"public\",\"√\",\"√\",\"√\",\"√\",\"protected\",\"√\",\"√\",\"√\",\"×\",\"无\",\"√\",\"√\",\"×\",\"×\",\"private\",\"√\",\"×\",\"×\",\"×\"]},\"358\":{\"h\":\"子类是否可以重写(覆盖)父类 private 或 static 方法\",\"t\":[\"Java 中 static 方法不能被重写，因为方法重写是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。（静态方法可以被继承，如果父类和子类中存在同样名称和参数的静态方法，那么该子类的方法会把原来继承过来的父类的方法隐藏）\",\"Java 中也不可以覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用， 如果是其他的类继承当前类是不能访问到 private 变量或方法的，当然也不能覆盖。\"]},\"359\":{\"h\":\"重写与重载的区别\",\"t\":[\"重写：所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类的访问范围必须大于等于父类的访问范围。 也就是说如果父类访问修饰符是 public，那么子类的访问修饰符也必须是 public\",\"重载：在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。重载是一个类中多态性的一种表现。重载要求同名方法的参数列表不同(参数类型，参数个数，甚至是参数顺序)，重载的时候，返回值类型可以相同也可以不同，无法以返回值类型作为判断重载函数的区分标准。\",\"二者区别：\",\"方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。\"]},\"360\":{\"h\":\"static 可以修饰类么\",\"t\":[\"​ static 一般用来修饰成员变量或方法。但有一种特殊用法是用 static 修饰内部类，普通类是不允许声明为静态的，只有内部类才可以。\"]},\"361\":{\"h\":\"什么时候会使用静态内部类\",\"t\":[\"静态内部类的主要特点：\",\"不持有外部类的引用（普通内部类持有）\",\"可以直接创建实例，不需要先创建外部类（普通内部类需要）\",\"可以有静态成员变量、方法（普通内部类不行）和非静态成员变量、方法\",\"只可以直接访问外部类静态成员，不可以直接访问外部类的非静态成员（普通内部类可以），需要通过传入外部类引用的方式才能访问。\",\"使用场景：\",\"​ 外部类与内部类有很强的联系，需要通过内部类的方式维持嵌套的可读性。内部类可以单独创建。内部类不依赖于外部类，外部类需要使用内部类，而内部类不需使用外部类（或者不合适持有外部类的强引用）。\"]},\"362\":{\"h\":\"接口 vs 抽象类\",\"t\":[\"深入理解 Java 的接口和抽象类\",\"从设计层面来说，抽象类是对类的抽象，是一种模板设计；接口是对行为的抽象，是一种行为规范。\",\"不同点：\",\"抽象类中可以定义构造函数，接口不能定义构造函数；\",\"JDK1.8 之前，抽象类中可以有抽象方法、静态方法和具体方法，而接口中只能有抽象方法（public abstract）和常量（public static final）；\",\"JDK8引入了接口默认方法，接口中可以包含带有具体实现的方法，需要使用 default 修饰。 JDK8中接口中可以包含静态方法。之前不能包含是因为，接口不可以实现方法，只可以定义方法，所以不能使用静态方法（因为静态方法必须实现）。现在可以包含了，只能直接用接口调用静态方法。JDK1.8 仍然不可以包含静态代码块。 \",\"抽象类中的成员权限可以是 public、默认、protected（抽象类中抽象方法就是为了重写，所以不能被 private 修饰），而接口中的成员只可以是 public（方法默认：public abstract、成员变量默认：public static final）；\",\"抽象类和接口的选择\",\"​ 抽象类是为了简化接口的实现，它不仅提供了公共方法的实现，让你可以快速开发，又允许你的类完全可以自己实现所有的方法，不会出现紧耦合的问题。\",\"应用场合：\",\"接口是对行为的抽象，行为模型应该总是通过接口而不是抽象类定义。\",\"抽象类是对类的抽象，为具体类提供准则时创建抽象类。。\"]},\"363\":{\"h\":\"子类初始化的顺序\",\"t\":[\"存在继承的情况下，初始化顺序为：\",\"父类（静态变量、静态语句块）\",\"子类（静态变量、静态语句块）\",\"父类（实例变量、普通语句块）\",\"父类（构造函数）\",\"子类（实例变量、普通语句块）\",\"子类（构造函数）\"]},\"364\":{\"h\":\"super 、transient\",\"t\":[\"super 的作用\",\"访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。\",\"访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。\",\"为什么 this 和 super 不能出现在一个构造函数里面？\",\"​ 因为 this 必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。\",\"transient 关键字的作用\",\"对于不想进行序列化的变量，使用 transient 关键字修饰。\",\"transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化。当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。\"]},\"365\":{\"h\":\"三、数据类型\"},\"366\":{\"h\":\"Java 都有哪些基本数据类型？\"},\"367\":{\"h\":\"char 和 String 的区别\",\"t\":[\"char 相当于一个int 值，可以参与表达式运算；String 代表一个地址值；\",\"int和char可以互换，可以直接将一个不超过char范围的数字赋值给char。 char c = 97;(此时print的话，是 a) \",\"占内存大小：字符常量占用 2 个字节，字符串常量占若干字节。\"]},\"368\":{\"h\":\"Integer/int、包装类的缓存\",\"t\":[\"int 是 Java 的八种基本数据类型之一，而 Integer 是 Java 为 int 类型提供的封装类；\",\"int 型变量的默认值是 0，Integer 变量的默认值是 null，说明 Integer 可以区分出未赋值和值为 0；\",\"Integer 变量必须实例化后才可以使用，而 int 不需要。\",\"基本数据类型是在栈上分配的，包装类是在堆中分配。\",\"比较\",\"两个 new 出来的 Integer 比较的是地址。\",\"Integer 和 int 比较时，Integer 自动拆箱，相当于两个 int 在比较。\",\"对于两个非 new 生成的 Integer 对象进行比较时，如果两个变量的值在区间 [-128, 127] 之间，则比较结果为 true，否则为 false。\",\"Java 在编译 Integer i = 100 时，会编译成 Integer i = Integer.valueOf(100)，而 Integer 类型的 valueOf 的源码如下所示：\",\"public static Integer valueOf(int var0) { return var0 >= -128 && var0 <= Integer.IntegerCache.high ? Integer.IntegerCache.cache[var0 + 128] : new Integer(var0); } 可以看出：Java 对于 [-128, 127] 之间的数会放到一个名为cache的数组中缓存，比如：Integer i = 127，会将 127 进行缓存，下次再写 Integer j = 127 的时候，就会直接从缓存中取出，而对于这个区间之外的数就需要 new 了。 \",\"包装类的缓存：\",\"Boolean：全部缓存\",\"Byte：全部缓存（Byte 的数值范围是 -128 ～ 127）\",\"Character：<= 127 缓存\",\"Short、Integer、Long：-128 ~127 缓存\",\"Float、Double：没有缓存\"]},\"369\":{\"h\":\"String 为什么要设计成不可变类\",\"t\":[\"字符串常量池的需要：字符串常量池是 Java 堆内存中一个特殊的存储区域, 当创建一个 String 对象时，假如此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象；\",\"允许 String 对象缓存 HashCode：Java 中 String 对象的哈希码被频繁地使用, 比如在 HashMap 等容器中。字符串不变性保证了 hash 码的唯一性，因此可以放心地进行缓存。这也是一种性能优化手段，意味着不必每次都去计算新的哈希码；\",\"String 被许多的 Java 类(库)用来当做参数，例如：网络连接地址 URL、文件路径 path、还有反射机制所需要的 String 参数等, 假若 String 不是固定不变的，将会引起各种安全隐患。\"]},\"370\":{\"h\":\"String 类可以被继承么？\",\"t\":[\"​ 不可以，因为被 final 修饰了。\",\"​ final 是 java 中的一个关键字，可以用来修饰变量、方法和类。用关键词 final 修饰的域成为最终域。用关键词 final 修饰的变量一旦赋值，就不能改变，也称为修饰的标识为常量。如果一个类的域被关键字 final 所修饰，它的取值在程序的整个执行过程中将不会改变。\"]},\"371\":{\"h\":\"final 修饰 StringBuffer 后还可以 append 吗？\",\"t\":[\"可以。final 修饰的是一个引用变量，那么这个引用始终只能指向这个对象，但是这个对象内部的属性是可以变化的。\"]},\"372\":{\"h\":\"数组和链表的区别\",\"t\":[\"存储形式：数组是一块连续的空间，声明时就要确定长度。；链表是一块可不连续的动态空间，长度可变，每个节点要保存相邻结点指针；\",\"数据查找方面：数组的线性查找速度快，查找操作直接使用偏移地址。链表需要按顺序检索节点，效率低\",\"数据插入或删除：链表可以快速插入删除节点，而数据则需要大量数据移动\",\"越界问题：链表不存在越界问题，数组有越界问题\"]},\"373\":{\"h\":\"数组和链表的应用场景\",\"t\":[\"数组应用场景：对于想要快速访问数据，不经常有插入删除元素的时候，选择数组\",\"链表应用场景：对于需要经常插入和删除元素，而对访问元素时的效率没有很高的要求的话，选择链表。\"]},\"374\":{\"h\":\"消息队列可以用数组实现吗\",\"t\":[\"​ 不推荐，因为消息队列中进来的任务数量不确定，并且插入与删除也比较频繁，还是链表更加适合。\"]},\"375\":{\"h\":\"四、Java IO\"},\"376\":{\"h\":\"1、IO 分类\"},\"377\":{\"h\":\"2、IO 与 NIO 区别？讲讲 NIO\",\"t\":[\"Java IO 是面向流的，NIO 是面向缓冲区的基于通道的 IO 操作；\",\"传统的 IO 流是阻塞式的，会一直监听一个 ServerSocket，在调用 read 等方法时，会一直等到数据到来或者缓冲区已满时才返回。调用 accept 也是一直阻塞到有客户端连接才会返回。每个客户端连接过来后，服务端都会启动一个线程去处理该客户端的请求。并且多线程处理多个连接。每个线程拥有自己的栈空间并且占用一些 CPU 时间。每个线程遇到外部未准备好的时候，都会阻塞掉。阻塞的结果就是会带来大量的线程上下文切换。\",\"NIO 是非阻塞式的，Java NIO 实际上就是多路复用 IO。 NIO 基于 Channel 和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。NIO 支持面向缓冲区的、基于通道的 IO 操作。NIO 将以更加高效的方式进行文件的读写操作。因此，单个线程可以监听多个数据通道。\"]},\"378\":{\"h\":\"直接缓冲区与非直接缓冲区\",\"t\":[\"非直接缓冲区\",\"​ 通过 allocate()方法获取的缓冲区都是非直接缓冲区，这些缓冲区是建立在JVM 堆内存之中。通过非直接缓冲区，想要将数据写入到物理磁盘中，或者是从物理磁盘读取数据。都需要经过 JVM 和操作系统，数据在两个地址空间中传输时，会copy一份保存在对方的空间中。所以非直接缓冲区的读取效率较低。\",\"直接缓冲区\",\"​ 只有ByteBuffer 可以获得直接缓冲区，通过allocateDirect()获取的缓冲区为直接缓冲区，这些缓冲区是建立在物理内存之中的.\",\"​ 直接缓冲区通过在操作系统和 JVM 之间创建物理内存映射文件加快缓冲区数据读/写入物理磁盘的速度。放到物理内存映射文件的数据就不归应用程序控制了，操作系统会自动将物理内存映射文件中的数据写入物理内存中。\"]},\"379\":{\"h\":\"通道(Channel)\",\"t\":[\"​ Channel 由 java.nio.channels 包定义的，通道表示 IO 源与目标打开的连接。Channel 类似于传统的“流”。只不过Channel 本身不能直接访问数据，Channel 只能与 Buffer 进行交互 。\",\"​ 应用程序进行读写操作调用函数时，底层调用操作系统提供给用户的读写 API，调用这些 API 时会发生对应的指令。DMA 会向 CPU 请求，让 DMA 去处理这些 IO 操作，从而可以让 CPU 去执行其他命令。DMA 处理 IO 操作时，会请求总线的使用权。当 IO 请求过多时，会导致大量总线用于处理 iO 请求，从而降低效率。\",\"​ 于是便有了 Channel，Channel 相当于一个专门用于 IO 操作的独立处理器，它具有独立处理 iO 的能力，当有 IO 请求时，它会自行处理这些 IO 请求。\"]},\"380\":{\"h\":\"3、BIO/NIO/AIO 区别？\",\"t\":[\"BIO：同步阻塞 IO，每一个客户端连接，服务器端都会对应一个处理线程，对于没有分配到处理线程的连接就会被阻塞或者被拒绝。相当于是。\",\"NIO：同步非阻塞 IO，基于 Reactor 模型，客户端和 channel（通道） 进行通信，channel 可以进行读写操作，通过多路复用器 selector 来轮询注册在其上的 channel，而后再进行 IO 操作。这样的话，在进行 IO 操作时用一个线程去处理就可以了。相当于是。\",\"AIO：异步非阻塞 IO，相比 NIO 更进一步，完全由操作系统来完成请求的处理，然后通知服务器端开启线程去处理，因此是。\",\"​ linux 系统中，所有的读写请求都可以当成文件的读写来操作，对文件的读写一般要经过内核态和用户态的切换，正因为有切换才导致了 IO 有同步和异步的说法。首先一个 IO 操作其实分成了两个步骤：发起 IO 请求和实际的 IO 操作。\",\"​ 同步 IO 和异步 IO 的区别就在于第二个步骤是否阻塞，如果实际的 IO 读写阻塞请求进程，那么就是同步 IO，因此阻塞 IO、非阻塞 IO、IO 复用都是同步 IO，如果不阻塞，而是操作系统帮你做完 IO 操作再将结果返回给你，那么就是异步 IO。\",\"​ 阻塞 IO 和非阻塞 IO 的区别在于第一步，发起 IO 请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞 IO，如果不阻塞，那么就是非阻塞 IO。\",\"同步 IO 的特点：\",\"同步 IO 指的是：用户进程触发 I/O 操作并等待或者轮询的去查看 I/O 操作是否就绪。\",\"同步 IO 的执行者是 IO 操作的发起者。同步 IO 需要用户进程自己去读取数据，而读取数据的过程就是一个内核态到用户态的数据拷贝过程，所以这里必须有个阻塞。\",\"异步 IO 的特点：\",\"异步 IO 是指用户进程触发 I/O 操作以后就立即返回，继续开始做自己的事情，而当 I/O 操作已经完成的时候会得到 I/O 完成的通知。\",\"异步 IO 的执行者是内核线程，内核线程将数据从内核态拷贝到用户态，所以这里没有阻塞。\"]},\"381\":{\"h\":\"4、IO 多路复用\",\"t\":[\"​ 在 Linux 系统中，网络连接在内核中以文件描述符（Fd）的形式存在。\",\"​ I/O 多路复用就通过一种机制，一个进程可以监视多个描述符，一旦某个 fd 就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。select，poll，epoll 都是 IO 多路复用的机制，但本质上都是同步 I/O，因为他们都需要在读写事件就绪后自己负责进行读写，这个读写过程是阻塞的，而异步 I/O 则无需自己负责进行读写，异步 I/O 中内核线程会负责把数据从内核空间拷贝到用户空间。\",\"select ==> 时间复杂度 O(n)\",\"​ 它仅仅知道有 I/O 事件发生了，却并不知道是哪几个流（可能有一个，多个，甚至全部），所以只能无差别轮询所有流，找出能读出数据，或者写入数据的流进行操作。\",\"​ select 最大的缺陷就是单个进程所打开的 fd 是有一定限制的，它由 FD_SETSIZE 设置，默认值是 1024/2048。\",\"poll ==> 时间复杂度 O(n)\",\"​ poll 本质上和 select 没有区别，它将用户传入的数据拷贝到内核空间（epoll 中，用户态和内核态是共享这一块内存的），然后内核去查询每个 fd 的状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。\",\"epoll ==> 时间复杂度 O(1)\",\"​ 不同于 select 和 poll 无差别轮询，epoll 中内核会把哪个流发生了怎样的 I/O 事件通知我们，所以我们说 epoll 实际上是**事件驱动（fd 绑定 event）**的。epoll 通过将有读写事件发生的连接重排至头部，将复杂度降低到了 O(1)。虽说连接数有上限，但是很大，1G 内存可以打开 10 万左右的连接。\",\"​ epoll 的消息传递方式：通过内核和用户空间共享一块内存来实现的。\",\"​ 有 EPOLL LT（水平触发） 和 EPOLL ET 两种触发模式，LT 是默认的模式，ET 是“高速”模式。LT 模式下，只要这个 fd 还有数据可读，每次 epoll_wait 都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论 fd 中是否还有数据可读。所以在 ET 模式下，read 一个 fd 的时候一定要把它的 buffer 读光，也就是说一直读到 read 的返回值小于请求值，或者遇到EAGAIN错误。还有一个特点是，epoll 使用“事件”的就绪通知方式，通过 epoll_ctl 注册 fd，一旦该 fd 就绪，内核就会采用类似 callback 的回调机制来激活该 fd，epoll_wait 便可以收到通知。\",\"epoll 为什么要有 EPOLL ET 触发模式？\",\"​ 如果采用 EPOLL LT 模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率.。而采用 EPOLL ET 这种边沿触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。\"]},\"382\":{\"h\":\"五、Java 异常\"},\"383\":{\"h\":\"1、finally 必须执行！\",\"t\":[\"记住一个原则：不管怎样，finally 代码块中的语句都会执行！（除非在 try 中强制退出！）\",\"情况 1：try 和 catch 中有 return，finally 中没有 return。执行！\",\"情况 2：try 和 catch 中有 return，finally 中没有 return，但 finally 中有对 try 或 catch 中要 return 数据进行操作的代码。\",\"返回的数据为基本数据类型，则 finally 中对要返回数据操作无影响。（比如返回 num 的值为 4，finally 中的 num++会让 num 变成 5，但是还是返回 4）\",\"返回的数据为引用数据类型，finally 如果改变了返回对象的属性，则影响结果。\",\"情况 3：try 和 catch 中有 return，finally 中也有 return。try 或 catch 中 return 后面的代码会执行，但最终的返回结果为 finally 中的 return 值，需要注意的是 try 或 catch 中 return 后面的代码会执行，只是存起来了，并没有返回，让 finally 捷足先登了。\"]},\"384\":{\"h\":\"2、Error 和 Exception 的区别？\",\"t\":[\"Error 类和 Exception 类的父类都是 Throwable 类。主要区别如下：\",\"说明\",\"举例\",\"Error（错误）\",\"系统级错误，程序运行过程中发生严重错误，无法处理，只能退出\",\"OutOfMemoryError（内存不足错误）、StackOverflowError（栈溢出错误）\",\"Exception（异常）\",\"程序需要捕获、处理的异常，是由于程序设计不完善而出现的问题\",\"运行时异常和编译时异常\"]},\"385\":{\"h\":\"3、运行时异常与受检异常\",\"t\":[\"编译时异常（受检异常）：指编译期间，编译器检测到某段代码可能会发生某些问题，需要程序员提前给代码做出错误解决方案，否则编译无法通过。\",\"运行时异常（非受检异常）：指编译通过了，但运行时出现的错误。\",\"RuntimeException 举例：\",\"RuntimeException\",\"说明\",\"Java.lang.NullPointerException\",\"空指针异常\",\"Java.lang.NumberFormatException\",\"字符串转换为数字异常\",\"Java.lang.IndexOutOfBoundsException\",\"数组角标越界异常\",\"Java.lang.illegalArgumentException\",\"方法传递参数异常\",\"Java.lang.ClassCastException\",\"数组类型转换异常\"]},\"386\":{\"h\":\"4、throw vs throws？\",\"t\":[\"throw 用在方法体内，表示将异常抛出给调用者。\",\"throws 用在方法声明后面，表示这个方法会抛出某种类型的异常，给方法调用者来解决。\"]},\"387\":{\"h\":\"六、Java 集合\"},\"388\":{\"h\":\"1、Collection vs Collections\",\"t\":[\"Collection 是一个集合接口，提供了对集合对象进行基本操作的通用接口方法。\",\"Collections 是一个操作 Set、List、Map 集合工具类，提供了对集合元素排序、查找、修改等功能。\"]},\"389\":{\"h\":\"2、Iterable vs Iterator\",\"t\":[\"。\",\"Iterable 接口是专门创建新的迭代器，该接口包含一个能够产生 Iterator 接口的 iterator( ) 方法，实现了这个接口的集合对象支持迭代。\",\"Iterator 接口是一个顺序遍历迭代器，它能够用来遍历集合中的元素，JDK 中的集合框架继承了 Iterable 接口，并对 iterator( ) 方法进行了重写。所以当调用集合的 iteartor( ) 方法会返回该集合所实现的特定迭代器对象。\"]},\"390\":{\"h\":\"3、Comparable vs Comparator\",\"t\":[\"Java 实现对象排序的方式有两种：\",\"自然排序：java.lang.Comparable\",\"定制排序：java.util.Comparator\",\"Comparable 和 Comparator 应该怎么选择呢？\",\"当比较规则不会发生改变时，或者说当比较规则只有 1 个时，建议实现 Comparable 接口。\",\"当比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用 Comparator 接口。\",\"//自定义Arrays.sort()的例子： Arrays.sort(T[],new Comparator<Integer>(){ public int compare(Interger a, Integer b){ return b-a; //降序 } }); \"]},\"391\":{\"h\":\"4、集合的遍历\",\"t\":[\"遍历 Collection 集合\",\"遍历 Collection 集合中元素可以通过 for 循环、for-each、迭代器。\",\"for-each 反编译成字节码之后，可以看到本质上也是通过迭代器来遍历的，它只比迭代器遍历多了生成中间变量这一步，所以 for-each 性能略微下降了一些。\",\"for-each 和迭代器需要实现 Iterable 接口并实现 iterator( ) 方法，实质上 Collection 集合都继承了 Iterable 接口并实现了 iterator( ) 方法，表明 Collection 集合下所有实现都可以采用 for-each 和迭代器来遍历。\",\"遍历 Map 集合\",\"Map 集合无法直接使用 for-each 或迭代器遍历。Map 集合通过 entrySet() 方法转换成 Set 集合，然后获取迭代器对象进行遍历。\",\"List 的遍历效率比较\",\"ArrayList 用 for 循环遍历比 iterator 迭代器遍历快，LinkedList 用 iterator 迭代器遍历比 for 循环遍历快。\",\"ArrayList 是直接通过数组来进行存储，所以在使用下标的方式循环遍历时性能最好，通过下标可以直接取数据，速度最快，而且由于 ArrayList 是实现了 RandomAccess 接口（随机存储），该接口是一个标记接口，表明了 ArrayList 集合中数据元素之间没有关联，支持快速随机访问。而如果对于 ArrayList 使用 for-each 或迭代器遍历就没有 for 循环遍历效率高了，因为迭代器强制将 RandomAccess 的 ArrayList 建立了前后遍历关系，且在每次遍历过程中进行了一堆判断，所有相对于 ArrayList 来说，。\",\"LinkedList 底层实现是双向链表，前后元素是通过链表中指针建立关联，无法直接取到对应的下标，因此在使用普通的 index 索引下标遍历时就需要计算对应的元素在哪，效率很低。而迭代器的实现就是指向下一个元素，迭代器直接通过 LinkedList 的指针进行遍历，一次遍历就能找到相应元素，所以 LinkedList 在使用迭代器遍历时效率最高。\"]},\"392\":{\"h\":\"5、ArrayList、LinkedList、Vector\",\"t\":[\"ArrayList：\",\"ArrayList 实现了 List 接口，底层是基于数组实现的，并且实现了。\",\"由于底层是数组实现，所以元素在内存中是连续存储的，可以直接通过下标来查询数组，查询快，但增删慢，但这个增删慢也不是绝对的。\",\"内部grow() 方法来实现动态扩容，当添加元素发现容量满了时，就扩容到原来数组的 1.5 倍。\",\"此外，它实现的接口： RandomAccess(这个接口的类支持快速随机访问，直接可以通过下标访问)、Cloneable、Serializable。\",\"LinkedList：\",\"LinkedList 实现了 List 接口，底层是基于双向链表实现，它增删速度比较快，但查询速度比较慢，在硬盘中的存储是不连续的。\",\"LinkedList 链表由一系列表项连接而成，一个表项包含 3 个部分：元素内容、前驱表和后驱表。链表内部有一个 header 表项，既是链表的开始也是链表的结尾。header 的后继表项是链表中的第一个元素，header 的前驱表项是链表中的最后一个元素。\",\"虽然 LinkedList 没有下标的概念，但 LinkedList 依旧可以，如：删除元素时可以通过remove(int index)& remove(Object o) ，，它首先检查索引值合法性，然后通过从头遍历节点来实现删除操作，删除的节点等待 GC 回收。\",\"此外，它实现的接口：Cloneable、Serializable。\"]},\"393\":{\"h\":\"ArrayList 与 LinkedList 的区别\",\"t\":[\"ArrayList 是实现了基于动态数组的数据结构，而 LinkedList 是基于链表的数据结构；\",\"对于随机访问 get 和 set，ArrayList 要优于 LinkedList，因为 LinkedList 要移动指针；\",\"对于添加和删除操作 add 和 remove，一般大家都会说 LinkedList 要比 ArrayList 快，因为 ArrayList 要移动数据。\",\"Vector:\",\"Vector 与 ArrayList 一样，也是通过数组实现的，。\",\"它的方法上加了 synchronized 修饰来保证线程安全，因此它的访问速度比 ArrayList 慢，效率低下，很少使用。\",\"可以使用 CopyOnWriteArrayList 容器\",\"ArrayList 的增删未必就是比 LinkedList 要慢：\",\"如果增删都是在末尾来操作，此时 ArrayList 就不需要移动和复制数组来进行操作了。如果数据量有百万级的时，速度是会比 LinkedList 要快的。\",\"如果删除操作的位置是在中间。由于 LinkedList 的消耗主要是在遍历上，ArrayList 的消耗主要是在移动和复制上（底层调用的是 arrayCopy() 方法，是 native 方法）。LinkedList 的遍历速度是要慢于 ArrayList 的复制移动速度的如果数据量有百万级的时，还是 ArrayList 要快。\"]},\"394\":{\"h\":\"6、Deque、Queue、Stack\",\"t\":[\"// 栈：peek() push() pop() Stack<T> stack = new Stack<>(); Stack<T> stack = new LinkedList<>(); // 优先队列，可以作为堆使用(小顶堆) PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() { public int compare(int[] m, int[] n) { return m[1] - n[1]; } }); // Queue：poll() peek() offer() Queue<T> queue = new LinkedList<>(); // Duque：双端队列 // 队尾：offerLast() pollFirst() peekFirst() 队首：offerFirst() pollLast() peekLast() // ArrayDeque通常作为栈或队列使用，但是栈的效率不如LinkedList高。LinkedList通常作为栈或队列使用，但是队列的效率不如ArrayQueue高。 Duque<T> duque = new LinkedList<>(); Duque<T> duque = new ArrayDuque<>(); \"]},\"395\":{\"h\":\"7、HashMap\",\"t\":[\"底层数据结构：\",\"JDK7：Entry 数组 + 链表\",\"JDK8：Node 数组 + 链表/红黑树\"]},\"396\":{\"h\":\"Hashmap 底层原理\",\"t\":[\"​ Hashmap 底层就是一个数组结构，数组汇总的每一项又是一个链表。数组+链表结构，新建一个 HashMap 时，会初始化一个数组，Entry(键值对)就是数组中的元素，它持有指向下一个元素的引用，就构成了链表。Hashmap 底层采用一个 Entry 数组保存所有 key-value 键值对，当需要存储一个键值对对象时，会根据 hash 算法来决定其在数组中的位置，再根据 equals 方法确定其在数组位置上链表的位置。当需要取出一个 Entry 对象时，也会根据 hash 算法找到其在数组中的存储位置， 在根据 equals 方法从该位置上的链表中取出 Entry。\"]},\"397\":{\"h\":\"put 过程\",\"t\":[\"​ 首先对 key 做 hash 运算，计算出该 key 所在的 index，如果没有碰撞，直接放入数组中，如果碰撞了，判断目前的数据结构是链表还是红黑树，根据不同的情况来进行插入；假设 key 是相同的，则替换原来的值。最后判断哈希表是否满了(当前哈希表的大小*负载因子，与哈希表中元素数量比较)，满了则扩容。\"]},\"398\":{\"h\":\"get 过程\",\"t\":[\"​ 首先对 key 做 hash 运算，计算出 key 所在的 index，判断是否有 hash 冲突，假设没有冲突直接返回，假设有冲突则判断当前数据结构是链表还是红黑树，分别从不同的数据结构中取出。\",\"首先将 key hash 之后取得所定位的桶。\",\"如果桶为空则直接返回 null 。\",\"否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。\",\"如果第一个不匹配，则判断它的下一个是红黑树还是链表。\",\"红黑树就按照树的查找方式返回值。\",\"不然就按照链表的方式遍历匹配返回值。\",\"注意：\",\"JDK7 插入时使用头插法；\",\"JDK8 之后，使用尾插法，且当链表长度 > 8 并且数组长度 ≥ 64 时，使用红黑树来解决链表查询慢的问题，当链表长度 ≤ 6 就转回链表。\"]},\"399\":{\"h\":\"初始化过程(new 一个 Hashmap)\",\"t\":[\"​ Hashmap 有几个构造方法，但最主要的就是指定初始值大小和负载因子大小，如果我们不指定，默认的 HashMap 大小为 16，负载因子的大小为 0.75。（念这个）\",\"​ 负载因子的大小决定着哈希表的扩容和哈希冲突。例如 hashmap 的大小为 16，负载因子为 0.75，这意味着数组最多只能放 12 个元素，一旦超过 12 个元素，则哈希表需要扩容。\",\"创建 HashMap 集合时，集合中的 map 全为 null：\",\"JDK7，在构造方法中创建了一个长度为 16 的 Entry[ ] table 用来存储键值对数据，Entry<K,V>。\",\"JDK8 ，不是在构造方法中创建数组，在首次 resize() 时，创建一个长度为 16 的 Node[ ] table 来存储键值对数据，实质上 Node<K,V> implements Map.Entry<K,V>。负载因子是 0.75（填入表中的元素个数/散列表的长度）， 如果自己传入初始大小 k，初始化大小为大于 k 的 2 的整数次方。例如如果传 25，大小为 32。\"]},\"400\":{\"h\":\"HashMap 中怎样判断一个元素是否相同？\",\"t\":[\"​ 首先比较 hash 值，随后用==运算符和或 equals()方法来判断该元素是否相同。\",\"​ 如果只有 hash 值相同，那就说明该元素哈希冲突了，如果 hash 值和 equals()或者==都相同，那说明该元素是同一个。\"]},\"401\":{\"h\":\"什么情况下才会用到红黑树\",\"t\":[\"​ 当数组大小大于 64 且链表的大小大于 8 的时候才会将链表改为红黑树，当红黑树大小为 6 时，会退化为链表。链表查询时间复杂度 O(N)，插⼊时间复杂度 O(1)，红⿊树查询和插⼊时间复杂度 O(logN)\",\"​ \"]},\"402\":{\"h\":\"resize()\",\"t\":[\"有两种情况会调用 resize 方法：\",\"第一次调用 put() 方法时，会调用 resize()方法对数组进行初始化。\",\"扩容时会调用 resize()，数组大小翻倍。\"]},\"403\":{\"h\":\"为什么 JDK8 之后要改成尾插法？\",\"t\":[\"头插法在并发下，扩容可能造成循环链表；\",\"JDK8 之后，当链表长度达到阈值，升级为红黑树后头插法就不适用了。\"]},\"404\":{\"h\":\"HashMap 的 size 为什么必须是 2 的整数次方？\",\"t\":[\"为了能让 HashMap 存储高效，尽量减少碰撞，也就要尽量把数据分配均匀。\",\"计算元素存放位置时，使用 hash 值对数组长度取模运算，这样一来，元素分布相对来说比较均匀，但模运算的效率不如位运算，所以源码中做了优化，使用 hash&(length-1) ，而实际上 hash%length = hash&(length-1) 的前提是 length = 2^n。\",\"bucketIndex = indexFor(hash, table.length); static int indexFor(int h, int length) { return h & (length-1); } \",\"如果创建 HashMap 对象时，假如输入的数组长度是 10，那么 HashMap 通过一系列位运算和或运算得到的是 2 的幂次数，并且是离那个数最近的数字。\"]},\"405\":{\"h\":\"为什么不直接通过 Key.hashCode()计算 hash 值\",\"t\":[\"//HashMap 中的 hash 方法将高位和低位都利用起来了，为了减少哈希冲突，提高效率。 static final int hash(Object key){ int h; return (key==null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } \",\"​ 先计算出 hashcode 值，再与高 16 位做异或运算，产生最终哈希值；好处是：增加了随机性，减少了碰撞的可能。\",\"​ 因为key.hashCode()函数调用的是 key 键值类型自带的哈希函数，返回 int 型散列值。int 值范围为**-2147483648~2147483647**，大概 40 亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。HashMap 数组的初始大小才 16，用之前需要对数组的长度取模运算，得到的余数才能用来访问数组下标。\",\"​ 这也正好解释了为什么 HashMap 的数组长度要取 2 的整数幂。因为使用 length - 1 正好相当于一个“低位掩码”。& 操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度 16 为例，16 - 1=15。2 进制表示是 00000000 00000000 00001111。假如和通过key.hashCode()计算得到的 hash 值做 & 操作的话，结果就是截取了最低的四位值。这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后 4 位的话会很容易造成计算结果一样，导致 hash 冲突。\"]},\"406\":{\"h\":\"Hash 扩容机制\",\"t\":[\"JDK7：每次扩容通过 hash 值和新数组大小取余计算出原有对象加入新桶内的位置，非常耗时。\",\"​ 首先调用 resize 方法，如果原有 table 长度已经到达上限，就不在扩容，否则，创建一个新的 table，并调用 transfer 方法，transfer 方法的作用是把原 table 的 Node 放到新的 table 中，使用的是头插法，也就是说，新 table 中的链表顺序和原 table 是相反的，可能会导致环形链表(线程 1 准备处理节点，线程二把 HashMap 扩容成功，链表已经逆向排序，那么线程 1 在处理节点时就可能出现环形链)。\",\"JDK8：因为每次扩容都是翻倍，与原来计算的 (n-1)&hash 的结果相比，只是多了一个 bit 位，因此在扩容时不需要取余，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就可以了，是 0 的话索引不变，是 1 的话索引变成 原来索引 + 旧数组容量，省去了重新计算索引值的时间。\",\"​ \"]},\"407\":{\"h\":\"HashMap vs HashTable\",\"t\":[\"继承的父类不同\",\"Hashtable 继承自 Dictionary 类，而 HashMap 继承自 AbstractMap 类，但两者都实现了 Map 接口。\",\"线程安全问题\",\"HashMap 线程不安全，Hashtable 线程安全。\",\"存储 null 问题\",\"HashMap 允许 key 和 value 为 null，而 Hashtable 中 key 和 value 都不允许出现 null 值。\",\"内部数组初始化大小不同\",\"HashMap 内部数组初始化大小为 16，增长方式是 2 的倍数。\",\"Hashtable 内部数组初始化大小为 11，增长方式是 old × 2 + 1 。\"]},\"408\":{\"h\":\"HashMap vs TreeMap\",\"t\":[\"相同点：\",\"HashMap 和 TreeMap 类实现 Map<K, V>，Cloneable，Serializable 接口；\",\"两者都基于键存储值，键值始终唯一，如果我们再次添加相同的键，则旧值将被新值替换；\",\"两者都不是线程安全的。\",\"不同点：\",\"HashMap 是基于哈希表实现的，TreeMap 是基于树结构（如：红黑树）实现的。\",\"HashMap 不对键进行排序，TreeMap 会对键进行排序。\",\"HashMap 允许一个空键和多个空值，TreeMap 不允许空键，但允许多个空值。\",\"HashMap 访问和插入速度比 TreeMap 快，因为 HashMap 不会排序，因此它可以使用 put( ) 和 get( ) 方法以 O(1) 时间复杂度访问和插入。\",\"HashMap 使用 equals( ) 方法进行重复键比较，但对于 TreeMap，键是根据 compareTo( ) 方法进行比较和排序的。\"]},\"409\":{\"h\":\"HashMap 的线程安全问题\",\"t\":[\"HashMap 是线程不安全的，主要体现：\",\"在 JDK8 之前，在多线程环境下，扩容时可能造成元素间形成一个循环链表，造成并发死链的问题。\",\"在 JDK8 中，解决了并发死链的问题，不过会发生数据覆盖的情况。\",\"解决方案：\",\"Hashtable：直接在操作方法上加 synchronized 关键字，锁住整个数组，粒度比较大。\",\"Collections.synchronizedMap：使用 Collections 集合工具的内部类，通过传入 Map 封装出一个 SynchronizedMap 对象，内部定义了一个对象锁，方法内通过对象锁实现。\",\"ConcurrentHashMap：使用分段锁，降低了锁粒度，让并发度大大提高。成员变量使用 volatile 修饰，免除了指令重排序，同时保证内存可见性，另外使用 CAS 操作和 synchronized 结合实现赋值操作，多线程操作只会锁住当前操作索引的节点。再加上 JDK1.6 后对 synchronized 进行了一个锁升级优化过程，所以它的效率更高。\"]},\"410\":{\"h\":\"ConcurrentHashMap\",\"t\":[\"​ ConcurrentHashMap 底层数据结构是数组+链表/红黑树，它支持高并发的访问和更新，是线程安全的。ConcurrentHashMap 通过在部分加锁和利用 CAS 算法来实现同步，在 get 的时候没有加锁，Node 都用了 volatile 修饰，在扩容时，会给每个线程分配对应的区间，并且防止 putVal 导致数据不一致，会给线程的所负责的区间加锁。\",\"​ 为什么用分段锁：保证在操作不同段 map 的时候， 可以并发执行， 操作同段 map 的时候，进行锁的竞争和等待。从而达到线程安全， 且效率大于 synchronized。\",\"​ Segament 是一个 ConcurrentHashMap 内部类，底层结构与 HashMap 一致。另外 Segament 继承自 ReentrantLock。\",\"​ 当新元素加入 ConcurrentHashMap 时，首先根据 key hash 值找到相应的 Segament。接着直接对 Segament 上锁，若获取成功，后续操作步骤如同 HashMap。\"]},\"411\":{\"h\":\"CopyOnWriteArrayList\",\"t\":[\"​ 而CopyOnWriteArrayList 就是通过 Copy-On-Write(COW)，即写时复制的思想来通过延时更新的策略来实现数据的最终一致性(不能保证数据的实时一致性)，并且能够保证读线程间不阻塞。\",\"​ 与读写锁的异同：\",\"​ 相同点：1. 两者都是通过读写分离的思想实现；2.读线程间是互不阻塞的\",\"​ 不同点：对读线程而言，为了实现数据实时性，在写锁被获取后，读线程会等待或者当读锁被获取后，写线程会等待，从而解决“脏读”等问题。也就是说如果使用读写锁依然会出现读线程阻塞等待的情况。而 COW 则完全放开了牺牲数据实时性而保证数据最终一致性，即读线程对数据的更新是延时感知的，因此读线程不会存在等待的情况。\",\"​ 缺点：\",\"内存占用问题：因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对 象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对 象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比 如说 200M 左右，那么再写入 100M 数据进去，内存就会占用 300M，那么这个时候很有可能造成频繁的 minor GC 和 major GC。\",\"数据一致性问题：CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用 CopyOnWrite 容器。\"]},\"412\":{\"h\":\"8、LinkedHashMap、TreeMap\",\"t\":[\"HashMap 内部节点是有序的吗？：是无序的，根据 hash 值随机插入。\",\"那有没有有序的 Map？：LinkedHashMap 和 TreeMap。\",\"LinkedHashMap 怎么实现有序的？\",\"​ LinkedHashMap 本质上就是 HashMap+双向链表\",\"​ LinkedHashMap 内部维护了一个双向链表，有头尾节点，同时 LinkedHashMap 节点 Entry 内部除了继承 HashMap 的 Node 属性，还有 before 和 after 用于标识前置节点和后置节点。可以实现按插入的顺序或访问顺序排序，即对每次 put 进来的 Entry 会将其插入到双向链表的尾部。\",\"TreeMap 怎么实现有序的？\",\"​ TreeMap 底层数据结构是红黑树，TreeMap 的 key 不能为 null(如果为 null，没法排序了)，TreeMap 有序是通过 comparator 来进行比较的，如果 comparator 为 null，那么就使用自然顺序。\",\"​ TreeMap 是按照 Key 的自然顺序或者Comprator 的顺序进行排序，内部是通过=红黑树来实现。所以要么 key 所属的类实现 Comparable 接口，或者自定义一个实现了 Comparator 接口的比较器，传给 TreeMap 用于 key 的比较。\"]},\"413\":{\"h\":\"9、HashSet 的实现原理\",\"t\":[\"​ HashSet 的实现是依赖于 HashMap的，HashSet 的值都是存储在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象，HashSet 不允许值重复。因此，HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，当存储的值已经存在时返回 false。\",\"HashSet 怎么保证值不会重复的？\",\"public boolean add(E e) { return map.put(e, PRESENT)==null; } // map 的 value 则是 PRESENT 变量，这个变量只作为放入 map 时的一个占位符而存在，所以没什么实际用处。 // HashMap 的 key 是不能重复的，而这里HashSet 的元素又是作为了 map 的 key，当然也不能重复了。 \"]},\"414\":{\"h\":\"10、LinkedHashMap 源码分析\",\"t\":[\"​ LinkedHashMap 刚好就比 HashMap 多这一个功能，就是其提供有序，并且，LinkedHashMap 的有序可以按两种顺序排列，一种是按照插入(每插入一个放在最后面一个)的顺序，一种是按照读取(读哪个那个放在链表的最后面)的顺序（这个题目的示例就是告诉我们要按照读取的顺序进行排序），内部是靠 建立一个双向链表 来维护这个顺序的，在每次插入、删除后，都会调用一个函数来进行 双向链表的维护 ，准确的来说，是有三个函数来做这件事，这三个函数都统称为 回调函数 ，这三个函数分别是：\"]},\"415\":{\"h\":\"Linux & Git\"},\"416\":{\"h\":\"系统目录结构\",\"t\":[\"命令\",\"说明\",\"/ (根目录)\",\"在 Linux 下有且只有一个根目录.在终端里输入“/home”，意思是先从/（根目录）开始，再进入到 home 目录。\",\"/bin\",\"Binaries 的缩写，存放二进制可执行文件（ls、tar、mv、cat），常用命令一般都在这里。\",\"/boot\",\"放置 linux 系统启动时用到的一些文件，如 Linux 的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub。\",\"/dev\",\"Device 的缩写， 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。\",\"/etc\",\"用来存放所有的系统管理所需要的配置文件和子目录，重要的配置文件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。\",\"/home\",\"用户的主目录。在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。\",\"/var\",\"放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log 等。\",\"/lib\",\"Library 的缩写，存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。\",\"/usr\",\"应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放库文件。\",\"/opt\",\"optional 的缩写，这是给主机额外安装软件所摆放的目录。\",\"/proc\",\"Processes(进程) 的缩写，是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里。\",\"/sbin\",\"存放系统管理员使用的二进制可执行文件（只有 root 用户才能使用的系统级别管理命令和程序）。\",\"/mnt\",\"系统管理员安装临时文件系统的安装点，可以让用户临时挂载其他文件系统。\",\"/lost+found\",\"平时是空的，用于存放系统非正常关机留下的文件\"]},\"417\":{\"h\":\"命令行中的 ctrl 组合键\",\"t\":[\"Ctrl+c: 结束正在运行的程序 Ctrl+d: 结束输入或退出shell Ctrl+s: 暂停屏幕输出【锁住终端】 Ctrl+q: 恢复屏幕输出【解锁终端】 Ctrl+l: 清屏，【是字母L的小写】等同于Clear 当前光标到行首：ctrl+a 当前光标到行尾：ctrl+e 删除当前光标到行首：ctrl+u 删除当前光标到行尾：ctrl+k Ctrl+y: 在光标处粘贴剪切的内容 Ctrl+r: 查找历史命令【输入关键字，就能调出以前执行过的命令】 Ctrl+t: 调换光标所在处与其之前字符位置，并把光标移到下个字符 Ctrl+x+u: 撤销操作 Ctrl+z: 转入后台运行 \"]},\"418\":{\"h\":\"文件与目录管理\",\"t\":[\"绝对路径与相对路径\",\"绝对路径： 路径的写法，由根目录 / 写起，例如： /usr/share/doc 这个目录。\",\"相对路径： 路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： cd ../man 。\",\"处理目录的常用命令\",\"ls（英文全拼：list files）: 列出目录及文件名\",\"cd（英文全拼：change directory）：切换目录\",\"pwd（英文全拼：print work directory）：显示目前的目录\",\"mkdir（英文全拼：make directory）：创建一个新的目录\",\"rmdir（英文全拼：remove directory）：删除一个空的目录。rmdir [-p] 目录名称 #-p:一次删除多级空目录\",\"cp（英文全拼：copy file）: 复制文件或目录\",\"rm（英文全拼：remove）: 删除文件或目录\",\"mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称\"]},\"419\":{\"h\":\"ls (列出目录)\",\"t\":[\"选项与参数：\",\"-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来\",\"-d ：仅列出目录本身，而不是列出目录内的文件数据\",\"-l ：长数据串列出，包含文件的属性与权限等等数据\",\"ls -al ~ #将当前目录下的所有文件列出来(含属性与隐藏档) \"]},\"420\":{\"h\":\"cd (切换目录)\",\"t\":[\"cd [相对路径或绝对路径] mkdir runoob #使用 mkdir 命令创建 runoob 目录 cd /root/runoob/ #使用绝对路径切换到 runoob 目录 cd ./runoob/ #使用相对路径切换到 runoob 目录 cd ~ # 表示回到自己的家目录，亦即是 /root 这个目录 cd .. # 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思 \"]},\"421\":{\"h\":\"pwd (显示目前所在的目录)\",\"t\":[\"pwd [-P] # -P:显示出确实的路径，而非使用连结 (link) 路径。 \"]},\"422\":{\"h\":\"mkdir (创建新目录)\",\"t\":[\"mkdir [-mp] 目录名称 #-p:帮助你直接将所需要的目录(包含上一级目录)递归创建起来 -m:配置文件的权限 mkdir -p test1/test2/test3/test4 mkdir -m 711 [目录名] \"]},\"423\":{\"h\":\"cp (复制文件或目录)\",\"t\":[\"cp [-adfilprsu] 来源档(source) 目标档(destination) cp [options] source1 source2 source3 .... directory \",\"**-a：**相当于 -pdr 的意思；(常用)\",\"**-i：**若目标档(destination)已经存在时，在覆盖时会先询问动作的进行\",\"**-p：**连同文件的属性一起复制过去，而非使用默认属性(备份常用)\",\"**-r：**递归持续复制，用于目录的复制行为\"]},\"424\":{\"h\":\"rm (移除文件或目录)\",\"t\":[\"rm [-fir] 文件或目录 \",\"-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；\",\"-i ：互动模式，在删除前会询问使用者;\",\"-r ：递归删除，最常用在目录的删除。很危险！\",\"find . -name \\\"*.log\\\" | xargs rm -f \"]},\"425\":{\"h\":\"mv (移动或修改名称)\",\"t\":[\"mv [-fiu] source destination mv [options] source1 source2 source3 .... directory \",\"-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；\",\"-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！\",\"-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)\"]},\"426\":{\"h\":\"查看进程杀死进程启动进程\",\"t\":[\"1.查进程 ps 命令查找与进程相关的 PID 号： ps a 显示现行终端机下的所有程序，包括其他用户的程序。 ps -A 显示所有程序。 ps c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。 ps -e 此参数的效果和指定\\\"A\\\"参数相同。 ps e 列出程序时，显示每个程序所使用的环境变量。 ps f 用 ASCII 字符显示树状结构，表达程序间的相互关系。 ps -H 显示树状结构，表示程序间的相互关系。 ps -N 显示所有的程序，除了执行 ps 指令终端机下的程序之外。 ps s 采用程序信号的格式显示程序状况。 ps S 列出程序时，包括已中断的子程序资料。 ps -t<终端机编号> 指定终端机编号，并列出属于该终端机的程序的状况。 ps u 以用户为主的格式来显示程序状况。 ps x 显示所有程序，不以终端机来区分。\",\"2.杀进程 使用 kill 命令结束进程：kill xxx 常用：kill －9 324 Linux 下还提供了一个 killall 命令，可以直接使用进程的名字而不是进程标识号，例如：# killall -9 NAME\",\"查看自己的 IP 地址 命令：ifconfig 格式：ifconfig -a\",\"查看路由表 命令：netstat 格式：netstat -rn\"]},\"427\":{\"h\":\"Linux 链接\",\"t\":[\"Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln 命令产生硬链接。\",\"硬连接\",\"​ 硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。\",\"​ 硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。\",\"软连接\",\"​ 另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。\"]},\"428\":{\"h\":\"文件内容查看\",\"t\":[\"Linux 系统中使用以下命令来查看文件的内容：\",\"cat 由第一行开始显示文件内容。cat [-AbEnTv] 目录/文件\",\"tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！\",\"nl 显示的时候，输出行号。 nl [-bnw] 文件\",\"more 一页一页的显示文件内容。\",\"less 与 more 类似，但是比 more 更好的是，可以往前翻页。\",\"head 只看头几行，head [-n number] 文件 。number 代表显示几行的意思，默认 10。\",\"tail 只看尾巴几行，tail [-n number] 文件 \"]},\"429\":{\"h\":\"more & less\",\"t\":[\"在 more 这个程序的运行过程中，你有几个按键可以按的：\",\"空格：代表向下翻一页；\",\"Enter ：代表向下翻『一行』；\",\"/字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；\",\":f ：立刻显示出档名以及目前显示的行数；\",\"q ：代表立刻离开 more ，不再显示该文件内容。\",\"b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。\",\"less 运行时可以输入的命令有：\",\"空格 ：向下翻动一页；\",\"[pagedown]：向下翻动一页；\",\"[pageup] ：向上翻动一页；\",\"/字串 ：向下搜寻『字串』的功能；\",\"?字串 ：向上搜寻『字串』的功能；\",\"n ：重复前一个搜寻 (与 / 或 ? 有关！)\",\"N ：反向的重复前一个搜寻 (与 / 或 ? 有关！)\",\"q ：离开 less 这个程序；\"]},\"430\":{\"h\":\"文件属性与权限\",\"t\":[\"在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。d：目录 -：文件 l：链接文档\",\"​ 接下来 的字符中，以三个为一组，且均为 rwx 的三个参数的组合。其中， r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute，)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已。\",\"读权限 r（read） ：对于文件，具有读取文件内容的权限；对于目录，具有浏览目录的权限。\",\"写权限 w（write） ：对于文件，具有修改文件内容的权限；对于目录，具有删除、移动目录内文件的权限。\",\"可执行权限 x（execute）： 对于文件，具有执行文件的权限；对于目录，该用户具有进入目录的权限。\"]},\"431\":{\"h\":\"chgrp：更改文件属组\",\"t\":[\"chgrp [-R] 属组名 文件名 #-R:递归更改文件属组。 \"]},\"432\":{\"h\":\"chown：更改文件属主和属组\",\"t\":[\"chown [–R] 属主名 文件名 chown [-R] 属主名：属组名 文件名 \"]},\"433\":{\"h\":\"chmod：修改文件权限\",\"t\":[\"chmod 修改文件权限有两种使用格式：字母法与数字法\",\"字母法：chmod u/g/o/a +/-/= rwx 文件\",\"chmod u=rwx,g=rx,o=r 文件名 #设定权限 chmod a-x 文件名 #例如要拿掉全部人的可执行权限 \",\"u：user ，所有者；g：group，用户组；o：other，其他用户；a：all 表示这三者皆是。\",\"+：增加权限；-：撤销权限；=：设定权限。\",\"数字法：r：4；w：2；x：1；-：0 chmod 751 file\"]},\"434\":{\"h\":\"查找、搜索命令\",\"t\":[\"find：在指定目录下查找文件 which：在环境变量 $PATH 设置的目录里查找符合条件的文件 whereis：查找二进制文件和源代码文件，如：whereis redis-cli locate：快速查找系统数据库中（var/lib/mlocate/mlocate.db）指定的内容 grep <被查找的字符串> <文件名>：查找文件里符合条件的字符串 默认不显示行号，-n 显示行号 \"]},\"435\":{\"h\":\"网络命令\",\"t\":[\"ifconfig：查看网络配置 ping：测试网络联通 netstat：显示各种网络相关信息 \",\"应用场景：\",\"查询机器与哪些应用建立了 TCP 连接？\",\"netstat -anp //-a：显示所有连接和监听端口；-n：以数字方式显示地址和端口号；-p：显示进程的pid和名字 netstat -anp|grep 8080 //查看该占用端口的进程 \"]},\"436\":{\"h\":\"进程管理\",\"t\":[\"free：查看内存使用情况 ps：显示当前运行的进程，常接 grep 命令查找程序，ps -ef | grep <进程关键字> top：实时显示系统中各个进程的资源占用情况 kill -9 [PID]：杀死进程 -9：立即杀死进程 \"]},\"437\":{\"h\":\"压缩解压命令\",\"t\":[\"tar -czvf test.tar.gz test1.txt test2.txt //压缩文件 tar -xzvf test.tar.gz //解压文件 tar -tzvf test.tar.gz //列出解压文件内容 \"]},\"438\":{\"h\":\"Linux 管道命令：|\",\"t\":[\"Linux 的管道命令是’|’，通过它可以对数据进行连续处理，其示意图如下：\"]},\"439\":{\"h\":\"统计命令：wc\",\"t\":[\"wc 命令将计算指定文件的行数、字数，以及字节数。\",\"$ wc testfile # testfile文件的统计信息 3 92 598 testfile # testfile文件的行数为3、单词数92、字节数598 \"]},\"440\":{\"h\":\"监控系统性能\",\"t\":[\"Linux 中需要监控的资源主要有：CPU、内存、硬盘空间、I/O 时间、网络时间、应用程序等。\",\"影响系统性能的主要因素有：\",\"下面的命令可以用来：\"]},\"441\":{\"h\":\"Linux 磁盘管理\",\"t\":[\"df（英文全称：disk full）：列出文件系统的整体磁盘使用量\",\"du（英文全称：disk used）：检查磁盘空间使用量，与 df 命令不同的是 du 命令是对文件和目录磁盘使用的空间的查看。\",\"fdisk：用于磁盘分区，fdisk [-l] 装置名称\",\"df [-ahikHTm] [目录或文件名] # -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示 du [-ahskm] 文件或目录名称 #-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 \"]},\"442\":{\"h\":\"du 和 ls 区别？\",\"t\":[\"du 和 ls 都可以用来查看文件大小，但它们输出的值有可能不同。\",\"du （disk usage）：展示文件占用的磁盘空间\",\"ls：展示文件内容的大小\",\"举一个形象的例子：中秋节时购买月饼礼盒，月饼体积可认为是文件内容大小，加上包装礼盒的总体积可认为是磁盘空间使用量。这种情况使得 du 往往会比 ls 展示的文件大小要大一些。\",\"为什么文件占用的磁盘空间比文件本身大？\",\"文件系统（FAT、NTFS、exFAT）将磁盘按照固定数据块（block）大小进行分割切块，默认分配单元大小是 4096 字节，即 4 KB。大部分文件系统规定：\",\"一个数据块中最多存放一个文件的内容，当没存满时，剩余的空间不得被其他文件使用\",\"当一个文件的内容较大时，则可以存储到多个数据块中\",\"因此一个大小是 3 bytes 的文件，但限于 Linux 文件系统的限制，它需要占用一个数据块来存储这个文件，所以这个文件实际占用的磁盘空间就是 4 KB 了。\"]},\"443\":{\"h\":\"统计 /var/log/ 下所有文件个数\",\"t\":[\"/var/log/ 下所有文件包括当前目录和子目录以及子目录的子目录下面的文件。\",\"[root@oldboy36 ~]# ll -R /var/log/ | grep \\\"^[sl-][rwx-]{9}\\\" | wc -l 74 \",\"ll：输出当前文件夹下的文件信息\",\"grep：查找文件中符合条件的字符串，将输出信息过滤一部分\",\"-R：递归子文件夹\",\"wc -l：统计输出信息的行数\"]},\"444\":{\"h\":\"Git 基础理论\",\"t\":[\"​ Git 本地有三个工作区域：工作区（Working Directory）、暂存区（Stage/Index）、资源库（Repository 或 Git Directory）。如果加上远程的 Git 仓库则有四个工作区域：\",\"工作区（Working Directory）：就是你在电脑里能看到的目录。平时存放代码的地方。\",\"版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是 Git 的版本库。Git 的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有 Git 为我们自动创建的第一个分支master（主分支），以及指向master的一个指针叫HEAD。\"]},\"445\":{\"h\":\"新建仓库\",\"t\":[\"# 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] \"]},\"446\":{\"h\":\"配置\",\"t\":[\"# 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \\\"[name]\\\" $ git config [--global] user.email \\\"[email address]\\\" \"]},\"447\":{\"h\":\"增加/删除文件\",\"t\":[\"# 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] \",\"为什么 Git 添加文件需要add，commit一共两步呢？\",\"​ 因为commit可以一次提交很多文件，所以你可以多次add不同的文件。\"]},\"448\":{\"h\":\"代码提交\",\"t\":[\"# 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... \"]},\"449\":{\"h\":\"查看信息\",\"t\":[\"git status [filename]：显示文件当前的状态。文件的四种状态：\",\"# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\\\"提交说明\\\"必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat \\\"@{0 day ago}\\\" # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog \"]},\"450\":{\"h\":\"Tag\",\"t\":[\"​ 发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照，创建和删除标签都是瞬间完成的。\",\"Git 有 commit，为什么还要引入 tag？ tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起。\",\"# 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] \"]},\"451\":{\"h\":\"分支\",\"t\":[\"# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] \"]},\"452\":{\"h\":\"远程同步\",\"t\":[\"​ 实际情况往往是这样，找一台电脑充当服务器的角色，每天 24 小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。\",\"要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；\",\"关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名；\",\"关联后，使用命令git push -u origin master第一次推送 master 分支的所有内容；\",\"此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；\",\"# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名。也就是关联一个远程库 $ git remote add [库名] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all \"]},\"453\":{\"h\":\"撤销\",\"t\":[\"# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop \"]},\"454\":{\"h\":\"Mysql\"},\"455\":{\"h\":\"数据库的三大范式\",\"t\":[\"第一范式：数据库表中不能出现重复记录，每个字段是原子性的不能再分。关于第一范式，每一行必须唯一，也就是每个表必须有主键，这是我们数据库设计的最基本要求，主要通常采用数值型或定长字符串表示，关于列不可再分，应该根据具体的情况来决定。如联系方式，为了开发上的便利行可能就采用一个字段了。\",\"第二范式：非主键字段要完全依赖主键字段，不能产生部分依赖。\",\"第三范式：非主键字段必须直接依赖于主键字段，不能存在依赖传递。\",\"一对一设计，有两种设计方案：（实际开发中有可能一张表数据太多，放不下，所以拆成两张表）\",\"第一种设计方案：主键共享。（这个用的少）\",\"第二种设计方案：外键唯一。（fk+unique，引用主表的主键列）\"]},\"456\":{\"h\":\"关系型数据库介绍\",\"t\":[\"​ 顾名思义，关系型数据库就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。\",\"关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。\",\"​ 大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。\"]},\"457\":{\"h\":\"SQL、DBMS、DBS、DB\",\"t\":[\"DB：数据库，存储数据的仓库。\",\"DBMS：（软件）数据库管理系统，又称为数据库软件或者数据库产品，用于创建和管理数据库，常见的有MySQL、Oracle、SQL Server。\",\"DBS：数据库系统，数据库系统是一个通称，包括数据库、数据库管理系统、数据库管理人员等，是最大的范畴。\",\"SQL：结构化查询语言，用于和数据库通信的语言，不是某个数据库软件特有的，而是几乎所有的主流数据库软件通用的语言。\"]},\"458\":{\"h\":\"MySQL 权限表\",\"t\":[\"​ MySQL服务器通过权限表控制用户对数据库的访问，权限表存放在mysql数据库里，由**mysql_install_db**脚本初始化。这些权限表分别为user，db，table_priv，columns_priv和host。\",\"user权限表：记录允许连接到服务器的用户账号信息，里面的权限是全局级的\",\"db权限表：记录各个账号在各个数据库上的操作权限\",\"table_priv权限表：记录数据表级的操作权限\",\"columns_priv权限表：记录数据列级的操作权限\",\"host权限表：配合db权限表对给定主机上数据库级操作权限做更细致的控制。这个权限表不受GRANT和REVOKE语句的影响\"]},\"459\":{\"h\":\"常用命令\",\"t\":[\"登录：mysql -uroot -p123456（mysql -uroot -p，不显示密码登录）\",\"退出：exit\",\"查看有哪些数据库show databases;（默认自带了四个数据库）\",\"使用数据库：use 库名;\",\"查看某个数据库下面有哪些表：show tables\",\"MySQL启动：net start MySQL\",\"MySQL关闭：net stop MySQL\",\"查看表的结构：desc 表名\"]},\"460\":{\"h\":\"SQL约束有哪几种\",\"t\":[\"主键约束、唯一约束、默认约束、检查约束、外键约束\"]},\"461\":{\"h\":\"#{ } 和 ${ } 区别？\",\"t\":[\"#{}是预编译处理，${}是字符串替换。\",\"#{key}：获取参数的值，预编译到 SQL 中，可简单理解为一个占位符 “？”，有效防止 SQL 注入，安全。\",\"${key}：获取参数的值，拼接到 SQL 中，存在 SQL 注入问题，不安全。\"]},\"462\":{\"h\":\"主键、外键和唯一的区别\",\"t\":[\"外键：引用另外一个表中的一列或多列数据，被引用列应该具有主键约束或者唯一性约束。外键用来建立和加强两个表数据之间的连接。\",\"alert table 表名 add constraint FK_ID foreign key(外键字段名) references 外表表名(主键字段名) # 外键语法 \",\"，自增长列必须为一个 key，key 指索引，即：primary key、foreign key、unique key。\",\"保证唯一性\",\"是否允许为空\",\"一个表中可以有多少个\",\"主键\",\"√\",\"×\",\"只能有一个\",\"唯一\",\"√\",\"√\",\"可以有多个\",\"外键\",\"×（可以有重复值）\",\"√\",\"可以有多个\"]},\"463\":{\"h\":\"外键的作用\",\"t\":[\"外键的主要作用是保证数据的一致性和完整性，并且减少数据冗余。主要体现在以下两个方面：\",\"阻止执行\",\"从表插入新行，其外键值不是主表的主键值便阻止插入。\",\"从表修改外键值，新值不是主表的主键值便阻止修改。\",\"主表删除行，其主键值在从表里存在便阻止删除(要想删除，必须先删除从表的相关行，再删除主表)。\",\"主表修改主键值，旧值在从表里存在便阻止修改(要想修改，必须先删除从表的相关行)。\",\"级联执行\",\"主表删除行，连带从表的相关行一起删除。\",\"主表修改主键值，连带从表相关行的外键值一起修改。\"]},\"464\":{\"h\":\"为什么一张表只能有一个主键\",\"t\":[\"首先讲讲为什么要有主键？\",\"有些数据库中虽然主键不是必须的，但是我们最好为每个表设置一个主键，，它的作用：\",\"用于与其它表的外键关联以及本记录的修改与删除。\",\"保证实体完整性，表的记录有唯一区分的字段。\",\"增加检索速度。\",\"另外，从数据库的三大范式来看，从第二范式起，要求表中的所有数据都要和主键有完全依赖关系，。\",\"​ 按照我的理解来说，当设置主键时，MySQL 会自动添加一个与主键对应的唯一索引，如果表中有 100w 条数据，我们给多个字段添加主键，都会维护一个索引表，给数据库造成很大压力。实际上只需要 1 个主键就可以完成数据检索工作，所以一张表只能有一个主键。\"]},\"465\":{\"h\":\"自增id\"},\"466\":{\"h\":\"为什么建表使用自增 id 作为主键？\",\"t\":[\"​ InnoDB 表中的数据是直接存储在主键聚簇索引的叶子节点中，每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页，总的来说就是可以提高查询和插入的性能。\",\"​ 若表的主键不是顺序的 id，而是无规律的数据，插入新的记录时，无法按顺序添加，而是需要找一个合适的位置，可能产生大量的页分裂，导致大量的内存碎片，并且在寻找合适位置插入时，目标页可能不在内存中，这也导致了大量的随机 IO，影响插入效率。\"]},\"467\":{\"h\":\"自增id与UUID的区别\",\"t\":[\"优点\",\"缺点\",\"自增id\",\"需要很小的数据存储空间，仅仅需要4 byte 。insert和update操作时使用自增id的性能比UUID好，所以使用int将会提高应用程序的性能。\",\"如果经常有合并表的操作，就可能会出现主键重复的情况。使用INT数据范围有限制。如果存在大量的数据，可能会超出INT的取值范围。\",\"UUID\",\"能够保证独立性，程序可以在不同的数据库间迁移，效果不受影响。保证生成的ID不仅是表独立的，而且是库独立的，这点在你想切分数据库的时候尤为重要。\",\"比较占地方，和INT类型相比，存储一个UUID要花费更多的空间。 使用UUID后，URL显得冗长，不够友好。\"]},\"468\":{\"h\":\"自增id用完了怎么办？\",\"t\":[\"表定义自增值 id：表定义的自增值达到上限后的逻辑是：再申请下一个 id 时，得到的值保持不变。因此在建表的时候需要考察你的表是否有可能达到这个上限，如果有可能，就应该创建成 8 个字节的 bigint unsigned。\",\"InnoDB 系统自增 row_id：如果你创建的 InnoDB 表没有指定主键，那么 InnoDB 会给你创建一个不可见的，长度为 6 个字节的 row_id。在达到上限后，下一个值又变为0。且在 InnoDB 逻辑里，申请到 row_id=N 后，如果表中已经存在 row_id=N 的行，新写入的行就会覆盖原有的行。\"]},\"469\":{\"h\":\"主从复制的原理⭐\",\"t\":[\"​ 主从复制并不是复制磁盘上的数据库文件，而是通过binlog日志复制到需要同步的从服务器上。MySQL数据库支持单向、双向、链式级联等不同业务场景的复制。在复制的过程中，一台服务器当主服务器（Master），接收来自用户的内容更新，而一个或多个其它的服务器来当从服务器（Slaver），接收来自Master上binlog文件的的日志内容，解析出SQL,重新更新到Slave，使得主从服务器的数据达到一致。\",\"①当Master节点进行insert、update、delete操作时，会按顺序写入到binlog中。\",\"②salve从库连接master主库，Master有多少个slave就会创建多少个binlog dump线程。\",\"③当Master节点的binlog发生变化时，binlog dump 线程会通知所有的salve节点，并将相应的binlog内容推送给slave节点。\",\"④I/O线程接收到 binlog 内容后，将内容写入到本地的 relay-log。\",\"⑤SQL线程读取I/O线程写入的relay-log，并且根据 relay-log 的内容对从数据库做对应的操作。\"]},\"470\":{\"h\":\"主从复制涉及的线程\",\"t\":[\"binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。\",\"I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。\",\"SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。\"]},\"471\":{\"h\":\"数据类型\"},\"472\":{\"h\":\"整型\",\"t\":[\"​ TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。\",\"​ INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。\"]},\"473\":{\"h\":\"浮点数\",\"t\":[\"​ FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。\",\"​ FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。\"]},\"474\":{\"h\":\"字符型\"},\"475\":{\"h\":\"时间和日期\",\"t\":[\"​ MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。\",\"DATETIME\",\"能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。它与时区无关。\",\"默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22 :37 :08”，这是 ANSI 标准定义的日期和时间表示方法。\",\"TIMESTAMP\",\"和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。\",\"它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。\",\"MySQL 提供了FROM_UNIXTIME()函数把 UNIX 时间戳转换为日期，并提供了UNIX_TIMESTAMP()函数把日期转换为 UNIX 时间戳。默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。\"]},\"476\":{\"h\":\"int(10) 中 10 指什么？\",\"t\":[\"INT[(M)] [UNSIGNED] [ZEROFILL] M 默认为11 \",\"​ 10 就是上述语句里的 M，指，最大值为 255。\",\"​ 最大显示宽度意思是，如果是 int(10)，字段存的值是 10，则会自动在之前补 8 个 0，显示为 0000000010。\"]},\"477\":{\"h\":\"char、varchar和text的区别？\",\"t\":[\"**char(n) ：**固定长度类型，比如：订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。char 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。\",\"**varchar(n) ：**可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节。\",\"text：不设长度，适用于不知道最大长度的字段，比如个性签名等。不过最大的存储空间和 varchar差不多，但是性能低，所以尽量用 varchar。\",\"所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。\"]},\"478\":{\"h\":\"varchar(10) 和 varchar(20) 的区别？\",\"t\":[\"​ varchar(10) 中 10 的涵义最多存放 10 个字符，varchar(10) 和 varchar(20) 存储\\\"hello\\\"所占磁盘空间一样，但后者在排序时会消耗更多内存，硬盘上的存储空间是根据实际字符长度来分配存储空间，但是对于内存则不一样，它是使用固定大小的内存块来保存值，就是使用字符类型定义的长度即10个字符空间与20个字符空间。尤其是使用临时表进行排序会操作时，会消耗更多的内存。在使用磁盘进行排序时，也是一样。\",\"​ 因为涉及到文件排序或者基于磁盘的临时表时，更长的列会消耗更多的内存，所以在使用时，我们不能太过浪费内存空间，还是需要评估实际使用的长度来设置字符的长度。推荐冗余10%的长度（因业务而异）。\"]},\"479\":{\"h\":\"关键字\"},\"480\":{\"h\":\"UNION 与 UNION ALL 的区别？\",\"t\":[\"UNION 用于把来自多个 SELECT 语句的结果组合到一个结果集合中，MySQL 会把结果集中重复的记录删掉，而使用 UNION ALL，MySQL 会把所有的记录返回，且效率高于 UNION 。\"]},\"481\":{\"h\":\"where 与 having 的区别\",\"t\":[\"用的地方不一样：having只能用于 select 语句中。\",\"having是从前面筛选的字段再筛选，而where是从数据表中的字段直接进行的筛选的\",\"select goods_name,goods_number from sw_goods where goods_price > 100 #正确 select goods_name,goods_number from sw_goods having goods_price > 100 # 报错！！！因为前面并没有筛选出goods_price \"]},\"482\":{\"h\":\"in 和 exists\",\"t\":[\"exists：EXISTS会对外查询的表每一行进行循环匹配，其中子查询可以使用索引，外查询全表扫描。\",\"in：常用于 where 表达式中，其作用是查询某个范围内的数据。IN中的SQL查询只会查询一次，然后把结果集存在临时文件中，然后再与外层查询sql进行匹配，其中外查询与子查询都可以使用索引。\",\"select * from A where id in (select is from B) \",\"外查询表大，子查询表小，选择IN；外查询表小，子查询表大，选择EXISTS；若两表差不多大，则差不多。\"]},\"483\":{\"h\":\"DROP、DELETE 与 TRUNCATE 的区别？\",\"t\":[\"DROP\",\"DELETE\",\"TRUNCATE\",\"SQL语句类型\",\"DDL\",\"DML\",\"DDL\",\"回滚\",\"不可回滚\",\"可回滚\",\"不可回滚\",\"删除内容\",\"从数据库中删除表，所有都会被删\",\"删除表的全部或一部分数据，表结构还在\",\"删除表的所有数据，表结构还在\",\"删除速度\",\"最快\",\"慢，需要逐行删除\",\"快\"]},\"484\":{\"h\":\"order by 是怎么工作的\",\"t\":[\"select city,name,age from t where city='杭州' order by name limit 1000 \",\"全字段排序（优先选择）\",\"初始化 sort_buffer，确定放入 name、city、age 这三个字段；\",\"从索引 city 找到第一个满足 city='杭州’条件的主键 id；\",\"到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；\",\"从索引 city 取下一个记录的主键 id；\",\"重复步骤 3、4 直到 city 的值不满足查询条件为止；\",\"对 sort_buffer 中的数据按照字段 name 做快速排序；\",\"按照排序结果取前 1000 行返回给客户端。\",\"rowid排序\",\"初始化 sort_buffer，确定放入两个字段，即 name 和 id；\",\"从索引 city 找到第一个满足 city='杭州’条件的主键 id；\",\"到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；\",\"从索引 city 取下一个记录的主键 id；\",\"重复步骤 3、4 直到不满足 city='杭州’条件为止；\",\"对 sort_buffer 中的数据按照字段 name 进行排序；\",\"遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。\",\"全字段排序 VS rowid 排序\",\"如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。\",\"如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。\",\"这也就体现了 MySQL 的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。\",\"对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。\"]},\"485\":{\"h\":\"关联查询(连接查询) join\",\"t\":[\"left join：左连接，返回左表中所有的记录以及右表中连接字段相等的记录。\",\"如果从表中有和他匹配的，则显示匹配的值，如果从表中没有和他匹配的，则显示null\",\"right join：右连接，返回右表中所有的记录以及左表中连接字段相等的记录。\",\"inner join：内连接，又叫等值连接，只返回两个表中连接字段相等的行。\",\"union：全连接\",\"union语句注意事项：\",\" 1.通过union连接的SQL它们分别单独取出的列数必须相同； 2.不要求合并的表列名称相同时，以第一个sql 表列名为准； 3.使用union 时，完全相等的行，将会被合并，由于合并比较耗时，一般不直接使用 union 进行合并，而是通常采用union all 进行合并； 4.被union 连接的sql 子句，单个子句中不用写order by ，因为不会有排序的效果。但可以对最终的结果集进行排序； (select id,name from A order by id) union all (select id,name from B order by id); //没有排序效果 (select id,name from A ) union all (select id,name from B ) order by id; //有排序效果 \"]},\"486\":{\"h\":\"分页查询 limit\",\"t\":[\"​ 当需要从数据库查询的表有上万条记录的时候，一次性查询所有结果会变得很慢，特别是随着数据量的增加特别明显，这时需要使用分页查询。\",\"一般分页查询：使用简单的 limit 子句就可以实现\",\"两个重要参数\",\"​ pageNumber：当前页，PageSize：每页数据量\",\"SELECT * FROM table LIMIT 1000 10; # 第1001条到第1010条数据 \",\"第一个参数指定第一个返回记录行的偏移量，注意从0开始。\",\"第二个参数指定返回记录行的最大数目，为 -1 表示检索从某一个偏移量到记录集的结束所有的记录行。\",\"如果只给定一个参数：它表示返回最大的记录行数目。\",\"这种分页查询方式会从数据库第一条记录开始扫描，所以越往后，查询速度越慢，而且查询的数据越多，也会拖慢总查询速度。\",\"建立主键或者唯一索引优化\",\"使用子查询优化\",\"# 先定位偏移位置的 id，然后往后查询，这种方式适用于 id 递增的情况 select * from orders_table where gender = 1 and id >= (select id from orders_table where gender = 1 limit 100000, 1) limit 100 \",\"使用 id 限定优化\",\"# 这种方式假设数据表的id是连续递增的，则我们根据查询的页数和查询的记录数可以算出查询的id的范围 select * from orders_history where type=2 and id between 1000000 and 1001000 limit 100; # 或者 select * from orders_history where id >= 1000001 limit 100; \"]},\"487\":{\"h\":\"MySQL 关键字执行顺序\",\"t\":[\"FROM ： 对FROM左边的表和右边的表计算笛卡尔积，产生虚表VT1；\",\"ON ： 对虚拟表VT1进行ON筛选，只有那些符合条件的行才会被记录在虚拟表VT2中；\",\"JOIN ：如果是OUT JOIN，那么将保留表中（如左表或者右表）未匹配的行作为外部行添加到虚拟表VT2中，从而产生虚拟表VT3；\",\"WHERE ：对虚拟表VT3进行WHERE条件过滤，只有符合的记录才会被放入到虚拟表VT4；\",\"GROUP BY：根据GROUP BY子句中的列，对虚拟表VT4进行分组操作，产生虚拟表VT5；\",\"CUBE|ROLLUP：对虚拟表VT5进行CUBE或者ROLLUP操作，产生虚拟表VT6；\",\"HAVING ：对虚拟表VT6进行 HAVING 条件过滤，只有符合的记录才会被插入到虚拟表VT7中；\",\"SELECT ：执行SELECT操作，选择指定的列，插入到虚拟表VT8中；\",\"DISTINCT ：对虚拟表VT8中的记录进行去重，产生虚拟表VT9；\",\"ORDER BY ：将虚拟表VT9中的记录按照进行排序操作，产生虚拟表VT10；\",\"LIMIT ：取出指定行的记录，产生虚拟表VT11，并将结果返回。\"]},\"488\":{\"h\":\"MySQL基础架构⭐\",\"t\":[\"简单来说 MySQL 主要分为 Server 层和存储引擎层：\",\"Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。\",\"存储引擎： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redo log 模块。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。\"]},\"489\":{\"h\":\"SQL 语句的执行流程？\",\"t\":[\"客户端与数据库server层建立 TCP 连接。客户端发送一条查询 SQL 请求给服务器；\",\"收到请求后，服务器先会查询缓存（目前已经弃用）。如果命中了缓存，则立即返回存储在缓存中的结果；\",\"如果未命中缓存，服务器端会进行查询优化处理，生成执行计划。这个阶段主要包括解析 SQL、预处理、优化 SQL 执行计划；\",\"MySQL 根据执行计划调用存储引擎的 API 来执行查询；\",\"将结果返回给客户端。\",\"查询语句的执行流程如下：权限校验---> 分析器---> 优化器---> 执行器---> 存储引擎\",\"更新语句执行流程如下：连接器----> 分析器---> 优化器----> 执行器----> 权限校验---->存储引擎----> redo log(prepare 状态)----> binlog----> redo log(commit状态)\",\"WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。\",\"更新语句执行流程\",\"mysql> update T set c=c+1 where ID=2; \",\"​ 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。 ​ 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。 ​ 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。 ​ 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。 ​ 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。\"]},\"490\":{\"h\":\"Server 层基本组件介绍\",\"t\":[\"连接器\",\"连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。\",\"主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。\",\"查询缓存(以弃用)\",\"查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。\",\"连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。\",\"MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。\",\"所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。\",\"分析器\",\"MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：\",\"第一步，词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。\",\"第二步，语法分析，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。\",\"完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。\",\"优化器\",\"​ 优化器的作用就是按照MySQL认为的最优的执行方案去执行，比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。经过了优化器之后，可以说这个语句具体该如何执行就已经定下来。\",\"执行器\",\"​ 当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。\",\"​ 存储引擎描述的是表的存储方式，不同的存储引擎导致底层表在存储数据时采用不同方式存储。\"]},\"491\":{\"h\":\"InnoDB\",\"t\":[\"是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。实现了四个标准的隔离级别，默认级别是 RR，并通过 MVCC + Next-Key Locking 防止幻读。\",\"内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。\",\"支持行锁、事务、外键、崩溃恢复\"]},\"492\":{\"h\":\"MyISAM\",\"t\":[\"设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。提供了大量的特性，包括压缩表、空间数据索引等。\",\"只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。\",\"可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。\",\"如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。\"]},\"493\":{\"h\":\"MyISAM 和 InnoDB 的区别\",\"t\":[\"InnoDB\",\"MyISAM\",\"存储结构\",\"采用两个文件组织一张表：frm（定义表结构），idb（索引和数据）\",\"采用三个文件组织一张表：表结构文件、索引文件、数据文件\",\"事务\",\"支持事务，具有提交(commit)和回滚(rollback)事务的能力\",\"不支持事务\",\"锁机制\",\"支持行级锁和表级锁，行级锁操作时只锁某一行，适合高并发操作\",\"表级锁，即使操作一条记录也会锁住整个表，不适合高并发操作\",\"缓存\",\"不仅缓存索引还要缓存真实数据，对内存要求较高\",\"只缓存索引，不缓存真实数据\",\"外键\",\"支持\",\"不支持\",\"MVCC\",\"支持\",\"不支持\",\"数据库异常崩溃后的安全恢复\",\"InnoDB 在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 redo log。\",\"不支持\"]},\"494\":{\"h\":\"MEMORY\",\"t\":[\"MEMORY 存储引擎使用在内存中的数据来创建表，而且所有数据都存在内存中。\",\"每个基于 memory 存储引擎的表实际对应一个磁盘文件，该文件的文件名和表名是相同的，类型为 .frm。该文件只存储表的结构，而其数据文件都是存储在内存中，这样有利于对数据的快速处理，提高整个表的处理能力。\",\"memory 存储引擎默认使用哈希 hash 索引，其速度比使用 B+Tree 型要快。：MEMORY 存储引擎用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于 MEMORY 的表的生命周期很短，一般是一次性的。 \"]},\"495\":{\"h\":\"buffer pool 缓冲池\",\"t\":[\"缓冲池是一种常见的降低磁盘访问的机制；\",\"缓冲池通常以页(page)为单位缓存数据；\",\"缓冲池的常见管理算法是LRU，memecache，OS，InnoDB都使用了这种算法；\",\"InnoDB对普通 LRU 进行了优化：MySQL缓冲池\",\"将缓冲池分为老年代和新生代，入缓冲池的页，优先进入老年代，页被访问，才进入新生代，以解决预读失效的问题；\",\"另一种情况就是，页在老年代中的停留时间超过配置阈值的，也会进入新生代，以解决批量数据访问，大量热数据淘汰（缓冲池污染）的问题。\"]},\"496\":{\"h\":\"InnoDB引擎的关键特性\",\"t\":[\"插入缓冲(insert buffer)：\",\"​ 对于非聚集索引的插入或者更新操作，不是每一次都直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中，然后再以一定的频率和情况进行Insert Buffer和辅助索引叶子节点的合并操作，这时通常将多个插入合并到一个操作中(因为在一个索引页中)，这就大大提高了对于非聚集索引插入的性能。需要满足非唯一的辅助索引条件。\",\"二次写(double write)：\",\"​ double write由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上共享表空间连续的128个页，即两个区，大小同样为2MB。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序的写入到共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题，在完成double write页的写入后，再将doublewrite buffer中的页写入到各个表空间文件中，此时的写入是离散的。\",\"自适应哈希索引：\",\"​ InnoDB会监控对表上各索引页的查询，如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称为自适应哈希索引。\",\"异步IO:\",\"​ 用户可以在发出一个IO请求后立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作的完成，这就是AIO。\",\"刷新邻接页：\",\"​ 当刷新一个脏页时，InnoDB会检测该页所在区的所有页，如果是脏页，那么一起进行刷新，这样做的好处是通过AIO可以将多个IO写入操作合并为一个IO操作。\"]},\"497\":{\"h\":\"InnoDB索引的后台线程\"},\"498\":{\"h\":\"InnoDB的逻辑存储结构\",\"t\":[\"从InnoDB存储引擎的逻辑存储结构来看，所有数据都被逻辑的存放在一个空间中，称之为表空间。表空间由段、区、页组成。\",\"段：表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。数据段即B+树的叶子节点，索引段即B+树的非叶子节点。\",\"区：区是由连续页组成的空间，在任何情况下每个区的大小都为1MB，为了保证区中页的连续性，InnoDB存储引擎一次从磁盘申请4~5个区，在默认情况下，InnoDB存储引擎页的大小为16KB，即一个区中一共有64个连续的页\",\"页：页是InnoDB磁盘管理的最小单位，在InnoDB存储引擎中，默认每个页的大小为16KB，而从InnoDB 1.2x版本开始，可以通过参数**innodb_page_size**将页的大小设置为4k，8k，16k。\",\"行：InnoDB是面向列的，即数据是按行进行存放的\"]},\"499\":{\"h\":\"MVCC多版本并发控制⭐\",\"t\":[\"​ MVCC主要是为了提高数据库并发性能，其目的是用于处理读写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。\",\"​ 它的实现原理主要是版本链(3个隐式字段)，undo log ，Read View 来实现的。它为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库快照。MVCC的本质就是对比版本。\",\"​ 三个隐式字段DB_TRX_ID最近插入的事务ID、 DB_ROLL_PTR回滚指针, DB_ROW_ID隐藏主键等字段。\",\"​ read view中的重要字段分别是： trx_list（尚未提交commit的事务版本号集合，正在活跃的事务ID列表）， up_limit_id（trx_list列表中事务ID最小的ID）， low_limit_id（目前已出现事务ID的最大值+1）以及creator_trx_id（当前的事务版本号）。\",\"​ 铺垫到这了，很容易就发现， MVCC其实就是靠「⽐对版本」来实现读写不阻塞，⽽版本的数据存在于undo log中。 ⽽针对于不同的隔离级别（read commit和repeatable read），⽆⾮就是read commit隔离级别下，每次都获取⼀个新的read view， repeatable read隔离级别则每次事务只获取⼀个read view。\",\"当前读 & 快照读\",\"当前读：读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。\",\"快照读：像不加锁的 select 操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制 ,可以认为 MVCC 是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。\",\"只有select语句才会走MVCC机制，增删改都是走当前读\",\"数据库并发场景\",\"读-读：不存在任何问题，也不需要并发控制；\",\"读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读；\",\"写-写：有线程安全问题，可能会存在更新丢失问题。\",\"MVCC的好处\",\"在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能；\",\"同时还可以解决脏读、幻读、不可重复读，但不能解决更新丢失问题。\",\"​ 数据库的隔离等级，SQL 语句和当前数据库数据会共同影响该条 SQL 执行时数据库生成的锁模式，锁类型和锁数量。\"]},\"500\":{\"h\":\"锁的分类\",\"t\":[\"在当前读的情况下，MySQL 锁分为共享锁（S 锁/读锁）、排他锁（X 锁/写锁），共享锁与排他锁之间互相排斥(读写互斥)，共享锁与共享锁之间不排斥(读读共享)，排他锁与排他锁之间互相排斥(写写互斥)。\",\"select ... lock in share mode //加共享锁，可用于读锁 select ... for update //加排他锁，可用于写锁 \",\"按照锁粒度来区分，可以分为：。\",\"按照锁的实现分为：。\"]},\"501\":{\"h\":\"不同SQL语句对加锁的影响\",\"t\":[\"不同的 SQL 语句会加不同的锁，总结起来主要分为五种情况：\",\"SELECT 语句：正常情况下为快照读，不加锁；\",\"SELECT … LOCK IN SHARE MODE ：为当前读，加 S 锁；\",\"SELECT … FOR UPDATE ：为当前读，加 X 锁；\",\"常见的 DML(数据操作语句) 语句（如 INSERT、DELETE、UPDATE）为当前读，加 X 锁；\",\"常见的 DDL(数据定义语句，库和表的管理) 语句（如 ALTER、CREATE 等）加表级锁，且这些语句为隐式提交，不能回滚。\",\"​ 其中，当前读的 SQL 语句的 where 从句的不同也会影响加锁，包括是否使用索引，索引是否是唯一索引等等。\",\"​ SQL：delete from t1 where id = 10;\",\"​ 在RC的隔离级别下：\",\"id为为主键时，sql是需要在id = 10这条记录上加X锁即可\",\"id为唯一索引时，加两把X锁，一把写锁加在id索引上id = 10的这个记录上，同时找到聚簇索引另一把x锁加到聚簇索引(假设聚簇索引为name)(name = 'd',id = 10)的记录\",\"id为非唯一索引时，在id索引上满足条件的列，均会加锁，同时这些记录在主键索引上的记录也会被加锁。\",\"id无索引时，sql会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了2PL的约束。\",\"​ 在RR隔离级别下：\",\"id为主键时，sql是需要在id = 10这条记录上加X锁即可\",\"id为唯一索引时，加两把X锁，一把写锁加在id索引上id = 10的这个记录上，同时找到聚簇索引另一把x锁加到聚簇索引(假设聚簇索引为name)(name = 'd',id = 10)的记录\",\"id为非唯一索引时(重点加gap锁)，id列上有一个非唯一索引，对应SQL：delete from t1 where id = 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，在GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。(为什么id为主键或者唯一索引时不需要加gap锁：因为gap锁的目的是防止同一事物两次当前读出现幻读(插入使两次读不一样)但一个等值查询(因为其唯一)最多只会返回一条记录(不会有新的插入进来)所以不需要加gap锁)\",\"id无索引时，在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用因为gap锁会被释放。\",\"​ 在Serializable隔离级别下\",\"​ select * from t1 where id = 10\",\"快照读不复存在都是当前读，加读锁，也就是MVCC也不存在。\"]},\"502\":{\"h\":\"InnoDB 的三种行级锁⭐\"},\"503\":{\"h\":\"Record lock(记录锁)\",\"t\":[\"​ RC 和 RR 隔离级别都有。\",\"​ 单条索引上加锁，记录锁永远锁的是索引，锁住的是key，而非数据本身，如果innodb表中没有索引，那么会自动创建一个隐藏的聚簇索引，锁住的就是这个聚簇索引。所以说当一条 sql 没有走任何索引时，那么将会在每一条聚簇索引后面加 X 锁。\"]},\"504\":{\"h\":\"Gap lock(间隙锁)\",\"t\":[\"​ 只有 RR 可重复读隔离级别才有，主要是为了解决幻读问题，因为即使你把所有的行都加上Record lock锁，一旦有别的会话插入新的记录，还有会发生幻读。\",\"​ 间隙锁，是在索引的间隙之间加上锁，锁定一个范围，不包括记录本身。\"]},\"505\":{\"h\":\"Next-key lock(行锁和间隙锁组合起来)\",\"t\":[\"​ 只有 RR 隔离级别才有。前开后闭区间。\",\"​ Record Lock+Gap Lock 可以锁定一个范围，包含记录本身。innoDB用它(Next-key lock)来解决 RR 级别下当前读存在的幻读问题。（快照读的幻读问题由 MVCC 解决）\",\"​ 默认情况下，InnoDB工作在可重复读隔离级别下，并且会以Next-Key Lock的方式对数据行进行加锁，这样可以有效防止幻读的发生。Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。\"]},\"506\":{\"h\":\"行锁的选择\",\"t\":[\"​ 主要是根据索引加锁。\",\"如果更新条件没走索引，此时会进入全表扫描，扫表的时候，要阻止其他任何的更新操作，所以会上升为表锁。\",\"如果更新条件为索引字段，但是并非唯一索引(包括主键索引)，此时更新会使用Next-Key Lock。使用Next_key Lock的原因： \",\"首先保证符合条件的记录上加上排它锁，会锁定当前非唯一索引对应的主键索引的值\",\"还要保证锁定的区间不能插入新的数据(间隙锁)\",\"如果更新条件是唯一索引，就使用Record Lock(不用这个Next-Key Lock)\",\"InnoDB根据唯一索引，找到相应记录，将主键索引值和唯一索引值加上记录锁，但不使用GapLock\"]},\"507\":{\"h\":\"按锁粒度划分\"},\"508\":{\"h\":\"全局锁\",\"t\":[\"刚刚那个说的不对，是全局锁\",\"​ 顾名思义，全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法：\",\"Flush tables with read lock (FTWRL) \",\"​ 当你需要让整个库处于只读状态的时候，可以使用这个命令。全局锁的典型使用场景是，做全库逻辑备份。\",\"​ ⾏锁实际上是作⽤在索引之上的（索引上次已经说过了，这⾥就不赘述了）。当我们的SQL命中了索引，那锁住的就是命中条件内的索引节点（这种就是⾏锁），如果没有命中索引，那我们锁的就是整个索引树（表锁）。\"]},\"509\":{\"h\":\"行锁(会出现死锁)\",\"t\":[\"​ 行级锁是 Mysql 中锁定粒度最细的一种锁，加锁开销也最大，表示只针对当前操作的行进行加锁。分为：S锁、X锁\",\"读锁(共享锁、S锁)\",\"​ 若事务 T 对数据对象 A 加上 S 锁，则事务 T **可以读 A 但不能修改 A **，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。\",\"select ... lock in share mode; \",\"写锁(排它锁、X锁)\",\"​ 若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。\",\"select ... for update \"]},\"510\":{\"h\":\"表锁\",\"t\":[\"​ 表示当前的操作对整张表加锁，资源开销比行锁少，不会出现死锁的情况，但是发生锁冲突的概率很大。\",\"共享锁： LOCK TABLE table_name [ AS alias_name ] READ 排它锁： LOCK TABLE table_name [AS alias_name][ LOW_PRIORITY ] WRITE 解锁： unlock tables; //除了主动释放锁，在客户端断开时会自动释放，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。 \"]},\"511\":{\"h\":\"元数据锁 MDL(表级锁)\",\"t\":[\"​ MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是保证读写的正确性。可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查(DML)操作的时候，加 MDL 读锁；当要对表做结构变更操作(DDL)的时候，加 MDL 写锁。\",\"读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。\",\"读写锁之间，写锁之间是互斥的。以此来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。\"]},\"512\":{\"h\":\"\",\"t\":[\"​ 页级锁的锁定粒度介于行级锁和表级锁中间，一次锁定相邻的一组记录。\"]},\"513\":{\"h\":\"悲观锁与乐观锁\",\"t\":[\"悲观锁\",\"​ 在对任意记录进行修改前，先尝试为该记录加上 X 锁。如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。一般通过数据库的锁机制实现\",\"优缺点：\",\"​ 悲观锁实际上是采取了“先取锁再访问”的策略，为数据的处理安全提供了保证，但是在效率方面，由于额外的加锁机制产生了额外的开销，并且增加了死锁的机会。并且降低了并发性；当一个事物所以一行数据的时候，其他事物必须等待该事务提交之后，才能操作这行数据。\",\"使用场景：主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。\",\"乐观锁\",\"​ 乐观锁认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则给用户返回错误的信息，让用户决定如何去做。相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般通过记录数据版本、CAS来实现。\",\"优缺点：\",\"​ 乐观并发控制相信事务之间的数据竞争的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。\",\"使用场景：\",\"​ 多数用于数据争用不大、冲突较少的环境中，这种环境中，偶尔回滚事务的成本会低于读取数据时锁定数据的成本，因此可以获得比其他并发控制方法更高的吞吐量。\"]},\"514\":{\"h\":\"意向锁\",\"t\":[\"InnoDB 支持多粒度锁，它允许行级锁与表级锁共存。意向锁就是其中一种不与行级锁冲突的表级锁，分为两种：\",\"意向共享锁（IS）：事务有意向对表中的某些行加 S 锁。\",\"意向排他锁（IX）：事务有意向对表中的某些行加 X 锁。\",\"//事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 SELECT column FROM table ... LOCK IN SHARE MODE; //事务要获取某些行的 X 锁，必须先获得表的 IX 锁。 SELECT column FROM table ... FOR UPDATE; \",\"意向锁是由存储引擎自己维护的，用户无法手动操作意向锁，在为数据行加 S 锁或 X 锁 之前，InnoDB 会先获取该数据行所在数据表的对应意向锁。\",\"意向锁的作用？\",\"​ 举个例子，如果表中记录1亿，事务 A 把其中有几条记录上了行锁了，这时事务 B 需要给这个表加表锁，那么就需要去表中查找这1亿条记录是否上锁了。意向锁的作用就是，事务Ａ在加行锁之前，先加意向锁，再加Ｘ锁。事务 B 会检查该表上是否存在意向锁，存在的意向锁是否与自己准备加的锁冲突，如果有冲突，则等待直到事务Ａ释放，而无须逐条记录去检测。事务Ｂ更新表时，其实无须知道到底哪一行被锁了，它只要知道反正有一行被锁了就行了。\"]},\"515\":{\"h\":\"InnoDB加锁规则\",\"t\":[\"两个原则，两个优化，一个BUG：\",\"原则一：加锁的单位是 next-key lock，是前开后闭的区间。\",\"原则二：查询过程中访问到的对象才会加锁。\",\"优化一：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁(record Lock)。\",\"优化二：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。\",\"bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。\"]},\"516\":{\"h\":\"死锁⭐\",\"t\":[\"死锁现象\",\"​ 在 MySQL 的并发读写场景中，当两个及以上的事务，各事务都在等待对方释放已经持有的锁或因为加锁顺序不一致造成循环等待锁资源，就会出现 “死锁”。\",\"当出现死锁以后，有两种策略：\",\"锁超时等待。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。\",\"死锁检测(常用)：发现死锁后，主动回滚某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。InnoDB 目前处理死锁的方法是将持有最少行级 X 锁的事务进行回滚。\",\"避免死锁\",\"合理设计索引，区分度高的列放到组合索引前面，使业务 SQL 尽可能通过索引定位更少的行，减少锁竞争；\",\"调整业务逻辑 SQL 执行顺序，避免 update/delete 长时间持有锁的 SQL 在事务前面；\",\"避免大事务，尽量将大事务拆成多个小事务来处理，小事务发生锁冲突的概率也更小；优化 SQL 和表设计，减少同时占用太多资源的情况，如：减少连接的表，将复杂 SQL 分解为多个简单的 SQL；\",\"如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会；\",\"在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；\",\"对于非常容易产生死锁的业务部分，可以尝试使用表锁；\",\"设置 innodb_lock_wait_timeout 。\"]},\"517\":{\"h\":\"分布式锁\",\"t\":[\"MySQL 中提供了两个函数来实现分布式锁：\",\"get_lock('key',timeout) // 加锁，在timeout时间内获取锁 release_lock('key') // 释放锁 \",\"可以根据 key 来加锁，这是一个字符串，可以设置超时时间，当调用 release_lock('key') 或者客户端断开连接时释放锁。\",\"使用方法如下：\",\"//如果 10s 之内获取到锁则返回 1，否则返回 0 mysql> select get_lock('user_1', 10); -> 1 //如果该锁是当前客户端持有的则返回 1，如果该锁被其它客户端持有着则返回 0，如果该锁没有被任何客户端持有则返回 null mysql> select release_lock('user_1'); -> 1 \"]},\"518\":{\"h\":\"何为数据库事务？\",\"t\":[\"​ 平时，我们在谈论事务的时候，如果没有特指分布式事务，往往指的就是数据库事务。\",\"数据库事务有什么作用呢？\",\"​ 简单来说：数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：要么全部执行成功,要么全部不执行 。\"]},\"519\":{\"h\":\"事务的 ACID 特性\",\"t\":[\"原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；原⼦性由undo log⽇志来保证，因为undo log记载着数据修改前的信息。\",\"一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；一致性可以理解为我们使用事务的目的，而隔离性、原子性、持久性是为了保障一致性的手段。比如在事务发生过程中出现了异常，此时就得回滚事务而不是强行提交事务来导致数据不一致。\",\"隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；\",\"持久性（Durabilily）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。就是数据持久化在硬盘上。\",\"InnoDB 是怎么保证 ACID 特性的？\",\"InnoDB 引擎使用 redo log（WAL方式）保证事务的持久性，使用 undo log(回滚日志) ，以及两阶段提交机制来保证事务的原子性。\",\"InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。\",\"保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。\"]},\"520\":{\"h\":\"事务状态\",\"t\":[\"活跃状态：事务的第一个状态，任何正在执行的事务都处于此状态，所做的更改存储在主内存的缓冲区中。\",\"部分提交状态：执行上次操作后，事务进入部分提交状态。之所以是部分提交，是因为所做的更改仍然在主内存的缓冲区中。\",\"失败状态：如果某个检查在活动状态下失败，在活动状态或部分提交状态发生一些错误，并且事务无法进一步执行，则事务进入失败状态。\",\"中止状态：如果任何事务已达到失败状态，则恢复管理器将数据库回滚到开始执行的原始状态。\",\"提交状态：如果所有操作成功执行，则来自部分提交状态的事务进入提交状态。无法从此状态回滚，它是一个新的一致状态。\"]},\"521\":{\"h\":\"并发事务的问题⭐\",\"t\":[\"脏读（Dirty read）: A 事务读取 B 事务尚未提交的数据，此时如果 B 事务发生错误并执行回滚操作，那么 A 事务读取到的数据就是脏数据。\",\"丢失修改（Lost to modify）: 当两个或多个事务选择同一行，最初的事务修改值，会被后面的事务修改的值覆盖。\",\"不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务修改了该数据，导致事务 A 两次读到的数据是不一样的。\",\"幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\"]},\"522\":{\"h\":\"事务的四个隔离级别⭐\",\"t\":[\"READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。数据库一般都不会用，而且任何操作都不会加锁。\",\"READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。\",\"REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。MySQL默认采用 RR 隔离级别。\",\"SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。读加共享锁，写加排他锁，读写互斥。\",\"隔离级别\",\"脏读\",\"不可重复读\",\"幻读\",\"READ-UNCOMMITTED 读未提交\",\"√\",\"√\",\"√\",\"READ-COMMITTED 读已提交\",\"×\",\"√\",\"√\",\"REPEATABLE-READ 可重复读\",\"×\",\"×\",\"√\",\"SERIALIZABLE 可串行化\",\"×\",\"×\",\"×\"]},\"523\":{\"h\":\"RR 级别下如何解决幻读\",\"t\":[\"在 RR 和 RC 级别下，数据库的读分为快照读和当前读。\",\"快照读：不加锁的 select 操作（连 S读 锁都不加），读取的是快照（ReadView）中的数据，可能是历史数据。\",\"当前读：增删改以及加了 S 锁的查，读取的总是当前的最新数据。\",\"RR 级别下幻读的问题，我觉得要分快照读和当前读两种情况来讨论：\",\"​ 对于快照读，RR 中一个事务的所有快照读，读取的都是同一份快照（MVCC 机制），所以无论其他的事务怎么修改，无论是更新还是插入删除，都不会影响当前事务的快照读结果，也就不会出现不可重复读、幻读的情形。\",\"​ 对于当前读，你读取的行，以及行的间隙都会被加锁，直到事务提交时才会释放，其他的事务无法进行修改，所以也不会出现不可重复读、幻读的情形。\",\"​ 快照读，通过 MVCC 来避免幻读；当前读，通过 \\\"Next-key lock\\\" 来避免幻读。\",\"​ 事务之所以会出现 \\\"幻读\\\"，是因为先进行了一次快照读，读取了历史数据，再进行了一次当前读（insert row with id = 1)，读取最新数据，这样当然会出现幻读了。\"]},\"524\":{\"h\":\"事务的隔离级别都是如何实现的\",\"t\":[\"在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。\",\"读未提交：直接返回记录上的最新值，没有视图概念。\",\"读已提交：这个视图是在每个 SQL 语句开始执行的时候创建的。\",\"可重复读：这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。\",\"串行化：直接用加锁的方式来避免并行访问。\"]},\"525\":{\"h\":\"为什么尽量不要使用长事务？\",\"t\":[\"​ 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。\",\"​ 在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。当时看《MySQL45讲》里面有个例子说是数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。\"]},\"526\":{\"h\":\"事务的启动方式\",\"t\":[\"MySQL 的事务启动方式有以下几种：\",\"显式启动事务语句， begin transaction 或 start transaction 。配套的提交语句是 commit，回滚语句是 rollback。\",\"set autocommit=0，这个命令会将这个线程的自动提交关掉。有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。因此，建议总是使用 set autocommit=1, 通过显式语句的方式来启动事务。\"]},\"527\":{\"h\":\"索引相关语法\",\"t\":[\"ALTER TABLE 表名 ADD 索引类型(index/unique/primary key) 索引名(可以省略) (字段名, 字段名) create index <索引名称> on 表名(要建立索引的字段) #可用于对表增加普通索引或唯一索引 show index from table_name #查看索引 drop index index_name on table_name #删除索引 \",\"​ 添加索引\",\"​ 删除索引\"]},\"528\":{\"h\":\"何为索引\",\"t\":[\"索引是一种用于快速查询和检索数据的数据结构。索引的作用就相当于目录的作用。\",\"常见的索引结构有：B树、B+树和Hash。MySQL默认是B+树（包括MyISAM 引擎和 InnoDB 引擎）。\",\"优点：\",\"使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。\",\"通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\",\"在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。\",\"可以加速表和表之间的连接，一般是在外键上创建索引。\",\"缺点：\",\"创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。\",\"索引需要使用物理文件存储，也会耗费一定空间。\"]},\"529\":{\"h\":\"为啥加了索引，查询会变快\",\"t\":[\"​ 因为索引使用了B+树数据结构来存储，利用二分查找二等原理，有效减少了磁盘IO的次数，所以查询会变快。\"]},\"530\":{\"h\":\"索引应该何时使用\"},\"531\":{\"h\":\"需要创建索引的情况：\",\"t\":[\"1.主键，自动建立唯一索引 2.频繁作为查询的条件的字段 3.查询中与其他表关联的字段存在外键关系 4.查询中排序的字段，排序字段若通过索引去访问将大大提高排序的速度 5.查询中统计或者分组字段\"]},\"532\":{\"h\":\"避免创建索引的情况：\",\"t\":[\"1.数据唯一性差的字段不要使用索引 比如性别，只有两种可能数据。意味着索引的二叉树级别少，多是平级。这样的二叉树查找无异于全表扫描。\",\"2.频繁更新的字段不要使用索引 比如登录次数，频繁变化导致索引也频繁变化，增大数据库工作量，降低效率。\",\"3.字段不在where语句出现时不要添加索引 只有在where语句出现，mysql才会去使用索引\",\"4.数据量少的表不要使用索引 使用了改善也不大\"]},\"533\":{\"h\":\"建立索引的几大原则⭐\",\"t\":[\"（复合索引）最左前缀匹配原则： \",\"mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a=1 and b=2 and c>3 and d=4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的（但是可以索引下推优化），如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。\",\"= 和 in可以乱序，比如b=1 and a=2 and c=3 建立(a,b,c)索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式。\",\"尽量选择区分度高的列作为索引。\",\"索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。\",\"尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。\"]},\"534\":{\"h\":\"不走索引(索引失效)\",\"t\":[\"复合索引未用左列字段，索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。\",\"对于多个范围条件查询，MySQL 无法使用第一个范围列后面的其他索引列，对于多个等值查询则没有这种限制。\",\"like，以%开头\",\"隐式类型转换、隐式字符编码转换\",\"where中索引列有运算、使用了函数\",\"mysql觉得全表扫描更快时\"]},\"535\":{\"h\":\"索引优化\",\"t\":[\"为索引列选择合适的数据类型\",\"越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和 CPU 缓存中占用空间更少，处理起来更快\",\"简单的数据类型更好：整形数据比起字符，处理开销更小\",\"主键整型最好\",\"尽量避免 NULL，含有 NULL 的列做统计和查询优化很麻烦\",\"一般原则\",\"经常同时存储多列，且每列都含有重复值可考虑建组合索引，其前导列一定是使用最频繁的列\",\"建立索引的列不为 NULL\",\"只要列中包含有 NULL 值都将不会被包含在索引中，因此，在数据库设计时尽量不要让字段的默认值为 NULL\",\"使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量磁盘空间和 I/O 操作\",\"明确知道只会返回一条记录，加上 limit 1，存储引擎会在找到 1 条结果停止搜索，而不是继续查询下一条是否符合标准，提高了性能\",\"建立了联合索引，查询条件一定要符合最左前缀原则才能使用到索引\",\"不要在索引列上进行运算或使用函数，否则会使索引失效，从而进行全表扫描\",\"前导模糊查询不会使用索引\",\"更新太频繁的字段不适合创建索引\"]},\"536\":{\"h\":\"选错索引\",\"t\":[\"优化器选择索引的逻辑\",\"​ 优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句，在数据库里面，扫描行数是影响执行代价的因素之一。（当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。）扫描行数是怎么判断的呢？\",\"​ MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。这个统计信息就是索引的“区分度”，一个索引上不同的值越多，区分度就越好，而一个索引上不同的值的个数称之为“基数”，这个基数越大，索引的区分度越好。（使用show index可以看到一个索引的基数）MySQL 是怎样得到索引的基数的呢？MySQL中InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。\",\"​ 归根结底，MySQL选错索引是因为没能准确判断出扫描行数。\",\"索引选择异常的处理\",\"第一种方式是，采用force index强行选择一个索引。问题是一旦索引改了名字，这个语句也得改。\",\"第二种方式是，可以考虑修改语句，引导MySQL使用我们期望的索引。\",\"第三种方式是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。\"]},\"537\":{\"h\":\"哈希索引\",\"t\":[\"​ 基于哈希表实现。哈希索引将所有数据行的 hash 值存储在索引表中，同时在哈希表中保存指向每个数据行的指针。对于 hash 值相同的，采用链表的方式解决哈希冲突，类似于 HashMap。\",\"哈希索引能以 O(1) 时间进行查找，但是失去了有序性：\",\"哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序\",\"只支持精确查找，无法用于模糊查找和范围查找。\",\"如果哈希冲突很多，索引维护代价很高。\",\"查询流程如下： SELECT lname FROM testhash WHERE fname='Peter'; MySQL 先计算 'Peter' 的哈希值，并使用该值寻找对应的记录指针。因为 f('Peter')=8784，所以 MySQL 在索引中查找 8784，可以找到指向第三行的指针，最后一步是比较第三行的值是否是 'Peter'，以确保就是要查找的行。 \",\"自适应 哈希索引\",\"​ InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+ 树索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如：O(1) 的查找。\"]},\"538\":{\"h\":\"B+ Tree索引\",\"t\":[\"​ B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，通过顺序访问指针来提高区间查询的性能。\",\"​ MySQL 索引的数据结构对经典的 B+ 树进行了优化。在原来 B+ 树的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+ 树，提高区间访问的性能。\",\"操作\",\"​ 进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。\",\"​ 插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。\"]},\"539\":{\"h\":\"B+ 树能存多少数据\",\"t\":[\"​ 这里我们先假设 B+ 树高为2，即存在一个根节点和若干个叶子节点，那么这棵 。（这里假设一行记录的数据大小为 1K，实际上现在很多互联网业务数据记录大小通常就是 1K 左右）。\",\"​ 我们假设主键 ID 为 int 类型，长度为 4 字节，而指针大小在 InnoDB 源码中设置为 6 字节，这样一共 10 字节，一个非叶子节点可以存放 16384/10 = 1638个指针记录。那么可以算出一棵高度为 2的 B+ 树，能存放 1638*16 = 26208 条这样的数据记录。\",\"​ 根据同样的原理我们可以算出一个高度为 3 的 B+ 树可以存放：1638 × 1638 × 16 = 42928704 条这样的记录。。\",\"​ 在查找数据时一次页的查找代表一次 IO，所以通过主键索引查询通常只需要 1~3 次 IO 操作即可查找到数据。\",\"B+ 树可存多少行数据？\",\"​ 计算机中磁盘最小存储单元是扇区，一个扇区的大小是 512 字节，文件系统最小存储单元是块，一个块的大小是 4K，InnoDB 存储引擎最小存储单元是页，一个页的大小是 16 K。数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？假设一行数据的大小是 1K，那么一个页可以存放 16 行这样的数据。\"]},\"540\":{\"h\":\"B+树和其它的比较\"},\"541\":{\"h\":\"为什么使用B+树\",\"t\":[\"1.B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快 2.B+树查询速度更稳定：B+所有关键字数据地址都存储在叶子节点上，所以每次查找的次数都相同，所以查询速度要比B树更稳定 3.B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时更方便，数据紧密型很高，缓存的命中率也会比B树高。 4.B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描\",\"为什么索引不使用二叉树结构？\",\"​ 我们对自增长列建立索引，它是单边增长结构，就相当于链表，查询仍然是从头到尾，与整表扫描没有区别。\",\"为什么索引不使用红黑树？\",\"​ 红黑树每个节点出度最多为2，假设一张表几十w，几百w的数据，随着数据量越大，树的高度越来越高，效率很低。一般来说，一次IO能存入一个节点(因为一次IO只能访问一个数据块)\",\"为什么索引不使用 Hash 索引？\",\"哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序\",\"仅仅适用于精确查找，不支持范围查询和模糊查询\",\"如果发生 hash 冲突，索引维护代价很高，效率可能极差\",\"为什么索引不使用 B 树？\",\"B+ 树内节点不存储 data，使得每个节点中能够存放更多的 key，可以使得树更矮，IO 操作次数更少\",\"B+ 树的查询效率更加稳定，B 树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短\",\"B+ 树的叶子节点使用指针顺序连接在一起，提高了区间访问性能，B+树所有叶子节点构成了一个有序链表，在查询大小区间的数据时候更方便\"]},\"542\":{\"h\":\"B+树叶子结点数目是确定的吗？\",\"t\":[\"​ 因为索引是以B+树节点的形式存储在硬盘的每个页中的，而硬盘的最小存储单位页的大小通常是固定的（约4KB），因此用页的大小除每个节点的大小，就可以得出每个节点的子节点数的近似值（对于非叶子结点，每个节点只存储了主键和一个存储了子节点指针的列表，因此大小是已知的，而叶子节点就很难确定了）。\"]},\"543\":{\"h\":\"磁盘IO与预读 & 局部性原理\",\"t\":[\"​ 数据库磁盘IO，访问数据文件，数据文件由多个数据块(数据库访问磁盘数据的基本单位)组成，一次IO只能访问一个数据块。\",\"磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分。 \",\"寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下。\",\"旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms。\",\"传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相比前两个可忽略不计。\",\"那么一次磁盘IO的时间大概是9ms左右，一台500-MIPS的机器同时间可以执行40万条指令。所以磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。\"]},\"544\":{\"h\":\"索引分类\"},\"545\":{\"h\":\"主索引和辅助索引\",\"t\":[\"InnoDB 存储引擎有两大类索引：\",\"主索引/聚簇索引：InnoDB 聚簇索引的叶子节点保存了行数据，InnoDB 有且只有一个聚簇索引。\",\"普通索引/辅助索引：InnoDB 普通索引的叶子节点存储主键值，以及指向主键的指针。\"]},\"546\":{\"h\":\"聚簇索引和非聚簇索引\",\"t\":[\"聚簇索引：索引字段+全部其他表字段保存在一个文件中，将索引结构与数据放到了一块，索引表的叶子节点保存了行数据，索引项的顺序与表中记录的物理顺序一致。 \",\"聚簇索引不是人为创建的，默认是主键，一个表只能有一个。\",\"如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替。\",\"如果没有这样的索引，InnoDB 会在内部生成一个名为 GEN_CLUST_INDEX 的隐式的聚簇索引。\",\"非聚簇索引：索引字段和表中全量字段分两个文件进行保存，索引树的叶子节点(存放的不是数据本身，而是存放数据的地址)中存储对应全量数值在磁盘上的地址；将索引结构与数据分开存储，索引表的叶子节点保存了行的物理地址，它指向了对应的行数据，表数据存储顺序与索引顺序无关。\"]},\"547\":{\"h\":\"索引类型(按物理分类)\",\"t\":[\"在Innodb下主键索引是聚集索引，在Myisam下主键索引是非聚集索引\",\"聚簇索引： 聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。 将数据存储与索引放到了一块，找到索引也就找到了数据，不需要根据主键或行号去进行回表查询。\",\"​ 一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为 NULL 的唯一索引，如果还是没有的话，就采用 Innodb 存储引擎为每行数据内置的 6 字节 ROWID 作为聚集索引。\",\"​ InnoDB中的辅助索引： 在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值，以及指向主键值的指针；通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。\",\"非聚簇索引：\",\"​ MyISAM存储引擎中：非聚簇索引就是指B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。主要用在MyISAM存储引擎中**.MyISAM引擎使用B+Tree作为索引结构，叶子节点的data域存放的是数据记录的地址**。MyISAM(使用的是非聚簇索引)的主键索引与辅助键索引的区别就是，主键索引是唯一的，辅助索引可以不是。\"]},\"548\":{\"h\":\"索引类型(按常规功能/逻辑分类)\",\"t\":[\"普通索引：仅加速查询\",\"唯一索引：加速查询 + 列值唯一（可以有null）\",\"主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个\",\"全文索引：对文本的内容进行分词，进行搜索\",\"索引类型(按是否建立在主键上分类)\",\"主键索引：\",\"​ 在MySQL的主键上创建的索引就是主键索引，主键索引会自动创建，一个表只能有一个主键索引，同时主键索引也是唯一索引。**一个没加主键的表，它的数据无序的放置在磁盘的存储器上，一行一行排列的很整齐，如果给表加上了主键，表在磁盘上的存储结构就变成了树状结构(B+树)，换句话说，整个表就变成了一个索引。**主键的作用就是把表的数据格式转换为”树(索引)“的格式。\",\"辅助索引： 在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，innodb中辅助索引叶子节点存储的不再是行的物理位置，而是键值和主键 ID。\",\"索引类型(按底层数据结构分类)\",\"哈希索引\",\"B+树索引\"]},\"549\":{\"h\":\"回表查询\",\"t\":[\"普通索引无法直接定位行记录，通常情况下，需要扫描两遍索引树，这样的查询叫 “二级索引“ 或 “回表查询”：\",\"先通过普通索引定位到主键值\",\"再由主键值通过聚簇索引定位到行记录\",\"缺点：需要扫描两次 B+ 树，性能较扫一遍索引树更低\",\"​ 辅助/二级索引属于非聚簇索引，叶子节点存储主键值，每次查找数据时，根据索引找到叶子中的主键值，根据主键值再到聚簇索引中得到完整的行记录，也就是回表查询。\",\"​ 聚簇索引的叶子节点存储了一行完整的数据，而二级索引只存储了主键值，相比于聚簇索引，占用的空间更少。当我们为表建立多个索引时，如果都是聚簇索引，那将占用大量内存空间，所以 InnoDB 中主键所建立的是聚簇索引，而唯一索引、普通索引等都是二级索引。\"]},\"550\":{\"h\":\"覆盖索引\",\"t\":[\"​ 即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录，称为覆盖索引，即只需扫描索引而无须回表。覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引不存储索引列的值，所以mysql只能用B+tree索引做覆盖索引。\",\"​ 如何实现覆盖索引？常见的方法是：将被查询的字段，建立到联合索引里去。\",\"​ 因为我们建立的是联(复)合索引，所以就是非聚簇索引，非聚簇索引的叶子节点上会存放键的值，也就是我们的(b,c,d) 这三个字段，还会存放主键a字段用于回表操作。\",\"是不是覆盖索引失效一定会做回表查询？\",\"​ 不一定，因为回表是因为在聚簇索引的叶子节点里才有数据，如果存储引擎使用的是MyISAM，就不用回表，直接根据对应的叶子地址去查询数据。\"]},\"551\":{\"h\":\"联合索引\",\"t\":[\"​ 对多个字段同时建立的索引。以联合索引 (a，b，c) 为例，将相当于创建了三个索引 a | a,b| a,b,c，减少开销，但不支持 b,c 进行查找。正因为联合索引的b值可能没有顺序，所以用联合索引的时候很容易写出索引失效的语句。\"]},\"552\":{\"h\":\"最左前缀原则\"},\"553\":{\"h\":\"索引下推\",\"t\":[\"mysql> select * from tuser where name like '张 %' and age=10 and ismale=1; //name和age建立了联合索引 \",\"假如在5.6版本之前，会忽略 age 字段，直接通过 name 进行查询，假如在(name, age)上查到了两条结果，id分别为1、2，然后拿着这两个id一次次的回表查询。\",\"MySQL 5.6 引入的索引下推优化，不会忽略age字段，而是直接在索引内部对 age 进行判断，直接过滤掉不满足条件的记录，减少回表次数。主要是针对不满足最左前缀的部分。\"]},\"554\":{\"h\":\"前缀索引\",\"t\":[\"MySQL是支持前缀索引的，也就是说，可以定义字符串的一部分作为索引。如果不指定前缀索引，那么索引就是整个字符串。\",\"alter table User add index index1(email); #整个email字符串作为索引 alter table User add index index2(email(6)); #只取前6位字符作为索引 \",\"优点：占用的空间更小\",\"缺点：可能会额外增加记录扫描的次数\"]},\"555\":{\"h\":\"唯一索引与普通索引的速度比较\",\"t\":[\"​ 假设，执行查询的语句是 select id from T where k=5。这个查询语句在索引树上查找的过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点，然后可以认为数据页内部通过二分法来定位记录。\",\"对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。\",\"对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。\",\"​ 那么，这个不同带来的性能差距会有多少呢？答案是，微乎其微。而且由于唯一索引用不上 change buffer 的优化机制，因此如果业务可以接受，从性能角度出发优先考虑非唯一索引。\"]},\"556\":{\"h\":\"Explain 查看执行计划⭐\",\"t\":[\"​ 使用 Explain 命令来查看语句的执行计划，MySQL 在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息。可以通过其中和索引有关的信息来分析是否命中了索引。\",\"字段\",\"含义\",\"id\",\"操作表的顺序，id 值越大，优先级越高，越先执行\",\"select_type\",\"查询类型，主要用于区别普通查询，联合查询，子查询等的复杂查询。常见取值：SIMPLIE（单表查询，不使用表连接或子查询）、PRIMARY（查询中若包含任何复杂的子查询，最外层查询标记为该标识）、SUBQUERY（select 或 where 列表中包含了子查询）、DERIVED（from 列表中的子查询，把结果放在临时表中）\",\"显示访问类型，显示查询使用了何种类型\",\"possible_key\",\"查询时可能使用到的索引\",\"key\",\"查询时实际使用到的索引\",\"ref\",\"显示索引的哪一列被使用了，如果有可能是一个常数，哪些列或常量被用于查询索引列上的值\",\"根据表统计信息以及索引选用情况，大致估算出找到所需的记录所需要读取的行数\",\"Extra\",\"Using index：使用覆盖索引会出现；Using index condition：查找使用了索引，但还需要回表查询\",\"一般来说， 我们需要保证查询至少达到 range 级别， 最好达到 ref。按照从最佳到最坏类型排序：\",\"const：使用主键或非 NULL 的唯一索引，查询结果只有一条，同时优化过程中查询列值会转成常量\",\"eq_ref：使用唯一索引，多表关联查询出的记录只有一条\",\"ref：非唯一性索引查询出一条或多条记录\",\"range：使用索引进行行范围查询，where 后面出现 between、<、>、in、or 等操作\",\"index：遍历索引树，如：explain select id from t_user。通常比all快，因为索引文件比数据文件小很多。\",\"ALL：未使用索引，全表扫描\"]},\"557\":{\"h\":\"MySQL 问题排查的手段\",\"t\":[\"慢查询日志：将执行时间超过设定时间的 SQL 语句写到慢查询日志中，然后分析慢查询日志；\",\"show variables like '%quer%'; #查询慢查询是否开启以及日志存储位置等 set global slow_query_log=1; #开启慢查询-- 这不是永久开启 重启mysql回到原来设置 set global long_query_time=3; # 修改慢查询时间为3秒 \",\"show profiles：分析出最近几次执行的 SQL 语句耗时情况，可以进一步根据 Query_ID 来查看 sql 具体执行步骤；\",\"show processlist：实时查看 SQL 执行情况。这个没用过。\"]},\"558\":{\"h\":\"show profiles\",\"t\":[\"​ show profile 用来分析 sql 性能的消耗 。例如查询到 SQL 会执行多少时间，并显示 CPU、内存使用量，执行过程中系统锁及表锁的花费时间等信息。例如 SHOW PROFILE CPU/MEMORY/BLOCK IO FOR QUERY N 分别查询 id 为 N 的 SQL 语句的 CPU、内存以及 IO 的消耗情况。\",\"​ 当用 explain 无法解决慢 SQL 的时候，需要用shwo profile 来对 sql 进行更细致的分析，找出 sql 所花的时间大部分消耗在哪个部分，确认 sql的性能瓶颈。\"]},\"559\":{\"h\":\"慢查询\",\"t\":[\"[为什么我只查一行的语句，也执行这么慢？ ](file:///C:/Users/Administrator/Desktop/%E5%B0%8F%E7%B1%B3%E4%BA%91%E7%9B%98/Java/Java%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/mysql%20%E6%9E%81%E5%AE%A245%E8%AE%B2/mysql/%E5%AE%9E%E8%B7%B5%E7%AF%87/19%E4%B8%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%9F%A5%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%B9%9F%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F.html)\",\"原因\",\"等刷脏页：InnoDB在处理更新语句时，先写内存再写redo log，并不会立即将数据页的更新落地到磁盘（WAL机制），这就会产生升内存数据页和磁盘数据页的数据不一致的情况，这种数据不一致的数据页称为脏页，当脏页写入到磁盘（这个操作称为flush）后，数据一致后称为干净页\",\"等行锁：由于访问 id=1 这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我们的 select 语句就会被堵住\",\"undo log：\",\"select * from t where id = 1; # session A update t set c=c+1 where id = 1; # session B ,执行100000次 select * from t where id = 1 lock in share mode; # session C # 假如 B 在事务之间执行，那么： # C 会执行很快，因为 C 是当前读，会直接读到 100001 这个结果 # A 是执行性读，因此需要从 100001 开始，依次执行 B 生成的100000个 undolog，执行了100000次之后才将 1 返回，所以很慢 \",\"没加索引、选错索引\",\"思路\",\"通过慢查询日志去寻找哪些 SQL 执行效率低\",\"使用 explain 获取低效率 SQL 执行计划\",\"引起 SQL 很慢的原因与解决办法\",\"首先分析语句，看看是否加载了额外的数据，可能是查询了多余的行并且抛弃掉了, 可能是加载了许多结果中并不需要的列, 以此对语句进行分析以及重写\",\"分析语句的执行计划, 然后获得其使用索引的情况, 之后修改语句或者修改索引, 使得语句可以尽可能的命中索引\",\"如果对语句的优化已经无法进行, 可以考虑表中的数据量是否太大, 如果是的话可以进行横向或者纵向的分表\"]},\"560\":{\"h\":\"SQL 优化\",\"t\":[\"SQL 优化我们抓住 3 个点：最大化利用索引，尽可能避免全表扫描，减少无效数据的查询\",\"为搜索字段创建索引\",\"避免使用 select *，列出需要查询的字段\",\"单表数据量过大，分库分表\",\"尽量避免使用 in 和 not in，导致引擎走全表扫描\",\"尽量避免在字段开头模糊查询，导致索引失效\",\"如果是子查询，可以用 exists 代替；如果是连续数值，可以用 between 代替\",\"尽量避免使用 or，可能会导致索引失效。可以用 union 代替 or\",\"在一条 SQL 语句插入多条数据，减少 SQL 语句解析次数，减少 IO 次数，提高效率\",\"优化 order by，我们要尽量减少额外的排序，通过索引覆盖方式直接返回有序数据\"]},\"561\":{\"h\":\"千万级大表的优化\",\"t\":[\"​ 除非单表数据未来会一直不断上涨，否则不要一开始就考虑分库分表，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。事实上很多时候 MySQL 单表的性能依然有不少优化空间。\",\"优化顺序：\",\"优化 sql 和索引\",\"加缓存：redis\",\"主从复制 & 读写分离\",\"mysql 分区表\",\"垂直拆分：先垂直拆分，按照业务将表进行分类，分布到不同的数据库上面，这样使得数据库更加合理，如果一开始使用水平拆分，那么后面会增加垂直拆分的复杂度。\",\"水平拆分\"]},\"562\":{\"h\":\"CPU 使用率飙升\",\"t\":[\"第一步：使用top -h查看 cpu 的使用情况，观察是不是 mysql 占用导致的。\",\"第二步：如果是mysql导致的，查看当前所有连接信息，看是不是有消耗资源的sql在运行。\",\"第三步：找出消耗高的sql，利用explain看看执行计划是否准确，index是否缺失，或者是数据量太大造成的。\",\"第四步：开启慢查询日志，查看慢查询的 SQL。\",\"第五步：优化处理\",\"​ 一般肯定要kill掉这些线程，同时观察CPU使用率是否下降，进行相应调整之后，再重新跑这些 sql。\",\"​ 也有可能是每个 sql 消耗资源并不多，但是突然中间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起分析为何连接数会激增，再做出相应的调整，比如限制连接数等等。\"]},\"563\":{\"h\":\"IO性能瓶颈怎么解决\",\"t\":[\"可以考虑以下三种方法：\",\"设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，减少 binlog 的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。\",\"将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。这样做的风险是，主机掉电时会丢 binlog 日志。\",\"将 innodb_flush_log_at_trx_commit 设置为 2。这样做的风险是，主机掉电的时候会丢数据。\"]},\"564\":{\"h\":\"批量导入1000万数据？\",\"t\":[\"减少IO次数\",\"SQL写法优化，一条SQL语句插入多条数据\",\"合理设置批量大小\",\"尽量顺序插入， 减少索引的维护压力\"]},\"565\":{\"h\":\"怎么加快插入速度\",\"t\":[\"一次插入多条数据\",\"insert into table values('11','11'),('22','22'),('33','33')...; \",\"改写所有 insert into 语句为 insert delayed into\",\"这个insert delayed不同之处在于：立即返回结果，后台进行处理插入。\",\"加大 mysql 配置中的 bulk_insert_buffer_size，这个参数默认为 8M\",\"自动事务提交关掉，批量提交后再提交事务。\"]},\"566\":{\"h\":\"MySQL 普通日志\",\"t\":[\"错误日志（error_log）\",\"记录 MySQL 服务器运行过程中的错误信息。\",\"二进制日志（bin log）\",\"记录了所有 DML 和 DDL 语句，但不包括查询语句，此日志对于非常重要。\",\"由于日志以二进制方式存储，不能直接读取，需要使用 mysqlbinlog 工具查看。\",\"日志格式\",\"说明\",\"STATEMENT\",\"每一条对数据进行修改的 SQL 都会记录在日志文件中\",\"ROW\",\"记录的是每一行的数据变更，而不是记录 SQL 语句\",\"MIXED \",\"混合了 STATEMENT 和 ROW 两种格式，能够综合利用两者优点\",\"查询日志（general_log）\",\"记录了客户端所有的查询语句，而二进制日志不包含查询数据的 SQL 语句。\",\"慢查询日志（slow_query_log）\",\"记录了所有执行时间超过参数 long_query_time 值的 SQL 语句，long_query_time 默认为 10s。\",\"中继日志（relay_log）\",\"主从复制时使用的日志。\"]},\"567\":{\"h\":\"MySQL 事务日志⭐\",\"t\":[\"InnoDB 事务日志包括 redo log 和 undo log，redo log 是重做日志，undo log 是回滚日志。\"]},\"568\":{\"h\":\"redo log\",\"t\":[\"​ redo log 包括两部分：内存中的日志缓存（redo log buffer）和磁盘上的日志文件（redo log file）。redo log 会把事务执行过程中对表的修改操作都记录下来，系统崩溃后可以把事务所做的任何操作都恢复出来。有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力成为crash-safe。\",\"engine层物理日志，innodb特有\",\"记录对数据的更改内容。固定大小的几个文件，循环写。\",\"对于数据的修改，先统一在redo log中记录下来，不管是否页在内存中，都暂时不需要写入磁盘。（WAL）\",\"日志满了时，将前一部分同步到磁盘，然后擦除该部分后继续使用。\",\"​ 当我们在事务中尝试对数据进行更改，并不是马上写入磁盘，而是先将记录写入 redo log buffer，根据刷新机制，再将重做日志缓冲刷新到磁盘上的重做日志文件，最后再把内存中的数据变动同步到磁盘上。\",\"redo log 可能存在的三种状态\",\"存在 redo log buffer 中，物理上是在 MySQL 进程内存中，就是图中的红色部分；\",\"写到磁盘 (write)，但是没有持久化（fsync)，物理上是在文件系统的 page cache 里面，也就是图中的黄色部分；\",\"持久化到磁盘，对应的是 hard disk，也就是图中的绿色部分。\",\"redo log 的写入机制\",\"​ 日志写到 redo log buffer 是很快的，wirte 到 page cache 也差不多，但是持久化到磁盘的速度就慢多了。为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数：\",\"设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;\",\"设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；\",\"设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。\",\"​ InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。注意，事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些 redo log 也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的 redo log，也是可能已经持久化到磁盘的。实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的 redo log 写入到磁盘中。\",\"一种是，redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。\",\"另一种是，并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。\"]},\"569\":{\"h\":\"WAL\",\"t\":[\"​ WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。\"]},\"570\":{\"h\":\"undo log\",\"t\":[\"​ engine层逻辑日志，innodb特有。用于数据库的回滚操作以及 MVCC 查询老版本数据。undo log 保存数据提交之前的版本，即存储的是老版本数据。这样在发生错误时，就能回滚到事务之前的数据状态。\",\"​ 在数据修改时，不仅记录了 redo，还记录了相对应的 undo，当由于某些原因导致事务执行失败，则可以根据 undo log 日志恢复到更改之前的状态。\"]},\"571\":{\"h\":\"bin log\",\"t\":[\"​ binlog，即二进制日志，它记录了数据库上的所有改变，并以二进制的形式保存在磁盘中，追加写。是server层逻辑日志，各个引擎都能用。它可以用来查看数据库的变更历史、数据库增量备份和恢复、Mysql的复制（主从数据库的复制）。\",\"binlog的写入机制：\",\"​ 事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。一个事务的 bin log 是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。\",\"​ 系统给 binlog cache 分配了一片内存，每个线程一个，参数binlog_cache_size用于控制单个线程内binlog cache所占内存的大小，如果超过这个参数规定的大小，就要暂存到磁盘。事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache。\",\"可以看到：每个线程有自己 binlog cache，但是共用同一份 binlog 文件。\",\"write 和fsync的时机，是由参数sync_binlog控制的：\",\"sync_binlog=0的时候，表示每次提交事务都只write，不fsync(持久化)；\",\"sync_binlog=1的时候，表示每次提交事务都会执行fsync；\",\"sync_binlog=N(N>1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。\",\"在出现 IO 瓶颈的场景里，将 sync_binlog 设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成 0，比较常见的是将其设置为 100~1000 中的某个数值。但是，将 sync_binlog 设置为 N，对应的风险是：如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。\"]},\"572\":{\"h\":\"bin log的三种格式\",\"t\":[\"三种格式：\",\"Statement：每一条会修改数据的sql都会记录在binlog中。\",\"**优点：**不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。\",\"**缺点：**由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同的结果。\",\"Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。\",\"**优点：**binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。\",\"**缺点：**所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。\",\"Mixedlevel: 以上两种level的混合使用。\",\"一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。\",\"新版本的MySQL中对row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。\"]},\"573\":{\"h\":\"redo log 与 bin log 的区别\",\"t\":[\"redo log是InnoDB引擎特有的，只记录该引擎中表的修改记录。binlog是MySQL的Server层实现的，会记录所有引擎对数据库的修改。\",\"redo log是物理日志，记录的是在具体某个数据页上做了什么修改；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。\",\"redo log是循环写的，空间固定会用完；binlog是可以追加写入的，binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\"]},\"574\":{\"h\":\"change buffer\",\"t\":[\"​ 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。\",\"​ 需要说明的是，虽然名字叫做change buffer，实际上它是可以持久化的数据，也就是说change buffer在内存中有拷贝，也会被写入到磁盘上。\",\"​ 将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge，在数据库正常关闭的过程中，也会执行merge操作。\",\"​ 唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。\",\"唯一索引和普通索引对数据的更新过程\",\"这个记录要更新的目标页就在内存中 \",\"对于唯一索引来说，找到位置之后，判断有没有冲突，插入这个值，语句执行结束。\",\"对于普通索引来说，找到位置之后，直接插入这个值，语句执行结束。\",\"这个记录要更新的目标页不在内存中 \",\"对于唯一索引来说，需要将数据页读入内存，判断有没有冲突，插入这个值，语句执行结束。\",\"对于普通索引来说，则是将更新记录在change buffer中，语句执行就结束了。\",\"change buffer的使用场景\",\"​ 因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所在一个数据页做merge之前，change buffer记录的变更越多，收益就越大。\",\"​ 因此对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好；反之，假设一个业务的更新模式是写入之后马上会做查询，那么即时满足了条件，将更新先记录到change buffer，但之后由于马上要访问这个数据页，会立刻触发merge过程，这样随机IO的次数不会减少，反而增加了change buffer的维护代价。\",\"Insert Buffer\",\"非唯一辅助索引的插入操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个 Insert buffer 对象中，然后再以一定的频率和情况进行 Insert buffer 和辅助索引页子节点的 merge 操作，这样能将多个插入合并到一个操作中，提高了性能。\"]},\"575\":{\"h\":\"区分redo log和change buffer\",\"t\":[\"redo log主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。\",\"前者是日志文件，后者主要是内存中\",\"修改数据时，如果数据页已经在内存中，只写redo log。不在内存中，才会同时写change buffer和redo log\"]},\"576\":{\"h\":\"怎样让数据库恢复某时刻状态\",\"t\":[\"​ binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。\",\"​ 当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。\"]},\"577\":{\"h\":\"为什么同时需要binlog/redo log\",\"t\":[\"​ Crash-Safe是指：数据库在宕机重启后能够保证：所以已经提交的事务的数据依然存在，所有没有提交的事务的数据自动回滚。\",\"​ 因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。\"]},\"578\":{\"h\":\"为什么日志需要“两二阶段提交”？\",\"t\":[\"​ 这里不妨用反证法来进行解释。由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。用于解决了数据一致性的问题。\",\"先写 redo log 直接提交，然后写 binlog，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。\",\"先写 binlog，然后写 redo log，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据与原库不一样，出现数据不一致的情况。\",\"​ 如果采用 redo log 两阶段提交的方式就不一样了，写完 binlog 后，然后再提交 事务 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设事务 处于预提交状态，binlog 也已经写完了，这个时候发生了异常重启会怎么样呢？这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：\",\"判断 redo log 是否完整，如果判断是完整的，就立即提交。\",\"如果 事务 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 事务, 不完整就回滚事务。\"]},\"579\":{\"h\":\"主从复制、读写分离的优点\",\"t\":[\"​ 主从复制、读写分离一般是一起使用的。目的很简单，就是为了提高数据库的并发性能。你想，假设是单机，读写都在一台MySQL上面完成，性能肯定不高。如果有三台MySQL，一台mater只负责写操作，两台salve只负责读操作，性能不就能大大提高了吗？\",\"​ 所以主从复制、读写分离就是为了数据库能支持更大的并发。随着业务量的扩展、如果是单机部署的MySQL，会导致I/O频率过高。采用主从复制、读写分离可以提高数据库的可用性。\"]},\"580\":{\"h\":\"主从复制的原理\",\"t\":[\"​ 主从复制并不是复制磁盘上的数据库文件，而是通过binlog日志复制到需要同步的从服务器上。MySQL数据库支持单向、双向、链式级联等不同业务场景的复制。在复制的过程中，一台服务器当主服务器（Master），接收来自用户的内容更新，而一个或多个其它的服务器来当从服务器（Slaver），接收来自Master上binlog文件的的日志内容，解析出SQL,重新更新到Slave，使得主从服务器的数据达到一致。\",\"①当Master节点进行insert、update、delete操作时，会按顺序写入到binlog中。\",\"②salve从库连接master主库，Master有多少个slave就会创建多少个binlog dump线程。\",\"③当Master节点的binlog发生变化时，binlog dump 线程会通知所有的salve节点，并将相应的binlog内容推送给slave节点。\",\"④I/O线程接收到 binlog 内容后，将内容写入到本地的 relay-log。\",\"⑤SQL线程读取I/O线程写入的relay-log，并且根据 relay-log 的内容对从数据库做对应的操作。\"]},\"581\":{\"h\":\"涉及的线程\",\"t\":[\"binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。\",\"I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。\",\"SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。\"]},\"582\":{\"h\":\"主从同步的延迟原因\",\"t\":[\"原因：\",\"​ 假如一个服务器开放 Ｎ 个连接给客户端，这样有会有大并发的更新操作, 但是从服务器的里面读取 binlog 的线程仅有一个， 当某个 SQL 在从服务器上执行的时间稍长或者由于某个 SQL 要进行锁表就会导致主服务器的 SQL 大量积压，未被同步到 slave 里。这就导致了主从不一致， 也就是主从延迟。\",\"主从同步延迟的解决办法：\",\"​ 实际上主从同步延迟根本没有什么一招制敌的办法， 因为所有的 SQL 必须都要在从服务器里面执行一遍，但是主服务器如果不断的有更新操作源源不断的写入，那么一旦有延迟产生，那么延迟加重的可能性就会原来越大。当然我们可以做一些缓解的措施。\",\"我们知道因为主服务器要负责更新操作， 它对安全性的要求比从服务器高，所有有些设置可以修改，比如sync_binlog=1，innodb_flush_log_at_trx_commit = 1 之类的设置，而 slave 则不需要这么高的数据安全，完全可以将 sync_binlog 设置为 0 (不持久化)或者关闭 binlog、innodb_flushlog、innodb_flush_log_at_trx_commit 也 可以设置为 0 来提高 SQL 的执行效率。\",\"增加从服务器，这个目的还是分散读的压力， 从而降低服务器负载。\"]},\"583\":{\"h\":\"分库分表\",\"t\":[\"​ 数据库中的数据量不一定是可控的，随着时间和业务的发展，库中的表会越来越多，表中的数据量也会越来越大，相应地数据操作，例如 增删改查的开销 也会越来越大；另外，若不进行分布式部署，而一台服务器的 资源 （CPU、磁盘、内存、IO 等）是有限的，最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈。所以，从 性能 和 可用性 角度考虑，会进行数据库拆分处理，具体地说，把原本存储于一个库的数据分块存储到多个库上，把原本存储于一个表的数据分块存储到多个表上，即 分库分表。\"]},\"584\":{\"h\":\"分库与分表的选择\",\"t\":[\"​ 不管是IO瓶颈，还是CPU瓶颈，最终都会导致数据库的活跃连接数增加，进而逼近甚至达到数据库可承载活跃连接数的阈值。在业务Service来看就是，可用数据库连接少甚至无连接可用。接下来就可以想象了吧（并发量、吞吐量、崩溃）。\",\"IO瓶颈\",\"第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -> 分库和垂直分表。\",\"第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 -> 分库。\",\"CPU瓶颈\",\"第一种：SQL问题，如SQL中包含 join，group by，order by，非索引字段条件查询等，增加CPU运算的操作 -> SQL优化，建立合适的索引，在业务Service层进行业务计算。\",\"第二种：单表数据量太大，查询时扫描的行太多，SQL效率低，CPU率先出现瓶颈 -> 水平分表。\"]},\"585\":{\"h\":\"水平切分和垂直切分？\",\"t\":[\"​ 切分的目的：减少数据库负担，缩短查询时间\",\"​ 数据库分布式核心内容无非就是数据切分，以及切分后对数据的定位、整合。数据切分就是将数据分散存储到多个数据库中，使得单一数据库中的数据量变小，通过扩充主机的数量缓解单一数据库的性能问题，从而达到提升数据库操作性能的目的。\",\"水平切分(IO瓶颈)\",\"​ 水平切分是将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，水平切分是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力。\",\"​ 水平切分分为库内分表和分库分表，根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果。\",\"水平分表\",\"​ 和垂直分表有一点类似，不过垂直分表是基于列的，而水平分表是基于全表的。水平拆分可以大大减少单表数据量，提升查询效率。这里的水平分表指的是在一个数据库进行的库内分表。\",\"​ 库内分表只解决了单一表数据量过大的问题，但没有将表分布到不同机器的库上，因此对于减轻MySQL数据库的压力来说，帮助不是很大，大家还是竞争同一个物理机的CPU、内存、网络IO，最好通过分库分表解决。\",\"水平分库分表\",\"​ 将单张表的数据切分到多个服务器上去，每个服务器具有相同的库和表，只是表中数据集合不同。水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。\",\"水平拆分的优缺点\",\"优点：\",\"不存在单库数据量过大，高并发的性能瓶颈，提升系统稳定性和负载能力\",\"应用端改造较小，不需要拆分业务模块\",\"缺点：\",\"ACID被打破，跨分片的事务一致性难以保证\",\"跨库的join关联查询性能较差\",\"数据多次扩展难度和维护量极大\",\"靠外键进行约束的场景会受到影响\",\"依靠单库的自增ID会受到影响\",\"垂直切分(CPU瓶颈)\",\"​ 垂直切分常见的有两种垂直分库和垂直分表\",\"垂直分库：**将系统中的不同业务进行拆分，**例如商品一个库，订单一个库，用户一个库。若不拆分，每次访问都是落到单一的库上，这使得单库的处理能力成为瓶颈。若分库后将他们放到一个服务器上，这样虽然会减少单库的压力，但随着用户量增大，还是会让整个数据库处理能力成为瓶颈，还有单个服务器的磁盘空间、内存也会受非常大的影响。将其拆分到多个服务器上，问题便可解决。\",\"垂直分表：也就是大表拆小表，是基于列字段进行的。一般将不常用的，数据较大，长度较长(比如text类型字段)的字段数据差分到扩展表。Mysql底层是通过数据页存储的，一条记录占用空间过大会导致跨页(页溢出)，造成额外的性能开销(IO操作变多)。另外数据库以页为单位将数据加载到内存中，而页中存储的是行数据，页大小固定，一行占用空间越小，页中存储的数据就越多。这样表中字段长度较短且访问频率较高，内存能加载更多的数据，内存命中率更高，减少了磁盘IO提升数据库性能。\",\"垂直拆分的优缺点：\",\"优点： \",\"解决业务系统层面的耦合，业务清晰\",\"与微服务的治理类似，也能对不同的业务的数据进行分级管理、维护、监控、扩展等\",\"高并发情况下，垂直切分一定程度的提升IO、数据库连接数、单机硬件资源的瓶颈\",\"缺点： \",\"部分表无法join(拆分后，数据库可能是分布式在不同的实例和不同的主机上，join将会很麻烦)，只能通过接口聚合方式解决，提高了开发的复杂度\",\"单机的ACID被打破，需要引入分布式事务，而分布式事务处理比较复杂\",\"依然存在单表数据量过大的问题(需要水平切分)\",\"靠 外键约束的场景会受到影响\"]},\"586\":{\"h\":\"数据库分片的两种常见方案\",\"t\":[\"客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。\",\"中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现\"]},\"587\":{\"h\":\"常见的分库分表的策略\",\"t\":[\"根据数据范围切分\",\"按照时间区间或ID区间来切分。例如：按日期将不同月甚至是日的数据分散到不同的库中；将userId为1~9999的记录分到第一个库，10000~20000的分到第二个库，以此类推。某种意义上，某些系统中使用的\\\"冷热数据分离\\\"，将一些使用较少的历史数据迁移到其他库中，业务功能上只提供热点数据的查询，也是类似的实践。围路由设计的复杂点主要体现在分段大小的选取上，分段太小会导致切分后子表数量过多增加维护复杂度，分段太大可能会导致单表依然存在性能问题，按一般大老们的经验，分段大小100W至2000W之间，具体需要根据业务选 取合适的分段大小。\",\"优点： \",\"单表大小可控\",\"天然便于水平扩展，后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移\",\"使用分片字段进行范围查找时，连续分片可快速定位分片进行快速查询，有效避免跨分片查询的问题。\",\"缺点： \",\"热点数据成为性能瓶颈。连续分片可能存在数据热点，例如按时间字段分片，有些分片存储最近时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询。有些时候会猛访问个别服务器上的库，导致其性能瓶颈。\",\"hash切分\",\"一般采用hash取模mod的切分方式，例如：将 Customer 表根据 cusNo 字段切分到4个库中，余数为0的放到第一个库，余数为1的放到第二个库，以此类推。这样同一个用户的数据会分散到同一个库中，如果查询条件带有cusno字段，则可明确定位到相应库去查询。再比如说有用户表user,将其分成3个表user0,user1,user2.路由规则是对3取模,当uid=1时,对应到的是user1,uid=2时,对应的是user2.\",\"优点： \",\"数据分片相对比较均匀，不容易出现热点和并发访问的瓶颈\",\"缺点： \",\"后期分片集群扩容时，需要迁移旧的数据（使用一致性hash算法(一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，只有部分缓存会失效，不至于将所有压力都在同一时间集中到后端服务器上，具有较好的容错性和可扩展性)能较好的避免这个问题），否则会导致历史数据失效。\",\"容易面临跨分片查询的复杂问题。比如上例中，如果频繁用到的查询条件中不带cusno时，将会导致无法定位数据库，从而需要同时向4个库发起查询，再在内存中合并数据，取最小集返回给应用，分库反而成为拖累。\"]},\"588\":{\"h\":\"数据库分片常用的分片的方法\",\"t\":[\"查询切分\",\"将ID和库的Mapping关系记录在一个单独的库中。\",\"优点：ID 和库的 Mapping 算法可以随意更改。 缺点：引入额外的单点\",\"范围切分\",\"比如按照时间区间或ID区间来切分\",\"优点：单表大小可控，天然水平扩展。 缺点：无法解决集中写入瓶颈的问题。\",\"hash切分\",\"一般采用Mod来切分 ，易于水平扩展\"]},\"589\":{\"h\":\"分库分表后带来的问题\",\"t\":[\"当更新内容同时分布在不同库中，不可避免会带来跨库事务问题。跨分片事务也是分布式事务，没有简单的方案，一般可使用\\\"XA协议\\\"和\\\"两阶段提交\\\"处理。\",\"解决方案： \",\"使用分布式事务中间件\",\"使用MySQL自带的针对跨库的事务一致性方案(XA)不过性能要比单库的慢10倍左右\",\"跨库跨表的join\",\"跨节点的count，order by，group by以及聚合函数的问题\",\"数据迁移，容量规划，扩容等问题\",\"ID问题：不能再依赖数据库自身的主键生成机制，无法保证全局唯一，使用UUID做主键\"]},\"590\":{\"h\":\"页面\"},\"591\":{\"h\":\"页\",\"t\":[\"​ 页是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。存放我们常用的表中记录的那种类型的页，官方称这种存放记录的页为 索引（ INDEX ）页，而这些表中的记录就是我们日常所称的 数据 ，所以目前还是叫这种存放记录（数据）的页为 数据页。InnoDB 都是以页为单位存放数据的。\"]},\"592\":{\"h\":\"脏页与干净页\",\"t\":[\"​ 当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的内容就一致了，成为“干净页”。不论是脏页还是干净页，都在内存中。平时执行很快的更新操作，其实就是在写内存和日志，而MySQL偶尔“抖”一下的那个瞬间，可能就是在刷页（flush）。\"]},\"593\":{\"h\":\"刷页（两次写）\",\"t\":[\"​ 在刷脏页时，并不是直接刷入磁盘，而是copy到内存中的Doublewrite Buffer中，然后再拷贝至磁盘共享表空间（可以理解为磁盘）中，每次写入1M，等copy完成后，再将Doublewrite Buffer中的页写入磁盘文件。\",\"​ 有了两次写机制，即使在刷脏页时宕机了，在实例恢复的时候也可以从共享表空间中找到Doublewrite Buffer的页副本，直接将其覆盖原来的数据页即可。\"]},\"594\":{\"h\":\"什么时候会引发数据库刷页\",\"t\":[\"第一种情况：InnoDB的redo log写满了，这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。\",\"第二种情况：系统内存不足，当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。\",\"第三种情况：MySQL认为系统“空闲”的时候。\",\"第四种情况：MySQL正常关闭的时候。\",\"上述场景对性能的影响\",\"第一种：出现这种情况，整个系统就不能再接受更新了，所有的更新都必须堵住。\",\"第二种：这种情况其实是常态。\",\"InnoDB用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：\",\"还没有使用的。\",\"使用了并且是干净页。\",\"使用了并且是脏页。\",\"InnoDB的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。\",\"而当要读入的数据页没有再内存的时候，就必须到缓冲池中申请一个数据页，这时候只能把最久不使用的数据页从内存中淘汰掉；如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页，就必须先刷到磁盘，变成干净页之后才能复用。\",\"第三种和第四种：这两种情况系统的压力都没有。\"]},\"595\":{\"h\":\"sql注入\",\"t\":[\"SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。\"]},\"596\":{\"h\":\"#{ } 和 ${ } 区别？\",\"t\":[\"#{}是jdbc预编译处理，变量替换在DBMS中，${}是字符串替换，替换阶段是SQL解析阶段。\",\"#{key}：获取参数的值，预编译到 SQL 中，可简单理解为一个占位符 “？”，有效防止 SQL 注入，安全。\",\"${key}：获取参数的值，拼接到 SQL 中，存在 SQL 注入问题，不安全。表名作为变量时，必须使用${ }，因为占位符进行替换变量后会加上单引号(表名为字符串，sql占位符替换字符串时会带上单引号’ ‘)，而表名是不能加单引号的(``反引号可以)\"]},\"597\":{\"h\":\"sql预编译\",\"t\":[\"​ 定义: sql预编译是指数据库驱动在发送sql语句和参数给DBMS之前会对sql语句进行编译，这样DBMS执行sql时，就不需要重新编译。\",\"​ 为什么需要预编译：JDBC中使用对象PreparedStatement来抽象预编译语句，使用预编译。预编译阶段可以优化sql的执行，预编译之后的sql多数情况下可以直接执行，DBMS不需要再次编译，越复杂的sql，编译复杂度将越大，预编译阶段可以合并多次操作作为一个操作。预编译语句对象可以重复利用。把一个 sql 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个sql，可以直接使用这个缓存的 PreparedState 对象。mybatis 默认情况下，将对所有的 sql 进行预编译。\"]},\"598\":{\"h\":\"查询语句\"},\"599\":{\"h\":\"创建表(插入语句)\"},\"600\":{\"h\":\"分支结构中的case when\"},\"601\":{\"h\":\"一、评论系统设计\",\"t\":[\"评价系统数据库设计与实现\",\"​ 在以评论为主的树形结构中，数据库的设计非常灵活，可以是单表设计，每个评论都有一个parent_id指向父评论。还可以分开为两个表，评论一张表，对评论的回复是另一张表。\",\"假如使用的是单表设计，以新闻系统举例：\",\"评价表：\",\"create table if not exists comments ( commentId bigint auto_increment primary key, newsId bigint not null, parentId bigint, content text not null, userId bigint not null, date timestamp default current_timestamp(), foreign key (parentID) references comments (commentId), # parentID 指向父评论 foreign key (userID) references users (userId), # userID 指向users表 foreign key (newsID) references news (newsId) # newsID 指向news表 ) charset = utf8mb4; \",\"查询语句：\",\"#从 comments 和 users 表中通过 newsId 查找信息 SELECT a.commentId,a.newsId,a.parentId,a.newsId,a.content,a.date FROM comments AS a, users AS b WHERE a.newsId=#{newsId} AND a.userId=b.userId \"]},\"602\":{\"h\":\"Redis\"},\"603\":{\"h\":\"Redis 应用场景\",\"t\":[\"​ Redis (Remote Dictionary Server )，即远程字典服务，是一个开源的使用 ANSIC 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库并提供多种语言的 API。\",\"应用场景\",\"缓存热点数据：将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。\",\"限时业务的运行使用：使用 expire 设置键的过期时间。利用这一特性可以运用在手机验证码、限时优惠活动信息等业务场景。\",\"计数器：Redis 由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动，分布式序列号的生成。\",\"分布式锁：在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以借助 Redis 的 setnx 命令，来保证不同节点的线程同步执行。\",\"查找表、会话缓存：例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。\",\"消息队列（list）、共同推荐好友（放在 set 中，取交集）、排行榜（zset）、聊天室（发布订阅）。\"]},\"604\":{\"h\":\"Redis 为什么这么快 ⭐\",\"t\":[\"完全基于内存，绝大多数的请求都是纯内存操作。\",\"采用了单线程（因为 Redis 的性能瓶颈不在于 CPU，而是内存和网络带宽），从而避免了不必要的上下文切换和竞争条件。不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。(Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能比如持久化、异步删除、集群数据同步等是由额外线程执行的)\",\"数据结构优化很好，包括结构本身以及操作的时间空间复杂度。数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的。\",\"采用非阻塞-I/O 多路复用机制，提高了网络 IO 的并发性(再说一下 IO，Redis 使用的是非阻塞 IO，IO 多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争)。在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字，内核会一直监听这些套接字上的连接请求和数据请求，一旦有请求到达，在交给 Redis 线程处理，从而实现一个 Redis 线程处理多个 IO 流的效果。\",\"使用底层模型不同，其底层实现方式，以及与客户端通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，普通情况下的系统调用，会浪费一定的时间去移动和请求。\"]},\"605\":{\"h\":\"为什么要用 Redis\"},\"606\":{\"h\":\"为什么要用 Redis/为什么要用缓存\",\"t\":[\"提一下现在 web 应用的现状\",\"二八定律：80%的业务集中在 20%的数据上\",\"在日常的 Web 应用对数据库的访问中，读操作的次数远超写操作，所以需要读的可能性是比写的可能大得多的。当我们使用 SQL 语句去数据库进行读写操作时，数据库就会 去磁盘把对应的数据索引取回来，这是一个相对较慢的过程。\",\"使用 Redis 缓存带来的优势\",\"主要从“高性能''和”高并发“两点来看这个事情\",\"高性能\",\"假如用户第一次访问数据库中的某些数据，这个过程会比较慢，因为是从硬盘上读取的\",\"将该用户要访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度比较快\",\"如果数据库中的对应数据改变之后，同步改变缓存中相应的数据即可\",\"高并发\",\"直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求就会到缓存这里而不用经过数据库。\",\"也要提一下使用缓存的考虑\",\"但是使用内存进行数据存储开销也是比较大的，限于成本 的原因，一般我们只是使用 Redis 存储一些 常用和主要的数据，比如用户登录的信息等。\",\"一般而言在使用 Redis 进行存储的时候，我们需要从以下几个方面来考虑：\",\"业务数据常用吗？命中率如何？ 如果命中率很低，就没有必要写入缓存；\",\"该业务数据是读操作多，还是写操作多？ 如果写操作多，频繁需要写入数据库，也没有必要使用缓存；\",\"业务数据大小如何？ 如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；\",\"在考虑了这些问题之后，如果觉得有必要使用缓存，那么就使用它！\"]},\"607\":{\"h\":\"说说有哪些本地缓存解决方案\",\"t\":[\"1. JDK 自带的 HashMap 和 ConcurrentHashMap了。\",\"ConcurrentHashMap 可以看作是线程安全版本的 HashMap ，两者都是存放 key/value 形式的键值对。但是，大部分场景来说不会使用这两者当做缓存，因为只提供了缓存的功能，并没有提供其他诸如过期时间之类的功能。\",\"一个稍微完善一点的缓存框架至少要提供：过期时间、淘汰机制、命中率统计这三点。\",\"2. Ehcache 、 Guava Cache 、Spring Cache这三者是使用的比较多的本地缓存框架。\",\"Ehcache 的话相比于其他两者更加重量。不过，相比于 Guava Cache 、Spring Cache来说， Ehcache 支持可以嵌入到 hibernate 和 mybatis 作为多级缓存，并且可以将缓存的数据持久化到本地磁盘中、同时也提供了集群方案（比较鸡肋，可忽略）。\",\"Guava Cache 和Spring Cache两者的话比较像。\",\"Guava 相比于 Spring Cache 的话使用的更多一点，它提供了 API 非常方便我们使用，同时也提供了设置缓存有效时间等功能。它的内部实现也比较干净，很多地方都和ConcurrentHashMap的思想有异曲同工之妙。\",\"使用 Spring Cache 的注解实现缓存的话，代码会看着很干净和优雅，但是很容易出现问题比如缓存穿透、内存溢出。\",\"3.Caffeine\",\"相比于 Guava来说 Caffeine 在各个方面比如性能要更加优秀，一般建议使用其来替代 Guava。并且， Guava 和 Caffeine 的使用方式很像！\",\"本地缓存固然好，但是缺陷也很明显，比如多个相同服务之间的本地缓存的数据无法共享。\"]},\"608\":{\"h\":\"Redis 和 Guava Cache 的缓存是深拷贝还是浅拷贝\",\"t\":[\"Redis 缓存是深拷贝\",\"从 Redis 中获取缓存时，系统中的数据对象是 Redis 缓存的副本。 对该对象的任何操作都不会影响 Redis 中的缓存，后续再次获取还是修改之前的数据。除非执行 Redis 的更新操作。\",\"Guava 本地缓存直接获取则是浅拷贝\",\"以获取一个 MAP 为例：如果直接从缓存中取，则是浅拷贝。 对缓存数据的任何操作都会同时修改缓存中的数据，下次从缓存中获取则是修改之后的数据。\"]},\"609\":{\"h\":\"为什么不用本地缓存？\",\"t\":[\"​ 缓存分为本地缓存和分布式缓存，自带的 map 或 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，而且在多实例的情况下，每个实例都保存了一份缓存，缓存不具有一致性，即有以下两点局限性：\",\"本地缓存对分布式架构支持不友好，比如同一个相同的服务部署在多台机器上的时候，各个服务之间的缓存是无法共享的，因为本地缓存只在当前机器上有。\",\"容量跟随服务器限制明显。\"]},\"610\":{\"h\":\"Redis 和 Memcached 比较\",\"t\":[\"共同点 ：\",\"都是基于内存的缓存。\",\"都有过期策略。\",\"两者的性能都非常高。\",\"区别 ：\",\"Redis 支持更丰富的数据类型（支持更复杂的应用场景）。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。\",\"Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memecache 把数据全部存在内存之中。\",\"Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。\",\"Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的.\",\"Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。 （Redis 6.0 引入了多线程 IO ）\",\"Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。\",\"value 大小：Redis 可以达到 1GB，而 memcache 只有 1MB\"]},\"611\":{\"h\":\"多路 IO 复用/Redis 线程模型\",\"t\":[\"​ Redis 内部使用文件事件处理器file event handler。这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。事件分派器每次从事件队列中取出一个事件，把该事件交给对应的事件处理器进行处理。\",\"文件事件处理器的结构包含 4 个部分：\",\"多个 socket 套接字\",\"IO 多路复用程序\",\"文件事件分派器\",\"事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）\"]},\"612\":{\"h\":\"epoll\",\"t\":[\"1/29\",\"socket 一般不支持重复读取，当有数据被读之后，接受缓冲区就会将其移出。\",\"socket 利用 ip 地址和端口号，使用 tcp/udp 协议进行通信，在通信两端分别有文件描述符来描述接收和发送缓冲区管道，fifo 利用文件描述符。管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递\",\"socket 有一个文件描述符，两个缓冲区。管道有两个文件描述符，分别对应一个缓冲区的读端和写端。\",\"1/29\",\"​ epoll 通过两个方面，很好解决了 select/poll 的问题\",\"epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的 Socket 通过 epoll_ctl()函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删查的时间复杂度为 O(logn)，通过对这颗红黑树进行操作，就不需要像 select/poll 每次操作时都传入整个 Socket 集，只需传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。\",\"epoll 使用事件驱动的机制，内核里维护了一个链表来记录就绪事件，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事件发⽣的⽂件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，⼤⼤提⾼了检测的效率。\"]},\"613\":{\"h\":\"边缘触发和水平触发\",\"t\":[\"使⽤边缘触发(epoll 特有)模式时，当被监控的 Socket 描述符上有可读事件发⽣时， 服务器端只会从 epoll_wait 中苏醒⼀次，即使进程没有调⽤ read 函数从内核读取数据，也依然只苏醒⼀次，因此我们程序要保证⼀次性将内核缓冲区的数据读取完； 搭配非阻塞 IO 使用。效率高，因为减少 epoll_wait 的系统调用次数，系统调用是有一定开销的(毕竟有上下文的切换)\",\"ET 是高速工作方式，只支持 no-block socket。\",\"使⽤⽔平触发模式时，当被监控的 Socket 上有可读事件发⽣时， 服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束，⽬的是告诉我们有数据需要读取；\"]},\"614\":{\"h\":\"Redis 键值对结构组织(全局哈希表)\",\"t\":[\"​ 为了实现键到值的快速访问，Redis 使用了与一个哈希表(全局哈希表)来保存所有键值对。哈希桶中的键值对元素保存了 key 和 value 指针，分别指向了实际的键和值，这样一来，即使是一个集合，也可以通过 value 指针被查找到。\",\"​ 哈希表的最大好处，就是让我们可以用 O（1）的时间复杂度来快速查找到键值对--我们可以通过计算键的哈希值，就可以知道它所对应的哈希桶的位置，就可以访问响应的 entry 元素。\"]},\"615\":{\"h\":\"哈希 hash 冲突(渐进式 rehash)\",\"t\":[\"​ 使用两个全局哈希表，哈希表 1 和哈希表 2，一开始插入数据时，默认使用哈希表 1，此时哈希表 2 没有被分配空间，随着数据逐步增多：\",\"给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；\",\"把哈希表 1 的数据重新映射到哈希表 2 中(不是一下子全复制)，此时 Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带将这个索引位置上的所有键值对拷贝到哈希表 2 中，等处理下一个请求时，再顺带拷贝哈希表 1 中下一个索引位置的键值对。\",\"直到拷贝完毕，释放哈希表 1 空间\",\"​ 这样巧妙地把一次性大量的拷贝开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。\"]},\"616\":{\"h\":\"Redis5 种基本数据类型(数据结构)\",\"t\":[\"Redis 主要有 5 种基本数据类型，包括 String，List，Set，Zset，Hash。\"]},\"617\":{\"h\":\"String\",\"t\":[\"String 有三种不同的编码方式：\",\"基本编码方式是 RAW，是基于 SDS 实现，他会申请两次内存空间，第一次是申请 redisobject，第二次是申请 SDS 的内存空间\",\"存储的 SDS 长度小于 44 字节，会采用 EMBSTR编码，此时对象头(RedisObject)与 SDS 是一段连续空间，申请内存时只需要调用一次内存分配函数，效率更高。\",\"如果存储的字符串时整数，并且大小在 Long_MAX 范围内，采用INT 编码：直接将数据保存在 RedisObject 的 ptr 指针位置(刚好 8 字节)，不再需要 SDS 了。\"]},\"618\":{\"h\":\"List\",\"t\":[\"​ 3.2 版本以前当元素数量小于 512 并且元素大小小于 64 字节时采用 ZipList 编码，超过则采用 LinkedList 编码。\",\"​ 3.2 版本以后 List 采用的是 QuickList 也就是双向链表(LinkedList)+压缩链表(ZipList)结合来实现 List。\"]},\"619\":{\"h\":\"Set\",\"t\":[\"​ Set 是 Redis 中的集合，不一定确保元素有序，可以满足元素唯一、查询效率要求极高。\",\"为了查询效率和唯一性，set 采用 Dict 实现。Dict 的 key 用来存储元素，value 统一为 null\",\"当存储的所有数据都是整数，并且元素数量不超过 set-max-IntSet-entries 时，Set 会采用 Intset 实现，以节省内存(基于数组实现，内存空间连续节省内存)。\"]},\"620\":{\"h\":\"ZSet(Sorted Set)\",\"t\":[\"​ ZSet 也就是 SortedSet，其中每一个元素都需要制定一个 score 值和 member 值：\",\"可以根据 score 值排序\",\"member 必须唯一\",\"可以根据 member 查询分数\",\"​ Zset 底层数据结构必须满足键值存储、键必须唯一和可排序这三个需求。使用 SkipList+hash(Dict)来实现。\"]},\"621\":{\"h\":\"底层数据结构\"},\"622\":{\"h\":\"hash\",\"t\":[\"​ hash 的底层主要采用字典 dict 的结构，整体呈现层层封装。\",\"​ dict 有四部分组成，分别是 dictType(类型，不咋重要),dictht（核心），rehashidx(渐进式 hash 的标志)，iterators（迭代器），这里面最重要的就是 dictht 和 rehashidx。\",\"​ dictht，其有两个数组构成，**一个是真正的数据存储位置，还有一个用于 hash 过程，包括的变量分别是真正的数据 table 和一些常见变量。关于数据节点，每个节点都有 next 指针，方便指向下一个节点，这样目的是为了解决 hash 碰撞。**具体的可以看下图。\",\"Redis hash 是一个string 类型的 filed 和 value 的映射表。其添加、删除操作都是 O(1)。\",\"hash 适合用于存储对象。相较于把对象的每个字段存成单个 string 类型，将一个对象存储在 hash 类型中会占用更少的内存，且可以更方便的存取整个对象。\",\"省内存的原因：新建一个 hash 对象时开始是用**zipmap（又称 small hash）**来存储的。zipmap 并不是 hash table，但是相比正常的 hash 实现可以节省不少 hash 本身需要的一些元数据存储开销。zipmap 的添加、删除、查找都是 O(n)，所以如果 field 或者 value 的大小超出一定限制后，Redis 会在内部自动将 zipmap 替换成正常的 hash 实现。这个限制可以在配置文件中指定：hash-max-zipmap-entries 64 #配置字段最多64个、hash-max-zipmap-value 512#配置value最大为512字节。\"]},\"623\":{\"h\":\"字典(Dict)\",\"t\":[\"​ Dict 由三部分组成，分别是：哈希表(DictHashTable)(哈希表中有存放哈希节点的数组 dictEntry[])、哈希节点(DictEntry)、字典(Dict)。其中有两个哈希表 ht[0]用来平常存储，ht[1]用来 rehash。\",\"​ 在 Redis 中，字典是用于保存键值对的抽象数据结构，所有数据都保存在字典中。除此之外，字典还是哈希键的底层实现。\",\"Redis 哈希表使用链地址法解决哈希冲突，总是将新节点添加到链表的表头位置（头插）。\",\"渐进式 rehash\",\"​ rehash 操作不是一次性完成，而是采用渐进方式（每次增删改查(访问)dict 时执行一次 rehash），这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。\",\"​ 不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的 size 和 sizemask 变化，而 key 的查询会与 sizemask 有关，因此必须对哈希表中的每一个 key 重新计算索引，插入新的哈希表，这个过程叫rehash。按照新的 realsize 申请空间(扩容大小为第一个大于等于 used+1 的 2^n/收缩大小为第一个大于 used 的 2^n)，创建 dictht，并赋值给 dictht[1]，设置 dict.rehashidx = 0，标志开始 rehash\",\"​ 渐进式 rehash 通过记录 dict 的 rehashidx 完成；每次执行增删改查查操作时，都检查一下 dict.rehashidx 是否大于-1，如果是则将 dictht[0].dictEntry table[0]的(enrty)键值对链表 rehash 到 dictht[1]的键值对数组上，然后 rehashidx++，直到 dictht[0]的所有数据都 rehash 到 dictht[1]。\",\"​ 最后将 dictht[1]赋值给 dictht[0]，给 dictht[1]初始化为空哈希表释放原来的 dictht[0]的内存。\",\"​ 在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash，在 rehash 过程中，新增操作，则直接写入 ht[1]，查询、修改和删除会在 dictht[0]和 dictht[1]中一次查找并执行，这样可以确保 dictht[0]的数据只增不减，随着 rehash 的过程最终 dictht[0]变为空。\",\"​ 采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。(不会存在两个 dictht 中都有的情况)\",\"扩缩容的条件⭐\",\"​ Dict 在每次新增键值对时都会检查负载因子(LoadFactor=used/size)，满足以下两种情况时会触发哈希扩容\",\"哈希表的负载因子>=1，并且服务器没有执行 bgsave 或者 bgwriteof 等后台程序；\",\"哈希表的负载因子>5；\",\"​ Dict 除了扩容以外，每次删除元素时，也会对负载因子做检查，当负载因子<0.1 时，会做哈希表收缩。\",\"​ 正常情况下，当 hash 表中 元素的个数等于第一维数组的长度时，就会开始扩容，扩容的新数组是 原数组大小的 2 倍。不过如果 Redis 正在做 bgsave(持久化命令)，为了减少内存也得过多分离，Redis 尽量不去扩容，但是如果 hash 表非常满了，达到了第一维数组长度的 5 倍了，这个时候就会 强制扩容。\",\"​ 当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 元素个数低于数组长度的 10%，缩容不会考虑 Redis 是否在做 bgsave。\"]},\"624\":{\"h\":\"SDS(动态字符串)\",\"t\":[\"​ Redis 是 C 语言写的，但对于 Redis 的字符串，却不是 C 语言中的字符串（即以 '\\\\0' 结尾的字符串）。凡是在 Redis 中需要一个可变的字符串值时，就会使用 SDS 来表示字符串值。SDS 的定义：\",\"struct sdshdr { int len; //记录duf数组中已使用字节的数量，等于sds所保存字符串的长度 int free; //记录buf数组中未使用字节的数量 char buf[]; //字节数组，用于保存字符串 } \",\"与 c 语言字符串的差别：\",\"C 语言字符串\",\"SDS\",\"解释\",\"获取长度的时间复杂度为 O(n)\",\"获取长度的时间复杂度为 O(1)\",\"SDS 中 len 属性保存了字符串的长度\",\"修改字符串 n 次必定执行 n 次内存分配\",\"修改字符串最多执行 n 次内存分配\",\"SDS 会分配额外的空间，额外空间大小由 free 记录\",\"只能保存文本数据，非二进制安全，例如无法保存数组的结束字符‘\\\\0’\",\"可以保存文本数据或者二进制数据\",\"SDS 使用 buf 来保存一系列二进制数据\",\"可以使用<string.h>库中所有的函数\",\"可以使用<string.h>中部分函数\",\"SDS 中的 buf 相当于字符串\",\"​ 动态字符串的优点：\",\"获取字符串长度的时间复杂度为 O(1)，因为通过结构体中的 len 便可获得字符串长度\",\"杜绝缓冲区溢出：在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦未分配足够长度的内存空间，就会造成缓冲区溢出。对于 SDS 数据类型，进行字符修改时，，所以不会出现缓冲区溢出。\",\"减少修改字符串长度时所需的内存重分配次数：对于 SDS，由于 len 属性和 free 属性的存在，对于修改字符串 SDS 实现了空间预分配和惰性空间释放两种策略： \",\"空间预分配： ，对 SDS 进行空间扩展时，不仅会为 SDS 分配修改所必须的空间，还会分配额外未使用的空间，这样可以减少连续执行字符串增长操作所需的内存重分配次数。\",\"惰性空间： ，对 SDS 进行缩短操作时，程序不会立即回收缩短后多余的字节，而是使用 free 属性将这些字节的数量记录下来，等待将来使用，避免了缩短字符串时所需的内存重分配次数。\",\"二进制安全：C 语言字符串以空字符（'\\\\0'）作为字符串结束的标识，只要读到空字符就表明字符串结束。而对于一些二进制文件（如：图片、视频等），内容可能包括空字符串，因此 C 字符串无法正确存取。所有 SDS 的 API 都是以处理二进制方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。\"]},\"625\":{\"h\":\"IntSet(基于整数数组实现)\",\"t\":[\"​ Inset 是 Redis 中 set 集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征\",\"IntSet 升级(扩容)\",\"​ InSet 推荐在数据量不多的时候使用。\"]},\"626\":{\"h\":\"链表\",\"t\":[\"Redis3.2 以后已经不再使用\",\"链表是 list（列表）的底层实现，Redis 链表实现是双端、无环链表。\",\"Redis 链表特性\",\"说明\",\"双端\",\"链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为 O(1)\",\"无环\",\"表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL\",\"带链表长度计数器\",\"通过 len 属性获取链表长度的时间复杂度为 O(1)\",\"多态\",\"链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值\"]},\"627\":{\"h\":\"ZipList 压缩列表(ZipList)(内存空间连续)\",\"t\":[\"​ entry 的结构：\",\"​ previous_entry_lenth用于记录前一个 entry 的长度，当前一节点的长度小于 254 字节，则采用 1 个字节保存这个长度值，如果前一节点的长度大于等于 254 字节，则采用 5 个字节来保存这个长度值，第一个字节是 0xfe，后面四个字节才是前一个节点的真实长度数据。\",\"​ 压缩列表实际上类似于一个数组，数组的每一个元素对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有 zlend，表示列表结束。列表的节点之间不是通过指针连接，而是记录上一届点和本节点的长度来寻址(内存空间连续)，内存占用较低。\",\"​ 在压缩列表中，如果我们要查找定位第一个和最后一个元素，可以通过表头的三个字段的长度直接定位，时间复杂度是 O(1)。而查找其他元素时，就没有那么高效了，只能逐个查找，此时的时间复杂度就是 O(n)了。当数据量大时，效率下降，因此存储上限低。\"]},\"628\":{\"h\":\"\",\"t\":[\"​ 当有 N 个连续的长度为 250-253 字节之间的 entry(之后的假设用的 250 个字节)，因此 entry 的 previous_entry_length 属性是用一个字节，但如果此时突然在队首添加一个 254 字节的 entry，此时原队首的 previous_entry_length(原本是 1 个字节，现在由于前一个 entry 是 254 字节)变为 5 个字节，那么第二个 entry(原队首也就是第一个 entry)也变成了 254 个字节，这又会导致后面一系列的更新，这种连续多次空间扩展操作称之为连锁更新。\"]},\"629\":{\"h\":\"QuickList\",\"t\":[\"​ QuickList 是一个双端链表，只不过链表中的每个节点都是一个 ZipList。(通过创建多个 ZipList 来分片存储数据，以防存储大量数据时超出 ZipList 最佳的上限)\"]},\"630\":{\"h\":\"跳表(SkipList)\",\"t\":[\"​ 跳跃表是有序集合的底层实现，通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。 跳跃表支持平均 O(logN)、最坏 O(N) 复杂度的节点查找。跳表在 Redis 中用在了两个地方，一是实现有序集合键，二是集群节点中用作内部数据结构。\",\"结构：\",\"跳表是一个双向链表，每个节点都包含score(用于排序)和 element 值\",\"节点按照 score 值排序，如果 score 值一样按照 element 字典排序\",\"每个节点都可以包含多层指针，层数是 1-32 之间的随机数\",\"不同层指针到下一个节点的跨度不同，层级越高，跨度越大\",\"增删改查效率与红黑树基本一致，实现却更简单\",\"zskiplist结构构成：\",\"header：指向跳跃表的头节点，通过它定位到表头节点的时间复杂度为 O(1)。\",\"tail：指向跳跃表的表尾节点，通过它定位到表尾节点的时间复杂度为 O(1)。\",\"level：记录目前跳跃表内，层数最大的那个节点的层数。\",\"length：记录跳跃表的长度，也即是跳跃表目前包含节点的数量。\",\"跳跃表节点（zskiplistNode）构成\",\"层：每个层都带有两个属性，前进指针和跨度\",\"前进指针：指向表尾方向，用于从表头向表尾方向访问节点，查询数据只使用前进指针就可以了\",\"跨度：用于记录两个节点间的距离，用来计算节点的排位\",\"后退指针（BW）：指向当前节点的前一个节点，用于表尾向表头遍历，但查询数据时不会用到后退指针\",\"分值：节点保存的分值，按从小到大排列，分值相同的节点按照成员对象在字典序中的大小来进行排序\",\"成员对象：在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的。分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面（靠近表头方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）。\",\"为什么使用跳表？\",\"首先，因为 zset 要支持随机的插入和删除，所以它 不宜使用数组来实现，关于排序问题，我们也很容易就想到 红黑树/ 平衡树 这样的树形结构，为什么 Redis 不使用这样一些结构呢？\",\"**性能考虑：**插入速度非常快速，相比不需要进行旋转等操作来维护平衡性；\",\"**实现考虑：**在复杂度与红黑树相同（O(logN)）的情况下，跳跃表实现起来更简单，看起来也更加直观；\",\"跳表在范围查询的时候的效率是高于红黑树的，因为跳表是从上层往下层查找的，上层的区域范围更广，可以快速定位到查询的范围。\"]},\"631\":{\"h\":\"RedisObject\",\"t\":[\"​ redis 对象的对象头占 16 字节(不包含指向的内存空间，也就是真正的对象存储的空间)\"]},\"632\":{\"h\":\"Redis 过期键的删除策略\",\"t\":[\"我们 set key 的时候，都可以给一个 expire time，通过过期时间我们可以指定这个 key 可以存活的时间。过期策略通常有以下两种：\",\"惰性过期：只有当访问一个 key 时，才会判断该 key 是否已过期，过期则清除。该策略可以最大化地节省 CPU 资源，却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存。\",\"定期过期：redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的 key，Redis 默认会每秒进行十次过期扫描（100ms 一次），过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略\",\"1.从过期字典中随机 20 个 key；\",\"2.删除这 20 个 key 中已经过期的 key；\",\"3.如果过期的 key 比率超过 1/4，那就重复步骤 1；\",\"每隔一定的时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已过期的 key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。\",\"定时过期：每个设置过期时间的 key 都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的 CPU 资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。(没问不说)\",\"Redis 中同时使用了惰性过期和定期过期两种过期策略。\"]},\"633\":{\"h\":\"Redis 内存淘汰机制\",\"t\":[\"LRU(Least Recently Used)最近最少使用算法\",\"LFU(Least Frequently Used)最不经常使用\"]},\"634\":{\"h\":\"内存相关\"},\"635\":{\"h\":\"怎么保证 redis 中的数据都是热点数据？\",\"t\":[\"​ 当 redis 内存数据集大小上升到一定大小后，就会施行内存淘汰策略。\"]},\"636\":{\"h\":\"redis 的内存淘汰策略有哪些？\",\"t\":[\"全局的键空间选择性移除：\",\"noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。\",\"allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key。（这个是最常用的）\",\"allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key。\",\"设置过期时间的键空间选择性移除： 4. volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key。 5. volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。 6. volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。\",\"Redis 的内存淘汰策略的选取并不会影响过期的 key 的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。\"]},\"637\":{\"h\":\"Redis 如何做内存优化\",\"t\":[\"控制 key 的数量：当使用 Redis 存储大量数据时，通常会存在大量键，过多的键同样会消耗大量内存。Redis 本质是一个数据结构服务器，它为我们提供多种数据结构，如 hash，list，set，zset 等结构。使用 Redis 时不要进入一个误区，大量使用 get/set 这样的 API，把 Redis 当成 Memcached 使用。对于存储相同的数据内容，利用 Redis 的数据结构降低外层键的数量，也可以节省大量内存。\",\"缩减键值对象，降低 Redis 内存使用最直接的方式就是缩减键（key）和值（value）的长度。\",\"key 长度：如在设计键时，在完整描述业务情况下，键值越短越好。\",\"value 长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入 Redis。首先应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。其次在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。\",\"编码优化。Redis 对外提供了 string,list,hash,set,zet 等类型，但是 Redis 内部针对不同类型存在编码的概念，所谓编码就是具体使用哪种底层数据结构来实现。编码不同将直接影响数据的内存占用和读写效率。\"]},\"638\":{\"h\":\"Redis 怎么扩容\",\"t\":[\"如果 Redis 被当做缓存使用，使用一致性哈希实现动态扩容。\",\"如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，结点的数量一旦确定不能变化。否则的话(即 Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis集群可以做到这样。\"]},\"639\":{\"h\":\"缓存异常\"},\"640\":{\"h\":\"缓存预热\",\"t\":[\"​ 缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存，用户直接查询事先被预热的缓存数据。如果不进行预热，那么 Redis 初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。\",\"​ 比如秒杀活动开始前半小时，进行缓存预热，将一些商品信息先加载到缓存中，避免活动开始的一瞬间数据压力暴增。\",\"实现方案\",\"数据量不大的时候，工程启动的时候进行加载缓存动作。\",\"数据量大的时候，设置一个定时任务脚本，进行缓存的刷新。\",\"数据量非常大的时候，优先保证热点数据可以提前加载到缓存。\"]},\"641\":{\"h\":\"缓存穿透\",\"t\":[\"​ 缓存穿透是指查询一个不存在的数据，由于缓存不命中时，将导致这个不存在的数据每次请求都要到数据库去查询，而且由于数据库中也没有该数据，所以不能刷新到缓存，导致每次查询都是相同的结果，可能造成数据库短期内承受大量请求而崩掉。\",\"解决办法\",\"接口层增加校验，如在用户登陆的时候，可以增加一个用户鉴权校验，id<=0 的直接拦截。\",\"缓存空对象：如果一个查询返回的数据为空（不管是数据不存在， 还是系统故障），我们仍然把这个空结果进行缓存（将 key-value 对写为 key-null），但它的过期时间会很短，比如设置为 30s。这样可以防止攻击用户反复用同一个 id 暴力攻击。\",\"​ 龙虾三少：尽量不要使用 null 做防止击穿的手段，因为如果用 null 代码判断不出来是真的不存在还是就是存了 null，必须要用一次 keyexist 影响性能 ，一般都是放一个表示默认不存在的 object，比如缓存是放 user 信息的，没有这个 user 就可以放一个 user 对象，但对应的 id 是 0 或者-1 这种 ，在应用层做好判断\",\"布隆过滤器：将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。\"]},\"642\":{\"h\":\"缓存雪崩\",\"t\":[\"​ 缓存雪崩是指缓存同一时间大面积的失效（比如宕机等），导致后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。\",\"原因：缓存数据设置的过期时间是相同的，而 Redis 恰好将这部分数据全部删除。或者宕机 ---> 高可用。\",\"解决办法\",\"加锁排队：一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。\",\"缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。并设置热点数据永不过期，有更新操作就更新缓存就好了。\",\"redisTemplate.opsForValue().set(key,value); redisTemplate.expire(key,Math.random()*100, TimeUnit.MINUTES); \",\"可以把缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务。利用 sentinel 或 cluster 实现。\",\"采用多级缓存，比如本地进程作为一级缓存，redis 作为二级缓存，不同级别的缓存设置的超时时间不同，即使某级缓存过期了，也有其他级别缓存兜底。\",\"另外对于 \\\"Redis 挂掉了，请求全部走数据库\\\" 这样的情况，我们还可以有如下的思路：\",\"事发前：实现 Redis 的高可用(主从架构 + Sentinel 或者 Redis Cluster)，尽量避免 Redis 挂掉这种情况发生。\",\"事发中：万一 Redis 真的挂了，我们可以设置**本地缓存(**ehcache) + 限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)\",\"事发后：Redis 持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。\"]},\"643\":{\"h\":\"缓存击穿\",\"t\":[\"​ 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。\",\"​ 和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。所以系统存在以下问题时需要引入注意：当前 key 是一个热点 key，并发量很大；重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的 SQL、多次 IO、多个依赖等。\",\"解决方法\",\"分布式互斥锁：如果 key 不存在，就加锁，然后查 DB 入缓存，然后解锁；其他进程如果发现有锁就进行等待，然后等解锁后返回数据或进入 DB 查询。这种方案思路比较简单，但是存在一定的隐患，如果在查询数据库和重建缓存（key 失效后进行了大量的计算）时间过长，也可能会存在死锁和线程池阻塞的风险，高并发情景下吞吐量会大大降低！但是这种方法能够较好地降低后端存储负载，并在一致性上做得比较好。\",\"永不过期：设置热点数据永远不过期。由于没有设置真正的过期时间，实际上已经不存在热点 key 产生的一系列危害，但是会存在数据不一致的情况，同时代码复杂度会增大。\"]},\"644\":{\"h\":\"缓存降级\",\"t\":[\"​ 当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。其最终目的是保证核心服务可用，即使是有损的。如，双十一关闭修改收获地址的服务。\",\"解决方法\",\"​ 由于有些服务是无法降级的（如加入购物车、结算）。在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：一般、警告、错误、严重错误等。\",\"​ 一个比较常见的做法就是，Redis 出现问题，不去数据库查询，而是直接返回默认值给用户。\"]},\"645\":{\"h\":\"布隆过滤器\",\"t\":[\"​ 布隆过滤器本质上是由长度为 m 的位向量或位列表（仅包含 0 或 1 位值的列表）组成，最初所有的值均设置为 0。当我们向布隆过滤器中添加数据时，会使用多个 hash 函数对 key 进行运算，算得一个证书索引值，然后对位数组长度进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。即引入了 k 个相互独立的哈希函数，保证在给定的空间、误判率下、完成元素判重的过程。\",\"使用场景\",\"大数据判断是否存在：这就可以实现出上述的去重功能，如果你的服务器内存足够大的话，那么使用 HashMap 可能是一个不错的解决方案，理论上时间复杂度可以达到 O(1 的级别，但是当数据量起来之后，还是只能考虑布隆过滤器。\",\"解决缓存穿透：我们经常会把一些热点数据放在 Redis 中当作缓存，例如产品详情。 通常一个请求过来之后我们会先查询缓存，而不用直接读取数据库，这是提升性能最简单也是最普遍的做法，但是 如果一直请求一个不存在的缓存，那么此时一定不存在缓存，那就会有 大量请求直接打到数据库 上，造成 缓存穿透，布隆过滤器也可以用来解决此类问题。\",\"爬虫/ 邮箱等系统的过滤：平时不知道你有没有注意到有一些正常的邮件也会被放进垃圾邮件目录中，这就是使用布隆过滤器 误判 导致的。\",\"注意\",\"​ 布隆过滤器的initial_size设置的过大，会浪费存储空间，设置的过小，就会影响准确率，在使用之前一定要尽可能的精确估计元素数量，还要加上一定的冗余空间以避免实际元素可能会意外高出估计值很多。\",\"​ 布隆过滤器的error_rate越小，需要的存储空间就越大，对于不需要过于精确的场合，error_rate 设置的稍大一点也可以。在某些业务场景中出现误判的情况对用户无感知的时候，误判率也可以忽略不计了。\"]},\"646\":{\"h\":\"Redis 的持久化\",\"t\":[\"​ **为什么需要 Redis 持久化：**Redis 对数据的操作都是基于内存的，当遇到了进程退出、服务器宕机等意外情况，如果没有持久化机制，那么 Redis 中的数据将会丢失无法恢复。有了持久化机制，Redis 在下次重启时可以利用之前持久化的文件进行数据恢复。Redis 支持的两种持久化机制：\",\"RDB：把当前数据生成快照保存在硬盘上。\",\"AOF：记录每次对数据的操作到硬盘上。\"]},\"647\":{\"h\":\"RDB（Redis Database）\",\"t\":[\"​ 也称快照（snapshotting），按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件，对应产生的数据文件为 dump.rdb（存放在 bin 目录下)。通过配置文件中的 save 参数来定义快照的周期。核心函数：**rdbSave（生成 RDB 文件）和 rdbLoad（从文件加载内存）**两个函数。save和bgsave命令都可以手动触发 RDB 持久化。\",\"bgsave 的原理？\",\"​ ① 执行 bgsave 命令，Redis 父进程判断当前是否存在正在执行的子进程，如 RDB/AOF 子进程，如果存在 bgsave 命令直接返回。\",\"​ ② 如果没有正在执行的子进程，那么父进程执行 fork 操作创建子进程，fork 操作过程中父进程(redis 进程)会阻塞。\",\"​ ③ 父进程 fork 完成后，bgsave 命令返回(bgsave 命令就结束了)并不再阻塞父进程，可以继续响应其他命令。\",\"​ ④ 子进程创建 RDB 文件，根据父进程内存生成临时快照文件，完成后对原有文件进行替换，替换操作是原子的。\",\"​ ⑤ 子进程发送信号给父进程表示完成，父进程更新统计信息。\",\"触发机制\",\"手动触发分别对应 save 和 bgsave 命令：\",\"save（已经废弃）：阻塞当前 Redis 服务器服务，直到 RDB 持久化 过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。\",\"bgasve：Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短。bgsave 是针对 save 阻塞问题做的优化，因此 Redis 内部所有涉及 RDB 的操作都采用 bgsave 的方式。\",\"自动触发 RDB 持久化机制，例如：\",\"使用 save 相关配置，如 save m n，表示 m 秒内数据集存在 n 次修改时，自动触发 bgsave。\",\"如果从节点执行全量复制操作，主节点自动执行 bgsave 生成 RDB 文件并发送给从节点。\",\"执行 debug reload 命令重新加载 Redis 时也会自动触发 save 操作。\",\"默认情况下执行 shutdown 命令时，如果没有开启 AOF 持久化功能则自动执行 bgsave。\",\"在生成 RDB 期间，Redis 可以同时处理写请求么？\",\"​ 可以，Redis 使用操作系统的多进程写时复制技术 COW(Copy On Write) 来实现快照持久化，保证数据一致性。\",\"​ Redis 在持久化时会fork一个子进程，子进程负责将内存内容写入到临时文件，父进程继续处理 client 请求。由于 os 的 COW 机制，父子进程会共享相同的物理页面，当父进程处理写请求时，os 会为父进程要修改的页面创建副本。所以子进程地址空间内的数据是fork 时刻整个数据库的一个快照。\",\"​ 当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出。\"]},\"648\":{\"h\":\"RDB 的优缺点\",\"t\":[\"优点：RDB 文件是一个紧凑的二进制压缩文件，是 Redis 在某个时间点的全部数据快照。所以使用 RDB恢复数据的速度远远比 AOF 的快，非常适合备份、全量复制、灾难恢复等场景。\",\"缺点：每次进行bgsave操作都要执行 fork 操作创建子进程，属于重量级操作，频繁执行成本过高，所以无法做到实时持久化，或者秒级持久化。另外，由于 Redis 版本的不断迭代，存在不同格式的 RDB 版本，有可能出现低版本的 RDB 格式无法兼容高版本 RDB 文件的问题。\"]},\"649\":{\"h\":\"AOF（Append-only file）\",\"t\":[\"​ 把 Redis 服务器接收到的所有写命令都记录到日志中，redis 重跑一下日志文件相当于还原了数据。\",\"​ 由于快照方式是在一定间隔时间做一次，所以如果 redis 意外 down 掉的话，就会丢失最后一次快照后的所有更改。如果要求数据不能丢失任何修改的话，可以采用 aof 持久化方式。\",\"为什么 AOF 比 RDB 有更好的持久化性？\",\"​ 这是由于 AOF 会产生一个appendonly.aof持久化文件 ，Redis 将收到的写命令都通过Write函数追加到该文件的最后，类似于 MySQL 的 binlog 。当 Redis 重启时会通过重新执行文件中保存的写命令来重建整个数据库的内容。\",\"​ 当然由于 os 会在内核中缓存 write 做的修改，所以可能不是立即写到磁盘上，这样的话还是有可能丢失部分修改。不过我们可以通过文件告诉 Redis 我们想要通过 fsync 函数强制 os 写入到磁盘的时机。有三种方式：\"]},\"650\":{\"h\":\"AOF 的三种写回策略\",\"t\":[\"appendfsync always：收到写命令，写命令执行完后就立即写入磁盘，最慢，它在每一个写命令后都有一个慢速的落盘操作，不可避免的会影响主线程性能，但是保证完全的持久化。\",\"appendfsync everysec：每秒钟写入磁盘一次，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘。避免了同步写回的性能开销，虽然减少了对系统西能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。所以算两者的折中。\",\"appendfsync no：操作系统控制的写回，每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。在写完缓冲区后就可以继续执行后续的命令，但是落盘的时机已经不在 redis 手中，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了，完全依赖 os，性能最好，但持久化没保证。\",\"​ 想要高性能选择 No 策略，想要可靠性要 Always 策略，如果允许数据有一点丢失，又希望性能别受太大影响的话，就选择 everysec 策略。\"]},\"651\":{\"h\":\"AOF 文件过大(重写机制)\",\"t\":[\"​ AOF 日志不断变大，我们就需要重写(重写是通过 bgrewriteof 子进程完成的不会阻塞主进程)AOF 文件，新的 AOF 文件：Redis 根据数据库现状创建的，也就是读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入，记录的都是数据库中数据的最新状态，经过 AOF 重写后 AOF 文件会变小。\",\"​ 1、Redis 执行 fork() ，现在同时拥有父进程和子进程。 2、子进程开始将新 AOF 文件的内容写入到临时文件。 3、对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾,这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。 4、当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。 5、搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。\",\"AOF 的持久化文件越来越大怎么办？\",\"​ aof 方式会让持久化文件越来越大，例如我们调用incr test命令 100 次，文件中必须保存全部的 100 条命令，但其实有 99 条命令都是多余的。因为要恢复数据库的状态，文件中保存一条set test 100就够了。\",\"​ 所以为了压缩 aof 的持久化文件，Redis 提供了bgrewriteaof命令。收到此命令，Redis 将使用与快照类似的方式，将内存中的数据以命令的方式保存到临时文件中，最后替换原来的文件。\",\"AOF 文件破坏了怎么办？\",\"​ 如果文件有错误，redis 是启动不起来的，需要修复 aof 文件。redis 给我们提供了一个工具redis-check-aof --fix加上文件名appendonly.aof即可。\"]},\"652\":{\"h\":\"RDB 和 AOF 的区别\",\"t\":[\"AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据。\",\"AOF 比 RDB 更安全，但持久化文件也更大，修复的速度也比 RDB 慢很多。\",\"AOF 运行效率比 RDB 慢，RDB 比 AOF 性能好。\"]},\"653\":{\"h\":\"持久化方式的选择？\",\"t\":[\"1、如果是数据不那么敏感，且可以从其他地方重新生成补回的，可以关闭持久化。\",\"2、如果是数据比较重要，不想再从其他地方获取，且可以承受数分钟的数据丢失，比如作为缓存，那么可以只使用 RDB。\",\"3、如果是用于当做内存数据库，那么最好 RDB 和 AOF 都开启。\",\"4、Redis4.0 之后，添加了新的混合持久化方式。简单地说：将 RDB 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。\",\"优势：混合持久化结合了 RDB 持久化 和 AOF 持久化的优点， 由于绝大部分都是 RDB 格式，加载速度快，同时结合 AOF，增量的数据以 AOF 方式保存了，数据更少的丢失。\",\"兼容性差，一旦开启了混合持久化，在 4.0 之前版本都不识别该 aof 文件，同时由于前部分是 RDB 格式，阅读性较差。\"]},\"654\":{\"h\":\"Redis 如何保证高可用高并发性(主从+哨兵+集群)⭐\",\"t\":[\"​ Redis 中有三种集群方式用来保证高并发和高可用：主从复制，哨兵模式和集群\"]},\"655\":{\"h\":\"主从复制\",\"t\":[\"​ **概述：**为了避免单点故障，通常的做法是将数据库复制到多个副本部署在不同的服务器上。这样，即使有一套服务器出现了故障其他服务器仍然可以继续提供服务。Redis 提供了复制的功能，可以实现当一台数据库中的数据更新后，自动更新的数据同步到其他数据库上。一个 master 能对应多个 slave。一个 slave 只能对应一个 master。\",\"​ 先启动主节点，然后一台一台启动从节点。\",\"​ 作用：\",\"读写分离：master 写，slave 读，提高服务器读写负载能力\",\"负载均衡：salve 分担 master 负载，大大提高 Redis 并发量与数据吞吐量\",\"故障恢复：当 master 出现问题时，由 slave 提供服务，实现快速故障恢复\",\"高可用：基于主从复制，构造哨兵模式与集群，实现 Redis 的高可用\",\"​ 过程/原理：\",\"slave 启动成功之后，连接 master，发送 sync 命令；\",\"master 接收 sync 命令之后，开始执行 BGSAVE 命令生成 RDB 文件，并使用缓冲区记录此后执行的所有写命令。\",\"master 执行完 BGSAVE 后，向所有的 slave 发送快照文件。并在发送期间继续记录被执行的写命令\",\"slave 接收到快照文件后丢弃所有旧数据，载入收到的快照\",\"master 快照发送完毕后，开始向 slave 发送缓冲区的写命令\",\"slave 完成对快照文件的加载，开始接受命令请求，并执行主数据库缓冲区的写命令。(从数据库初始化完成)\",\"master 每执行一个写命令就像 slave 发送相同的写命令。slave 接收并执行写命令。(这是从数据库初始化完成后的操作)\",\"出现断开重连后，2.8 之后的版本会将断线期间的命令传给从数据库，增量复制。\",\"主从刚刚连接的时候，进行全量同步;全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。Redis 的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。\"]},\"656\":{\"h\":\"主从复制的优缺点\",\"t\":[\"​ 优点\",\"支持主从复制，主机会自动将数据同步到从机，可以进行读写分离;\",\"为了分载 Master 的读操作压力，Slave 服务器可以为客户端提供只读操作的服务，写服务依然必须由 Master 来完成;\",\"Slave 同样可以接受其他 Slaves 的连接和同步请求，这样可以有效地分载 Master 的同步压力;\",\"Master 是以非阻塞的方式为 Slaves 提供服务。所以在 Master-Slave 同步期间，客户端仍然可以提交查询或修改请求;\",\"Slave 同样是以阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis 则返回同步之前的数据。\",\"缺点\",\"Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复;\",\"主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性;\",\"如果多个 Slave 断线了，需要重启的时候，尽量不要在同一时间段进行重启。因为只要 Slave 启动，就会发送 sync 请求和主机全量同步，当多个 Slave 重启的时候，可能会导致 Master IO 剧增从而宕机。\",\"Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂;\",\"redis 的主节点和从节点中的数据是一样的，降低的内存的可用性\"]},\"657\":{\"h\":\"哨兵模式\",\"t\":[\"​ 主从模式下，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这种方式并不推荐，实际生产中，我们优先考虑哨兵模式。这种模式下，master 宕机，哨兵会自动选举 master 并将其他的 slave 指向新的 master。\",\"​ 在主从模式下，redis 同时提供了哨兵命令 redis-sentinel，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵进程向所有的 redis 机器发送命令，等待 Redis 服务器响应，从而监控运行的多个 Redis 实例。\",\"​ 哨兵可以有多个，一般为了便于决策选举，使用奇数个哨兵。哨兵可以和 redis 机器部署在一起，也可以部署在其他的机器上。多个哨兵构成一个哨兵集群，哨兵直接也会相互通信，检查哨兵是否正常运行，同时发现 master 宕机哨兵之间会进行决策选举新的 master ​ 哨兵模式的作用：\",\"通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器;\",\"当哨兵监测到 master 宕机，会自动将 slave 切换到 master，然后通过发布订阅模式通过其他的从服务器，修改配置文件，让它们切换主机;\",\"然而一个哨兵进程对 Redis 服务器进行监控，也可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。\",\"​ 哨兵模式的工作：\",\"每个 Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的 Master 主服务器，Slave 从服务器以及其他 Sentinel（哨兵）进程发送一个 PING 命令。\",\"如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）\",\"如果一个 Master 主服务器被标记为主观下线（SDOWN），则正在监视这个 Master 主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认 Master 主服务器的确进入了主观下线状态\",\"当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认 Master 主服务器进入了主观下线状态（SDOWN）， 则 Master 主服务器会被标记为客观下线（ODOWN）\",\"在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有 Master 主服务器、Slave 从服务器发送 INFO 命令。\",\"当 Master 主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master 主服务器的所有 Slave 从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。\",\"若没有足够数量的 Sentinel（哨兵）进程同意 Master 主服务器下线， Master 主服务器的客观下线状态就会被移除。若 Master 主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master 主服务器的主观下线状态就会被移除。\",\"​ 假设 master 宕机，sentinel 1 先检测到这个结果，系统并不会马上进行 failover(故障转移)选出新的 master，仅仅是 sentinel 1 主观的认为 master 不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由 sentinel 1 发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。\"]},\"658\":{\"h\":\"哨兵模式的优缺点\",\"t\":[\"​ 优点：\",\"哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。\",\"主从可以自动切换，系统更健壮，可用性更高。\",\"​ 缺点：\",\"具有主从模式的缺点，每台机器上的数据是一样的，内存的可用性较低。\",\"Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。\"]},\"659\":{\"h\":\"集群模式\",\"t\":[\"​ Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在 redis3.0 上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容；\",\"运行机制：\",\"在 Redis 的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383，可以从上面 redis-trib.rb 执行的结果看到这 16383 个 slot 在三个 master 上的分布。还有一个就是 cluster，可以理解为是一个集群管理的插件，类似的哨兵。\",\"当我们的存取的 Key 到达的时候，Redis 会根据 crc16 的算法对计算后得出一个结果，然后把结果和 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。\",\"当数据写入到对应的 master 节点后，这个数据会同步给这个 master 对应的所有 slave 节点。\",\"为了保证高可用，redis-cluster 集群引入了主从模式，一个主节点对应一个或者多个从节点。当其它主节点 ping 主节点 master 1 时，如果半数以上的主节点与 master 1 通信超时，那么认为 master 1 宕机了，就会启用 master 1 的从节点 slave 1，将 slave 1 变成主节点继续提供服务。\",\"如果 master 1 和它的从节点 slave 1 都宕机了，整个集群就会进入 fail 状态，因为集群的 slot 映射不完整。如果集群超过半数以上的 master 挂掉，无论是否有 slave，集群都会进入 fail 状态。\",\"redis-cluster 采用去中心化的思想，没有中心节点的说法，客户端与 Redis 节点直连，不需要中间代理层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。\"]},\"660\":{\"h\":\"集群模式的优缺点：\",\"t\":[\"优点 采用去中心化思想，数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布;\",\"可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除;\",\"高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升;\",\"降低运维成本，提高系统的扩展性和可用性。\",\"缺点 1.Redis Cluster 是无中心节点的集群架构，依靠 Goss 协议(谣言传播)协同自动化修复集群的状态\",\"但 GosSIp 有消息延时和消息冗余的问题，在集群节点数量过多的时候，节点之间需要不断进行 PING/PANG 通讯，不必须要的流量占用了大量的网络资源。虽然 Reds4.0 对此进行了优化，但这个问题仍然存在。\",\"2.数据迁移问题\",\"Redis Cluster 可以进行节点的动态扩容缩容，这一过程，在目前实现中，还处于半自动状态，需要人工介入。在扩缩容的时候，需要进行数据迁移。\",\"而 Redis 为了保证迁移的一致性，迁移所有操作都是同步操作，执行迁移时，两端的 Redis 均会进入时长不等的阻塞状态，对于小 Key，该时间可以忽略不计，但如果一旦 Key 的内存使用过大，严重的时候会接触发集群内的故障转移，造成不必要的切换。\"]},\"661\":{\"h\":\"Redis 的主从复制\",\"t\":[\"**概述：**主从复制，是指将一台 Redis 服务器的数据，复制到其它的 Redis 服务器。即使其中一台服务器宕机，其它服务器依然可以提供服务，实现 Redis 高可用。\",\"通过主从复制可以允许多个 slave server 拥有和 master server 相同的数据库副本。\",\"master 可以拥有多个 slave，多个 slave 可以连接同一个 master 外，还可以连接到其他 slave。\",\"主从复制不会阻塞 master，在同步数据时，master 可以继续处理 client 请求。\",\"如果 master 同时收到多个 slave 发来的同步连接命令，master 只会启动一个进程来写数据库镜像，然后发送给所有的 slave。\",\"主从复制作用：\",\"读写分离：master 写，slave 读，提高服务器读写负载能力\",\"负载均衡：salve 分担 master 负载，大大提高 Redis 并发量与数据吞吐量\",\"故障恢复：当 master 出现问题时，由 slave 提供服务，实现快速故障恢复\",\"高可用：基于主从复制，构造哨兵模式与集群，实现 Redis 的高可用\"]},\"662\":{\"h\":\"复制过程\",\"t\":[\"大体可以分为 3 个阶段：\",\"建立连接阶段：建立 slave 到 master 的连接，使 master 能够识别 slave， 并保存 slave 端口号\",\"主库同步数据到从库阶段：\",\"slave 启动成功连接到 master 后会发送一个 psync 同步命令\",\"master 收到 PSYNC 命令执行 BGSAVE 命令，在后台生成一个 rdb 文件，并创建一个发送缓冲区记录从当前开始执行的所有写命令\",\"master 将 RDB 文件发送给 slave，slave 接收并载入这个 RDB 文件\",\"master 将发送缓冲区的所有写命令发送给 slave\",\"发送同步期间新写命令到从库阶段：同步操作执行完后，主从服务器两者数据库达到一致状态。每当主服务器执行客户端发送写命令时，master 会将自己执行的写命令，发送给 slave 执行。（利用长连接进行写命令的传播）\"]},\"663\":{\"h\":\"复制期间网络断了咋办\",\"t\":[\"在 Redis 2.8 之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。\",\"从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步。\"]},\"664\":{\"h\":\"由于主从延迟导致读取到过期数据怎么处理？\",\"t\":[\"​ Redis 加入了一个新特性来解决主从不一致导致读取到过期数据问题，增加了 key 是否过期以及对主从库的判断，如果 key 已过期，当前访问的 master 则返回 null；当前访问的是从库，且执行的是只读命令也返回 null。\"]},\"665\":{\"h\":\"Redis 事务\",\"t\":[\"​ Redis 即使多个连接也是单线程写入。但是假如一个线程发送 1，2 两条指令，则在插入指令 1 之后，Redis 可能被其它线程抢先插入指令 3，从而执行顺序变成 1，3，2，事务就是防止 1，3，2 情况发生。\",\"​ 可以将 Redis 中的事务简单理解为：Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。 Redis 事务功能是通过MULTI、EXEC、DISCARD 和 WATCH 四个原语实现的。\",\"MULTI & EXEC：使用 MULTI 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 EXEC 命令将执行所有命令。\",\"DISCARD：如果事务定义过程中发现了问题，终止当前事务，发生在 MULTI 之后，EXEC 之前。\",\"WATCH：对 key 添加监视锁（乐观锁机制），在执行 EXEC 前如果 key 发生了变化，终止所有事务执行。\",\"Redis 事务的三个阶段：\",\"事务开始 MULTI\",\"命令入队\",\"事务执行 EXEC\",\"事务执行过程中，如果服务端收到有 EXEC、DISCARD、WATCH、MULTI 之外的请求，将会把请求放入队列中排队。\",\"注意事项：\",\"Redis 中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。\",\"事务中出现运行错误，那么正确的命令会被执行。\"]},\"666\":{\"h\":\"分布式\"},\"667\":{\"h\":\"什么是分布式锁？\",\"t\":[\"​ 分布式锁，顾名思义，就是分布式项目开发中用到的锁，可以用来控制分布式系统之间同步访问共享资源。\",\"分布式锁应该具备的条件：\",\"在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；\",\"高可用的获取锁与释放锁；\",\"高性能的获取锁与释放锁；\",\"具备可重入特性；\",\"具备锁失效机制，防止死锁；\",\"具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。\"]},\"668\":{\"h\":\"常见的分布式锁有哪些解决方案\",\"t\":[\"​ 目前分布式锁有三种流行方案，即基于关系型数据库、Redis、Zookeeper 的方案。\",\"基于关系型数据库，如 MySQL\",\"基于关系型数据库实现分布式锁，是依赖数据库的唯一性来实现资源锁定，比如主键和唯一索引等。\",\"缺点：\",\"这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。（搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上）\",\"这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。（做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍）\",\"这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。（搞一个 while 循环，直到 insert 成功再返回成功）\",\"这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。（在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了）\",\"基于 Redis 实现\",\"1、获取锁：setnx lock-key value来实现，返回 1 则设置成功。\",\"2、释放锁：del lock-key即可。\",\"3、锁超时：为了防止一个线程在获取锁后程序出现异常，导致其他线程/进程调用 setnx 命令总是返回 0 而进入死锁状态，需要为该 key 设置一个“合理”的过期时间。expire key 30。\",\"基于 Zookeeper 实现\",\"​ 基于 Zookeeper 临时有序节点可以实现的分布式锁。\",\"​ 大致思想为：每个客户端对某个方法加锁时，在 Zookeeper 上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。\",\"​ 在实践中，当然是从以可靠性为主。所以首推 Zookeeper。\"]},\"669\":{\"h\":\"Redis 实现分布式锁\",\"t\":[\"Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。\",\"占坑一般使用 **setnx(set if not exists)**指令，只允许被一个程序占有，使用完调用 del 释放锁。也可以配合EXPIRE key seconds自动释放锁。\",\"设置 key 的生存时间，当 key 过期时(生存时间为 0) ，会被自动删除\",\"风险/ 缺陷 ：原子性没有得到满足，所以不建议。\"]},\"670\":{\"h\":\"Redis 的分布式锁有什么缺陷\",\"t\":[\"Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。\"]},\"671\":{\"h\":\"分布式 Redis 是前期做还是后期规模上来了再做好？为什么？\",\"t\":[\"​ 既然 Redis 是如此的轻量（单实例只使用 1M 内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。\",\"​ 一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。\",\"​ 这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis 实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。\"]},\"672\":{\"h\":\"RedLock\",\"t\":[\"Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 Redlock，此种方式比原先的单节点的方法更安全。它可以保证以下特性：\",\"安全特性：互斥访问，即永远只有一个 client 能拿到锁。\",\"避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区。\",\"容错性：只要大部分 Redis 节点存活就可以正常提供服务。\",\"原理\",\"假设有 5 个完全独立的 Redis 主服务器\",\"1、获取当前时间戳。\",\"2、client 尝试按照顺序使用相同的 key,value 获取所有 Redis 服务的锁，在获取锁的过程中的获取时间比锁过期时间短很多，这是为了不要过长时间等待已经关闭的 Redis 服务。并且试着获取下一个 Redis 实例。 比如：TTL 为 5s,设置获取锁最多用 1s，所以如果一秒内无法获取锁，就放弃获取这个锁，从而尝试获取下个锁。\",\"3、client 通过获取所有能获取的锁后的时间减去第一步的时间，这个时间差要小于 TTL 时间并且至少有 3 个 Redis 实例成功获取锁，才算真正的获取锁成功。\",\"4、如果成功获取锁，则锁的真正有效时间是 TTL 减去第三步的时间差 的时间；比如：TTL 是 5s,获取所有锁用了 2s,则真正锁有效时间为 3s(其实应该再减去时钟漂移)。\",\"5、如果客户端由于某些原因获取锁失败，便会开始解锁所有 Redis 实例；因为可能已经获取了小于 3 个锁，必须释放，否则影响其他 client 获取锁。\"]},\"673\":{\"h\":\"发布及订阅消息\",\"t\":[\"概述\",\"发布订阅（pub/sub）是一种消息通信模式，主要目的是解耦消息发布者和消息订阅者之间的耦合，这点和设计模式中观察者模式比较相似。pub/sub 不仅仅解决发布者和订阅者直接代码级别耦合也解决两者在物理部署上的耦合。\",\"redis 作为一个 pub/sub 的 server，在订阅者和发布者之间起到了消息路由的功能。订阅者可以通过 subscribe 和 psubscribe 命令向 redis server 订阅自己感兴趣的消息类型，redis 将消息类型称为通道(channel)。\",\"当发布者通过 publish 命令向 redis server 发送特定类型的消息时。订阅该消息类型的全部 client 都会收到此消息。这里消息的传递是多对多的。一个 client 可以订阅多个 channel,也可以向多个 channel 发送消息。\",\"命令\",\"PSUBSCRIBE pattern订阅一个或多个符合给定模式的频道。\",\"PUBLISH channel message 将消息发送到指定的频道。\",\"SUBCRIBE channel 订阅给定的一个或多个频道的信息。\",\"UNSUBSCRIBE channel退订给定的频道。\"]},\"674\":{\"h\":\"Redis 单副本\",\"t\":[\"概述\",\"​ 采用单个 Redis 结点部署架构，没有备用结点实时同步数据，不提供数据持久化和备份策略，**适用于数据可靠性不高的纯缓存业务场景。**一旦这个 Redis 挂了，整个系统就不可用了。\",\"优点\",\"架构简单，部署方便。\",\"高性价比：缓存使用时无需备用结点（单实例可用性可以用 supervisor 或 crontab 保证），当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同一时刻只有一个实例对外提供服务。\",\"高性能。\",\"缺点\",\"不保证数据的可靠性。\",\"在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高性能，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务。\",\"高性能受限于单核 CPU 的处理能力（Redis 是单线程机制），CPU 为主要瓶颈，所以适合操作命令简单，排序，计算较少的场景。\"]},\"675\":{\"h\":\"Redis 多副本（主从）\",\"t\":[\"概述\",\"Redis 多副本，采用主从部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。\",\"主从实例部署在不同的物理服务器上，根据实际的基础环境配置，可以实现同时对外提供服务和读写分离策略。\",\"优点\",\"高可靠性：一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题。\",\"读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。\",\"缺点\",\"当主服务器宕机后，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其他从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐，还会造成一段时间内服务不可用。**这种方式并不推荐，实际生产中，我们优先考虑哨兵模式。这种模式下，master 宕机，哨兵会自动选举 master 并将其他的 slave 指向新的 master。 **\",\"主库的写能力受到单机的限制。\",\"主库的存储能力受到单机的限制。\",\"原生复制的弊端在早期的版本中也会比较突出，如：Redis 复制中断后，Slave 会发起 psync ，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。\"]},\"676\":{\"h\":\"Redis Sentinel（哨兵）\",\"t\":[\"​ 当主服务器宕机后，如果手动把一台从服务器切换为主服务器，费事费力，还会造成一段时间内服务不可用。我们优先考虑使用哨兵模式，它的原理是哨兵通过发送命令，等待 Redis 服务器响应，从而对主从结构中的每台服务器进行监控，当 master 出现故障时，通过投票机制选择新的 master 并将其余 slave 连接到新的 master。\",\"Redis Sentinel 部署架构主要包括两部分：Redis Sentinel 集群和 Redis 数据集群。\",\"其中 Sentinel 集群是由若干 Sentinel 节点组成的分布式集群，可以实现故障发现，故障自动转移，配置中心和客户端通知。Redis Sentinel 的节点数量要满足 2n+1（n>=1）的奇数个。\",\"注意：哨兵也是一台 Redis 服务器，只是不提供数据服务，我们一般配置多个哨兵，防止单个哨兵宕机，通常哨兵配置数量为单数。\",\"优点\",\"Sentinel 集群部署简单；\",\"能够解决 Redis 主从模式下的高可用切换问题；\",\"很方便实现 Redis 数据节点的线形扩展，轻松突破 Redis 自身单线程瓶颈，可极大满足 Redis 大容量或高性能的业务需求；\",\"可以实现一套 Sentinel 监控一组 Redis 数据节点或多组数据节点。\",\"缺点\",\"部署相对 Redis 主从模式要复杂一些，原理理解更繁琐；\",\"资源浪费，Redis 数据节点中 slave 节点作为备份节点不提供写服务；\",\"Redis Sentinel 主要是针对 Redis 数据节点中的主节点的高可用切换，对 Redis 的数据节点做失败判定分为主观下线和客观下线两种，对于 Redis 的从节点有对节点做主观下线操作，并不执行故障转移。\"]},\"677\":{\"h\":\"哨兵的作用和原理\",\"t\":[\"作用：\",\"监控，不断检查 master 和 slave 是否正常运行\",\"通知， 当被监控的服务器出现问题时，向其它发送通知\",\"自动故障转移，根据投票机制选取新的 master，然后通过发布订阅模式通知其它 slave ，修改配置文件，让它们切换主机 。\",\"原理：\",\"每个 Sentinel 以每秒一次的频率向它所知的 Master，Slave 以及其他 Sentinel 实例发送一个 PING 命令。\",\"如果一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被当前 Sentinel 标记为主观下线。\",\"如果一个 Master 被标记为主观下线，则正在监视这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 的确进入了主观下线状态。当有足够数量的 Sentinel（大于等于配置文件指定的值，一般是超过半数）在指定的时间范围内确认 Master 的确进入了主观下线状态，则 Master 会被标记为客观下线 。\",\"当 Master 被 Sentinel 标记为客观下线时，Sentinel 向所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次。\",\"若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会变成主观下线。若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。\",\"Sentinel 集群内部通过投票机制竞选一个领头的 Sentinel，由领头的 Sentinel 来决定新 master，挑选备选的 master 原则： \",\"过滤故障的节点\",\"响应快的，由于 Sentinel 不断向 slave 发送指令，我们挑个响应快的\",\"选择优先级 slave-priority 最大的从节点作为主节点\",\"Sentinel 发送指令，新 master 上任，其它 salve 通过发布订阅模式切换 master。\"]},\"678\":{\"h\":\"Redis Cluster\",\"t\":[\"概述\",\"Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下主从和哨兵存在难以扩容以及单机存储、读写能力受限的问题，且每台 Redis 服务器都存储相同的数据，很浪费内存，所以在 Redis3.0 上加入了 Cluster 集群模式，实现了 Redis 的分布式存储。\",\"集群通过分片（sharding）来进行数据共享，每个 Redis 节点存储不同的内容，并提供复制和故障转移功能。 当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster 能起到很好的负载均衡的目的。\",\"Redis Cluster 集群节点最小配置 6 个节点以上（3 主 3 从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。\",\"优点\",\"无中心架构；\",\"数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布；\",\"可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除；\",\"高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升；\",\"降低运维成本，提高系统的扩展性和可用性。\",\"缺点\",\"Client 实现复杂。\",\"数据通过异步复制，不保证数据的强一致性。\",\"Slave 在集群中充当“冷备”，不能缓解读压力，当然可以通过 SDK 的合理设计来提高 Slave 资源的利用率。\",\"Key 批量操作限制，如使用 mset、mget 目前只支持具有相同 slot 值的 Key 执行批量操作。对于映射为不同 slot 值的 Key 由于 Keys 不支持跨 slot 查询，所以执行 mset、mget、sunion 等操作支持不友好。\",\"Key 事务操作支持有限，只支持多 key 在同一节点上的事务操作，当多个 Key 分布于不同的节点上时无法使用事务功能。\"]},\"679\":{\"h\":\"数据分片(节点数据分配问题)\",\"t\":[\"​ 为了将不同的 key 分散放置到不同的 redis 节点，通常的做法是获取 key 的哈希值，然后根据节点数(对服务器的数量)来求模，但这种做法有明显弊端，当我们需要增加或减少一个节点时，会造成大量的 key 无法命中，所以就提出了一致性 hash 的概念。但是，Redis 集群没有使用一致性 hash，而是引入了哈希槽的概念。\",\"​ Redis Cluster 采用哈希槽分区，所有的键根据哈希函数映射到 0~16383 整数槽内。每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，每一个节点负责维护一部分槽以及槽所映射的键值数据。\"]},\"680\":{\"h\":\"哈希槽是如何映射到 Redis 实例上呢？\",\"t\":[\"根据键值对的 key，使用 CRC16 算法，计算出一个 16 bit 的值；\",\"将 16 bit 的值对 16384 执行取模，得到 0 ～ 16383 的数表示 key 对应的哈希槽。\",\"根据该槽信息定位到对应的实例。\",\"计算公式：CRC16(key) % 16384 \",\"使用哈希槽的好处就在于可以方便的添加或移除节点：\",\"当需要增加节点时，只需要把其它节点的哈希槽挪到新节点即可\",\"当需要移除节点时，只需要移除节点上的哈希槽挪到其它节点即可\"]},\"681\":{\"h\":\"一致性哈希\",\"t\":[\"​ 一致性哈希算法也是使用取模算法，但是普通哈希的取模算法是对服务器的数量进行取模，而一致性哈希算法是对 2^32 取模，具体步骤如下：\",\"一致性哈希算法将整个哈希值空间按照顺时针反向组织成一个虚拟的圆环，称为 Hash 环；\",\"讲个服务器使用 Hash 函数进行哈希，具体可以选择服务器的 IP 地址或主机名作为关键字进行哈希，从而确定每台机器在哈希环上的位置\",\"最后使用算法定位数据访问到相应服务器：将数据 key 使用相同的函数 Hash 计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针寻找，第一台遇到的服务器就是其该定位到的服务器。\",\"一致性哈希优点：\",\"前面提到，如果简单对服务器数量进行取模，那么当服务器数量发生变化时，会产生缓存的雪崩，从而很有可能导致系统崩溃，而使用一致性哈希算法就可以很好的解决这个问题，因为一致性 Hash 算法对于节点的增减都只需重定位环空间中的一小部分数据，只有部分缓存会失效，不至于将所有压力都在同一时间集中到后端服务器上，具有较好的容错性和可扩展性。\",\"一致性哈希缺点（环的倾斜，解决方法：虚拟节点）\",\"一致性哈希算法在服务节点太少的情况下，容易因为节点分部不均匀而造成数据倾斜问题，也就是被缓存的对象大部分集中缓存在某一台服务器上，从而出现数据分布不均匀的情况，这种情况就称为 hash 环的倾斜。如下图所示：\",\"解决方法：虚拟节点机制\",\"hash 环的倾斜在极端情况下，仍然有可能引起系统的崩溃，为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点，一个实际物理节点可以对应多个虚拟节点，虚拟节点越多，hash 环上的节点就越多，缓存被均匀分布的概率就越大，hash 环倾斜所带来的影响就越小，同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射。具体做法可以在服务器 ip 或主机名的后面增加编号来实现，加入虚拟节点以后的 hash 环如下： \",\"​\"]},\"682\":{\"h\":\"集群如何扩容？\",\"t\":[\"​ 集群扩容通过来实现。重新分片可以将已经分配给某个节点的任意数量的 slot 迁移给另一个节点，并且相关槽所属的键值对也会从源节点被移动到目标节点。\"]},\"683\":{\"h\":\"复制与故障转移\",\"t\":[\"​ Redis 集群中的节点分为主节点（master）和从节点（slave），读&写请求其实都是在 master 上完成的，slave 节点只是充当了一个数据备份的角色，当 master 发生了宕机，就会将对应的 slave 节点提拔为 master，来重新对外提供服务。\",\"​ 简单来说，集群中的每个节点都会定期地向集群中其它节点发送 PING 消息，以此来检测对方是否在线，节点正常状态下接收到 PING 消息会返回一个 PONG 消息。针对 A 节点，某一个节点认为 A 宕机了，那么此时是疑似下线。而如果集群内超过半数的节点认为 A 挂了， 那么此时 A 就会被标记为 已下线。\",\"​ 一旦节点 A 被标记为了已下线，集群就会开始执行故障转移。其余正常运行的 master 节点会进行投票选举，从 A 节点的 slave 节点中选举出一个，将其切换成新的 master 对外提供服务。当某个 slave 获得了超过半数的 master 节点投票，就成功当选。\"]},\"684\":{\"h\":\"节点间通信\",\"t\":[\"​ Redis 集群各节点之间的通讯协议：gossip 协议。\",\"​ gossip 协议的主要用途就是信息传播和扩散，它的基本思想：一个节点想要分享一些信息给网络中的其它的一些节点。于是，它周期性的随机选择一些节点，并把信息传递给这些节点。这些收到信息的节点接下来会做同样的事情，即把这些信息传递给其他一些随机选择的节点。\",\"​ 主要交换故障信息、节点的增加和移除、hash slot 信息等。这种机制的好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力；缺点则是元数据更新有延时，可能导致集群的一些操作会有一些滞后。\"]},\"685\":{\"h\":\"netty 的线程模型\",\"t\":[\"Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端,\",\"简单的说, Netty 就是一个 网络框架 ,可以用来开发服务器或者客户端,并且 netty 与普通的我们理解的 tomcat,springBoot,OKHttp 等不一样的地方在于,它并不局限于 HTTP 协议,他是基于 socket 的, 所以当我们有需要使用自定义应用层协议的开发需求的时候, 用 netty 就很合适了,比如分布式,长连接什么的, 当然我们也可以基于 Netty 开发 Http 的服务器和客户端\"]},\"686\":{\"h\":\"Java并发\"},\"687\":{\"h\":\"自我介绍\",\"t\":[\"尊敬的面试官您好，我是来自北京交通大学电子与信息工程学院的王佳璇，我的专业是新一代电子信息技术，2023 年 6 月毕业后就职于恒生电子股份有限公司至今。在职期间我主要负责新一代资金系统银行间同业存款交易的对话报价平台开发，主要使用的技术栈有 java spring springboot mysql redis rocketmq，以及恒生的微服务框架 jres。为了满足客户的信创需求，我还参与了 summit ui v1.0 的前端开发，以及 summit 客户端的信创适配。主要使用的技术栈有 vue3 pinia antdv antvG2 vtable wine 虚拟机。读研期间，我获得了一等学业奖学金，发表了一篇 CCF C 类会议论文，就职期间，我连续两年获得公司年度优秀员工奖。我的自我介绍结束了，感谢您的聆听。\"]},\"688\":{\"h\":\"宝洁八大问\",\"t\":[\"Star 法则，情况，任务，行为，结果\"]},\"689\":{\"h\":\"问题一：考察目的性\",\"t\":[\"大三下决定考研，搜集资料、择校，四个月每天学习 12h，复习四门科目，一战上岸。 工作过程中，遭遇技术栈之外的 vue 项目和 wine 信创适配项目。制定学习和工作计划，markdown 文档记录学习和调试过程。wine 项目已进入客户环境部署，vue 项目已进入试用。\"]},\"690\":{\"h\":\"问题二：考察领导力\",\"t\":[\"vue 项目初期没有前端，我主动承担所有前端开发工作，完成项目 POC 之后领导开始招人，在新人引进的过程中我积极承担交接工作。因为熟悉业务，在开发过程中我积极教新人业务方面的内容，现在项目已稳步推进。\"]},\"691\":{\"h\":\"问题三：考察计划性\",\"t\":[\"在接到开发任务时我一般会根据任务的截止时间拆分出多个 deadline，比如一个涉及调用三方服务的后端接口开发，我会给阅读文档、调通 api、完成业务、自测等任务设置各自的截止时间，逐步完成任务。完成任务的过程中，对于发现的问题我会记录文档，供后续查阅。\"]},\"692\":{\"h\":\"问题四：考察说服力\",\"t\":[\"我觉得用事实说话很重要。vue 项目中我会封装一些公共组件、公共函数，也会有自己觉得用起来不错的开发方式，我一般会将代码质量写好，自己测通之后建议同事试用。\"]},\"693\":{\"h\":\"问题五：考察协作力\",\"t\":[\"同业存款交易平台开发时由于其报文结构和状态流转过程的复杂性，需要经常请教业务和架构师，我会先将问题记录清楚，准备好业务和架构师可能要看的日志和报文，然后再请教他们。最后攻克了技术难点。\"]},\"694\":{\"h\":\"问题六：考察创新性\",\"t\":[\"在部门遇到客户端信创问题时，我提出了用 wine 解决的方案，在经历过一段时间的调试后，成功通过信创认证，并正在客户环境部署。\"]},\"695\":{\"h\":\"问题七：考察前瞻性\",\"t\":[\"在 vue 项目组件封装的时候，我能够预判后端接口可能存在的问题，积极与后端开发沟通，完成公共组件的封装。\"]},\"696\":{\"h\":\"问题八：考察学习能力\",\"t\":[\"领导分派的 wine 信创和 summit ui 开发 POC 任务中，我主动跳出现有技术栈学习 wine 和 vue 开发相关知识，最终 POC 成功通过，客户端也正在客户那边实际部署。\"]},\"697\":{\"h\":\"职业生涯规划\",\"t\":[\"深耕java后端与AIGC技术融合，构建出高价值，可落地的AI提效工具。3年内成为具备AI工程化和分布式系统架构设计​​能力的高级java开发工程师。\",\"深耕java后端与金融科技领域，构建出高可靠、低时延的金融平台。3年内成为具备分布式金融系统架构设计能力的高级java开发工程师。\"]},\"698\":{\"h\":\"\"},\"699\":{\"h\":\"mysql\"},\"700\":{\"h\":\"发生死锁调试命令\",\"t\":[\"# 查看死锁信息 show engine innodb status\\\\G # 调整资源访问顺序 \"]},\"701\":{\"h\":\"慢 sql 查询\",\"t\":[\"# 查看当前正在执行的sql，找出慢sql show processlist # 打开慢sql日志 ## 临时打开 SET GLOBAL slow_query_log='ON' slow_query_log_file long_query_time ## 永久打开 my.cnf(linux) my.ini(windows) \"]},\"702\":{\"h\":\"查看执行计划\",\"t\":[\"explain \",\"较为重要的参数： table：表名 rows：预计扫描行数 extra：using index | using filesort | key：实际选择的索引，若为 null，就没用上索引 type：访问类型：const 唯一值 | eq_ref 主键/唯一索引连接 | index 全索引扫描 | ALL 全表扫描\"]},\"703\":{\"h\":\"sql 题\",\"t\":[\"select name,score,class from ( select name,score,class, ROW_NUMBER() over (partition by class order by score desc) as rn from table ) as st where rn < 10;\"]},\"704\":{\"h\":\"redis\"},\"705\":{\"h\":\"常用命令\",\"t\":[\"SET key value SET key value NX EX 过期时间\",\"LPUSH key value RPOP key value\"]},\"706\":{\"h\":\"8 种缓存淘汰策略\",\"t\":[\"redis-cli noevication allkeys-random allkeys-lru allkeys-lfu # 针对设置了过期时间的key： volatile-lru volatile-lfu volatile-random volatile-ttl \"]},\"707\":{\"h\":\"aof 刷盘机制\",\"t\":[\"就是说有 append 先放操作系统缓冲区，然后以指定的频率写入磁盘\",\"# redis.conf # 打开aof appendonly yes # 刷新频率 appnedfsync always | everysec | no \"]},\"708\":{\"h\":\"混合持久化\",\"t\":[\"在 aof 触发重写时(可设置 rewrite-percentage 和 rewrite-min-size)，将 rdb 写在开头，重写期间的 aof 写在末尾\",\"# 开启aof appendonly yes # 开启混合持久化 aof-use-rdb-preamble yes # 刷盘频率 appendfsync everysec # 重写时机 # RDB备份策略 save 900 1 save 300 10 save 60 10000 \"]},\"709\":{\"h\":\"rocketmq\"},\"710\":{\"h\":\"框架\"},\"711\":{\"h\":\"Spring中用到了哪些设计模式\"},\"712\":{\"h\":\"工厂模式\",\"t\":[\"​ Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。工厂模式是把创建对象的任务交给工厂，从而来降低类与类之间的耦合（工厂模式的优点）。Spring最主要的两个特性就是AOP和IOC，其中IOC就是控制反转，将对象的控制权转移给Spring，并由Spring创建实例和管理各个实例之间的依赖关系，其中，对象的创建就是通过BeanFactory 和 ApplicationContext 完成的。\",\"​ BeanFactory是Spring里面最底层的接口，是Ioc的核心，定义了IOC的基本功能，包含了各种Bean的定义，加载、实例化、依赖注入和生命周期管理。BeanFactory采用的是延迟加载形式来注入Bean的，只有在使用某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，就不能提前发现一些存在的Spring的配置问题。\",\"​ ApplicationContext接口作为BeanFactory的子类，除了提供BeanFactory所具有的功能外，还扩展了其他更完整的功能，对于Bean创建，ApplicationContext在容器启动时，一次性创建了所有的Bean。\",\"BeanFactory 和 ApplicationContext的对比\",\"BeanFactory：延迟注入(使用到某个bean的时候才会注入)，会占用更少的内存，程序启动速度更快。\",\"ApplicationContext：容器启动时，不管用没用到，一次性创建所有的bean(refresh()方法)，BeanFactory 仅提供了最基本的依赖注入支持，ApplicationContext 扩展了 BeanFactory ,除了有BeanFactory的功能还有额外更多功能，所以一般开发人员使用ApplicationContext会更多。\",\"ApplicationContext的三个实现类：\",\"ClassPathXmlApplication：把上下文文件当成类路径资源。\",\"FileSystemXmlApplication：从文件系统中的 XML 文件载入上下文定义信息。\",\"XmlWebApplicationContext：从Web系统中的XML文件载入上下文定义信息。\"]},\"713\":{\"h\":\"单例模式\",\"t\":[\"​ 在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。\",\"​ 单例模式的优点：\",\"对于频繁使用的对象，可以省略创建对象所花费的时间，对于重量级对象而言，是可观的一笔系统开销\",\"由于new操作的次数减少，因而对系统内存的使用频率也会降低，减轻GC线程回收内存的压力。\",\"​ Spring中bean的默认作用域就是singleton(单例的)。(Spring的依赖注入都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean 的创建)除了singleton作用域，Spring中bean还有下面几种作用域：\",\"xml : <bean id=\\\"userService\\\" class=\\\"top.snailclimb.UserService\\\" scope=\\\"singleton\\\"/> 注解：@Scope(value = \\\"singleton\\\") \",\"prototype多实例：每次请求都会创建一个新的bean实例。\",\"request：每一次HTTP请求都会创建一个新的bean，该bean仅在HTTP request内有效\",\"session：每一次HTTP请求都会创建一个新的bean，该bean仅在当前HTTP session内有效\",\"singleton与prototype的区别：设置scope值是singleton时，加载spring配置文件时候就会创建单实例对象，设置scope值是prototype时，不是在加载Spring配置文件的时候创建对象，在调用getBean方法时创建多实例对象。\"]},\"714\":{\"h\":\"DCL(单例：双重校验锁)\",\"t\":[\"为什么两次if判断？\",\"​ 外层判断提高效率(如果判断单例不为空直接不用执行加锁动作)，内层判断防止多次实例化对象。\",\"​ 使用volatile的目的：避免指令重排序。例子：线程1此时创建了singleton对象(分配了内存空间，也就是完成了第一个步骤)，但是2,3步骤乱序了，先执行了3，后执行2，也就是先将引用了指向了对象(由于对象还没有初始化，此时的对象是没有初始化的对象，而引用仅仅是一个地址)，这时如果线程2走到第一个if(没有在synchronized的代码块中，没有受到保护)的位置进行判断时此时INSTANCE不为空，他现在只是一个指向还没有初始化对象的一个地址，也就是t2线程拿到了一个未初始化完毕的单例。但也与原本的单例模式初衷违背，因此需要volatile来避免指令重排序，以防出问题。\",\"​ 实例化对象需要分为三个步骤(INSTANCE = new Singleton()为例)：\",\"分配内存空间(给singleton实例对象分配内存)\",\"初始化对象(调用Singleton的构造函数来初始化成员变量)\",\"将内存空间的地址赋值给对应的引用(将单例对象指向分配的内存空间，此时Instance(引用)才不为空)\"]},\"715\":{\"h\":\"代理设计模式\",\"t\":[\"​ AOP(面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任**（例如事务处理、日志管理、权限控制等）**封装起来，便于减少系统重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。\",\"​ 代理模式的设计动机就是通过代理对象来访问真实对象，通过建立一个对象代理类，由代理对象控制原对象的引用，从而实现对真实对象的操作。在代理模式中，代理对象主要起到一个中介的作用，用于协调与连接调用者(客户端)和被调用者(目标对象)，在一定程度上降低了系统的耦合度，同时也保护了目标对象。但缺点是在调用者与被调用者之间增加了代理对象，可能会造成请求的处理速度变慢。\",\"​ Spring AOP是基于动态代理的，主要有两种方式，JDK动态代理和CGLIB动态代理：\",\"如果有要代理的对象，实现了需要代理的类接口，那么Spring就会通过JDK Proxy去创建代理对象。JDK动态代理的核心是InvocationHandler接口和Proxy类，在获取代理对象时，使用Proxy类来动态创建目标类的代理类，当代理对象调用真实对象的方法时，InvocationHandler通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起。\",\"如果被代理类没有实现接口的实现类，此时Spring AOP就会使用CGLIB来动态代理目标类，CGLIB(Code Generation Library)，是一个代码生成的类库，可以在运行时动态生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP**。CGLIB是通过继承的方式实现动态代理，如果某个类被标记为final，那么其将无法使用CGLIB动态代理**。\"]},\"716\":{\"h\":\"代理模式与装饰器模式的区别\",\"t\":[\"代理模式跟装饰器模式比较类似，有些读者可能容易将他们混淆，这里我们简单介绍下两者的区别：\",\"（1）装饰器模式关注于在对象上动态添加新行为，而代理模式虽然也可以增加新的行为，但关注于控制对象的访问。\",\"（2）装饰器模式执行主体是原类；代理模式是代理原类进行操作，执行主体是代理类。\",\"（3）代理模式中，代理类可以对客户端隐藏真实对象的具体信息，因此使用代理模式时，我们常常在代理类中创建真实对象的实例。而装饰器模式的通常做法是将原始对象作为参数传给装饰者的构造器。也就是说。代理模式的代理和真实对象之间的对象通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。\"]},\"717\":{\"h\":\"Spring框架的优势？\",\"t\":[\"轻量：Spring 是轻量的，基本的版本大约 2MB。\",\"控制反转IOC：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。\",\"AOP：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开。\",\"容器：Spring 包含并管理应用中对象的生命周期和配置。\",\"MVC框架：Spring 的 Web 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。\",\"事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。\",\"异常处理：Spring 提供方便的 API 把具体技术相关的异常（比如由 JDBC，Hibernate or JDO 抛出的）转化为一致的 unchecked 异常\"]},\"718\":{\"h\":\"IOC AOP\",\"t\":[\"IOC\",\"​ SpringIOC解决的是对象管理和对象依赖问题，本来使我们手动new出来的对象，现在则把对象交给Spring的IOC容器管理。IOC容器可以理解为一个对象工厂，其管理这些对象的创建和依赖关系。，它不是什么技术，而是一种解耦的设计思想。它的主要目的是借助于“第三方”(Spring 中的 IOC 容器) 实现具有依赖关系的对象之间的解耦(IOC容易管理对象，你只管使用即可)，从而降低代码之间的耦合度。IOC 是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。\",\"​ **Spring IOC容器就像是一个工厂一样，当我们需要创建一个对象的时候，只要配置好配置文件/注解即可，完全不用考虑对象是如何创建出来的。**IOC容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到他们被完全销毁。\",\"​ 所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。\",\"​ 控制反转IOC：把原有自己掌控的事去交给别人去处理(是一种思想/设计模式)，比如本来有我们自己new出来的对象，现在交由IOC容器，把对象的控制权交给他了。\",\"​ 举个例子：\\\"对象a 依赖了对象 b，当对象 a 需要使用 对象 b的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b的时候， 我们可以指定 IOC 容器去创建一个对象b注入到对象 a 中\\\"。 对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权翻转，这就是控制反转名字的由来。\",\"​ 依赖注入(DI)：IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的，DI其实是控制反转的实现方式，对象无需自行创建或管理它的依赖关系，依赖关系被自动注入到需要他们的对象中去。依赖注入就是将实例变量传入到一个对象中去。\",\"​ DI是如何实现的？：依赖注入是通过反射实现的，它允许程序在运行的时候动态生成对象、执行对象的方法、改变对象属性，。\",\"​ 例子：比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的。\",\"IOC好处/作用：\",\"将对象集中处理，避免对象乱创建导致额外的内存开销。便于内存的优化\",\"降低耦合度，便于项目的扩展、易于维护，由容器去维护具体的对象。如果IoC+接口情况下，删除任意实现类都不会导致程序编译出错。虽然运行到特定得代码会报错，但是其他代码在使用时不会有问题，从侧面也反应出是松耦合。\",\"托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的。\",\"AOP(面向切面编程)\",\"​ 解决的是非业务代码抽取的问题，AOP的底层是动态代理技术，比如我们需要在方法上注入些重复性的非业务代码，就可以利用Spring AOP。AOP就是在方法前后增加非业务代码。\"]},\"719\":{\"h\":\"解释下AOP？\",\"t\":[\"​ 将与业务无关，却是业务模块所共同调用的逻辑封装起来，便于减少系统的重复代码，在需要执行时，，在不修改源码的基础上，对已有方法进行增强。\",\"​ 使用“横切”技术，AOP 把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，它们经常发生在核心关注点的多处，而各处都基本相似。比如：日志记录、性能统计、安全控制、事务处理、异常处理等。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。\",\"开发AOP三步走：编写核心业务代码→将公用代码抽取出来，制作成通知→在配置文件中，声明切入点与通知间的关系。\"]},\"720\":{\"h\":\"SpringAOP与Aspectj AOP的区别\",\"t\":[\"Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。\",\"Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，\",\"如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。\"]},\"721\":{\"h\":\"AOP的基本概念\",\"t\":[\"AOP相关术语\",\"说明\",\"Joinpoint（连接点）\",\"表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等。\",\"Pointcut（切入点）\",\"定义了相应的 Advice 将要发生的地方\",\"Advice（通知/增强）\",\"定义了在 Pointcut 里面定义的程序点具体要做的操作\",\"Aspect（切面）\",\"Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。\",\"Weaving（织入）\",\"把切面应用到目标对象并创建新的代理对象的过程\"]},\"722\":{\"h\":\"AOP 通知类型\",\"t\":[\"前置通知（Before）：目标方法被调用之前调用\",\"后置通知（After-returning）：目标方法被调用之后调用\",\"异常通知（After-throwing）：目标方法抛出异常后调用\",\"最终通知（After）：无论方法执行是否成功，都会调用\",\"环绕通知（Around）：在被通知的方法调用之前和调用之后执行自定义的行为\"]},\"723\":{\"h\":\"动态代理与静态代理\",\"t\":[\"​ 静态代理的的代理类是我们自己定义好的，在程序运行之前就已经编译完成，但是动态代理的代理类是在程序运行时创建的。相比于静态代理，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。比如我们想在每个代理方法之前都加一个处理方法，我们上面的例子中只有一个代理方法，如果还有很多的代理方法，就太麻烦了，我们来看下动态代理是怎么去实现的。\"]},\"724\":{\"h\":\"AOP代理的两种方式\",\"t\":[\"​ AOP中的代理说是由AOP框架动态生成的一个对象，该对象可以作为目标对象使用。Spring 中的AOP有两种，JDK动态代理，CGLIB代理，代理类在程序运行时创建的代理方式被成为动态代理。动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。是因为所有被代理执行的方法，都是通过在InvocationHandler中的invoke方法调用的，所以我们只要在invoke方法中统一处理，就可以对所有被代理的方法进行相同的操作了。例如，这里的方法计时，所有的被代理对象执行的方法都会被计时，然而我只做了很少的代码量。\"]},\"725\":{\"h\":\"JDK动态代理\",\"t\":[\"​ AOP 思想的实现一般都是基于代理模式 ，在 Java 中一般采用 JDK 动态代理模式，但是我们都知道，JDK 动态代理模式只能代理接口而不能代理类。因此，Spring AOP 会按照下面两种情况进行切换，因为 Spring AOP 同时支持 CGLIB、ASPECTJ、JDK 动态代理。\",\"​ 如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；JDK动态代理的核心是InvocationHandler接口和Proxy类，在获取代理对象时，使用Proxy类来动态创建目标类的代理类，当代理对象调用真实对象的方法时，InvocationHandler通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起。\",\"​ JDK动态代理原理：\",\"​ 在JDK动态代理中，要实现代理逻辑类就必须实现java.lang.reflect.InvocationHandler接口，实现里面的invoke方法。\",\"​ 第一步：建立代理对象和真实对象(实现类对象)之间的关系。用的bind方法，首先用成员变量来保存存入的真实对象。接着通过如下代码建立并生成代理对象。\",\"​ 生成代理对象的函数Proxy.newProxyInstance()方法中有三个参数，第一个参数是类加载器(真实对象的类加载器)，第二个参数是我们把生成的代理对象挂在那个接口之下，如果没有接口这里会报错。第三个参数是实现方法逻辑的代理类，就是用哪一个类去代理的，this代表的是当前对象，其必须实现InvocationHandler接口的invoke方法，invoke是代理逻辑的实现方法。以此将真实对象与动态对象绑定，同时返回代理对象。\",\"​ 第二步：实现代理逻辑方法，invoke方法可以实现代理逻辑，解释一下invoke方法的三个参数。\",\"​ 第一个参数proxy就是代理对象，也就是bind方法中返回的对象，method是当前调度方法也可以说是真实对象的方法，args就是调度方法的参数。当使用代理对象的调度方法(调度实现类中的方法)的时候就会执行invoke()方法（invoke中的invoke()方法指的是执行真实对象的方法，只不过是利用反射来实现的）。\"]},\"726\":{\"h\":\"CGLIB动态代理\",\"t\":[\"​ 如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类。其不需要提供任何接口只需要一个非抽象类就能完成动态代理。\",\"​ 这里使用的是CGLIB的加强者Enhancer，然后设置了超类的方法（setSuperclass，因为cls相当于真实对象的类），这里可以和JDK的获得真实对象的接口类比，其实就是设置将真实对象转换为什么类型的(这里的什么类型就是把真实对象转换为代理的这个代理的类型)；之后和JDK代理一样设置代理类是什么（setCallback）。其中的this代表当前对象，要求这个对象实现了MethodInterceptor类的intercept方法，然后再生产代理对象返回。\",\"​ 在这个类中interceptor就是代理逻辑方法，参数说明注释中已经说明。和JDK实现的代理没有什么区别，需要注意的是intercept方法里面，和JDK代理相比多了一个methodProxy参数，这个参数是方法代理，通过代理对象来实现真实对象的方法和之前略有不同。那这里为什么会有method这个参数呢，我的理解是CGLIB也可以代理接口，这个时候就可以用到它了，代理接口method、代理非抽象类用methodProxy，和之前的JDK相同一致。\"]},\"727\":{\"h\":\"两种代理的区别：\",\"t\":[\"JDK动态代理只能对实现了接口的类生成代理，没有实现接口的类不能使用。\",\"Cglib动态代理即使被代理的类没有实现接口，也可以使用，因为Cglib动态代理是使用继承被代理类的方式进行扩展。\",\"Cglib动态代理是通过继承的方式，覆盖被代理类的方法来进行代理，所以如果方法是被final修饰的话，就不能进行代理。\",\"​ JDK代理和CGLIB代理是很相似的，都是先生成代理对象，制定代理的逻辑类。而代理逻辑类要实现接口的一个方法，那么定义的方法就是代理对象的逻辑方法，可以控制真实对象的方法。区别是JDK代理只可以代理接口，而CGLIB既可以代理接口又可以代理非抽象类。\"]},\"728\":{\"h\":\"AOP实现的四种方式\",\"t\":[\"配置可以通过xml文件来进行，大概有四种方式：\",\" 配置ProxyFactoryBean，显式地设置advisors, advice, target等（基于代理的AOP ） \",\" 配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象 \",\" 通过<aop:config>来配置（纯POJO切面） \",\" 通过<aop: aspectj-autoproxy>来配置，使用**AspectJ的注解来标识通知及切入点** \"]},\"729\":{\"h\":\"解释下IOC？\",\"t\":[\"，用来削减程序间的耦合，解除代码中的依赖关系。\",\"实现原理\",\"创建 XML 配置文件，配置要创建的对象类\",\"创建工厂类，使用 dom4j 解析 XML 配置文件\",\"使用来创建类对象\",\"依赖注入也是通过反射机制来实现的，实例化一个类时，它通过反射调用类中 set 方法，将事先保存在 HashMap 中的类属性注入到类中。 \",\"应用场景：MVC 三层架构中，尽量避免使用 new 来实例化对象，最好将对象交由 Spring 容器创建，解耦。\"]},\"730\":{\"h\":\"常用注入bean的方式(怎么定义bean)\",\"t\":[\"构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。\",\"Setter 方法注入：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂方法实例化 bean 之后，调用该 bean 的 Setter 方法，即实现了基于 Setter 的依赖注入。\",\"基于注解的注入：最好的解决方案是用构造器参数实现强制依赖，Setter 方法实现可选依赖。\"]},\"731\":{\"h\":\"ioc与工厂模式区别\",\"t\":[\"​ 举个例子，如果用户需求发生变化，要把Chinese类修改一下。那么前一种工厂模式，就要更改Factory类的方法，并且重新编译布署。而IoC只需 要将class属性改变一下，并且由于IoC利用了Java反射机制，这些对象是动态生成的，这时我们就可以热插拨Chinese对象（不必把原程序停止 下来重新编译布署）\",\"​ 只有Java代码发生改变,JVM才需要重新编译布署.而XML文件的修改并没有发生Java代码发生改变,所以JVM不需要重新编译部署.如果下次我想要个英国人我只需要加个新的标签就行了,所以说热插拨。\",\"​ 注意，IoC的灵活性是有代价的：设置步骤麻烦、生成对象的方式不直观、反射比正常生成对象在效率上慢一点。因此使用IoC要看有没有必要，我认为比较通用的判断方式是：用到工厂模式的地方都可以考虑用IoC模式。\"]},\"732\":{\"h\":\"Bean相关\"},\"733\":{\"h\":\"bean的生命周期\",\"t\":[\"简单点说就是：bean的实例化–>bean的初始化–>bean的使用–>bean的销毁\",\"实例化：也就是new一个对象\",\"属性注入：Spring上下文对实例化的bean进行配置（IOC注入）\",\"设置beanId：如果实现BeanNameAware接口，调用setBeanName()方法设置ID\",\"调用BeanFactoryAware.setBeanFactory(setBeanFactory(BeanFactory)：可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以；\",\"调用ApplicationContextAware.setApplicationContext(ApplicationContext)：与BeanFactoryAware.setBeanFactory同样作用，但是ApplicationContextAware是子接口，可以实现更多接口；\",\"实例化之前调用：BeanPostProcessor.postProcessBeforeInitialization(Object obj, String s)方法调用，\",\"实例化：如果在spring配置中还配置了init-method属性，会自动调用该方法；\",\"实质化之后调用：如果关联BeanPostProcessor接口，调用postProcessAfterInitialization(Object obj, String s)方法， 注：前面这里我们就完成bean的实例化\",\"bean的销毁：当bean不再被使用时，就会调用destroy()方法；\",\"bean销毁调用方法：如果配置了destroy-method方法，会自动调用该方法；\"]},\"734\":{\"h\":\"Bean的作用域\",\"t\":[\"xml : <bean id=\\\"userService\\\" class=\\\"top.snailclimb.UserService\\\" scope=\\\"singleton\\\"/> 注解：@Scope(value = \\\"singleton\\\") \",\"@Scope(\\\"prototype\\\") / 设置作用域 \",\"singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的；(使用单例的原因：性能、不需要多例)\",\"prototype : 每次请求都会创建一个新的 bean 实例，创建后spring将不再对其管理；\",\"request：每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效，和 prototype 不同的是，spring 会继续监听管理；\",\"session : 每一次会话都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效；\",\"global session：全局的web域，类似于servlet中的application。\",\"singleton与prototype的区别：设置scope值是singleton时，加载spring配置文件时候就会创建单实例对象，设置scope值是prototype时，不是在加载Spring配置文件的时候创建对象，在调用getBean方法时创建多实例对象。\"]},\"735\":{\"h\":\"bean 线程安全问题？\",\"t\":[\"​ Spring 不保证 bean 的线程安全。Spring 中的 bean 默认都是单例的，当单例中存在竞争状态，即有线程安全问题。但一般不会出现线程安全问题，因为在 Spring 中，绝大部分 bean 都是无状态的，因此即使这些 bean 默认是单例的，也不会出现线程安全问题。\",\"有状态的 bean：对象中有实例变量（成员变量），可以保存数据，是非线程安全的 无状态的 bean：对象中没有实例变量（成员变量），不能保存数据，可以在多线程环境下共享，是线程安全的 \",\"比如：Controller、Service、Dao 这些类，这些类里面通常不会含有成员变量，因此它们被设计成单例的。如果这些类中定义了实例变量，就线程不安全了，所以尽量避免定义实例变量。\",\"解决线程并发问题\",\"Spring 对一些 Bean 中非线程安全状态采用 进行处理，解决线程安全问题。\"]},\"736\":{\"h\":\"获取bean的方式\",\"t\":[\"Spring 在代码中获取 bean 的几种方式\",\"在初始化时保存 ApplicationContext 对象：这种方式适用于采用 Spring 框架的独立应用程序，需要程序通过配置文件手工初始化Spring的情况。\",\"ApplicationContext ac = new FileSystemXmlApplicationContext(\\\"applicationContext.xml\\\"); ac.getBean(\\\"userService\\\");//比如：<bean id=\\\"userService\\\" class=\\\"com.cloud.service.impl.UserServiceImpl\\\"></bean> \",\"通过 Spring 提供的 utils 类获取 ApplicationContext 对象：这种方式适合于采用 Spring 框架的 B/S 系统，通过ServletContext对象获取ApplicationContext对象，然后在通过它获取需要的类实例。下面两个工具方式的区别是，前者在获取失败时抛出异常，后者返回null。\",\"ApplicationContext ac1 = WebApplicationContextUtils.getRequiredWebApplicationContext(ServletContext sc); ApplicationContext ac2 = WebApplicationContextUtils.getWebApplicationContext(ServletContext sc); ac1.getBean(\\\"beanId\\\"); ac2.getBean(\\\"beanId\\\"); \",\"抽象类 ApplicationObjectSupport 提供getApplicationContext()方法，可以方便的获取 ApplicationContext。Spring初始化时，会通过该抽象类的setApplicationContext(ApplicationContext context)方法将ApplicationContext 对象注入。\",\"WebApplicationContext wac = (WebApplicationContext)servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE); \",\"继承自抽象类 WebApplicationObjectSupport：类似上面方法，调用getWebApplicationContext()获取WebApplicationContext\",\"实现接口 ApplicationContextAware：实现该接口的setApplicationContext(ApplicationContext context)方法，并保存ApplicationContext 对象。Spring初始化时，会通过该方法将 ApplicationContext 对象注入。\",\"通过 Spring 提供的 ContextLoader：最后提供一种不依赖于servlet,不需要注入的方式。但是需要注意一点，在服务器启动时，Spring容器初始化时，不能通过以下方法获取Spring 容器\",\"WebApplicationContext wac = ContextLoader.getCurrentWebApplicationContext(); wac.getBean(beanID); \"]},\"737\":{\"h\":\"BeanFactory实现原理\",\"t\":[\"实质：由一个工厂类根据传入的参数，动态决定该创建哪一个产品类\",\"实现原理：\",\"bean容器的启动阶段：\",\"读取bean的xml配置文件，将bean元素分别转换成一个BeanDefinition对象\",\"然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个concurrentHashMap中。\",\"将BeanDefinition注册到了BeanFactory之后，spring提供了一个扩展的切口，允许通过实现接口BeanFactoryPOSTProcessor在此处插入我们定义的代码。典型的例子就是：PropertyPlaceholderConfigurer，我们一般在配置数据库的dataSource时使用到的占位符的值，就是它注入进去的。\",\"容器中bean实例化阶段\",\"实例化阶段主要是通过反射或者CGLIB对bean进行实例化，在这个阶段Spring又给我们暴露了很多的扩展点\",\"各种Aware接口，比如BeanFactoryAware，对于实现了这些Aware接口的bean，在实例化bean时Spring会帮我们注入对应的BeanFactory实例\",\"BeanPostProcessor接口，实现了BeanPostProcessor接口的bean，在实例化bean时Spring会帮我们调用接口中的方法\",\"InitializingBean接口，实现了InitializingBean接口的bean，在实例化bean时Spring会帮我们调用接口中的方法\",\"DisposableBean接口，实现了DisposableBean接口的bean，在该bean死亡时Spring会帮我们调用接口中的方法。\"]},\"738\":{\"h\":\"Spring的事务\"},\"739\":{\"h\":\"事务的实现方式\",\"t\":[\"Spring 中事务有两种实现方式：编程式事务 & 声明式事务\",\"编程式事务\",\"通过编码的形式来管理和维护事务。\",\"声明式事务，声明式事务实现又有两种方式：\",\"基于 XML 配置文件的方式\",\"在业务方法上添加 @Transactional 注解，将事务规则应用到业务逻辑中\",\"区别：编程式事务每次实现都要单独实现，但业务量大功能复杂时，使用编程式事务无疑是痛苦的，而声明式事务不同，声明式事务属于无侵入式，不会影响业务逻辑的实现，只需要在配置文件中做相关的事务规则声明或者通过注解的方式，便可以将事务规则应用到业务逻辑中。 显然声明式事务管理要优于编程式事务管理，这正是Spring倡导的非侵入式的编程方式。唯一不足的地方就是声明式事务管理的粒度是方法级别，而编程式事务管理是可以到代码块的，但是可以通过提取方法的方式完成声明式事务管理的配置。\"]},\"740\":{\"h\":\"事务的传播机制\",\"t\":[\"​ 事务传播行为是为了解决业务层方法之间互相调用的事务问题。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。在 TransactionDefinition 定义中包括了如下几个表示传播行为的常量：\",\"支持当前事务的情况：\",\"TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务；\",\"TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行；\",\"TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。\",\"不支持当前事务的情况：\",\"TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起；\",\"TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。\",\"TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。\",\"其他情况：\",\"TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED。\"]},\"741\":{\"h\":\"事务的隔离级别\",\"t\":[\"TransactionDefinition 接口中定义了五个表示隔离级别的常量：\",\"TransactionDefinition.ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ 隔离级别、Oracle 默认采用的 READ_COMMITTED 隔离级别；\",\"TransactionDefinition.ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读；\",\"TransactionDefinition.ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生；\",\"TransactionDefinition.ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生；\",\"TransactionDefinition.ISOLATION_SERIALIZABLE：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，严重影响性能。\"]},\"742\":{\"h\":\"Spring 框架中用到了哪些设计模式？\",\"t\":[\"工厂设计模式 : Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象；\",\"代理设计模式 : Spring AOP 功能的实现；\",\"单例设计模式 : Spring 中的 Bean 默认都是单例的；\",\"模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式；\",\"包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源；\",\"观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用；\",\"适配器模式：Spring AOP 的增强或通知(Advice)使用到了适配器模式、SpringMVC 中也是用到了适配器模式适配 Controller。\"]},\"743\":{\"h\":\"相关注解\",\"t\":[\"基于注解方式实现对象创建以及注入属性\",\"对象创建的注解：\",\"@Component：普通组件\",\"@Service：作用于业务逻辑层\",\"@Controller：作用于表现层（SpringMVC的注解）\",\"@Repository：作用于持久层\",\"属性注入的注解：\",\"@AutoWired：根据属性类型进行自动装配。\",\"@Qualifier：根据属性名称进行注入，和@AutoWired配合使用。\",\"@Resource：可以根据类型注入，可以根据名称注入。\",\"@Value：注入普通类型属性。\",\"完全注解开发：\",\"@Configuration //作为配置类，替代xml配置文件 @ComponentScan(basePackages =\\\"com.myj.spring5\\\") public class SpringConfig { //code } \"]},\"744\":{\"h\":\"JDBC 连接数据库步骤？\",\"t\":[\"加载 JDBC 驱动程序\",\"获取数据库连接对象\",\"创建数据库操作对象\",\"执行 SQL 语句\",\"获取查询结果集\",\"处理异常，关闭 JDBC 对象资源\"]},\"745\":{\"h\":\"Statement 和 PrepareStatement 区别？\",\"t\":[\"Statement 和 PrepareStatement 都是数据库操作对象，它们之间的区别：\",\"Statement 用于执行静态 sql 语句，执行时必须指定一个事先准备好的 sql 语句，也就是说 sql 语句是静态的\",\"PrepareStatement 支持预编译，采用 Cache 机制，对于多次重复执行的 sql 语句，可直接从 Cache 中取出，提高执行效率\",\"PrepareStatement 提高了代码的安全性，防止 sql 注入，sql 语句中可以使用 “？” 占位符，可以传动态的参数\",\"Statement stmt = connect.createStatementz(); String sql = \\\"SELECT * FROM myj WHERE userId=10000 AND name LIKE 'xiaoming'\\\"; ResultSet rs = stmt.executeUpdate(sql); PreparedStatement preparedStatement = connect.prepareStatement(\\\"SELECT * FROM myj WHERE userId=? AND name LIKE ?\\\"); prepareStatement.setInt(1, 10000); prepareStatement.setString(2, \\\"xiaoming\\\"); prepareStatement.executeUpdate(); \"]},\"746\":{\"h\":\"什么是Mybatis？优缺点\",\"t\":[\"​ MyBatis 是一个半ORM（对象关系映射）框架，内部封装了JDBC，是一个与数据库打交道的持久层框架，可以通过 XML 和注解来实现数据库 CRUD 操作，简化了开发。开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建 Statement 等繁杂的过程。程序员直接编写原生态 SQL，可以严格控制 SQL 执行性能，灵活度高。\",\"优点：\",\"基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 SQL 与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态 SQL 语句，并可重用；\",\"与 JDBC 相比，减少了代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；\",\"很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）；\",\"提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系组件维护。\",\"缺点：\",\"SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求；\",\"SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。\"]},\"747\":{\"h\":\"什么是 ORM？\",\"t\":[\"​ ORM（Object Relational Mapping）即对象关系映射，简单来说就是在关系型数据库和对象之间做一个映射。即可以将对象自动持久化到数据库中，也可以将数据库表中的行转化为 Java 对象。\"]},\"748\":{\"h\":\"为什么要做持久化和ORM设计？\",\"t\":[\"​ 在目前的企业应用系统设计中，MVC，即 Model（模型）- View（视图）- Control（控制）为主要的系统架构模式。MVC 中的 Model 包含了复杂的业务逻辑和数据逻辑，以及数据存取机制（如 JDBC的连接、SQL生成和Statement创建、还有ResultSet结果集的读取等）等。将这些复杂的业务逻辑和数据逻辑分离，以将系统的紧耦合关系转化为松耦合关系（即解耦合），是降低系统耦合度迫切要做的，也是持久化要做的工作。MVC 模式实现了架构上将表现层（即View）和数据处理层（即Model）分离的解耦合，而持久化的设计则实现了数据处理层内部的业务逻辑和数据逻辑分离的解耦合。 而 ORM 作为持久化设计中的最重要也最复杂的技术，也是目前业界热点技术。\"]},\"749\":{\"h\":\"MyBatis 与 Hibernate 的区别？\",\"t\":[\"MyBatis 是半自动 ORM 框架，它需要程序员自己编写 SQL；Hibernate 是全自动 ORM 框架，可以做到无 SQL 对数据库进行操作；\",\"MyBatis 直接编写原生 SQL，可以严格控制 SQL 执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是 MyBatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套 SQL 映射文件，工作量大。\",\"Hibernate 会根据模型配置自动生成和执行 SQL 语句，灵活度差。但是对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用 Hibernate 开发可以节省很多代码，提高效率。\"]},\"750\":{\"h\":\"#{ } 和 ${ } 区别？\",\"t\":[\"#{}是预编译处理，${}是字符串替换。\",\"#{key}：获取参数的值，预编译到 SQL 中，可简单理解为一个占位符 “？”，有效防止 SQL 注入，安全。\",\"${key}：获取参数的值，拼接到 SQL 中，存在 SQL 注入问题，不安全。\"]},\"751\":{\"h\":\"resultMap和resultType的区别\",\"t\":[\"基本映射：（resultType）使用resultType进行输出映射，只有查询出来的列名和pojo列名和pojo的属性名一致，该列才可以映射成功。（数据库，实体，查询字段,这些全部都得一一对应）\",\"高级映射：（resultMap） 如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。（高级映射，字段名称可以不一致，通过映射来实现）常用在列名和Java对象属性不一样的情况。\",\"​ resultType和resultMap功能类似 ，都是返回对象信息 ，但是resultMap要更强大一些 ，可自定义。因为resultMap要配置一下，表和类的一一对应关系，所以说就算你的字段名和你的实体类的属性名不一样也没关系，都会给你映射出来，但是，resultType就比较鸡肋了，必须字段名一样，比如说 cId和c_id 这种的都不能映射 。\"]},\"752\":{\"h\":\"Mybatis 的缓存？\",\"t\":[\"​ MyBatis 提供了缓存策略来减少数据库的查询次数，MyBatis 中缓存分为一级缓存，二级缓存，此外，为了提高扩展性，MyBatis 还定义了缓存接口 Cache，我们可以通过实现 Cache 接口来自定义二级缓存。\",\"一级缓存：也叫本地缓存，是 SqlSession 级别的缓存，是默认开启的。如果 SqlSession 执行插入、更新、删除，会清空 SqlSession 中的一级缓存，这样做的目的是让缓存中存储的是最新的信息，避免脏读。\",\"二级缓存 ：二级缓存也叫全局缓存，是基于 namespace 级别的缓存，需要手动开启配置。一级缓存作用域太低，所以诞生了二级缓存。\",\"缓存查询原理：\",\"先看二级缓存中有没有\",\"再看一级缓存中有没有\",\"查询数据库\"]},\"753\":{\"h\":\"Mybatis 分页？\",\"t\":[\"​ MyBatis 使用 RouBounds 对象对查询结果集进行分页，然后按照 RowBounds 设置的参数进行截取，它是针对 ResultSet 结果集执行的内存分页，而非物理分页。即：查出所有记录再按偏移量和 limit 取结果。，一般情况下我们会使用 Mybaits 的分页插件工具 PageHelper 来完成分页。基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，添加对应的物理分页语句和物理分页参数。\"]},\"754\":{\"h\":\"三层架构与MVC\",\"t\":[\"​ Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。\",\"首先，三层架构与MVC的目标一致：都是为了解耦和、提高代码复用。MVC是一种设计模式，而三层架构是一种软件架构。\",\"三层架构：\",\"表现层：负责接收客户端请求，接收用户参数，向客户端响应结果。\",\"业务层：负责业务逻辑处理，如：事务控制。\",\"持久层：和数据库交互，对数据库表进行 CRUD。\",\"MVC：\",\"MVC 是 Model — View — Controler 的简称，它是一种设计模式，它分离了表现与交互。它被分为三个核心部件：模型、视图、控制器。\",\"Model（模型）：模型负责各个功能的实现（如登录、增加、删除等）。模型用JavaBean（分为封装业务逻辑的JavaBean和封装数据的JavaBean）实现。\",\"View（视图）：负责页面的显示、与用户的交互。包含各种表单，主要用到的技术有html/css/jsp/js等前端技术。\",\"Controller（控制器）：控制器负责将视图与模型一一对应起来，相当于一个模型分发器。所谓分发就是：①接收请求，并将该请求跳转（转发，重定向）到模型进行处理。②模型处理完毕后，再通过控制器，返回给视图中的请求处。\"]},\"755\":{\"h\":\"SpringMVC 工作流程？\",\"t\":[\"对Servlet进行封装，屏蔽掉了很多Servlet的细节。\",\"控制器 DispatcherServlet 接受客户端请求 -> 找到处理器映射 HandlerMapping (处理器映射器)解析请求对应的 Handler ->HandlerAdapter(处理器适配器)会根据 Handler(处理器) 来调用真正的处理器来处理请求，并处理相应的业务逻辑 -> 处理器返回一个模型视图 ModelAndView -> 视图解析器(viewResolver)进行解析 -> 返回一个视图对象 -> 前端控制器 DispatcherServlet 渲染数据（Model）-> 将得到视图对象返回给用户。\",\"具体如下：\",\"用户向服务器发送请求，请求被 Spring 前端控制器Servelt DispatcherServlet 捕获；\",\"前端控制器DispatcherServlet 对请求 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器List，就是HandlerExecutionChain ），最后以 HandlerExecutionChain 对象的形式返回；\",\"DispatcherServlet 根据获得的 Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得 HandlerAdapter 后，此时将开始执行拦截器的 preHandler(…)方法）\",\"(调用适配器对象实例的handle方法真正执行代码逻辑处理)提取 Request 中的模型数据，填充 Handler 入参，开始执行Handler（Controller)。在填充 Handler 的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：\",\"HttpMessageConveter：将请求消息（如：Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息；\",\"数据转换：对请求消息进行数据转换。如：String 转换成 Integer、Double 等；\",\"数据格式化：对请求消息进行数据格式化。如：将字符串转换成格式化数字或格式化日期等；\",\"数据验证：验证数据的有效性（长度、格式等），验证结果存储到 BindingResult 或 Error 中;\",\"Handler 执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；\",\"根据返回的 ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的 ViewResolver)返回给DispatcherServlet；\",\"ViewResolver 结合 Model 和 View(视图)，来渲染视图；(将模型数据填充到视图中)\",\"将渲染结果返回给客户端。\",\"视图view是一个接口，它的实现类支持不同的视图类型如jsp，freemarker，pdf等等。\"]},\"756\":{\"h\":\"SpringMVC 的核心组件？\",\"t\":[\"DispatcherServlet：前端控制器，它是整个流程的控制中心，由它调用其它组件处理用户的请求。相当于MVC中的C。\",\"HandlerMapping：处理器映射器，根据用户请求找到具体哪个类，哪个方法执行。\",\"HandlerAdapter：处理器适配器，按照HandlerAdapter 要求的规则去执行 Handler。\",\"Handler：处理器，由我们根据自己业务开发。\",\"ViewResolver：视图解析器，把逻辑视图解析成具体的视图\",\"View：View 是一个接口，实现类支持不同的 View 类型（jsp、freemarker…）。\"]},\"757\":{\"h\":\"SpringMVC 的控制器是不是单例模式，如果是会有什么问题，怎么解决？\",\"t\":[\"是单例模式，所以在多线程访问的时候有线程安全问题。但是不要使用同步，会影响性能，解决方案是在控制器里面不能写字段。\"]},\"758\":{\"h\":\"SpringMVC 怎么样设定重定向和转发的？\",\"t\":[\"转发：在返回值前面加 “forward:”\",\"重定向：在返回值前面加 “redirect:”\"]},\"759\":{\"h\":\"过滤器 & 拦截器 & 监听器？\",\"t\":[\"当访问服务器的资源时，过滤器、拦截器可以将请求拦截下来，完成一些特殊的功能，如：登录验证、统一编码处理、敏感字符过滤。\",\"过滤器\",\"监听器\",\"拦截器\",\"关注的点\",\"web请求\",\"系统级别参数、对象\",\"Action（部分web请求）\",\"如何实现的\",\"函数回调\",\"事件\",\"Java反射机制（动态代理）\",\"应用场景\",\"设置字符编码、URL级别的权限访问控制、过滤敏感词汇、压缩响应信息\",\"统计网站在线人数、清除过期session\",\"拦截未登陆用户、审计日志\",\"是否依赖Servlet容器\",\"依赖\",\"不依赖\",\"Servlet提供的支持\",\"Filter接口\",\"ServletContextListener抽象接口、HttpSessionListener抽象接口\",\"Spring提供的支持\",\"HandlerInterceptorAdapter类、HandlerInterceptor接口\",\"级别\",\"系统级\",\"系统级\",\"非系统级\",\"过滤器（Filter）\",\"过滤器的配置比较简单，直接实现 Filter 接口，Filter 接口中定义了 3 个方法：\",\"init( )：服务器启动后，会创建 Filter 对象，然后调用 init 方法，只执行一次，用于加载资源\",\"doFilter( )：每一次请求被拦截资源时执行，执行多次\",\"destroy( )：服务器关闭后，Filter 对象被销毁，如果服务器是正常关闭，则会执行该方法，只执行一次，用于释放资源\",\"过滤器执行流程：\",\"执行过滤器 2. 执行放行后的资源 3. 回来执行过滤器放行下边的代码\",\"拦截器（Interceptor）\",\"SpringMVC配置拦截器直接实现 HandlerInterceptor 接口，HandlerInterceptor 接口中定义了 3 个方法：\",\"preHandle( )：这个方法将在请求处理之前进行调用，返回值为 true 表示继续执行，false 表示当前请求结束\",\"postHandle( )：只有在 preHandle( ) 方法返回值为 true 时才会执行。在 Controller 中的方法调用之后，DispatcherServlet 返回渲染视图之前被调用\",\"afterCompletion( )：只有在 preHandle( ) 方法返回值为 true 时才会执行。在整个请求结束之后， DispatcherServlet 渲染了对应的视图之后执行，并通过 addPathPatterns、excludePathPatterns 等属性设置需要拦截或需要排除的 URL。\",\"监听器\",\"它可以监听客户端的请求、服务器端的操作从而自动执行一些操作等。监听器不需要访问，它是自动执行的，由一些事件自动触发。\",\"常用的监听接口：ServletContext 监听接口、ServletSession 监听接口。\"]},\"760\":{\"h\":\"SSM框架\"},\"761\":{\"h\":\"什么是SSM框架\",\"t\":[\"​ SSM框架是spring、springMVC、和mybatis框架的整合，是标准的MVC模式。标准的SSM框架有四层，分别是持久层dao层(mapper)，业务层service层，表现层controller层和view层。使用spring实现业务对象的管理，使用springMVC负责请求的转发和视图管理，mybatis作为数据对象的持久化引擎。\"]},\"762\":{\"h\":\"持久层：dao层(mapper)层\",\"t\":[\"​ 作用：主要是做数据持久层工作，负责与数据库进行联络的一些任务都封装在此。\",\"Dao层首先设计的是接口，然后在spring的配置文件中定义接口的实现类\",\"然后可以在模块中进行接口的调用来进行数据业务的处理。(不用关心接口的实现类是哪个类)\",\"数据源的配置以及有关数据库连接的参数都在Spring的配置文件中进行配置\"]},\"763\":{\"h\":\"业务层：service层\",\"t\":[\"​ 作用：Service层主要负责业务模块的逻辑应用设计\",\"先设计接口然后在设计实现类，然后在spring的配置文件中配置其实现的关联。(业务逻辑层的实现具体要调用到自己已经定义好的Dao的接口上)这样就可以在应用中调用Service接口来进行业务处理。\",\"建立好Dao之后再建立service层，service层又要在controller层之下，因为既要调用Dao层的接口又要提供接口给controller层。每个模型都有一个service接口，每个接口分别封装各自的业务处理的方法。\"]},\"764\":{\"h\":\"表现层：Controller层\",\"t\":[\"​ 作用：负责具体的业务模块流程的控制。\",\"配置也同样在Spring的配置文件中进行\",\"调用Service层提供的接口来控制业务流程\",\"业务流程的不同会有不同的控制器，在具体的开发中可以将我们的流程进行抽象的归纳，设计出可以重复利用的子单元流程模块。\"]},\"765\":{\"h\":\"view层\",\"t\":[\"​ 作用：主要和控制层紧密结合，主要负责前台jsp页面的表示。\"]},\"766\":{\"h\":\"各层之间的联系\",\"t\":[\"​ DAO层，Service层这两个层次都可以单独开发，互相的耦合度很低，完全可以独立进行，这样的一种模式在开发大项目的过程中尤其有优势，Controller，View层因为耦合度比较高，因而要结合在一起开发，但是也可以看做一个整体独立于前两个层进行开发。这样，在层与层之前我们只需要知道接口的定义，调用接口即可完成所需要的逻辑单元应用，一切显得非常清晰简单。\"]},\"767\":{\"h\":\"什么是Springboot\",\"t\":[\"用来简化spring应用的初始搭建以及开发过程 使用特定的方式来进行配置（properties或yml文件）\",\"创建独立的spring应用程序 main方法运行\",\"嵌入的Tomcat 无需部署war文件\",\"简化maven配置\",\"自动配置spring添加对应功能starter自动化配置\",\"答：spring boot来简化spring应用开发，约定大于配置，去繁从简，just run就能创建一个独立的，产品级别的应用\"]},\"768\":{\"h\":\"Springboot有哪些优点\",\"t\":[\"快速创建独立运行的spring项目与主流框架集成\",\"使用嵌入式的servlet容器，应用无需打包成war包\",\"starters自动依赖与版本控制\",\"大量的自动配置，简化开发，也可修改默认值\",\"准生产环境的运行应用监控\",\"与云计算的天然集成\",\"独立运行 简化配置 自动配置 无代码生成和XML配置 无需部署war文件\"]},\"769\":{\"h\":\"\",\"t\":[\"这可以使用DEV工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat将重新启动。\",\"Spring Boot有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。\",\"开发人员可以重新加载Spring Boot上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot在发布它的第一个版本时没有这个功能。\",\"这是开发人员最需要的功能。DevTools模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供H2数据库控制台以更好地测试应用程序。\",\"org.springframework.boot\",\"spring-boot-devtools\",\"true\"]},\"770\":{\"h\":\"\",\"t\":[\"1、Spring\",\"Spring最重要的特征是依赖注入。所有 SpringModules 不是依赖注入就是 IOC 控制反转。\",\"当我们恰当的使用 DI 或者是 IOC 的时候，我们可以开发松耦合应用。松耦合应用的单元测试可以很容易的进行。\",\"2、Spring MVC\",\"Spring MVC 提供了一种分离式的方法来开发 Web 应用。通过运用像 DispatcherServelet，MoudlAndView 和 ViewResolver 等一些简单的概念，开发 Web 应用将会变的非常简单。\",\"3、SpringBoot\",\"Spring 和 SpringMVC 的问题在于需要配置大量的参数。\",\"Spring Boot 通过一个自动配置和启动的项目来解决这个问题。为了更快的构建产品就绪应用程序，Spring Boot 提供了一些非功能性特征。\"]},\"771\":{\"h\":\"\",\"t\":[\"Spring Boot 项目的启动注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：\",\"@SpringBootConfiguration\",\"@ComponentScan\",\"@EnableAutoConfiguration\",\"其中@EnableAutoConfiguration 是实现自动配置的入口，该注解又通过 @Import 导入第三方提供的bean配置类：AutoConfigurationImportSelector，在该类中加载 META-INF/spring.factories 的配置信息。然后筛选出以 @EnableAutoConfiguration 为 key 的数据，加载到 IOC 容器中，实现自动配置功能！\",\"​ 本质上来说，其实@EnableAutoConfiguration会帮助springboot应用把所有符合@Configuration配置都加载到当前SpringBoot创建的IoC容器。\"]},\"772\":{\"h\":\"\",\"t\":[\"Starter是Spring Boot中的一个非常重要的概念，Starter相当于模块，它能将模块所需的依赖整合起来并对模块内的Bean根据环境（ 条件）进行自动配置。使用者只需要依赖相应功能的Starter，无需做过多的配置和依赖，Spring Boot就能自动扫描并加载相应的模块\",\"它整合了这个模块需要的依赖库；\",\"提供对模块的配置项给使用者；\",\"提供自动配置类对模块内的Bean进行自动装配；\",\"例如，在Maven的依赖中加入spring-boot-starter-web就能使项目支持Spring MVC，并且Spring Boot还为我们做了很多默认配置，无需再依赖spring-web、spring-webmvc等相关包及做相关配置就能够立即使用起来。\"]},\"773\":{\"h\":\"怎么开发starter\",\"t\":[\"新建Maven项目，在项目的POM文件中定义使用的依赖；\",\"新建配置类，写好配置项和默认的配置值，指明配置项前缀；\",\"新建自动装配类，使用@Configuration和@Bean来进行自动装配；\",\"新建spring.factories文件，指定Starter的自动装配类；\"]},\"774\":{\"h\":\"为什么我们需要 spring-boot-maven-plugin?\",\"t\":[\"spring-boot-maven-plugin 提供了一些像 jar 一样打包或者运行应用程序的命令。\",\"1、spring-boot:run 运行你的 SpringBoot 应用程序。\",\"2、spring-boot：repackage 重新打包你的 jar 包或者是 war 包使其可执行\",\"3、spring-boot：start 和 spring-boot：stop 管理 Spring Boot 应用程序的生命周期（也可以说是为了集成测试）。\",\"4、spring-boot:build-info 生成执行器可以使用的构造信息。\"]},\"775\":{\"h\":\"springboot读取配置文件的方式\",\"t\":[\"springboot默认读取配置文件为application.properties或者是application.yml\"]},\"776\":{\"h\":\"springboot集成mybatis的过程\",\"t\":[\"添加mybatis的starter maven依赖\",\"<dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> <version>1.3.2</version> </dependency> \",\"在mybatis的接口中 添加@Mapper注解\",\"在application.yml配置数据源信息\"]},\"777\":{\"h\":\"Spring Boot 的核心注解是哪个？\",\"t\":[\"启动类上面的注解是**@SpringBootApplication**，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：\",\"@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。\",\"@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。\",\"@ComponentScan：Spring组件扫描。\"]},\"778\":{\"h\":\"开启 Spring Boot 特性有哪几种方式？\",\"t\":[\"1）继承spring-boot-starter-parent项目\",\"2）导入spring-boot-dependencies项目依赖\"]},\"779\":{\"h\":\"spring-boot-starter-parent有什么作用\",\"t\":[\"定义了Java编译版本是1.8\",\"使用UTF-8进行编码\",\"继承自spring-boot-dependencies，这个里面定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写一来是才不需要版本号\",\"执行打包操作的配置\",\"自动化的配置过滤\",\"针对application.properties和application.yml的资源过滤\"]},\"780\":{\"h\":\"Spring Boot 需要独立的容器运行吗？\",\"t\":[\"可以不需要，内置了 Tomcat/ Jetty 等容器。\"]},\"781\":{\"h\":\"启动 Spring Boot 的方式\",\"t\":[\"1）打包用命令或者放到容器中运行\",\"2）用 Maven/ Gradle 插件运行\",\"3）直接执行 main 方法运行\"]},\"782\":{\"h\":\"SpringBoot 实现热部署有哪几种方式？\",\"t\":[\"主要有两种方式：\",\"1、Spring Loaded\",\"2、Spring-boot-devtools\"]},\"783\":{\"h\":\"Spring Boot 的核心配置文件有哪几个？它们的区别是什么？\",\"t\":[\"Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。\",\"application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。\",\"bootstrap 配置文件由父 ApplicationContext加载的，比application优先加载，配置在应用程序上下文的引导阶段生效，一般来说我们在speing cloud config或者Nacos中回用到它，且bootstrap中的属性不能被覆盖\"]},\"784\":{\"h\":\"SpringBoot的配置加载顺序\",\"t\":[\"在spring boot项目中，可以通过以下几种方式来加载配置\",\"properties文件\",\"yml 文件\",\"系统环境变量\",\"命令行参数\"]},\"785\":{\"h\":\"yml相对于properties配置的优势\",\"t\":[\"配置有序，在一些特殊的场景下，配置有序很关键\",\"支持数组，数组中的元素可以是基本数据类型也可以是对象\",\"简洁\",\"相比于 properties配置文件，yml还有一个缺点，就是不支持**@PropertySource**注解导入自定义的yml配置\"]},\"786\":{\"h\":\"怎么在自定义端口上运行SpringBoot应用程序\",\"t\":[\"在application.properties中指定端口，默认是8080端口\"]},\"787\":{\"h\":\"SpingBoot是否可以使用xml配置\",\"t\":[\"SpringBoot推荐使用java配置而非xml配置，但是SpringBoot中也可以使用xml配置，通过**@ImportResource**注解可以引入一个xml配置\"]},\"788\":{\"h\":\"Spring Boot 可以兼容老 Spring 项目吗，如何做？\",\"t\":[\"可以兼容，使用 @ImportResource 注解导入老 Spring 项目配置文件。\"]},\"789\":{\"h\":\"如何实现SpringBoot的安全性\",\"t\":[\"使用spring-boot-starter-security依赖项，并且添加安全配置，它只需要很少的代码，配置类将必须扩展WebSecurityConfigurerAdapter并覆盖其方法\"]},\"790\":{\"h\":\"SpringBoot打成的jar和普通的jar有什么区别\",\"t\":[\"SpringBoot项目最终打包的jar是可执行的jar，这种jar可以直接通过**java -jar xxx.jar命令来运行，这种jar不可以作为普通的jar被其他项目依赖**，即使依赖了也不能使用其中的类\",\"SpringBoot的jar无法被其他项目依赖，主要还是它和普通jar的结构不同。普通的jar包，解压后直接就是包名，包里就是我们的代码，而SpringBoot打包成的可执行jar解压后，在**\\\\BOOT-INF\\\\classes**目录下才是我们的代码，因此无法直接引用。如果非要引用，可以在pom.xml文件中增加配置，将springBoot项目打包成两个jar，一个可执行，一个可引用\",\"<plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> \"]},\"791\":{\"h\":\"如何使用springBoot实现异常处理\",\"t\":[\"Spring提供了一种使用ControllerAdvice处理异常的非常有用的方法，通过实现一个ControllerAdvice类，来处理控制器抛出的所有异常\"]},\"792\":{\"h\":\"Maven的目录结构\"},\"793\":{\"h\":\"Maven基本命令\",\"t\":[\"-v：查询Maven版本。本命令用于检查maven是否安装成功。Maven安装完成之后，在命令行输入mvn -v，若出现maven信息，则说明安装成功。\",\"compile：编译。将java源文件编译成class文件。\",\"test:测试项目。执行test目录下的测试用例。\",\"package：打包。将项目打成jar包。\",\"clean：删除target文件夹。\",\"install：安装。将当前项目放到Maven的本地仓库中，供其他项目使用。\"]},\"794\":{\"h\":\"什么是Maven仓库？\",\"t\":[\"Maven仓库用来存放Maven管理的所有Jar包。分为：本地仓库 和 中央仓库。\",\"本地仓库：Maven本地的Jar包仓库。\",\"中央仓库： Maven官方提供的远程仓库。\",\"当项目编译时，Maven首先从本地仓库中寻找项目所需的Jar包，若本地仓库没有，再到Maven的中央仓库下载所需Jar包。\"]},\"795\":{\"h\":\"什么是“坐标”？\",\"t\":[\"在Maven中，坐标是Jar包的唯一标识，Maven通过坐标在仓库中找到项目所需的Jar包。\",\"如下代码中，groupId和artifactId构成了一个Jar包的坐标。\",\"<dependency> <groupId>cn.missbe.web.search</groupId> <artifactId>resource-search</artifactId> <packaging>jar</packaging> <version>1.0-SNAPSHOT</version> </dependency> \",\"groupId:所需Jar包的项目名\",\"artifactId:所需Jar包的模块名\",\"version:所需Jar包的版本号\"]},\"796\":{\"h\":\"传递依赖 与 排除依赖\",\"t\":[\"传递依赖：如果我们的项目引用了一个Jar包，而该Jar包又引用了其他Jar包，那么在默认情况下项目编译时，Maven会把直接引用和简洁引用的Jar包都下载到本地。\",\"排除依赖：如果我们只想下载直接引用的Jar包，那么需要在pom.xml中做如下配置：(将需要排除的Jar包的坐标写在中)\",\"<exclusions> <exclusion> <groupId>cn.missbe.web.search</groupId> <artifactId>resource-search</artifactId> <packaging>pom</packaging> <version>1.0-SNAPSHOT</version> </exclusion> </exclusions> \"]},\"797\":{\"h\":\"依赖范围scope\",\"t\":[\"compile ：默认范围，用于编译\",\"provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath\",\"runtime: 在执行时需要使用\",\"test: 用于test任务时使用\",\"system: 需要外在提供相应的元素。通过systemPath来取得\",\"systemPath: 仅用于范围为system。提供相应的路径\",\"optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用\"]},\"798\":{\"h\":\"依赖冲突\",\"t\":[\"若项目中多个Jar同时引用了相同的Jar时，会产生依赖冲突，但Maven采用了两种避免冲突的策略，因此在Maven中是不存在依赖冲突的。\",\"短路优先：若本项目引用了A.jar，A.jar又引用了B.jar，B.jar又引用了X.jar，并且C.jar也引用了X.jar。在此时，Maven只会引用引用路径最短的Jar。\",\"本项目——>A.jar——>B.jar——>X.jar 本项目——>C.jar——>X.jar \",\"声明优先：引用路径长度相同时，在pom.xml中谁先被声明，就使用谁。\"]},\"799\":{\"h\":\"聚合\",\"t\":[\"将多个项目同时运行就称为聚合。\",\"实现 只需在pom中作如下配置即可实现聚合：\",\"<modules> <module>web-connection-pool</module> <module>web-java-crawler</module> </modules> \"]},\"800\":{\"h\":\"继承\",\"t\":[\"在聚合多个项目时，如果这些被聚合的项目中需要引入相同的Jar，那么可以将这些Jar写入父pom中，各个子项目继承该pom即可。\",\"实现：\",\"父pom配置：将需要继承的Jar包的坐标放入标签即可。 <dependencyManagement> <dependencies> <dependency> <groupId>cn.missbe.web.search</groupId> <artifactId>resource-search</artifactId> <packaging>pom</packaging> <version>1.0-SNAPSHOT</version> </dependency> </dependencies> </dependencyManagement> 子pom配置： <parent> <groupId>父pom所在项目的groupId</groupId> <artifactId>父pom所在项目的artifactId</artifactId> <version>父pom所在项目的版本号</version> </parent> <parent> <artifactId>resource-search</artifactId> <groupId>cn.missbe.web.search</groupId> <version>1.0-SNAPSHOT</version> </parent> \"]},\"801\":{\"h\":\"RPC\",\"t\":[\"​ RPC（Remote Procedure Call，远程过程调用），是一种进程间通信方式，也就是说两台服务器 A、B，一个应用部署在 A 服务器上，想要调用 B 服务器上应用提供的函数/方法，由于不在同一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用参数。如果是本地方法调用，直接压栈即可。RPC 就是要像调用本地的函数一样去调远程函数。\",\"​ RPC 是一个分布式计算的 CS 模式，总是由 Client 向 Server 发出一个执行若干过程请求，Server 接受请求，使用客户端提供的参数，计算完成之后将结果返回给客户端。\",\"原理\",\"服务集成 RPC 后，服务（ Provider，服务提供者）启动后会通过 Registry（服务注册与发现的服务管理中心），把服务的唯一 ID 和 IP 地址，端口信息等注册到 RPC 框架注册中心（图中的 Registry 部分）。\",\"当调用者（Consumer）想要调用服务的时候，通过 Provider 注册时的服务唯一 ID 去注册中心查找在线可供调用的服务，返回一个 IP 列表（3.notify 部分）。\",\"第三步 Consumer 根据一定的策略，比如随机或者轮训从 Registry 返回的可用 IP 列表真正调用服务（4.invoke）。Container：服务运行容器，如 jetty。\",\"最后是统计功能，RPC 框架都提供监控功能，监控服务健康状况，控制服务线上扩展和上下线（5.count）\"]},\"802\":{\"h\":\"如果服务提供者挂了，注册中心如何知道服务不可用了呢？\",\"t\":[\"​ 服务掉线分为主动下线和心跳检测。\",\"​ 比如服务由于发版时，在重启之前先主动通知注册中心：我要重启了，有流量进来先不要分给我，让别的机器服务，等我重启成功后在放流量进来，或者是在管理后台手动直接摘掉机器，这个是主动下线。\",\"​ 心跳检测是处理服务非正常下线（如断电断网）的情况，这个时候如果注册中心不知道该服务已经掉线，一旦被其调用就会带来问题。为了避免出现这样的情况，注册中心增加一个心跳检测功能，它会对服务提供者（Provider）进行心跳检测，比如每隔 30s 发送一个心跳，如果三次心跳结果都没有返回值，就认为该服务已下线，赶紧更新 Consumer 的服务列表，告诉 Consumer 调用别的机器。\"]},\"803\":{\"h\":\"如果注册中心挂了，那服务之间还能相互调用吗？\",\"t\":[\"问：如果注册中心挂了，比如你用的是 Zookeeper，如果 Zookeeper 挂了，那服务之间还能相互调用吗？\",\"答：首先注册中心挂掉也要分两种情况，如果数据库挂了，ZK 还是能用的，因为 ZK 会缓存注册机列表在缓存里。其次 ZK 本身就是一个集群的，一台机器挂了，ZK 会选举出集群中的其他机器作为 Master 继续提供服务，如果整个集群都挂了也没问题，因为调用者本地会缓存注册中心获取的服务列表。省略和注册中心的交互，Consumer 和 Provider 采用直连方式，这些策略都是可配置的。\"]},\"804\":{\"h\":\"能否自己写一个 RPC 框架？RPC的技术重点\",\"t\":[\"虽然没有自己动手写过，但是有三个需要实现的技术重点：\",\"int Multiply(int l, int r) { int y = l * r; return y; } int lvalue = 10; int rvalue = 20; int l_times_r = Multiply(lvalue, rvalue) \",\"在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，Multiply 是在另一个进程中执行的。我们如何实现远程调用呢？\",\"。我们怎么告诉远程机器我们要调用 Multiply 函数呢？在本地调用中，函数体是直接通过函数指针来指定，我们调用 Multiply，编译器就自动帮我们调用它相应的函数指针。但在远程调用中，函数指针是不行的，因为两个进程的地址空间完全不同。所以，在 RPC 中，所有函数都必须有自己的一个 ID，并且这个 ID 在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个 ID。然后我们还需要在客户端和服务端分别维护一个 ”函数 <--> Call ID“ 的对应表。当客户端需要进行远程调用时，它就查一下这个表，找出相应的 Call ID，然后把它传给服务端，服务端也通过查表来确定客户端需要调用的函数，然后执行相应函数代码。\",\"。客户端怎么把方法参数值传给远程函数呢？本地调用过程中，直接把参数压到栈中，然后函数自己去栈中读即可。但在远程调用过程中，客户端跟服务端是不同的进程，不能通过内存来传递参数。因此需要客户端把参数转换成字节流，传给服务端，然后服务端将字节流转换成自身能读取的格式，是一个序列化和反序列化的过程。同理，从服务端返回的值也需要序列化反序列化的过程。\",\"。数据准备好了之后，如何进行传输？网络传输层需要把调用的ID和序列化后的参数传给服务端，然后把计算好的结果序列化传给客户端。大部分 RPC 框架都使用 TCP 协议。\",\"客户端 invoke 方法编写，使用 JDK 的动态代理技术，客户端调用远程服务方法时调用的是 InvocationHandler 的 invoke 方法。\",\"客户端 Filter 方法编写，完善的 RPC 框架少不了监控、路由、降级、鉴权等功能。\",\"创建 Socket，在 Filter 方法中实现 Client.write 方法，其逻辑为从连接池（ChannelPool）中获取连接，然后将数据写进 Channel。\",\"实现数据序列化、压缩，目的减少网络传输的数据量，向服务端发送 request 数据，这里可以使用 Netty 异步通讯框架。\",\"服务端收到客户端发过的消息后，从 Channel 中将消息读出来之前，也会先经反序列化解压。\",\"请求就到了服务端 Filter 中。请求依次经过监控、鉴权方法。\",\"根据客户端传递来的服务信息和参数，通过反射调用相应的业务服务并拿到业务处理结果。然后在 ResponseFilter 中将返回结果写入 Channel。\",\"服务端序列化、压缩等，发送给客户端。\",\"客户端收到消息后，经过客户端反序列化、解压缩，后交给 ResponseThreadPoolProcessor 线程池处理。\",\"ResponseThreadPoolProcessor 收到消息后，就将结果返回给之前的方法调用，整个调用请求就结束了。\"]},\"805\":{\"h\":\"已经有 http 协议接口，或者说 RestFul 接口，为什么还要使用 RPC 技术？\",\"t\":[\"​ 系统与系统交互较少的情况下，使用 http 协议优点显而易见：开发简单、测试也比较直接、部署方便，利用现成的 http 协议进行系统间通讯，如果业务真的慢慢做大，系统也慢慢扩大，RPC 框架的好处就显示出来 了，⾸先 RPC 支持长链接，通信不必每次都要像 http 一样去重复 3 次握⼿，减少了网络开销。 ​ 其次就是 RPC 框架一般都有注册中心模块，有完善的监控管理功能，服务注册发现、服务下线、服务动态扩展等都方便操作，服务化治理效率大大提高。\",\"​ 基于 TCP 协议实现的 RPC，能更灵活地对协议字段进行定制，相比 http 能减少网络传输字节数（比如http的头信息等），降低网络开销（握手）提高性能。实现更大的吞吐量和并发数，但是需要更多的关注底层复杂的细节， 对开发人员的要求也高，增加开发成本。\"]},\"806\":{\"h\":\"RPC 和 HTTP 区别？\",\"t\":[\"​ RPC 适合用来做内部进程间的调用，主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便；HTTP 适合用来做外部浏览器接口调用，API 接口调用，第三方接口调用等。实际上很多所谓的 RPC 框架就是在 TCP 上自己封装的应用层协议，可以让请求报文体积更小，所以就不会像 HTTP 协议那么臃肿\"]},\"807\":{\"h\":\"RPC 接口如何保证幂等性？\",\"t\":[\"​ 。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果时网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条，这就没有保证接口的幂等性。\",\"什么情况下需要保证接口的幂等性？在增删改查中，尤为注意的就是增加或者修改。\",\"查询操作：查询对于结果不会有任何改变，查询一次或多次，在数据不变的情况下，查询结果是一样的， select 具有天然的幂等性。\",\"删除操作：删除一次或删除多次都是把数据删除，因此删除操作也是具有幂等性的。\",\"更新操作：如把表中 id 为 xxx 的记录的 A 字段值增加 1，这种操作就是不幂等的。\",\"新增操作：增加在重复提交的场景下会出现幂等性问题，如：支付问题。\",\"如何设计接口才能做到幂等呢？\",\"全局唯一 ID + 唯一索引：根据业务生成一个全局唯一 ID，调用接口时会传入该 ID，在 MySQL 表中建立一个唯一索引，接口提供方拿到 ID 做数据库的 insert 操作，如果插入成功，则响应服务请求；插入失败，则通过事务回滚\",\"token 机制：生成全局唯一 token，调用接口时会传入该 token，接口提供方会去 Redis 中查询这个 token 是否存在，如果存在则说明该操作已经执行过了，将拒绝本次服务请求；否则响应服务并将 token 写入 Redis 中，之后包含相同业务 token 参数请求将被拒绝\",\"分布式锁：比如在支付场景，接口提供方增加一个 setnx 判断，订单 id 作为 key， value 随便放，如果设置成功，才放行，否则说明已经支付过了。\"]},\"808\":{\"h\":\"集群和分布式区别？\",\"t\":[\"集群：同一个业务，部署在多个服务器上。\",\"分布式：同一个业务，拆分成多个子业务部署在多个服务器上。\"]},\"809\":{\"h\":\"什么是 Dubbo？关键功能？\",\"t\":[\"​ 基于 Java 的高性能轻量级的 RPC 分布式服务框架，它提供三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，服务自动注册和发现。\",\"​ 把大型系统划分为一个个小的功能模块，将这些模块分布在各个服务器上，这么多服务器合起来组成一个完整系统来提供服务，模块间也有联系，我们需要一个治理系统来维护复杂的关系，保证系统有条不紊的进行，dubbo 就能维护和治理复杂的关系，有了它我们就可以使用分布式的思想来架构应用。\"]},\"810\":{\"h\":\"Dubbo 服务关键节点？\",\"t\":[\"服务提供者：暴露服务的服务提供方，\",\"服务消费者：调用远程服务的服务消费方，，服务消费者从提供者地址列表中，基于负载均衡算法，选一台提供者进行调用，如果调用失败，再选择另一台调用。\",\"注册中心：注册中心返回服务提供者地址列表给消费者。\",\"监控中心：统计消费者和提供者在内存中累计调用次数和调用时间，定时每分钟发送一次统计到监控中心。\"]},\"811\":{\"h\":\"RPC/Dubbo 的服务注册流程\",\"t\":[\"服务容器负责启动，加载，运行服务提供者。\",\"服务提供者在启动时，向注册中心注册自己提供的服务，暴露自己的 IP 和端口信息。\",\"服务消费者在启动时，向注册中心订阅自己所需的服务。\",\"注册中心返回服务提供者列表给消费者，如果有变更，注册中心将基于长连接推送给数据消费者。\",\"服务消费者，从提供这地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另外一台服务调用。\",\"服务消费者和提供者，在内存中累计调用次数和调用时间，定时发送一次统计数据到监控中心\"]},\"812\":{\"h\":\"Dubbo 负载均衡策略？\",\"t\":[\"Dubbo 负载均衡策略\",\"说明\",\"Random \",\"随机，按权重设置随机概率\",\"RoundRobin\",\"轮询\",\"LeastActive\",\"调用服务器之前询问上次处理请求花费时间，挑一个响应速度最快的服务器\",\"ConsistentHash\",\"一致性 Hash，相同参数请求总是发到同一提供者\"]},\"813\":{\"h\":\"集群容错几种方法？\",\"t\":[\"集群容错方案\",\"说明\",\"Failover \",\"失败自动切换，当出现失败，重试其它服务器\",\"Failfast\",\"快速失败，只发起一次调用，失败立即报错\",\"Failsafe\",\"失败安全，出现异常时，直接忽略\",\"Failback\",\"失败自动恢复，记录失败请求，定时重发\",\"Forking\",\"并行调用多个服务器，只要一个成功即返回\",\"Broadcast\",\"广播调用所有提供者，逐个调用，任意一台报错则报错\"]},\"814\":{\"h\":\"Dubbo 使用什么通信框架？\",\"t\":[\"Dubbo 使用 Netty 作为网络传输框架。，即调用 Dubbo 请求后，调用线程将会阻塞，直至服务提供者返回结果，同时也支持异步调用。\"]},\"815\":{\"h\":\"Dubbo 和 SpringCloud 对比？\",\"t\":[\"Dubbo 只是解决分布式系统之间远程调用问题（RPC 问题），并不能解决分布式系统所有问题，SpringCloud 有针对分布式系统存在问题的一套解决方案。\",\"微服务架构需要解决的问题？\",\"这么多服务，客户端之间如何去访问？\",\"这么多服务，服务之间如何进行通信？Dubbo\",\"这么多服务，如何治理？ZooKeeper\",\"服务挂了，怎么办？\"]},\"816\":{\"h\":\"ZooKeeper是什么？\",\"t\":[\"​ Zookeeper 是一个分布式服务框架，是集群的管理者，监视着集群中各个节点的状态，根据节点提交的反馈进行下一步操作，分布式应用程序可以基于 Zookeeper 实现数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。\",\"​ 简单来说，Zookeeper = 文件系统 + 通知机制。\"]},\"817\":{\"h\":\"监听通知机制\",\"t\":[\"​ 客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。\",\"​ client 端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些 client 会收到 zk 的通知，然后 client 可以根据 znode 变化来做出业务上的改变等。\"]},\"818\":{\"h\":\"文件系统 & Znode\",\"t\":[\"​ Zookeeper维护一个类似文件系统的多层级节点命名空间（节点称为 znode），与文件系统不同的是，这些节点都可以设置关联的数据（存储数据），而文件系统中只有文件节点可以存放数据而目录节点不行。\",\"​ Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为1M。\",\"有四种类型的znode：\",\"持久化目录节点create /test devil：客户端与zookeeper断开连接后，该节点依旧存在。除非手动删除，否则节点一直存在于 Zookeeper 上。\",\"持久化顺序节点create -e /test devil：基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。\",\"临时目录节点create -s/test：临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。\",\"临时顺序节点create -e -s /test：基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。\"]},\"819\":{\"h\":\"Zookeeper 的部署方式有哪几种？\",\"t\":[\"部署方式有单机模式、集群模式（奇数台）。\",\"角色：Leader 和 Follower。\",\"集群最少需要机器数：3。因为 zk 集群的机制是只要超过半数的节点正常，集群就能正常提供服务，2 个节点的 cluster 就不能挂掉任何一个节点了，3 个节点的 cluster 可以挂掉一个节点。\"]},\"820\":{\"h\":\"Zookeeper 选举机制？\",\"t\":[\"Zookeeper 为了保证各节点的协同工作，在工作时需要一个 Leader 角色，而 Zookeeper 默认采用 FastLeaderElection 算法，且投票数大于半数则胜出的机制。？\",\"处理所有的写请求并同步给 Follower\",\"启动时同步数据给 Follewer 节点\",\"选举机制相关概念\",\"服务器 ID：在配置集群时设置的 myid 参数文件，且参数分别为服务器 1、服务器 2、服务器 3，编号越大在 FastLeaderElection 算法中的权重越大。\",\"选举状态。选举过程中，zk 服务器有四种状态，分别为：\",\"竞选状态（LOOKING）\",\"随从状态（FOLLOWING，同步 Leader 状态，参与投票）\",\"观察状态（OBSERVING，同步 Leader 状态，不参与投票）\",\"领导者状态（LEADING）\",\"数据 ID（Zxid）：服务器中存放的最新数据版本号，该值越大则说明数据越新，在选举过程中越新权重越大。\",\"逻辑时钟：就是投票轮数，用来判断多个投票是否在同一轮选举周期中，该值在服务端是一个自增序列，每次进入新一轮的投票后，都会对该值进行加 1 操作\",\"选举机制\",\"zk 选举机制有两种类型，分别为：\",\"服务器启动时期的 Leader 选举，即初次选举\",\"全新集群选举是新搭建起来的，没有数据 ID 和逻辑时钟数据影响集群的选举。假设，目前有 5 台服务器，它们的编号是 1~5，按编号依次启动 zk 服务。\",\"服务器 1 启动，首先，会给自己投票；其次，发投票信息，由于其它机器还没有启动，所以它无法接收到投票的反馈信息，因此服务器 1 一直属于 LOOKING 状态\",\"服务器 2 启动，首先，会给自己投票；其次，在集群中启动 zk 服务的机器发起投票对比，这时它会与服务器 1 交换结果，由于服务器 2 编号大，所以服务器 2 胜出，此时服务器 1 会将票投给服务器 2，但此时服务器 2 的投票数并没有大于集群半数（2 < 5/2），所以两个服务器的状态依然是 LOOKING 状态\",\"服务器 3 启动，首先，会给自己投票；其次，与之前启动的服务器 1、2 交换信息，由于服务器 3 的编号最大，所以服务器 3 胜出，那么，此时投票数正好大于半数（3 > 5/2），所以服务器 3 称为 Leader，服务器 1、2 称为 Follower\",\"服务器 4 启动，首先，会给自己投票；其次，与之前启动的服务器 1、2、3 交换信息，尽管服务器 4 的编号大，但是服务器 3 已经胜出，所以服务器 4 只能成为追随者\",\"服务器 5 启动，同服务器 4 一样，均成为追随者状态\",\"总结： 1.每个服务器启动后先选自己 2.选自己发现当不了 leader，然后把这一票投给 id 大的 3.一旦某台服务器的票数超过半数以上，立刻升级为 leader 4.之后再启动的服务器不管 id 多大，只能当 follower \",\"Leader 突然宕机，重新进行选举\",\"由于 zk 集群已经运行过一段时间，那么服务器中就会存在运行的数据，选举的过程中就需要引入服务器 ID、数据 ID 和逻辑时钟。\",\"统一逻辑时钟后，对比数据 ID 值，数据 ID 反应数据的新旧程度，因此数据 ID 大的胜出\",\"如果逻辑时钟和数据 ID 都相同的情况下，那么比较服务器 ID（编号），值大则胜出\",\"简单来讲，非全新集群选举时是优中选优，保证 Leader 是 zk 集群中数据最完整、最可靠的一台服务器。\"]},\"821\":{\"h\":\"分布式锁\",\"t\":[\"​ Zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。Zookeeper 可以对分布式锁进行控制。\"]},\"822\":{\"h\":\"Zookeeper 的监听原理是什么？\",\"t\":[\"在 main 线程中创建 Zookeeper 客户端，这时就会创建 2 个线程，一个负责网络连接通信（connect），一个负责监听（listener）\",\"通过 connect 线程将注册的监听事件发送给 Zookeeper\",\"在 Zookeeper 的注册监听器列表中将注册的监听事件添加到列表中\",\"Zookeeper 监听到有数据或路径变化，就会将这个消息发送给 listener 线程\",\"listener 线程内部调用了 process( ) 方法\"]},\"823\":{\"h\":\"Zookeeper 常用命令？\",\"t\":[\"help //显示所有操作命令 ls path[watch] //使用ls命令来查看当前znode中所包含的内容 ls2 path[watch] //查看当前节点数据并能看到更新次数等内容 create //普通创建：-s(含有序列,顺序节点)/-e(临时，重启或者超时消失) get path[wathch] //获得节点的值 set //设置节点的具体值 stat //查看节点状态 delete //删除节点 rmr //递归删除节点 \"]},\"824\":{\"h\":\"什么是 Nginx？\",\"t\":[\"​ Nginx 是高性能的 HTTP 和反向代理的web服务器，处理高并发能力是十分强大的，能经受高负载的考验，有报告表明能支持高达 50,000 个并发连接数。具体配置在 nginx.conf， 它监听的端口号：80。\",\"特点：占有内存小，并发能力强。中国大陆使用Nginx网站用户有：百度，京东、新浪、网易、淘宝、腾讯等。\",\"完全由C语言写成，能够在不间断服务的情况下进行软件版本的升级。\"]},\"825\":{\"h\":\"Nginx与Tomcat的区别？\",\"t\":[\"nginx常用做静态内容服务和代理服务器，直面外来请求转发给后面的应用服务（tomcat等），tomcat更多用来做一个应用容器，让javaweb app跑在里面的东西，对应同级别的有jboss、jetty等东西。（但是事无绝对，nginx也可以通过模块开发来提供应用功能，tomcat也可以直接提供http服务，通常用在内网和不需要流控等小型服务的场景。）\",\"严格的来说，Apache/Nginx 应该叫做「HTTP Server」；而 Tomcat 则是一个「Application Server」，或者更准确的来说，是一个「Servlet/JSP」应用的容器（Ruby/Python 等其他语言开发的应用也无法直接运行在 Tomcat 上）。 \",\"一个 HTTP Server 关心的是 HTTP 协议层面的传输和访问控制，所以在 Apache/Nginx 上你可以看到代理、负载均衡等功能。客户端通过 HTTP Server 访问服务器上存储的资源（HTML 文件、图片文件等等）。\",\"应用服务器，则是一个应用执行的容器。它首先需要支持开发语言的 Runtime（对于 Tomcat 来说，就是 Java），保证应用能够在应用服务器上正常运行。其次，需要支持应用相关的规范，例如类库、安全方面的特性。对于 Tomcat 来说，就是需要提供 JSP/Sevlet 运行需要的标准类库、Interface 等。为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。\"]},\"826\":{\"h\":\"正向代理 & 反向代理\",\"t\":[\"正向代理：通过代理服务器来访问服务器的过程就叫正向代理，需要在客户端配置代理服务器进行指定网站访问。正向代理相对于目标服务器而言隐藏了客户端的真实IP地址，因为对于目标服务器而言所有请求都是从正向代理服务器发出的，正向代理主要是为了突破网络访问限制，比如科学上网，还有就是隐藏客户端IP地址。\",\"反向代理：反向代理对于客户端而言隐藏了目标服务器IP地址，只需要知道代理服务器地址就能访问到目标服务器的资源。其主功能是可以做负载均衡和安全防护。不过，不管正向代理还是反向代理，都能加快客户端的访问速度，因为nginx服务器是一个高性能的http web服务器，其能够对代理中的数据作缓冲。\"]},\"827\":{\"h\":\"Nginx的主要特征\",\"t\":[\"反向代理：Nginx不仅可以反向代理，还可以正向代理来进行上网等功能。\",\"负载均衡：将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上。\",\"动静分离：为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析。动静分离目前实现方案分两种： \",\"把静态文件独立成单独的域名，放在独立的服务器上，是目前主流的方案。\",\"动态跟静态文件混合在一起发布，通过 Nginx 分开。\"]},\"828\":{\"h\":\"Nginx高性能原因\"},\"829\":{\"h\":\"1、epoll多路复用\",\"t\":[\"​ 在了解epoll多路复用之前，先看看Java BIO模型，也就是Blocking IO，阻塞模型。当客户端与服务器建立连接之后，通过Socket.write()向服务器发送数据，只有当数据写完之后，才会发送。如果当Socket缓冲区满了，那就不得不阻塞等待。\",\"​ 接下来看看Linux Select模型。该模式下，会监听一定数量的客户端连接，一旦发现有变动，就会唤醒自己，然后遍历这些连接，看哪些连接发生了变化，执行IO操作。相比阻塞式的BIO，效率更高，但是也有个问题，假如10000个连接变动了1个，那么效率将会十分低下，所以有1024个数量上限。此外，Java NIO或者Non-Blocking IO就借鉴了Linux Select模型。\",\"​ 而epoll模型，在Linux Select模型之上，新增了回调函数，更变触发回调直接读取（理论上无上限），不用遍历，效率更高。\"]},\"830\":{\"h\":\"2、master-worker进程模型\",\"t\":[\"​ 通过ps -ef|grep nginx命令可以看到有两个Nginx进程，一个标注为master，一个标注为worker，而且worker进程是master进程的子进程。这种父子关系的好处就是，master进程可以管理worker进程。\",\"​ 客户端的请求，并不会被master进程处理，而是交给下面的worker进程来处理，多个worker进程通过“抢占”的方式，取得处理权。如果某个worker挂了，master会立刻感知到，用一个新的worker代替。这就是Nginx高效率的原因之一，这个是Nginx可以平滑重启的原理。\",\"​ 此外，worker进程是单线程的，没有阻塞的情况下，效率很高。而epoll模型避免了阻塞。\",\"​ 综上，epoll+master-worker使得worker进程可以高效率地执行单线程I/O操作。\"]},\"831\":{\"h\":\"3、协程机制\",\"t\":[\"Nginx引入了一种比线程更小的概念，那就是“协程”。一个线程可以有多个协程。\",\"依附于线程的内存模型，切换开销小；\",\"遇到阻塞，Nginx会立刻剥夺执行权，代码同步，调用新的不阻塞的协程；\",\"由于在同一个线程内，也不需要加锁。\"]},\"832\":{\"h\":\"Nginx 负载均衡算法？\",\"t\":[\"Nginx 负载均衡算法\",\"说明\",\"轮询 \",\"每个请求按时间顺序逐一分配到不同的后端服务器\",\"weight 权重\",\"根据权重分配，权重越高被分配的客户端越多\",\"ip_hash\",\"每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器\",\"fair\",\"按后端服务器的响应时间来分配请求，响应时间短的优先分配\"]},\"833\":{\"h\":\"mater-workers机制（Nginx原理）\",\"t\":[\"nginx 启动后，是由两个进程组成的。master（管理者）和worker（工作者）。\",\"一个nginx 只有一个master。但可以有多个worker。过来的请求由master管理，worker进行争抢式的方式去获取请求。\"]},\"834\":{\"h\":\"master-workers 机制的好处\",\"t\":[\"每个 worker 采用独立的进程，不需要加锁，所以省掉了锁带来的开销。一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的 worker 进程。\",\"可以使用 nginx –s reload 热部署，利用 nginx 进行热部署操作\"]},\"835\":{\"h\":\"设置多少个 worker？\",\"t\":[\"​ Nginx 同 redis 类似都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话下。每个 worker 的线程可以把一个 cpu 核心的性能发挥到极致。所以 worker 数和服务器的 cpu 核心数相等是最为适宜的。设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。\"]},\"836\":{\"h\":\"发送请求，占用了 worker 的几个连接数？\",\"t\":[\"2 或者 4 个。\",\"2 个（访问静态资源，一来一回），这种情况是直接将静态资源放在了 Nginx 服务器上。\",\"4 个（访问动态资源，一来一回 + Tomcat 的一来一回）。\",\"假设Nginx有一个master，有四个worker，每个worker支持最大的连接数是1024，那么支持的最大并发数是多少？\",\"4 * 1024 / 2 = 2048 或者 4 * 1024 / 4 = 1024。\"]},\"837\":{\"h\":\"Nginx重启之后，为什么master不会挂？\",\"t\":[\"sbin/nginx -s reload 重启之后，worker的端口号会变，master的不会变的原因？\",\"​ 因为master不能挂，挂了整个nginx就废了。master进程发送信号给 worker进程，要求worker进程将所有的socket对应的句柄交给master进程去管理，然后master进程重新去load配置文件，启动一个新的worker进程，然后将对应的句柄交给新的worker进程管理。\"]},\"838\":{\"h\":\"为什么worker内部不使用多线程？\",\"t\":[\"​ 首先，多线程就是为了防止单线程堵塞，造成效率问题。但是worker里的单线程是非阻塞的，只不过是调用socket的read和write，而且是在epoll中，速度是非常快的，不会造成堵塞，单线程反而更快，仅仅只是一份内核空间到用户的拷贝。\"]},\"839\":{\"h\":\"MQ\"},\"840\":{\"h\":\"什么是 MQ？作用？\",\"t\":[\"MQ（Message Queue，消息队列），是 “先进先出” 的一种数据结构，存储消息的中间件，多用于分布式系统之间进行通信。\",\"MQ 作用：一般用来解决应用解耦、异步处理、流量削峰等问题，实现高性能，高可用，可伸缩和最终一致性架构。\",\"应用解耦\",\"订单系统和库存系统、支付系统、物流系统耦合在一起，如果库存系统出现问题，可能订单系统也会出现问题，系统容错性低\",\"如果增加 X 系统，程序员需要修改订单系统的代码，扩展性差\",\"异步处理\",\"第一种用户下单需要等待 920ms 才能得到下单响应，第二种用户下单只需要 25ms 就能得到下单响应\",\"用户下单请求发送给消息队列之后立即响应，因为订单系统已经完成它的工作，不用管库存系统、支付系统、物流系统是否成功，因为它们是从 MQ 中拿数据进行消费\",\"流量削峰\",\"并发量大时，所有的请求直接怼到数据库，给数据库造成巨大压力\",\"可应用到秒杀场景：秒杀请求直接进消息队列，消息队列设置定长，只能存储 1w 个数据，10w 个用户谁快谁先进消息队列，然后秒杀业务再从消息队列中取出数据进行业务计算\"]},\"841\":{\"h\":\"MQ的缺点\",\"t\":[\"系统可用性降低：解耦后，多个系统通过消息中间件交互，MQ挂了整个系统就挂了。\",\"系统复杂度提升：需要考虑消息的处理，包括消息幂等性（重复消费问题），消息保序性（一个订单多条消息问题），以及消息中间件本身的持久化和稳定性可靠性。\",\"消息一致性问题：A系统处理完业务，通过MQ给B、C、D三个系统发消息数据，如果B系统、C系统处理成功，D系统处理失败。如何保证消息数据处理的一致性？\"]},\"842\":{\"h\":\"常用的MQ\"},\"843\":{\"h\":\"push、pull\",\"t\":[\"push\",\"消息消费的过程：\",\"mq接收到消息\",\"mq主动将消息推送给消费者（消费者需提供一个消费接口）\",\"mq属于主动方，消费者属于一种被动消费，一旦有消息到达mq，会触发mq推送机制，将消息推送给消费者，不管消费者处于何种状态。\",\"优点：\",\"消费者代码较少：对于消费者来说，只需提供一个消费接口给mq即可；mq将接收到的消息，随即推送到指定的消费接口\",\"消息实时性比较高：对于消费者来说，消息一旦到达mq，mq会立即推送给消费者\",\"缺点：\",\"消费者属于被动方，消息量比较大时，对消费者性能要求比较高；若消费者机器资源有限，可能会导致压力过载，引发宕机的情况。\",\"对消费者可用性要求比较高：当消费者不可用时，会导致很push失败，在mq方需要考虑至少推送成功一次，这块的设计下章节会做说明。\",\"pull （Kafka、RocketMq）\",\"消息消费的过程：\",\"消费端采用轮询的方式，从mq服务中拉取消息进行消费\",\"消费完成通知mq删除已消费成功的消息\",\"继续拉取消息消费\",\"对于消费者来说，是主动方，可以采用线程池的方式，根据机器的性能来增加或缩小线程池的大小，控制拉取消息的速度，可以很好的控制自身的压力。\",\"优点：\",\"消费者可以根据自己的性能主动控制消息拉去的速度，控制自己的压力，不至于把自己弄跨\",\"实时性相对于push方式会低一些\",\"消费者属于主动方，控制权更大一些\",\"缺点：\",\"消费方需要实现消息拉取的代码\",\"消费速度较慢时，可能导致mq中消息积压，消息消费延迟等\",\"总结\",\"消费者性能较好，对实时性要求比较高的，可以采用push的方式。\",\"消费者性能有限，建议采用pull的方式。\",\"整体上来说，主要在于消费者的性能，机器的性能如果没有问题，push和pull都是可以的。\"]},\"844\":{\"h\":\"Kafka的消费模式\",\"t\":[\"​ Kafka的消费模式主要有两种：一种是一对一的消费，也即点对点的通信，即一个发送一个接收。第二种为一对多的消费，即一个消息发送到消息队列，消费者根据消息队列的订阅拉取消息消费。\",\"一对一\",\"​ 消息生产者发布消息到Queue队列中，通知消费者从队列中拉取消息进行消费。消息被消费之后则删除，Queue支持多个消费者，但一条消息只能被一个消费者消费。\",\"一对多\",\"​ 这种模式也称为发布/订阅模式，即利用Topic存储消息，消息生产者将消息发布到Topic中，同时有多个消费者订阅此topic，消费者可以从中消费消息，注意发布到Topic中的消息会被多个消费者消费，消费者消费数据之后，数据不会被清除，Kafka会默认保留一段时间，然后再删除。\"]},\"845\":{\"h\":\"Kafka基础架构\",\"t\":[\"Producer：消息生产者，向Kafka中发布消息的角色。\",\"Consumer：消息消费者，即从Kafka中拉取消息消费的客户端。\",\"Consumer Group：消费者组，消费者组则是一组中存在多个消费者，消费者消费Broker中当前Topic的不同分区中的消息，消费者组之间互不影响，所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。某一个分区中的消息只能够一个消费者组中的一个消费者所消费\",\"Broker：一台Kafka服务器就是一个Broker，一个集群由多个Broker组成，一个Broker可以容纳多个Topic。\",\"Topic：主题，可以理解为一个队列，生产者和消费者都是面向一个Topic。topic是一个逻辑概念\",\"Partition：分区，为了实现扩展性，一个非常大的Topic可以分布到多个Broker上，一个Topic可以分为多个Partition，每个Partition是一个有序的队列(分区有序，不能保证全局有序)是一个物理概念\",\"Replica：副本Replication，为保证集群中某个节点发生故障，节点上的Partition数据不丢失，Kafka可以正常的工作，Kafka提供了副本机制，一个Topic的每个partition有若干个副本，一个Leader和多个Follower\",\"Leader：每个分区多个副本的主角色，生产者发送数据的对象，以及消费者消费数据的对象都是Leader。\",\"Follower：每个分区多个副本的从角色，实时的从Leader中同步数据，保持和Leader数据的同步，Leader发生故障的时候，某个Follower会成为新的Leader。\"]},\"846\":{\"h\":\"Kafka的文件存储\",\"t\":[\"Kafka文件存储是通过本地落盘的方式存储的，主要是通过相应的log与index等文件保存具体的消息文件。.index文件是索引文件，存储了消息的offset。.log中存放的是真实的数据。\",\"Producer生产的数据会不断追加到该log文件的末端，且每条数据都有自己的offset。消费者组中的每个消费者，都会实时记录自己消费到了哪个offset，以便出错时恢复。\",\".log太大了怎么办？：生产者不断向log文件追加消息文件，为了防止log文件过大导致定位效率低下，Kafka的log文件以1G（可以设置）为一个分界点，当.log文件大小超过1G的时候，此时会创建一个新的.log文件，同时为了快速定位大文件中消息位置，Kafka采取了分片和索引的机制来加速定位。\"]},\"847\":{\"h\":\"partition的数据文件（offffset，MessageSize，data）\",\"t\":[\"partition中的每条Message包含了以下三个属性： offset，MessageSize，data：\",\"offset表示Message在这个partition中的偏移量，offset不是该Message在partition数据文件中的实际存储位置，而是逻辑上一个值，它唯一确定了partition中的一条Message，可以认为offset是partition中Message的 id；\",\"MessageSize表示消息内容data的大小；\",\"data为Message的具体内容。\"]},\"848\":{\"h\":\"数据文件分段 segment\",\"t\":[\"​ Kafka为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为index。 index文件中并没有为数据文件中的每条Message建立索引，而是采用了稀疏存储的方式，每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间，从而可以将索引文件保留在内存中。\"]},\"849\":{\"h\":\"负载均衡\",\"t\":[\"​ 由于消息topic由多个partition组成，且partition会均衡分布到不同broker上。因此，为了有效利用broker集群的性能，提高消息的吞吐量，producer可以通过随机或者hash等方式，将消息平均发送到多个partition上，以实现负载均衡。\"]},\"850\":{\"h\":\"Kafka为什么这么快\",\"t\":[\"顺序写磁盘：Kafka的producer生产数据，需要写入到log文件中，写的过程是追加到文件末端，顺序写的方式，官网有数据表明，同样的磁盘，顺序写能够到600M/s，而随机写只有200K/s，这与磁盘的机械结构有关，顺序写之所以快，是因为其省去了大量磁头寻址的时间。\",\"零复制技术：通常情况下，Kafka的消息会有多个订阅者，生产者发布的消息会被不同的消费者多次消费，为了优化这个流程，Kafka使用了“零拷贝技术”。\",\"传统拷贝：操作系统将数据从磁盘文件中读取到内核空间的页面缓存---->应用程序将数据从内核空间读入到用户空间缓冲区---->应用程序将读到的数据写回内核空间并放入到socket缓冲区---->操作系统将数据从socket缓冲区复制到网卡接口，此时数据通过网络发送给消费者\",\"零拷贝技术：只用将磁盘文件的数据复制到页面缓存中一次，然后将数据从页面缓存直接发送到网络中（发送给不同的订阅者时，都可以使用同一个页面缓存），从而避免了重复复制的操作。如果有10个消费者，传统方式下，数据复制次数为4*10=40次，而使用“零拷贝技术”只需要1+10=11次，1表示从磁盘复制到页面缓存，10表示10个消费者各自读取一次页面缓存。\"]},\"851\":{\"h\":\"生产者\"},\"852\":{\"h\":\"生产者分区分配策略\",\"t\":[\"分区的原因：\",\"方便在集群中扩展：每个partition通过调整以适应它所在的机器，而一个Topic又可以有多个partition组成，因此整个集群可以适应适合的数据\",\"可以提高并发：以Partition为单位进行读写。类似于多路。\",\"分区的原则：\",\"指明partition（这里的指明是指第几个分区）的情况下，直接将指明的值作为partition的值。\",\"没有指明partition的情况下，但是存在值key，此时将key的hash值与topic的partition总数进行取余得到partition值。\",\"值与partition均无的情况下，第一次调用时随机生成一个整数，后面每次调用在这个整数上自增，将这个值与topic可用的partition总数取余得到partition值，即round-robin（轮询）算法。\"]},\"853\":{\"h\":\"AR、ISR\",\"t\":[\"ISR：In-Sync Replicas 副本同步队列，由leader维护。 AR：Assigned Replicas 所有副本。\",\"若有一个follower坏了，导致不能发送ack怎么办？\",\"​ 采用了第二种方案进行同步ack之后，如果leader收到数据，所有的follower开始同步数据，但有一个follower因为某种故障，迟迟不能够与leader进行同步，那么leader就要一直等待下去，直到它同步完成，才可以发送ack，此时需要如何解决这个问题呢？\",\"​ leader维护了一个动态的ISR（in-sync replica set），即与leader保持同步的follower集合，当ISR中的follower完成数据的同步之后，给leader发送ack，如果follower长时间没有向leader同步数据，则该follower将从ISR中被踢出，该之间阈值由replica.lag.time.max.ms参数设定。当leader发生故障之后，会从ISR中选举出新的leader。\"]},\"854\":{\"h\":\"ack机制(生产者消息可靠性保证)\",\"t\":[\"​ 为保证producer发送的数据能够可靠的发送到指定的topic中，topic的每个partition收到producer发送的数据后，都需要向producer发送ack ，如果producer收到ack就会进行下一轮的发送，否则重新发送数据。\",\"​ 对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没有必要等到ISR中所有的follower全部接受成功。Kafka为用户提供了三种可靠性级别，用户根据可靠性和延迟的要求进行权衡，选择不同的配置。\",\"0：producer不等待broker的ack，这一操作提供了最低的延迟，broker接收到还没有写入磁盘就已经返回，当broker故障时有可能丢失数据。\",\"1（默认）：producer等待broker的ack，partition的leader落盘成功后返回ack，如果在follower同步成功之前leader故障，那么将丢失数据。（只是leader落盘）\",\"-1：producer等待broker的ack，partition的leader和ISR的follower全部落盘成功才返回ack，但是如果在follower同步完成后，broker发送ack之前，如果leader发生故障，会造成数据重复。全部落盘。\"]},\"855\":{\"h\":\"数据一致性：LEO、HW(高水位)\",\"t\":[\"​ LEO(Log End Offset)：每个副本最后的一个offset。\",\"​ HW(High Watermark)：高水位，指代消费者能见到的最大的offset，ISR队列中最小的LEO。\",\"follower故障和leader故障：\",\"follower故障：follower发生故障后会被临时踢出ISR，等待该follower恢复后，follower会读取本地磁盘记录的上次的HW，并将log文件高于HW的部分截取掉，从HW开始向leader进行同步，等待该follower的LEO大于等于该partition的HW，即follower追上leader之后，就可以重新加入ISR了。\",\"leader故障：leader发生故障之后，会从ISR中选出一个新的leader，为了保证多个副本之间的数据的一致性，其余的follower会先将各自的log文件高于HW的部分截掉，然后从新的leader中同步数据。\",\"这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复\"]},\"856\":{\"h\":\"ExactlyOnce/幂等性(重复数据)\",\"t\":[\"幂等性：同一用户对于同一操作的一次请求与多次请求，结果是一样的\",\"At Least Once\",\"At Most Once\",\"服务器ACK级别设置为-1（all）\",\"服务器ACK级别设置为0\",\"保证producer到Server之间不会丢失数据\",\"不能保证数据不丢失\",\"不能保证数据不重复\",\"可以保证数据不重复\",\"对于重要的数据，则要求数据不重复也不丢失，即Exactly Once即精确的一次。\",\"在0.11版本的Kafka之前，只能保证数据不丢失，在下游对数据的重复进行去重操作，对于多个下游应用的情况，则分别进行全局去重，对性能有很大影响。\",\"0.11版本的kafka，引入了一项重大特性：幂等性，Kafka 中的幂等性指代Producer不论向Server发送了多少次重复数据，Server端都只会持久化一条数据。\",\"幂等性 + At Least Once = Exactly Once\",\"幂等性：主要为了解决消息重复\",\"启用幂等性：在 Producer 的参数中设置enable.idempotence=true即可。\",\"Kafka 的幂等性实现：实际是将之前的去重操作放在了数据上游来做，开启幂等性的 Producer 在初始化的时候会被分配一个PID，发往同一个 Partition 的消息会附带Sequence Number，而Broker端会对<PID,Partition,SeqNumber>做缓存，当具有相同主键的消息的时候，Broker 会持久化一条。\",\"PID在重启之后会发生变化，同时不同的 Partition 也具有不同的主键，所以幂等性无法保证跨分区跨会话的Exactly Once。\"]},\"857\":{\"h\":\"消费者\"},\"858\":{\"h\":\"消费者消费方式\",\"t\":[\"consumer采用pull的方式来从broker中读取数据。\",\"​ push推的模式很难适应消费速率不同的消费者，因为消息发送率是由broker决定的，它的目标是尽可能以最快的速度传递消息，但是这样容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull方式则可以让consumer根据自己的消费处理能力以适当的速度消费消息。\",\"​ pull模式不足在于如果Kafka中没有数据，消费者可能会陷入循环之中 (因为消费者类似监听状态获取数据消费的)，一直返回空数据，针对这一点，Kafka的消费者在消费数据时会传入一个时长参数timeout，如果当前没有数据可供消费，consumer会等待一段时间之后再返回，时长为timeout。\"]},\"859\":{\"h\":\"消费者分区分配策略\",\"t\":[\"是指一个 consumer group 中一个 consumer ，如何选择一个 topic 多个 partition 中的一个 partition 来进行 pull 消息。\",\"**Kafka的两种分配策略：**round-robin循环、range。\",\"轮询策略\",\"​ 主要采用轮询的方式分配所有的分区。按照分区字典对分区和消费者进行排序，然后对分区进行轮询，遇到自己订阅的则消费。轮询的方式会导致每个Consumer所承载的分区数量不一致，从而导致各个Consumer压力不均。\",\"Range策略（默认）\",\"​ 按照range的方式进行分配，本质上是遍历每个topic，然后将这些topic按照其订阅的consumer数进行平均分配，多出来的则按照consumer的字典序挨个分配，这种方式会导致在前面的consumer得到更多的分区，导致各个consumer的压力不均衡。\"]},\"860\":{\"h\":\"Consumer Group 的 offset 放在哪儿\",\"t\":[\"​ 由于Consumer在消费过程中可能会出现断电宕机等故障，Consumer恢复以后，需要从故障前的位置继续消费，所以Consumer需要实时记录自己消费到了那个offset，以便故障恢复后继续消费。由group+partition+topic来唯一确定offset\",\"​ Kafka0.9版本之前，consumer默认将offset保存在zookeeper中，但是 ZooKeeper 这类元框架其实并不适合进行频繁的写更新，而 Consumer Group 的位移更新却是一个非常频繁的操作。这种大吞吐量的写操作会极大地拖慢 ZooKeeper 集群的性能。\",\"​ 0.9版本之后，consumer默认将offset保存在kafka一个内置的topic中，该topic为__consumer_offsets\"]},\"861\":{\"h\":\"Kafka中zookeeper的作用\",\"t\":[\"Broker 注册 ：在 Zookeeper 上会有一个专门用来进行 Broker 服务器列表记录的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到/brokers/ids 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去\",\"Topic 注册 ： 在 Kafka 中，同一个Topic 的消息会被分成多个分区并将其分布在多个 Broker 上，这些分区信息及与 Broker 的对应关系也都是由 Zookeeper 在维护。\",\"负载均衡 ：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。\"]},\"862\":{\"h\":\"事务\"},\"863\":{\"h\":\"Producer事务\",\"t\":[\"开启：enable.idempotence = true\",\"​ 为了跨分区、跨会话的事务，需要引入一个全局唯一的Transaction ID，并将Producer获得的PID(可以理解为Producer ID)和Transaction ID进行绑定，这样当Producer重启之后就可以通过正在进行的Transaction ID获得原来的PID。\",\"​ 为了管理Transaction，Kafka引入了一个新的组件Transaction Coordinator，Producer就是通过有和Transaction Coordinator交互获得Transaction ID对应的任务状态，Transaction Coordinator还负责将事务信息写入内部的一个Topic中，这样即使整个服务重启，由于事务状态得到保存，进行中的事务状态可以恢复，从而继续进行。\",\"幂等性 Producer 只能保证单分区、单会话上的消息幂等性；而事务能够保证跨分区、跨会话间的幂等性\"]},\"864\":{\"h\":\"Consumer事务\",\"t\":[\"​ 对于Consumer而言，事务的保证相比Producer相对较弱，尤其是无法保证Commit的信息被精确消费，这是由于Consumer可以通过offset访问任意信息，而且不同的Segment File声明周期不同，同一事务的消息可能会出现重启后被删除的情况。\"]},\"865\":{\"h\":\"消息顺序性的体现\",\"t\":[\"Kafka只能保证partition内消息顺序有序，无法保证全局有序\",\"生产者端：通过分区的leader副本负责数据顺序写入，来保证消息顺序性。不同partition之间不能保证顺序。但是绝大多数用户都可以通过message key来定义，因为同一个key的Message可以保证只发送到同一个partition。Kafka中发送1条消息的时候，可以指定(topic, partition, key) 3个参数。partiton和key是可选的。如果你指定了partition，那就是所有消息发往同1个partition，就是有序的。\",\"消费者端：Kafka保证，1个partition只能被1个consumer消费。或者你指定key（比如order id），具有同1个key的所有消息，会发往同1个partition。\",\"为什么做不到全局有序？ 因为消息会发送到不一样的分区，分区之间发送的顺序是无法保证的。可以将Partition设置为1。\",\"如何做到并发且全局有序？\",\"topic设置一个分区，发送端和消费端开启多线程生产和消费。\",\"topic设置多个分区，自定义发送端的分区策略，数据发送到同一个分区中，消费端开启多线程消费。\",\"topic设置多个分区，自定义发送端的分区策略，数据发送不同分区，消费时按发送分区的顺序消费，发送和消费端都启动多线程来提高并发度。\"]},\"866\":{\"h\":\"消息重复消费和消息漏掉的场景\",\"t\":[\"重复消费\",\"消费端，处理完数据还没来的及提交，程序就挂了，导致再次连接时，重新消费这一批数据。**处理方案：**将消息提交改为手动提交，数据处理和消息提交放在一个事务里，可以借助mysql的事务。\",\"producer 送的消息没有收到ack，导致producer重试。 **解决方案：**启动kafka的幂等性 enable.idempotence=true 同时要求 ack=all 且 retries>1。\",\"漏掉消息\",\"生产端，ack=0不重试，ack=1 leader写入就返回，这种情况下，leader挂了，重新选举生成的leader并没有这个偏移量导致消息重复，消费端，先提交，后处理数据的时候出现异常\",\"分区副本数小于2个,导致没有足够数量的副本参与新leader选举, 无法保证数据的高可用,当原leader挂了之后, 没有follower被选举为leader。\"]},\"867\":{\"h\":\"分区器、序列化器、拦截器\",\"t\":[\"序列化器 \",\"字符串序列化器 StringSerializer\",\"整形 IntegerSerializer\",\"字节数组 ByteSerializer\",\"分区器 \",\"kafka 本身有自己的分区策略，如果未指定，则采用默认的分区策略。\",\"kafka 默认的分区策略是根据key进行分区的分配，即hash(key) % numPartitions, numPartitions:分区数量，如果key相同，则被分配到同一个分区。\",\"拦截器 \",\"拦截器主要用于client的定制化控制逻辑，生产者拦截器可以用在消息发送前做一些准备工作\",\"使用场景： \",\"按照某种规则过滤不符合要求的消息\",\"修改消息内容\",\"统计类需求\",\"顺序：拦截器 -> 序列化器 -> 分区器\"]},\"868\":{\"h\":\"如何判断一个节点是否还活着\",\"t\":[\"节点必须可以维护和ZooKeeper 的连接，Zookeeper通过心跳机制检查每个节点的连接。\",\"如果节点是个follower，他必须能及时的同步leader的写操作，延时不能太久。\"]},\"869\":{\"h\":\"负载均衡算法\",\"t\":[\"轮询\",\"所有请求被依次分发到每台应用服务器上\",\"优点：每台服务器需要处理的请求数目相同，适用于服务器硬件都相同的场景\",\"缺点：服务器压力一样，不适合服务器配置不同的情况\",\"随机\",\"请求被随机分配到各个服务器\",\"优点：使用简单，因为好的随机数本身就很均衡\",\"缺点：不适合机器配置不同的场景\",\"最少连接\",\"将请求分配到连接数最少的服务器上（目前处理请求最少的服务器）。\",\"优点：根据服务器当前的请求处理情况，动态分配 缺点：算法实现相对复杂，需要监控服务器请求连接数\",\"源地址散列\",\"根据IP地址进行Hash计算，得到应用服务器，这样来自同一个IP地址的请求总在同一个服务器上处理 优点：将来自同一IP地址的请求，同一会话周期内，转发到相同的服务器；实现会话粘滞 缺点：目标服务器宕机后，会话会丢失\",\"加权轮询\",\"在轮询，随机，最少链接，Hash等算法的基础上，通过加权的方式，进行负载服务器分配。 优点：根据权重，调节转发服务器的请求数目； 缺点：使用相对复杂\"]},\"870\":{\"h\":\"CAP理论\",\"t\":[\"​ 指的是在一个分布式系统中，当出现了网络分区的时候，只能选择CP（ZooKeeper）或者AP（Redis）架构。\",\"一致性（Consistency）：无论访问哪个节点，都能获得相同的结果。\",\"可用性（Availability）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）\",\"分区容忍性（Partition tolerance）：分布式系统出现网络分区的时候，仍然能够对外提供服务。\",\"注意点：\",\"ZooKeeper 保证的是 CP：任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。\",\"如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。\",\"什么是网络分区？\",\"​ 分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。\"]},\"871\":{\"h\":\"BASE理论\",\"t\":[\"​ BASE 是 Basically Available（基本可用） 、Soft-state（软状态） 和 Eventually Consistent（最终一致性） 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。\",\"核心思想：\",\"​ 即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。\"]},\"872\":{\"h\":\"Paxos算法\",\"t\":[\"​ Paxos 算法诞生于 1990 年，这是一种解决分布式系统一致性的经典算法 。但是，由于 Paxos 算法在国际上被公认的非常难以理解和实现，因此不断有人尝试简化这一算法。到了2013 年才诞生了一个比 Paxos 算法更易理解和实现的分布式一致性算法—Raft 算法。\"]},\"873\":{\"h\":\"Raft 算法\",\"t\":[\"分布式算法的挑战\",\"时序性：运行在不同网络下的机器中的进程如何判断一些事件的发生顺序。\",\"并发性：运行在不同网络下的机器中的进程如何共享资源，而互不干扰。如访问共同的数据库。\",\"健壮性：应对网络中的不稳定性以及硬件的不稳定性。\",\"一致性：如何保障无论访问哪个服务节点，都能获得相同的结果。\",\"共识算法\",\"​ 共识是可容错系统中的一个基本问题：即使面对故障，服务器也可以在共享状态上达成一致。\",\"​ 共识算法允许一组节点像一个整体一样一起工作，即使其中的一些节点出现故障也能够继续工作下去，其正确性主要是源于复制状态机的性质：一组Server的状态机计算相同状态的副本，即使有一部分的Server宕机了它们仍然能够继续运行。\",\"适用于实际系统的共识算法通常具有以下特性：\",\"安全。确保在非拜占庭条件（也就是上文中提到的简易版拜占庭）下的安全性，包括网络延迟、分区、包丢失、复制和重新排序。\",\"高可用。\",\"一致性不依赖时序。错误的时钟和极端的消息延迟，在最坏的情况下也只会造成可用性问题，而不会产生一致性问题。\",\"在集群中大多数服务器响应，命令就可以完成，不会被少数运行缓慢的服务器来影响整体系统性能。\"]},\"874\":{\"h\":\"节点类型\",\"t\":[\"一个 Raft 集群包括若干服务器，以典型的 5 服务器集群举例。在任意的时间，每个服务器一定会处于以下三个状态中的一个：\",\"Leader：负责发起心跳，响应客户端，创建日志，同步日志。\",\"Candidate：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。\",\"Follower：接受 Leader 的心跳和日志同步数据，投票给 Candidate。\",\"在正常的情况下，只有一个服务器是 Leader，剩下的服务器是 Follower。Follower 是被动的，它们不会发送任何请求，只是响应来自 Leader 和 Candidate 的请求。\"]},\"875\":{\"h\":\"日志\",\"t\":[\"entry：每一个事件成为 entry，只有 Leader 可以创建 entry。entry 的内容为<term,index,cmd>，其中 cmd 是可以应用到状态机的操作。\",\"log：由 entry 构成的数组，每一个 entry 都有一个表明自己在 log 中的 index。只有 Leader 才可以改变其他节点的 log。entry 总是先被 Leader 添加到自己的 log 数组中，然后再发起共识请求，获得同意后才会被 Leader 提交给状态机。Follower 只能从 Leader 获取新日志和当前的 commitIndex，然后把对应的 entry 应用到自己的状态机中。\"]},\"876\":{\"h\":\"任期\",\"t\":[\"​ raft 算法将时间划分为任意长度的任期（term），任期用单调递增的数字表示，是一个逻辑时间，越大的term表示任期越新。每一个任期的开始都是一次选举，在选举开始时，一个或多个 Candidate 会尝试成为 Leader。 如果一个 Candidate 赢得了选举，它就会在该任期内担任 Leader。如果没有选出 Leader，将会开启另一个任期，并立刻开始下一次选举。raft 算法保证在给定的一个任期最少要有一个 Leader。\",\"​ 每个节点都会存储当前的 term 号，当服务器之间进行通信时会交换当前的 term 号；如果有服务器发现自己的 term 号比其他人小，那么他会更新到较大的 term 值。如果一个 Candidate 或者 Leader 发现自己的 term 过期了，他会立即退回成 Follower。如果一台服务器收到的请求的 term 号是过期的，那么它会拒绝此次请求。\"]},\"877\":{\"h\":\"leader选举\",\"t\":[\"raft 使用心跳机制来触发 Leader 的选举。\",\"选举开始的条件：\",\"​ Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。如果一台服务器能够收到来自 Leader 或者 Candidate 的有效信息，那么它会一直保持为 Follower 状态，并且刷新自己的 electionElapsed，重新计时。\",\"​ 如果一个 Follower 在一个周期内没有收到心跳信息，就叫做选举超时，然后它就会认为此时没有可用的 Leader，并且开始进行一次选举以选出一个新的 Leader，然后他会向所有节点发起 RequestVoteRPC 请求。选主期间整个集群对外是不可用的。\",\"赢得选举的条件是：\",\"​ 一个 Candidate 在一个任期内收到了来自集群内的多数选票（N/2+1），就可以成为 Leader。\",\"选不出leader怎么办？\",\"​ 由于可能同一时刻出现多个 Candidate，导致没有 Candidate 获得大多数选票，如果没有其他手段来重新分配选票的话，那么可能会无限重复下去。\",\"​ raft 使用了随机的electionTimeout来避免上述情况。每一个 Candidate 在发起选举后，都会随机化一个新的electionTimeout，这种机制使得各个follower能够分散开来，在大多数情况下只有一个服务器会率先超时；它会在其他服务器超时之前赢得选举。\"]},\"878\":{\"h\":\"日志复制\",\"t\":[\"​ 一旦选出了 Leader，它就开始接受客户端的请求。每一个客户端的请求都包含一条需要被复制状态机（Replicated State Mechine）执行的命令。\",\"​ Leader 收到客户端请求后，会生成一个 entry，包含<index,term,cmd>，再将这个 entry 添加到自己的日志末尾后，向所有的节点广播该 entry，要求其他服务器复制这条 entry。\",\"​ 如果 Follower 接受该 entry，则会将 entry 添加到自己的日志后面，同时返回给 Leader 同意。如果 Leader 收到了多数的成功响应，Leader 会将这个 entry 应用到自己的状态机中，之后可以成为这个 entry 是 committed 的，并且向客户端返回执行结果。\",\"​ Leader 需要保证自己存储全部已经提交的日志条目。这样才可以使日志条目只有一个流向：从 Leader 流向 Follower，Leader 永远不会覆盖已经存在的日志条目。每个 Candidate 发送 RequestVoteRPC 时，都会带上最后一个 entry 的信息。所有节点收到投票信息时，会对该 entry 进行比较，如果发现自己的更新，则拒绝投票给该 Candidate。\"]},\"879\":{\"h\":\"时间与可用性\",\"t\":[\"​ raft 的要求之一就是安全性不依赖于时间：系统不能仅仅因为一些事件发生的比预想的快一些或者慢一些就产生错误。为了保证上述要求，最好能满足以下的时间条件：\",\"broadcastTime << electionTimeout << MTBF \",\"broadcastTime：向其他节点并发发送消息的平均响应时间；\",\"electionTimeout：选举超时时间；\",\"MTBF(mean time between failures)：单台机器的平均健康时间；\",\"broadcastTime<<electionTimeout：为的是使Leader能够持续发送心跳信息（heartbeat）来阻止Follower开始选举；\",\"electionTimeout<<MTBF：为的是使得系统稳定运行。当Leader崩溃时，大约会在整个electionTimeout的时间内不可用；我们希望这种情况仅占全部时间的很小一部分。\",\"由于broadcastTime和MTBF是由系统决定的属性，因此需要决定electionTimeout的时间。一般来说，broadcastTime 一般为 0.5～20ms，electionTimeout 可以设置为 150～300ms，MTBF 一般为一两个月。\"]},\"880\":{\"h\":\"一致性哈希\",\"t\":[\"​ 不同的负载均衡算法适用的业务场景也不同的。轮训这类的策略只能适用与每个节点的数据都是相同的场景，访问任意节点都能请求到数据。但是不适用分布式系统，因为分布式系统意味着数据水平切分到了不同的节点上，访问数据的时候，一定要寻址存储该数据的节点。\",\"使用哈希算法的问题\",\"​ 哈希算法最简单的做法就是进行取模运算。但是有一个很致命的问题，如果节点数量发生了变化，也就是在对系统做扩容或者缩容时，必须迁移改变了映射关系的数据，否则会出现查询不到数据的问题。\",\"​ 要解决这个问题的办法，就需要我们进行迁移数据，比如节点的数量从 3 变化为 4 时，要将计算公式由hash(key) % 3变成 hash(key) % 4 ，重新对数据和节点做映射。假设总数据条数为 M，哈希算法在面对节点数量变化时，最坏情况下所有数据都需要迁移，所以它的数据迁移规模是 O(M)，这样数据的迁移成本太高了。\",\"一致性哈希算法\",\"​ 为了避免分布式系统在扩容或者缩容时，发生过多的数据迁移，采用一致性哈希算法。一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而一致哈希算法是对 2^32 进行取模运算，是一个固定的值。可以把一致哈希算法是对 2^32 进行取模运算的结果值想象成一个 2^32 个点组成的圆环，这个圆环被称为哈希环，如下图：\",\"一致性哈希要进行两步哈希：\",\"第一步：对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希；\",\"第二步：当对数据进行存储或访问时，对数据进行哈希映射；\",\"所以，一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上。对「数据」进行哈希映射得到一个结果后，往顺时针的方向的找到第一个节点，就是存储该数据的节点。在一致哈希算法中，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。\",\"存在的问题\",\"​ 一致性哈希算法并不保证节点能够在哈希环上分布均匀，这样就会带来一个问题，会有大量的请求集中在一个节点上。在这种节点分布不均匀的情况下，进行容灾与扩容时，哈希环上的相邻节点容易受到过大影响，容易发生雪崩式的连锁反应。\",\"解决方案：使用虚拟节点\",\"​ 要想解决节点能在哈希环上分配不均匀的问题，就是要有大量的节点，节点数越多，哈希环上的节点分布的就越均匀。但问题是，实际中我们没有那么多节点。所以这个时候我们就加入虚拟节点，也就是对一个真实节点做多个副本。\",\"​ 具体做法是，不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。\",\"​ 引入虚拟节点后，可以会提高节点的均衡度，还会提高系统的稳定性。所以，带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景。\"]},\"881\":{\"h\":\"海量数据问题\",\"t\":[\"处理海量数据问题，无非就是：\",\"分而治之/hash映射 + hash统计 + 堆/快速/归并排序；\",\"Bloom filter/Bitmap；\",\"Trie树/数据库/倒排索引；\",\"外排序；\",\"分布式处理之hadoop/mapreduce。\"]},\"882\":{\"h\":\"布隆过滤器\",\"t\":[\"适用范围\",\"​ 检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。\",\"使用场景：\",\"判断给定数据是否存在： \",\"比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5 亿以上！）\",\"防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）\",\"邮箱的垃圾邮件过滤、黑名单功能等等。\",\"去重：比如爬给定网址的时候对已经爬取过的 URL 去重。\",\"基本原理及要点\",\"当一个元素加入布隆过滤器中的时候，会进行如下操作：\",\"使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。\",\"根据得到的哈希值，在位数组中把对应下标的值置为 1。\",\"当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：\",\"对给定元素再次进行相同的哈希计算；\",\"得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。\",\"结论：\",\"​ 因为不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。也就是说，布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。\",\"实现\",\"手动实现布隆过滤器（Java）\",\"Google开源的Guava中自带的布隆过滤器\",\"//首先引入依赖 <dependency> <groupId>com.google.guava</groupId> <artifactId>guava</artifactId> <version>28.0-jre</version> </dependency> // 创建了一个最多存放最多 1500 个整数的布隆过滤器，并且我们可以容忍误判的概率为0.01 BloomFilter<Integer> filter = BloomFilter.create( Funnels.integerFunnel(), 1500, 0.01); // 判断指定元素是否存在 System.out.println(filter.mightContain(1)); System.out.println(filter.mightContain(2)); // 将元素添加进布隆过滤器 filter.put(1); filter.put(2); System.out.println(filter.mightContain(1)); System.out.println(filter.mightContain(2)); //当 mightContain() 方法返回 true 时，我们可以 99％确定该元素在过滤器中，当过滤器返回 false 时，我们可以 100％确定该元素不存在于过滤器中。 \",\"Redis中的布隆过滤器：Redis v4.0 之后有了 Module（模块/插件） 功能，Redis Modules 让 Redis 可以使用外部模块扩展其功能 。布隆过滤器就是其中的 Module。\"]},\"883\":{\"h\":\"BitMap\",\"t\":[\"适用范围\",\"可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下\",\"基本原理及要点\",\"使用bit数组来表示某些元素是否存在，比如8位电话号码\",\"扩展\",\"bloom filter可以看做是对bit-map的扩展\",\"问题实例\",\"已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。\",\"8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。\",\"2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。\",\"将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map。\"]},\"884\":{\"h\":\"Hash\",\"t\":[\"适用范围\",\"快速查找，删除的基本数据结构，通常需要总数据量可以放入内存\",\"基本原理及要点\",\"hash函数选择，针对字符串，整数，排列，具体相应的hash方法。\",\"碰撞处理，一种是open hashing，也称为拉链法；另一种就是closed hashing，也称开地址法，opened addressing。\",\"扩展\",\"d-left hashing中的d是多个的意思，我们先简化这个问题，看一看2-left hashing。2-left hashing指的是将一个哈希表分成长度相等的两半，分别叫做T1和T2，给T1和T2分别配备一个哈希函数，h1和h2。在存储一个新的key时，同时用两个哈希函数进行计算，得出两个地址h1[key]和h2[key]。这时需要检查T1中的h1[key]位置和T2中的h2[key]位置，哪一个位置已经存储的（有碰撞的）key比较多，然后将新key存储在负载少的位置。如果两边一样多，比如两个位置都为空或者都存储了一个key，就把新key存储在左边的T1子表中，2-left也由此而来。在查找一个key时，必须进行两次hash，同时查找两个位置。\",\"问题实例\",\"海量日志数据，提取出某日访问百度次数最多的那个IP。\",\"IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将ip直接存入内存，然后进行统计。\"]},\"885\":{\"h\":\"堆\",\"t\":[\"适用范围\",\"海量数据前n大，并且n比较小，堆可以放入内存\",\"基本原理及要点\",\"最大堆求前n小，最小堆求前n大。\",\"方法，比如求前n小，我们比较当前元素与最大堆里的最大元素，如果它小于最大元素，则应该替换那个最大元素。这样最后得到的n个元素就是最小的n个。适合大数据量，求前n小，n的大小比较小的情况，这样可以扫描一遍即可得到所有的前n元素，效率很高。\",\"扩展\",\"双堆，一个最大堆与一个最小堆结合，可以用来维护中位数。\",\"问题实例\",\"100w个数中找最大的前100个数。\",\"用一个100个元素大小的最小堆即可。\"]},\"886\":{\"h\":\"双层桶划分----其实本质上就是【分而治之】的思想，重在“分”的技巧上！\",\"t\":[\"适用范围\",\"第k大，中位数，不重复或重复的数字 基本原理及要点\",\"因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。可以通过多次缩小，双层只是一个例子。 问题实例\",\"2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。\",\"有点像鸽巢原理，整数个数为2^32，也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。\",\"5亿个int找它们的中位数 首先我们将 int 划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。\",\"然后第二次扫描我们只统计落在这个区域中的那些数就可以了。\",\"实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。\"]},\"887\":{\"h\":\"数据库索引\",\"t\":[\"适用范围\",\"大数据量的增删改查\",\"基本原理及要点\",\"利用数据的设计实现方法，对海量数据的增删改查进行处理。\"]},\"888\":{\"h\":\"倒排索引\",\"t\":[\"适用范围\",\"搜索引擎，关键字查询\",\"基本原理及要点\",\"一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。\",\"以英文为例，下面是要被索引的文本： T0 = \\\"it is what it is\\\" T1 = \\\"what is it\\\" T2 = \\\"it is a banana\\\"\",\"我们就能得到下面的反向文件索引：\",\"\\\"a\\\": {2} \\\"banana\\\": {2} \\\"is\\\": {0, 1, 2} \\\"it\\\": {0, 1, 2} \\\"what\\\": {0, 1}\",\"检索的条件\\\"what\\\",\\\"is\\\"和\\\"it\\\"将对应集合的交集。\",\"正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。\",\"扩展\",\"文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。\"]},\"889\":{\"h\":\"外排序\",\"t\":[\"适用范围\",\"大数据的排序，去重\",\"基本原理及要点\",\"外排序的归并方法，置换选择败者树原理，最优归并树\",\"问题实例\",\"有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。\",\"这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1m做hash有些不够，所以可以用来排序。内存可以当输入缓冲区使用。\"]},\"890\":{\"h\":\"trie树\",\"t\":[\"适用范围\",\"数据量大，重复多，但是数据种类小可以放入内存\",\"基本原理及要点\",\"实现方式，节点孩子的表示方式\",\"扩展\",\"压缩实现。\",\"问题实例\",\"有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序。\",\"1000万字符串，其中有些是相同的(重复)，需要把重复的全部去掉，保留没有重复的字符串。请问怎么设计和实现？\",\"寻找热门查询：查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个，每个不超过255字节。\"]},\"891\":{\"h\":\"分布式处理 mapreduce\",\"t\":[\"适用范围\",\"数据量大，但是数据种类小可以放入内存\",\"基本原理及要点\",\"将数据交给不同的机器去处理，数据划分，结果归约。\",\"问题实例\",\"The canonical example application of MapReduce is a process to count the appearances of each different word in a set of documents:\",\"海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。\",\"一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数的中数(median)？\",\"经典问题分析\",\"上千万or亿数据（有重复），统计其中出现次数最多的前N个数据,分两种情况：可一次读入内存，不可一次读入。\",\"可用思路：trie树+堆，数据库索引，划分子集分别统计，hash，分布式计算，近似统计，外排序\",\"所谓的是否能一次读入内存，实际上应该指去除重复后的数据量。如果去重后数据可以放入内存，我们可以为数据建立字典，比如通过 map，hashmap，trie，然后直接进行统计即可。当然在更新每条数据的出现次数的时候，我们可以利用一个堆来维护出现次数最多的前N个数据，当然这样导致维护次数增加，不如完全统计后在求前N大效率高。\",\"如果数据无法放入内存。一方面我们可以考虑上面的字典方法能否被改进以适应这种情形，可以做的改变就是将字典存放到硬盘上，而不是内存，这可以参考数据库的存储方法。\",\"当然还有更好的方法，就是可以采用分布式计算，基本上就是map-reduce过程，首先可以根据数据值或者把数据hash(md5)后的值，将数据按照范围划分到不同的机子，最好可以让数据划分后可以一次读入内存，这样不同的机子负责处理各种的数值范围，实际上就是map。得到结果后，各个机子只需拿出各自的出现次数最多的前N个数据，然后汇总，选出所有的数据中出现次数最多的前N个数据，这实际上就是reduce过程。\",\"实际上可能想直接将数据均分到不同的机子上进行处理，这样是无法得到正确的解的。因为一个数据可能被均分到不同的机子上，而另一个则可能完全聚集到一个机子上，同时还可能存在具有相同数目的数据。比如我们要找出现次数最多的前100个，我们将1000万的数据分布到10台机器上，找到每台出现次数最多的前 100个，归并之后这样不能保证找到真正的第100个，因为比如出现次数最多的第100个可能有1万个，但是它被分到了10台机子，这样在每台上只有1千个，假设这些机子排名在1000个之前的那些都是单独分布在一台机子上的，比如有1001个，这样本来具有1万个的这个就会被淘汰，即使我们让每台机子选出出现次数最多的1000个再归并，仍然会出错，因为可能存在大量个数为1001个的发生聚集。因此不能将数据随便均分到不同机子上，而是要根据hash 后的值将它们映射到不同的机子上处理，让不同的机器处理一个数值范围。\"]},\"892\":{\"h\":\"1 海量日志数据，提取出某日访问百度次数最多的那个IP\",\"t\":[\"首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。\",\"或者如下阐述（雪域之鹰）：\",\"算法思想：分而治之+Hash\",\"IP地址最多有 2^32=4G 种取值情况，所以不能完全加载到内存中处理；\",\"分而治之/Hash映射：可以考虑采用“分而治之”的思想，按照 IP 地址的 Hash(IP)%1024 值，把海量 IP 日志分别存储到1024 个小文件中。这样，每个小文件最多包含 4MB 个IP地址；\",\"hash统计：对于每一个小文件，可以构建一个 IP 为 key，出现次数为 value 的 Hash map，同时记录当前出现次数最多的那个 IP 地址；\",\"堆/快速排序：可以得到 1024 个小文件中的出现次数最多的 IP，再依据常规的排序算法得到总体上出现次数最多的 IP；\",\"所以上面第2步可以保证同一个IP不会被散列到不同的小文件上\"]},\"893\":{\"h\":\"2 (百度)搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。\",\"t\":[\"百度面试题\",\"假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。\",\"问题解析：\",\"要统计最热门查询，首先就是要统计每个查询出现的次数，然后根据统计结果，找出Top 10。所以我们可以基于这个思路分两步来设计该算法。即，此问题的解决分为以下两个步骤：\",\"第一步：查询统计\",\"维护一个Key 为Query 字串，Value 为该 Query 出现次数的 HashMap，统计每个 Query 字段出现的次数，最终我们在**O(N)**的时间复杂度内完成了对该海量数据的处理。\",\"第二步：找出Top 10\",\"借助小根堆，找出Top K，时间复杂度为N‘logK。\",\"具体过程是，堆顶存放的是整个堆中最小的数，现在遍历N个数，把最先遍历到的k个数存放到最小堆中，并假设它们就是我们要找的最大的k个数，X1>X2...Xmin(堆顶)，而后遍历后续的N-K个数，一一与堆顶元素进行比较，如果遍历到的Xi大于堆顶元素Xmin，则把Xi放入堆中，而后更新整个堆，更新的时间复杂度为logK，如果Xi<Xmin，则不更新堆，整个过程的复杂度为O(K)+O((N-K)logK)=O(NlogK)。\",\"所以，我们最终的时间复杂度是：O（N） + N'*O（logK）。（N为1000万，N’为300万）\"]},\"894\":{\"h\":\"3 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。\",\"t\":[\"分而治之/hash映射\",\"顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,...x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。\",\"hash统计\",\"对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。\",\"堆/归并排序\",\"取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似与归并排序）的过程了。\"]},\"895\":{\"h\":\"4 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。\",\"t\":[\"方案一\",\"hash映射\",\"顺序读取10个文件，按照hash(query)%10的结果将 query 写入到另外10 个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。\",\"hash统计\",\"找一台内存在 2G 左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注：hash_map(query,query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。\",\"堆/快速/归并排序\",\"利用快速/堆/归并排序按照出现次数进行排序。将排序好的 query 和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。对这10个文件进行归并排序（内排序与外排序相结合）。\",\"方案二\",\"一般 query 的总量是有限的，只是重复的次数比较多而已，可能对于所有的 query，一次性就可以加入到内存了。这样，我们就可以采用 trie 树/hash_map 等直接来统计每个 query 出现的次数，然后按出现次数做快速/堆/归并排序就可以了。\",\"方案三\",\"与方案1类似，但在做完 hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。\"]},\"896\":{\"h\":\"5 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？\",\"t\":[\"方案一\",\"可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。\",\"分而治之/Hash映射\",\"遍历文件a，对每个 url 求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为 300M。\",\"遍历文件b，采取和a相同的方式将 url 分别存储到1000小文件（记为b0,b1,...,b999）。\",\"这样处理后，所有可能相同的 url 都在对应的小文件（a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的 url。然后我们只要求出1000对小文件中相同的 url 即可。\",\"Hash统计\",\"求每对小文件中相同的 url 时，可以把其中一个小文件的 url 存储到 hash_set 中。然后遍历另一个小文件的每个 url，看其是否在刚才构建的 hash_set 中，如果是，那么就是共同的 url，存到文件里面就可以了。\",\"方案二\",\"如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。\"]},\"897\":{\"h\":\"6 怎么在海量数据中找出重复次数最多的一个？\",\"t\":[\"只用2GB内存在20亿个整数中找到出现次数最多的数\",\"分而治之/Hash映射\",\"把包含20亿个数的小文件用哈希函数分为16个小文件，根据哈希函数的性质，同一种数不可能被散列到不同的小文件上，同时每个小文件中不同的数一定不会大于2亿种，假设哈希函数足够优秀\",\"Hash统计\",\"对每一个小文件用哈希表来统计其中每种数出现的次数，这样就得到了16个文件中各自出现次数最多的数，还有各自的次数统计\",\"堆/快速/归并排序\",\"选出16个小文件各自的第一名中谁出现的次数最多即可\"]},\"898\":{\"h\":\"7 上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。\",\"t\":[\"上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第2题提到的堆机制完成。\"]},\"899\":{\"h\":\"8 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。\",\"t\":[\"这题是考虑时间效率。\",\"用 trie树 统计每个词出现的次数，时间复杂度是O(nle)（le表示单词的平准长度）。\",\"找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(nlg10)。\",\"所以总的时间复杂度，是O(nle)与O(nlg10)中较大的哪一个。\"]},\"900\":{\"h\":\"1 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。\",\"t\":[\"方案1\",\"采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，用2个位置表示一个数出现的频率，整数 num 对应 Bitmap 中Bitmap[num*2] 和 Bitmap[num*2+1]两位，共需内存2^32 * 2 bit=1 GB内存，还可以接受。\",\"然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。\",\"方案二\",\"也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。\"]},\"901\":{\"h\":\"2 腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？\",\"t\":[\"方案一：\",\"直接读入内存大约需要16G（2^32^4byte），使用bigmap，大约需要512M（2^32bit）的内存，一个bit位（总共有40多亿个bit）代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。时间复杂度为O(n)\",\"方案二：\",\"因为2^32为40亿多，所以给定一个数可能在，也可能不在其中；这里我们把40亿个数中的每一个用32位的二进制来表示。 假设这40亿个数开始放在一个文件中。然后将这40亿个数分成两类: 1.最高位为0 2.最高位为1\",\"并将这两类分别写入到两个文件中，其中一个文件中数的个数<=20亿，而另一个>=20亿（这相当于折半了）；与要查找的数的最高位比较并接着进入相应的文件再查找\",\"再然后把这个文件为又分成两类: 1.次最高位为0 2.次最高位为1 并将这两类分别写入到两个文件中，其中一个文件中数的个数<=10亿，而另一个>=10亿（这相当于折半了）； 与要查找的数的次最高位比较并接着进入相应的文件再查找。 ....... 以此类推，就可以找到了,而且时间复杂度为O(logn)。\"]},\"902\":{\"h\":\"1. 给2000千万高考学生排序，要求要能根据分数找到该学生的排名？\",\"t\":[\"千万别被2000千万这个数字唬住，理性的看一下题，“高考”这个词不知道你注意到了没？这是一个隐藏条件。你高考考了多少分？\",\"总分多少？可能有的小伙伴已经反应过来了。高考750分，分数大小是固定的，那我们开一个750长度的数组，记录每个分数的的个数就可以了。\",\"对，就是使用桶排序的算法，来进行排。\",\"这一类题他虽然样子很吓人，但是仔细 发现他的范围很小，就抓住他这个范围小来做文章。\",\"时间复杂度：n 空间复杂度750\"]},\"903\":{\"h\":\"\",\"t\":[\"我们不能用一个int去装，可以用一位bit去装。\",\"详解：\",\"int = 4byte= 32bit\",\"用一个int型的数组来存储数据，数组中每个元素都是Integer类型的，这样每个元素对应32位二进制位，让每一位二进制代表一个整数的话，这样，数组中的一个元素可以记录32个整数\",\"这样每个元素记录32个整数，则一共需要2亿/32 长度的数组\",\"先利用x/32找到数组下标，然后利用 x%32 找到他对应的整数中的位，令这一位为1\"]},\"904\":{\"h\":\"\",\"t\":[\"这道题可能就没那个多的奇技淫巧了。\",\"条件一个一个的增加，先是找出频率最高的5个，这个没有多余的话，肯定是根据频率最大堆排序。\",\"那么一个超大文件，也就是说i我们内存没办法直接装下，可以将这个文件先分解（根据实际内存大小和文件大小判断，下边以5000份做例子），这时候我们把文件分成了5000份的小文件，然后我们为每个小文件构造一个数量为5的最大堆。其余的数字就可以清掉了。然后5000个小文件就行排序，这时候归并就要登场了。\",\"我们通过归并然后对这5千个数据进行归并拿前5。这就找到了。\"]},\"905\":{\"h\":\"算法\"},\"906\":{\"h\":\"二叉树\"},\"907\":{\"h\":\"遍历\",\"t\":[\"​ 前、中、后序遍历的区别是第几次到达这个节点的时候打印。\"]},\"908\":{\"h\":\"非递归实现前、中、后序遍历\",\"t\":[\"前序遍历\",\"方法一：弹出栈打印，先压右孩子，再压左孩子。\",\"if(root!=null){ Stack<TreeNode> stack=new Stack<>(); stack.add(root); if(!stack.empty()){ root=stack.pop(); //弹出栈打印 System.out.println(root.val); if(root.right!=null) stack.push(root.right); if(root.left!=null) stack.push(root.left); } } \",\"方法二：根节点入栈，打印根节点，访问左子树，做到头之后，取出栈顶节点，访问右子树\",\"Stack<TreeNode> stack = new Stack<>(); while(root!=null||!stack.empty()){ while(root!=null){ //一直往左走 stack.push(root); System.out.println(root.val); root=root.left } root=stack.pop(); root=root.right; } \",\"中序遍历\",\"因为是左-根-右，整条左边界依次入栈，之后弹出打印节点，然后来到弹出节点的右树上继续执行。\",\" Stack<TreeNode> stack = new Stack<>(); while(root != null || !stack.isEmpty()){//只要当前节点不为空(即当前节点的左右子树没有访问完毕)或者栈中还有节点(还有节点没有访问) //只要还有左子树 while(root != null){ stack.push(root);//根节点入栈 root = root.left;//访问左子树 } root = stack.pop();//取出左子树的根节点 System.out.println(root.val);//打印根节点 root = root.right;//访问右子树 } \",\"后序遍历\",\"跟前序遍历的两个方法类似。因为是左-右-根，所以再定义一个栈，先放入根，再放右，再放左。\",\"Stack<TreeNode> stack1 = new Stack<>(); Stack<TreeNode> stack2 = new Stack<>(); if(root == null) return list; while(!stack.empty()){ TreeNode node = stack1.pop(); //先放入根 stack2.push(node.val); //因为stack2得继续放入右，所以stack1得先放入左，再放入右 if(node.left != null) stack.push(node.left); if(node.right != null) stack.push(node.right); } \"]},\"909\":{\"h\":\"查找\"},\"910\":{\"h\":\"二分查找\"},\"911\":{\"h\":\"普通二分\",\"t\":[\"int binary_search(int[] nums, int target) { int left = 0, right = nums.length - 1; while(left <= right) { int mid = left + (right - left) / 2; if (nums[mid] < target) { left = mid + 1; } else if (nums[mid] > target) { right = mid - 1; } else if(nums[mid] == target) { // 直接返回 return mid; } } // 直接返回 return -1; } \"]},\"912\":{\"h\":\"搜索左边界\",\"t\":[\"循环过后的 left，是夹着 target 值的两个元素的右边元素的下标。也就是nums[left]>=target。\",\"可以这样想：搜索左边界，所以右边界，一直移到 target 左边才停止；搜索右边界同理。\",\"int left_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left <= right) { int mid = left + (right - left) / 2; if (nums[mid] < target) { left = mid + 1; } else if (nums[mid] > target) { right = mid - 1; } else if (nums[mid] == target) { // 别返回，右侧边界左移 right = mid - 1; } } // 最后要检查 left 越界的情况 if (left >= nums.length || nums[left] != target) return -1; return left; } \"]},\"913\":{\"h\":\"搜索右边界\",\"t\":[\"循环过后的 right，是夹着 target 值的两个元素的左边元素的下标。也就是nums[right]<=target。\",\"int right_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left <= right) { int mid = left + (right - left) / 2; if (nums[mid] < target) { left = mid + 1; } else if (nums[mid] > target) { right = mid - 1; } else if (nums[mid] == target) { // 别返回，左侧边界右移 left = mid + 1; } } // 最后要检查 right 越界的情况 if (right < 0 || nums[right] != target) return -1; return right; } \"]},\"914\":{\"h\":\"查找树\"},\"915\":{\"h\":\"二叉排序树\",\"t\":[\"又称二叉查找树。它或者是一颗空树，或者具有以下特点：\",\"若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值。\",\"若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值。\",\"它的左右子树也均是二叉排序树。\"]},\"916\":{\"h\":\"二叉平衡树（AVL 树）\",\"t\":[\"特点：\",\"它是一种高度平衡的二叉平衡树，其左右子树的高度最多相差 1。\",\"在插入、删除数据时通过左旋/右旋操作保持二叉树的平衡。\",\"查找的时间复杂度是 O(logn)，而插入删除也为 O(logn)。\",\"在作为数据库索引的数据结构时的弊端：\",\"一个结点存储一个元素，那么在元素非常多的时候，可能需要树的度和高度都非常大，这使得磁盘 IO 操作次数非常多（访问一次树的结点就是一次 IO，IO 的次数取决于树的高度）。为了打破一个结点只能存储一个元素的限制，引入了多路查找树的概念。\",\"AVL 树不支持查询范围的快速查找（只有 B+树才支持）。\"]},\"917\":{\"h\":\"多路查找树\"},\"918\":{\"h\":\"2-3 树/2-3-4 树\",\"t\":[\"特点：\",\"每个结点拥有 2 个孩子或 3 个孩子（或 4 个孩子）。\",\"一个 2 结点包含一个元素和两个孩子（或没有孩子），注意与二叉排序树不同，不能只有一个孩子。\",\"一个 3 结点包含一大一小两个元素和三个孩子（或没有孩子）。\",\"一个 4 结点包含大中小三个元素和四个孩子（或没有孩子）。\"]},\"919\":{\"h\":\"B 树\",\"t\":[\"概述：\",\"​ B 树是一种平衡的多路查找树，2-3 树、2-3-4 树都是 B 树的特例。结点最大的孩子数目称为 B 树的阶。\",\"m 阶的 B 树具有以下特点：\",\"每个结点的值（索引）都是按递增次序排序存放的，左小右大。\",\"如果根结点不是叶结点，那么其最少有两个子树。\",\"每个非根的分支结点（非根非叶）都有 k-1 个元素和 k 个孩子，其中 k 的范围为[Math.ceil(M/2)，M]。\",\"所有叶子都处于同一层。\",\"所有分支结点包含下列数据：（n,A0,K1,A1,K2...Kn,An）。其中 Ki 是关键字（值、索引），Ai 是指向子树的指针，且 Ai-1 指向的子树所包含的索引值均小于 Ki。n 是关键字 K 的个数，也就是第三条中的 k。\",\"为什么使用 B 树可以大幅减少 IO 次数呢？\",\"​ 假设要处理的数据很大，因此无法将 B 树一次全部装入内存。因此我们只需要调整 B 树，使其阶数与硬盘存储的页面大小相匹配。比如一棵 B 树的阶为 1001，也就是一个结点能够存放 1000 个关键字，高度为 3，那么它可以存储超过 10 亿个关键字。我们可以让根节点永久保留在内存中，那么查找某一个关键字的至多需要两次 IO 即可。\",\"​ 但是 B 树还是有缺陷的，假如说要找到 10 到 30 之间的元素个数，那么找到小于 15 的元素个数之后，还要从根结点继续查找。\"]},\"920\":{\"h\":\"B+树\",\"t\":[\"B 树和 B+树最主要的区别在于非叶子结点是否存储数据的问题。B+树特别适合带范围的查找。\",\"特点：\",\"B+树的非叶子结点不存储数据。\",\"出现在分支结点中的元素会被当做它们在该分支节点位置的中序后继者（叶子结点）中再次列出。所有分支结点包含的关键字可以看成索引，仅含有其子树中最大（或最小）的关键字。\",\"叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。\"]},\"921\":{\"h\":\"红黑树\",\"t\":[\"​ 解决二叉树多次插入新的节点导致不平衡的问题\",\"1.节点颜色有红色和黑色 【2-3 树到红黑树的转化已经解释过】\",\"2.根节点必为黑色 【2-3 树中如果根节点为 2 节点，那么它本来就对应红黑树中黑节点；如果根节点为 3 节点，也可以用黑色节点表示较大的那个元素，然后较小的元素作为左倾红节点存在于红黑树中】\",\"3.所有叶子节点都是黑色 【此处提到的叶子其实是空链接 null】\",\"4.任意节点到叶子节点经过的黑色节点数目相同\",\"【红黑树中的红节点是和黑色父节点绑定的，在 2-3 树中本来就是同一层的，只有黑色节点才会在 2-3 树中真正贡献高度，由于 2-3 树的任一节点到空链接距离相同，因此反应在红黑树中就是黑色完美平衡】\",\"5.不会有连续的红色节点 2-3 树中本来就规定没有 4 节点，2-3-4 树中虽然有 4 节点，但是要求在红黑树中体现为一黑色节点带两红色儿子，分布左右，所以也不会有连续红节点\"]},\"922\":{\"h\":\"哈希表查找\",\"t\":[\"概述：\",\"散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每一个关键字 key 对应一个存储位置 f（key）。\",\"对应关系 f 称为散列函数，又称哈希函数。\",\"采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表（哈希表）。\",\"步骤：\",\"在存储时，通过散列函数计算记录的散列地址，并按此地址存储该记录。\",\"在查找时，同样通过计算的散列地址，找到该记录。\",\"特点：\",\"散列技术最适合的求解问题是查找与给定值相等的记录，省的比较了。\",\"设计一个简单、均匀、存储利用率高、冲突少的散列函数极为重要。\"]},\"923\":{\"h\":\"散列函数的构造方法\",\"t\":[\"直接定址法：也就是取关键字的某个线性值作为地址，需要事先知道关键字的分布情况，用的很少。\",\"数字分析法：抽取关键字的一部分来做某些运算，适合关键字位数很多的情况（比如手机号）。\",\"平方取中法：对关键字平方再取中间几位作为地址，适合不知道关键字的分布，而位数比较少的情况。\",\"折叠法：将关键字分割再做相加等处理。\",\"除留余数法：（最常用的方法）对于散列表长为 m 的散列函数公式：f(key)=key mod p(p≤m)当然，还可以对关键字折叠、平方之类的操作之后再取模。\",\"随机数法：f(key)=random(key)适合关键字长度不等的情况。\"]},\"924\":{\"h\":\"处理散列冲突的方法\",\"t\":[\"再散列函数法：事先准备多个散列函数，每当发生散列地址冲突时，就换一个散列函数。\",\"链地址法：将所有关键字为同义词的记录存储在一个单链表中，不过也带来了查找时遍历单链表的损耗。\",\"公共溢出区法：将所有冲突的元素放在一个公共溢出区。\",\"开放地址法：一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，总能找到空的散列地址。\"]},\"925\":{\"h\":\"散列表查找的性能分析\",\"t\":[\"散列函数是否均匀。\",\"处理冲突的方法。\",\"散列表的装填因子。（装填因子 α=填入表的记录个数/散列表的长度）\"]},\"926\":{\"h\":\"链表\"},\"927\":{\"h\":\"找单向链表的倒数第 k 个结点\",\"t\":[\"​ 由于单链表不知道其长度 n，如果用 for 循环 n-k 个节点找的话，需要先遍历链表一次确定长度 n，因此需要遍历两次，不太行。\",\"​ 解法：使用双指针，p1，p2 都指向头结点，先让 p1 走 k 步，然后 p1，p2 同时走，直到 p1 走到链表尾的 null 此时 p2 的位置就是倒数第 k 个节点。\"]},\"928\":{\"h\":\"常见数据结构的时间复杂度\"},\"929\":{\"h\":\"排序\"},\"930\":{\"h\":\"冒泡排序(N^2)\",\"t\":[\"时间复杂度 O(N^2)，额外空间复杂度 O(1)，实现可以做到稳定性。第一次遍历 N,第二次 N-1，第三次 N-2，最后 1，共[N+(N-1)+(N-2)+(N-3)+.....+1]\",\"基本思想：通过对待排序序列从前向后（从下标较小的元素开始） ,依次比较相邻元素的值， 若发现逆序则交换。一共进行数组的个数-1 次排序。每次把最大的值交换到后面。\",\"优化：如果一趟比较下来没有进行过交换， 就说明序列有序， 因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换。\",\"public static void bubbleSort(int[] arr){ if(arr == null || arr.length<2){ return; } //用来优化的标志，如果在这一趟排序中，若flag最后仍为FALSE，则说明已经有序 boolean flag = false; int temp = 0; //临时变量，用来交换 //一共进行arr.length-1次大的循环 for(int i = 0 ; i < arr.length - 1; i ++){ for(int j = 0; j < arr.length -1- i; j++){ if(arr[j] > arr[j+1]) { flag = true; //发生了交换就将flag赋为true temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } if(!flag){ // 在一趟排序中， 一次交换都没有发生过，排序已经完成 break; }else{ flag = false; } } } \"]},\"931\":{\"h\":\"选择排序(N^2)\",\"t\":[\"时间复杂度 O(N^2)， 额外空间复杂度 O(1)， 不可以做到稳定性\",\"基本思想：第一次从 arr[0]~arr[n-1] 中选取最小值，与 arr[0]交换， 第二次从 arr[1]~arr[n-1]中选取最小值， 与 arr[1]交换， 第三次从 arr[2]~arr[n-1]中选取最小值， 与 arr[2]交换， …， 第 i 次从 arr[i-1]~arr[n-1]中选取最小值， 与 arr[i-1]交换， …, 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值，与 arr[n-2]交换， 总共通过 n-1 次， 得到一个按排序码从小到大排列的有序序列。每次把最小的值交换到前面\",\"public static void selectSort(int[] arr){ for(int i = 0; i < arr.length-1; i ++){ int minIndex = i; //将i作为当前的最小值 for(int j = i+1; j < arr.length; j ++){ minIndex = arr[minIndex] > arr[j] ? j:minIndex; } swap(arr,i,minIndex); } } public static void swap(int[] arr, int i, int j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } \"]},\"932\":{\"h\":\"插入排序(N^2)\",\"t\":[\"时间复杂度 O(N^2)， 额外空间复杂度 O(1)， 实现可以做到稳定性 ，最好 O(N)\",\"**基本思想：**把 n 个待排序的元素看成为一个有序表和一个无序表， 开始时有序表中只包含一个元素， 无序表中包含有 n-1 个元素， 排序过程中每次从无序表中取出第一个元素， 把它的排序码依次与有序表元素的排序码进行比较， 将它插入到有序表中的适当位置， 使之成为新的有序表。\",\"public static void insertSort(int[] arr){ if(arr == null || arr.length < 2){ return; } //从第1个数与第0个数的对比开始 for(int i = 1; i < arr.length; i ++){ for(int j = i - 1; j >= 0; j --){ //比较当前的数和它后面的数的大小，前面已经排好序了 if(arr[j] > arr[j+1]){ swap(arr,j,j+1); } } } } public static void swap(int[] arr, int i, int j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } \"]},\"933\":{\"h\":\"希尔排序(O < N^2)\",\"t\":[\"是插入排序的改进版本，是第一批时间复杂度突破 O(N^2) 的算法。将原本大量记录数的记录进行分组，分割成若干个子序列，然后对这些子序列内分别进行插入排序，当整个序列基本有序时，再对全体记录进行一次直接插入排序。\",\"public class ShellSort { //核心代码---开始 public static void sort(Comparable[] arr) { int j; for (int gap = arr.length / 2; gap > 0; gap /= 2) { for (int i = gap; i < arr.length; i++) { Comparable tmp = arr[i]; for (j = i; j >= gap && tmp.compareTo(arr[j - gap]) < 0; j -= gap) { arr[j] = arr[j - gap]; } arr[j] = tmp; } } } } \",\"class Solution { public void shellsort(int[] arr) { for (int gap = arr.length / 2; gap > 0; gap /= 2) for (int i = gap; i < arr.length; i++) { for (int j = i; j >= gap; j -= gap) { if (arr[j] < arr[j - gap]) { swap(arr, j, j - gap); } else { break; } } } //交换 } public void swap(int[] nums, int i, int j) { int tem = nums[i]; nums[i] = nums[j]; nums[j] = tem; return; } } \"]},\"934\":{\"h\":\"归并排序/分治(N*logN)\",\"t\":[\"时间复杂度 O(N*logN)， 额外空间复杂度 O(N)， 实现可以做到稳定性。递归实际利用的是栈结构。\",\"public static void mergeSort(int[] arr){ if(arr == null || arr.length < 2){ return; } sortProcess(arr, 0, arr.length-1); } /** * 排序的过程（分 + 治） * @param arr 要排序的数组 * @param l 左边的索引 * @param r 右边的索引 */ public static void sortProcess(int[] arr, int l , int r) { if (l == r) { //递归结束的条件(base case) //说明此时待排序的数组中只有一个数 return; } int mid = l + ((r - l) >> 1); sortProcess(arr, l, mid); //对左半部分排序 sortProcess(arr, mid + 1, r); //对右半部分排序 merge(arr, l, mid, r); //合并相邻的有序子序列 } /** * 合并相邻的有序序列 * @param arr * @param l * @param mid * @param r */ public static void merge(int arr[], int l, int mid, int r){ int[] helper = new int[r - l + 1]; //辅助数组，用来暂存合并后的有序数据 int i = 0; //指示helper中第一个为空的位置，即下一个元素要插入的位置 int p1 = l; //指向左半部分的第一个元素 int p2 = mid + 1; //指向右半部分的第一个元素 //当两个指针都不越界时 //越界指当p1指向了右半部分或者当p2大于r之后 while(p1 <= mid && p2 <= r){ helper[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++]; } //当p1越界，将右半部分数组的剩余部分复制到helper while(p2 <= r){ helper[i++] = arr[p2++]; } //当p2越界，将左半部分数组的剩余部分复制到helper while(p1 <= mid){ helper[i++] = arr[p1++]; } //将helper中元素复制到arr中的对应位置 for(int j = 0; j < helper.length; j ++){ arr[l+j] = helper[j]; } } \"]},\"935\":{\"h\":\"快速排序(N*logN)\",\"t\":[\"相当于冒泡排序的升级，同属交换排序类。\",\"基本思想：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。\",\"快排的最坏情况为：\",\"​ 待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，另一个为空。\",\"class Solution { public int[] sortArray(int[] nums) { sort(nums,0, nums.length-1); return nums; } public void sort(int[] array,int left,int right) { if (left>=right)return; int base=(int)(Math.random()*(right-left+1))+left; int i = left; int j = right; while (i<j){ while (base<j&&array[j]>=array[base]){ j--; } swap(array,j,base); base = j; while (base>i&&array[i]<=array[base]){ i++; } swap(array,i,base); base = i; } sort(array, left, base-1); sort(array, base+1, right); return; } public void swap(int[] array,int left,int right) { int tmp = array[left]; array[left]= array[right]; array[right]=tmp; return; } } \",\"public class QuickSort { public static void quickSort(int[] arr,int low,int high){ int i,j,temp,t; if(low>high){ return; } i=low; j=high; //temp就是基准位 temp = arr[low]; while (i<j) { //先看右边，依次往左递减 while (temp<=arr[j]&&i<j) { j--; } //再看左边，依次往右递增 while (temp>=arr[i]&&i<j) { i++; } //如果满足条件则交换 if (i<j) { t = arr[j]; arr[j] = arr[i]; arr[i] = t; } } //最后将基准为与i和j相等位置的数字交换 arr[low] = arr[i]; arr[i] = temp; //递归调用左半数组 quickSort(arr, low, j-1); //递归调用右半数组 quickSort(arr, j+1, high); } public static void main(String[] args){ int[] arr = {10,7,2,4,7,62,3,4,2,1,8,9,19}; quickSort(arr, 0, arr.length-1); for (int i = 0; i < arr.length; i++) { System.out.println(arr[i]); } } } \",\"public void quickSort (int[] nums, int low, int high) { if(low >= high) return; int povit = Partition(nums, low, high); quickSort(nums, low, povit - 1); quickSort(nums, povit + 1, high); } public int Partition (int[] nums, int low, int high) { int m = low + (high - low) / 2; int temp; //将nums[low]三数取其中 if (nums[low] > nums[high]) { temp = nums[low]; nums[low] = nums[high]; nums[high] = temp; } if (nums[m] > nums[high]) { temp = nums[m]; nums[m] = nums[high]; nums[high] = temp; } if (nums[m] > nums[low]) { temp = nums[m]; nums[m] = nums[low]; nums[low] = temp; } //将nums[low]的值先存到povit中，采取赋值方法（而非交换） int povit = nums[low]; while (low < high) { while (low < high && nums[high] >= povit) high--; nums[low] = nums[high]; while (low < high && nums[low] <= povit) low++; nums[high] = nums[low]; } nums[low] = povit;//此时low=high return low; } \"]},\"936\":{\"h\":\"寻找第 k 大的数（基于快速排序）\",\"t\":[\"public int findKthLargest(int[] nums, int k) { myQuickSort(nums,k,0,nums.length-1); return nums[nums.length-k]; } public void myQuickSort(int[] nums,int k,int low,int high){ int len=nums.length; if(low>=high) return; int povit=Partition(nums,low,high); //主要是增加判断，减少不必要的排序 if(povit==len-k) return; else if(povit<len-k) myQuickSort(nums,k,povit+1,high); else myQuickSort(nums,k,low,povit-1); } public int Partition(int[] nums,int low,int high){ int m=low+(high-low)/2; int temp; //将nums[low]三数取其中 if(nums[low]>nums[high]){ temp=nums[low]; nums[low]=nums[high]; nums[high]=temp; } if(nums[m]>nums[high]){ temp=nums[m]; nums[m]=nums[high]; nums[high]=temp; } if(nums[m]>nums[low]){ temp=nums[m]; nums[m]=nums[low]; nums[low]=temp; } int povit=nums[low]; while(low<high){ while(low<high&&nums[high]>=povit) high--; nums[low]=nums[high]; while(low<high&&nums[low]<=povit) low++; nums[high]=nums[low]; } nums[low]=povit; return low; } \"]},\"937\":{\"h\":\"堆排序(N*logN)\",\"t\":[\"​ 相当于简单选择排序的升级，时间复杂度 O(NlogN)， 额外空间复杂度 O(NlogN)， 不可以做到稳定性 。建立大顶堆是 O(N），二叉树的高度是 O(logN)，每次调整的最大次数是 O(logN)。\",\"堆结构：完全二叉树。位置 i 的左孩子的下标是 2i+1，右孩子的下标是 2i+2，父节点的下标(i-1)/2。\",\"每个结点的值都大于或等于其左右孩子结点的值， 称为大顶堆。注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。\",\"建立大顶堆的过程：\",\"heapInsert: 分别比较数组中的元素和父节点的大小，若大于父节点的大小，则交换顺序，i 的父节点是(i-1)/2\",\"heapFy: 父节点和两个孩子中较大的比较，若小于孩子中较大的，就和孩子交换\",\"public static void heapSort(int[] arr){ if (arr == null || arr.length < 2) { return; } //构造出最初的大顶堆 for (int i = 0; i < arr.length; i++) { heapInsert(arr, i); } //将最大值和堆中的最后一个元素交换 int size = arr.length; swap(arr, 0, --size); while (size > 0) { //将剩下的前size个元素构成大顶堆 heapify(arr, 0, size); //将最大值和堆中的最后一个元素交换 swap(arr, 0, --size); } } //将arr[index]放到合适的位置 public static void heapInsert(int[] arr, int index){ while(arr[index] > arr[(index - 1) / 2]){ //如果当前数大于父节点，则当前数和当前父节点交换 swap(arr,index,(index - 1) / 2); index = (index - 1) / 2; //让index指向交换后的位置，继续查看和交换后父节点的关系 } } //将剩下的size个元素重新调整成大顶堆 public static void heapify(int[] arr, int index, int size) { int left = 2*index + 1; //左孩子的位置 while(left < size) { //找出左右子节点中最大的值 int largest = (left + 1) < size && arr[left + 1] > arr[left] ? (left + 1) : left; ////找出父节点和孩子之间的最大值 largest = arr[index] > arr[largest] ? index : largest; if (largest == index) { break; } //让父节点和最大的值进行交换 swap(arr, index, largest); index = largest; left = 2 * index + 1; } } public static void swap(int[] arr, int i, int j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } \"]},\"938\":{\"h\":\"Arrays.sort()\",\"t\":[\"​ 当 size<60，使用插入排序，当 size>60 时，使用归并或者快速排序，其中基础类型用 quick，class 等对象类型。默认用 merge 进行，因为基础排序不在乎稳定性，只要求快，merge 是稳定的。\",\"// [[5,4],[6,4],[2,3]] // 按照第一列从小到大排列，第二列从大到小 Arrays.sort(envelopes, new Comparator<Integer>() { public int compare(int[] interval1, int[] interval2) { return interval1[0] == interval2[0] ? interval2[1] - interval1[1] : interval1[0] - interval2[0]; } }); \"]},\"939\":{\"h\":\"栈、队列\"},\"940\":{\"h\":\"栈\",\"t\":[\"​ 栈：一种特殊的线性表，其只允许在固定的一端插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出 LIFO (Last In First Out) 的原则；\"]},\"941\":{\"h\":\"队列\",\"t\":[\"​ 相比栈，队列的特性和栈是相反的。它只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出 FIFO (First In First Out) 的特性。入队列：进行插入操作的一端称为队尾；出队列：进行删除操作的一端称为队头，对于队列来说，一种入队顺序，只有一种出队顺序。\"]},\"942\":{\"h\":\"栈和队列的应用场景\",\"t\":[\"​ 栈：当问题关心最近一次的操作，而且需要在 O（1）的时间内查找到更前的一次操作时使用栈。\",\"​ 队列：当需要按照一定的顺序来处理数据，且数据的数据量在不断的变化的时候，例如排队问题，排在对头的先处理。\"]},\"943\":{\"h\":\"位运算符\",\"t\":[\"运算符\",\"意义\",\"&\",\"按位与\",\"|\",\"按位或\",\"~\",\"按位非\",\"^\",\"按位异或：不同为 1，相同为 0\",\"<<\",\"左移：左移 n 位相当于乘以 2 的 n 次方\",\">>\",\"右移：右移 n 位相当于除以 2 的 n 次方\",\"<<<\",\"无符号右移：与 右移>> 的区别就是无论操作数是正数还是负数，高位都是补 0\"]},\"944\":{\"h\":\"左移<< 和 右移 >>\"},\"945\":{\"h\":\"位运算的常见使用\"},\"946\":{\"h\":\"1.判断一个数的奇偶性\",\"t\":[\"n & 1 == 1 //奇数，奇数的二进制的最后一位肯定是1 n & 1 == 0 //偶数，偶数的二进制的最后一位肯定是0 \"]},\"947\":{\"h\":\"2.交换两个数\",\"t\":[\"int a = 3; int b = 4; a = a ^ b; b = b ^ a; // b = b ^ (a ^ b) --> b = a a = a ^ b; // a = (a ^ b) ^ (b ^ (a ^ b)) -- > a = b \",\"上面的计算主要遵循了一个计算公式\",\"b ^ (a ^ b) = a \"]},\"948\":{\"h\":\"3.n&(n-1)\",\"t\":[\"等于 n 去掉末尾的那个 0，也就是说当n&(n-1) == 0时，n 必为 2 的次幂。\"]},\"949\":{\"h\":\"4.快速幂\",\"t\":[\"public double myPow(double x, int n) { if(n==0) return 1; double res = 1; long a = n; long b = Math.abs(a); while(b>0){ //当末位是1时，乘进res if((b&1) == 1) res = res*x; x *= x; b >>>= 1; //去掉最后一位 } if(n<0) return 1/res; return res; } \"]},\"950\":{\"h\":\"ACM 模式代码\"},\"951\":{\"h\":\"多行输入\",\"t\":[\"输入： 5 10 9 0 5 9 1 8 1 0 1 9 100 输出： 43 \",\"import java.util.Arrays; import java.util.Scanner; public class MUltilineInput { public static void main(String[] args) { //Scanner类默认的分隔符就是空格 Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int full = sc.nextInt(); int avg=sc.nextInt(); int[][] nums=new int[n][2]; for(int i=0;i<n;i++){ nums[i][0]=sc.nextInt(); nums[i][1]=sc.nextInt(); } //核心代码 ... //输出答案 System.out.println(...); } } } \"]},\"952\":{\"h\":\"一次读取一行数据\",\"t\":[\"输入： 1 2 3 4 5 6 7 8 输出： 10 26 \",\"import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { //以字符串的形式，读取一行数据 String str = sc.nextLine(); String [] strs = str.split(\\\" \\\"); int res = 0; for(String s : strs){ res += Integer.parseInt(s); } System.out.println(res); } return; } } \"]},\"953\":{\"h\":\"一维数组输入\",\"t\":[\"输入例子: 7 15 15 5 3 7 9 14 0 输出例子: //保留两位小数 2.50 \",\"import java.util.Arrays; import java.util.Scanner; public class ArrayInput { public static void main(String[] args){ Scanner sc = new Scanner(System.in); while (sc.hasNext()){ int n = sc.nextInt(); //存入第一个行第1个数 long l = sc.nextLong(); //存入第一个行第2个数 long[] nums = new long[n]; //将第2行的数存入数组 for (int i = 0; i < n; i++){ nums[i] = sc.nextLong(); } //核心代码 ... //输出答案，保留两位小数 System.out.println(String.format(\\\"%.2f\\\",gap/2.0)); } } \"]},\"954\":{\"h\":\"二维数组输入\",\"t\":[\"如果要求的测试用例需要读取二维数组，我们应该先读取二维数组的长度和宽度存在两个整数中。在下一行将一串整型数字存入二维数组中。\",\"注意：为了换行读取可以使用nextLine()跳过换行。\",\"Scanner sc = new Scanner(System.in); while(sc.hasNext()) { int r = sc.nextInt(); //读取行 int c = sc.nextInt(); //读取列 int[][] matrix = new int[r][c]; sc.nextLine(); // 跳过行数和列数后的换行符 for(int i=0;i<r;i++) { for (int j = 0; j < c; j++) { matrix[i][j] = sc.nextInt(); } } //核心代码 ... } \"]},\"955\":{\"h\":\"链表输入\",\"t\":[\"//以反转链表为例 //输入是一串数字，请将其转换成单链表格式之后，再进行操作。 //输入描述: 一串数字，用逗号分隔 //输入实例: 1,2,3,4,5 import java.util.Scanner; import java.util.Stack; public class LinkListInput { //先构建一个节点类，用于链表构建 static class LinkNode { int val; LinkNode next; public LinkNode(int val){ this.val = val; } } public static void main(String[] args){ Scanner scanner = new Scanner(System.in); //以字符串形式作为输入 String str = scanner.next().toString(); //通过分隔符将其转为字符串数组 String[] arr = str.split(\\\",\\\"); //初始化一个整数数组 int[] ints = new int[arr.length]; //给整数数组赋值 for(int j = 0; j < ints.length; j++) { ints[j] = Integer.parseInt(arr[j]); } //创建头节点 LinkNode head = new LinkNode(0); //初始化链表 LinkNode p = head; for(int i = 0; i < ints.length; i++){ p.next = new LinkNode(ints[i]); p = p.next; } //核心代码 ... //打印答案 //输出： 1,5,2,4,3 while (head != null) { if(head.next == null){ System.out.print(head.val); }else{ System.out.print(head.val + \\\",\\\"); } head = head.next; } } } \"]},\"956\":{\"h\":\"树的输入\",\"t\":[\"import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Stack; //以判断是否是二叉搜索树为例 //给定一个二叉树，判断其是否是一个有效的二叉搜索树。 //输入： // 5 // / \\\\ // 1 3 // / \\\\ // 4 6 //输出: false //构造树需要的结点类 class TreeNode { TreeNode left, right; int val; public TreeNode(int val) { this.val = val; } } public class TreeInput { // 根据数组构造二叉树，输入格式： [5,1,3,null,null,4,6] public TreeNode constructBinaryTree(int[] vec) { TreeNode[] vecTree = new TreeNode[vec.length]; TreeNode root = null; for (int i = 0; i < vec.length; i++) { TreeNode node = null; if (vec[i] != -1) node = new TreeNode(vec[i]); vecTree[i] = node; if (i == 0) root = node; } for (int i = 0; i * 2 + 2 < vec.size(); i++) { if (vecTree[i] != NULL) { vecTree[i]->left = vecTree[i * 2 + 1]; vecTree[i]->right = vecTree[i * 2 + 2]; } } return root; } public static void main(String[] args) throws IOException { //核心代码 ... } } \"]},\"957\":{\"h\":\"hashmap 抛出第一个 key\",\"t\":[\"map.keySet().iterator().next() \"]},\"958\":{\"h\":\"计算机网络\"},\"959\":{\"h\":\"在浏览器中输入 URL 地址到显示主页的过程？\",\"t\":[\"DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址；\",\"ARP协议：从 IP 地址，解析出硬件地址。\",\"TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；\",\"发送 HTTP 请求：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求；如果是HTTPs连接的话，看HTTPs的工作原理。\",\"服务器处理请求并返回 HTTP 报文。具体是服务器接收到这个请求，根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；\",\"浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。\",\"连接结束。\",\"Tomcat层面：\",\"​ 一个http请求到来，容器将请求封装为Servlet中的HttpServletRequest对象，调用init()方法，service()方法输出response，由容器包装为httpresponse返回给客户端。\"]},\"960\":{\"h\":\"互联网的组成\",\"t\":[\"边缘部分\",\"由所有连接在互联网上的主机组成，这部分是用户直接使用的。这些主机又称为端系统。\",\"按照通信方式可分为：客户-服务器方式（C/S方式）和对等方式（P2P方式）。\",\"核心部分\",\"由大量网络和连接这些网络的路由器组成，为边缘部分提供服务。\",\"在网络核心部分起特殊作用的是路由器，是一种专用计算器。\",\"路由器（网络层）是实现分组交换的关键，其任务是转发收到的分组，也就是把数据（IP报文）传送到正确的网络。\",\"分组交换\",\"分组交换采用存储转发技术。\",\"需要发送的整块数据称为一个报文。\",\"把一个报文划分成几个分组，再加上一些控制信息组成的首部，就构成了一个分组。分组又称为包，首部又称为包头。\"]},\"961\":{\"h\":\"五（七）层协议的体系结构\",\"t\":[\"五层协议：\",\"1、应用层\",\"是体系结构的最高层。\",\"是通过应用进程间的交互来完成特定的网络应用。\",\"其定义的是应用进程间通信和交互的规则。\",\"2、运输层（包括两种协议）\",\"任务是负责向两台主机中进程之间的通信提供通用的数据传输服务。\",\"传输控制协议TCP：提供面向连接、可靠的数据传输服务，其数据传输的单位是报文段。\",\"用户数据报协议UDP：提供无连接的、尽最大努力的数据传输服务，（不能保证数据传输的可靠性），其数据传输的单位是用户数据报。\",\"​ 传输层可能⼤家刚接触的时候，会认为它负责将数据从⼀个设备传输到另⼀个设备，事实上它并不负责 实际场景中的⽹络环节是错综复杂的，中间有各种各样的线路和分叉路⼝，如果⼀个设备的数据要传输给另⼀个设备，就需要在各种各样的路径和节点进⾏选择，⽽传输层的设计理念是简单、⾼效、专注，如果传输层还负责这⼀块功能就有点违背设计原则了。\",\"3、网络层\",\"​ ⽹络层负责将数据从⼀个设备传输到另⼀个设备，通过IP地址这个设备的编号，进行寻址和路由将数据从一个设备传输到另一个设备。\",\"负责不同主机间的通信服务。\",\"发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。\",\"在TCP/IP协议中，分组也叫作IP数据报。\",\"互联网是由大量异构网络通过路由器相互连接起来的。\",\"异构网络：如果一个网络中包含不同的操作系统或者不同的网络架构，那么称这个网络为异构网络。\",\"​ IP 协议的寻址作⽤是告诉我们去往下⼀个⽬的地该朝哪个⽅向⾛，路由则是根据「下⼀个⽬的地」选择路径。寻址更像在导航，路由更像在操作⽅向盘。\",\"4、数据链路层\",\"数据层将网络层交下来的IP数据报组装成帧，在两个相邻节点间的链路上传送帧。\",\"每一帧包括数据和必要的控制信息。\",\"控制信息还使接收端能够检测到所收到的帧中有无差错。如有差错，丢弃帧；如需改正数据，就要采用可靠传输协议来纠正出现的差错。\",\"上面那一条也说明，数据链路层不仅要检错，而且要纠错。\",\"那问题来了，路由器怎么知道这个 IP 地址是哪个设备的呢？ 于是，就需要有⼀个专⻔的层来标识⽹络中的设备，让数据在⼀个链路中传输，这就是数据链路层（Data LinkLayer），它主要为⽹络层提供链路级别传输的服务。 每⼀台设备的⽹卡都会有⼀个 MAC 地址，它就是⽤来唯⼀标识设备的。路由器计算出了下⼀个⽬的地 IP 地址，再通过 ARP 协议找到该⽬的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。\",\"5、物理层\",\"在物理层上所传数据的单位是比特。\",\"七层协议\",\"OSI七层参考模型\",\"说明\",\"应用层\",\"可以和用户交互，能产生网络流量的应用程序，如：QQ、浏览器等\",\"表示层\",\"负责数据格式转换，将应用处理的信息转换为适合网络传输的格式，或将下一层数据转换成上一层能处理的消息\",\"会话层\",\"建立及管理会话\",\"传输层\",\"提供可靠传输、不可靠传输、流量控制，分割与重组数据，能够错误纠正，失败重传\",\"网络层\",\"负责选择最佳路径，规划IP地址\",\"数据链路层\",\"将数据包封装成帧，透明传输，差错校验，只检错不纠错，发送数据有错误就丢弃\",\"物理层\",\"负责网络通信的二进制比特流传输\"]},\"962\":{\"h\":\"每一层对应的网络协议有哪些？\",\"t\":[\"层级\",\"网络协议\",\"应用层\",\"HTTP、文件传输协议FTP、域名系统DNS、安全外壳协议SSH、动态主机配置协议DHCP\",\"传输层\",\"TCP、UDP\",\"网络层\",\"网际协议IP、地址解析协议ARP、网际控制报文协议ICMP\",\"数据链路层\",\"自动重传请求协议ARQ、点对点协议PPP\",\"物理层\",\"中继器、集线器、网线\"]},\"963\":{\"h\":\"数据传递过程\",\"t\":[\"对等层：因为上图的复杂过程对用户屏蔽，所以觉得进程AP1直接把数据交给了AP2。对于任何两个相同的层次，也好像如同上图虚线一样传递给了对方，这就是所谓对等层之间的通信。\",\"协议栈：因为这几个层次画在一起很像一个栈结构。\",\"协议数据单元PDU：OSI把对等层之间传送的数据单位称为该层的协议数据单元PDU。\"]},\"964\":{\"h\":\"TCP/IP的体系结构\",\"t\":[\"​ TCP/IP,是包含了一系列构成互联网基础的网络协议，是Internet的核心协议，基于TCP/IP的参考模型将协议分成四个层次，分别是链路层(网络接口层)、网络层、传输层和应用层。\",\"​ TCP/IP协议族按照层次由上到下，层层包装。最上面是应用层，第二层是传输层有TCP和UDP协议，第三层是网络层，ip协议就在这里，它负责对数据加上ip地址和其他数据以及确定传输的目标。第四层是数据链路层，为待传送的数据加一个以太网协议头为最后的数据传输做准备。\",\"沙漏计时器形状的TCP/IP协议族示意\",\"可以看到：\",\"TCP/IP协议可以为各式各样的应用提供服务（所谓everything over IP）。\",\"TCP/IP协议允许IP协议在各式各样的网络构成的互联网上运行（所谓IP over everything）。\"]},\"965\":{\"h\":\"各层中间设备的名称\",\"t\":[\"将网络互联起来要使用一些中间设备。有以下四种不同的中间设备：\",\"物理层使用的中间设备叫做转发器。\",\"数据链路层使用的中间设备叫做交换机。\",\"网络层使用的中间设备叫做路由器。\",\"网络层以上使用的中间设备叫做网关。用网关连接两个不兼容系统需要在高层进行协议的转换。由于比较复杂，目前用的比较少。有时把路由器也称为网关。\",\"虽然没有一种单一网络能够适应所有用户的需求，但是我们可以利用IP协议使这个网络在网络层看起来好像是一个统一的网络。\"]},\"966\":{\"h\":\"基本概念\",\"t\":[\"考虑的是怎么才能在连接各种计算机的传输媒体上传输数据比特流。\",\"可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，比如：机械特性（接线器的形状、尺寸），电器特性（接口电缆上电压的范围），功能特性（某条线上电压的意义）......\",\"作用\",\"尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据连接层感觉不到这些差异，这样就可以让数据链路层只需要考虑如何完成本层的协议和服务。\",\"通信方式分类\",\"单向通信，又称为单工通信。\",\"双向交替通信，又称为半双工通信。\",\"双向同时通信，又称为全双工通信。\"]},\"967\":{\"h\":\"信道复用技术\",\"t\":[\"频分复用FDM\",\"所有用户在同样的时间占用不同的带宽资源。\",\"时分复用TDM\",\"所有用户在不同的时间占用同样的频带宽度。\",\"统计时分复用STDM\",\"是一种改进的时分复用，集中器常使用这个统计时分复用。\",\"STDM帧不是固定分配时隙，而是按需动态地分配时隙。\",\"统计复用又称为异步时分复用。\",\"波分复用WDM\",\"就是光的频分复用。\",\"现在已经能做到在一根光纤上复用几十路或更多路数的光载波信号，称为密集波分复用。\",\"码分复用CDM\",\"也称为码分多址CDMA。\"]},\"968\":{\"h\":\"宽带接入技术\",\"t\":[\"1、ADSL技术\",\"非对称数字用户线ADSL技术对现有的模拟电话用户线进行改造，使其能够承载宽带数字业务。\",\"2、光纤同轴混合网（HFC网）\",\"是在目前覆盖面很广的有线电视网的基础上开发的一种居民宽带接入网。\",\"3、FTTx技术\",\"光纤到户FTTH。\",\"为了有效地利用光纤资源，在光纤干线和用户之间广泛使用无源光网络PON。\",\"数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。\",\"数据链路层主要属于计算机网络的低层，使用的信道主要有以下两种类型：\",\"点对点信道：使用一对一的点对点通信方式。\",\"广播信道：使用一对多的广播通信方式。\"]},\"969\":{\"h\":\"CRC校验\",\"t\":[\"​\"]},\"970\":{\"h\":\"使用点对点信道的数据链路层\"},\"971\":{\"h\":\"数据链路和帧\",\"t\":[\"数据链路：在一条线路上传输数据时，除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。现在常使用网络适配器来实现这些协议。\",\"帧：点对点信道的数据链路层的协议数据单元。\"]},\"972\":{\"h\":\"封装成帧\",\"t\":[\"封装成帧就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。\",\"首部和尾部的一个重要作用就是帧定界。此外，还有很多必要的控制信息。\",\"每一种链路层协议都规定了所能传送的帧的数据部分长度上限——最大传送单元MTU(Maximum Transfer Unit)。\",\"当数据是有ASCII码组成的文本文件时，帧定界可以使用特殊的帧定界符。\"]},\"973\":{\"h\":\"透明传输\",\"t\":[\"​ 不管传输什么样的比特组合，这样的传输就是透明传输。当数据中存在与帧结束符相同的数据，就必须采取适当措施来处理，否则计算机会误认为该数据就是帧结束符，造成数据接收不完整。\",\"字节填充法：在发送端，在一串比特流尚未加上SOH、EOT时，先用硬件扫描整个帧，在控制字符前插入转义字符 \\\"ESC\\\"，接收端将数据送往网络层前删除插入的转义字符。\",\"零比特填充法：在发送端，在一串比特流尚未加上帧头帧尾时，先用硬件扫描整个帧，只要发现 5 个连续 1，则立即填入一个 0；在接收一个帧时，先找到帧尾以确定帧的边界，接着再用硬件对其中的比特流进行扫描，每当发现 5 个连续 1 时，就将这 5 个连续 1 后的一个 0 删除，以还原成原来的比特流。\"]},\"974\":{\"h\":\"差错检测\",\"t\":[\"1变0,0变1，称为比特差错。一段时间内，传输错误的比特占所有传输比特总数的比例称为误码率BER。\",\"目前广泛使用了循环冗余检验CRC的检错技术。其原理是在数据后面添加供差错监测用的冗余码。这种冗余码成为帧检验序列FCS。\",\"现在的通信网络采用区别对待： \",\"对于通信质量较好的有线链路，不使用确认和重传机制，即不要求数据链路层向上提供可靠的传输服务；\",\"对于通知质量较差的无线传输链路，使用确认和重传机制，数据链路层向上提供可靠的传输服务。\"]},\"975\":{\"h\":\"点对点协议PPP\",\"t\":[\"PPP协议是用户计算机与ISP进行通信时所使用的的数据链路层协议。\",\"PPP协议应满足的要求\",\"简单\",\"封装成帧\",\"透明性\",\"多种网络层协议：必须能够在同一条物理链路上同时支持多种网络层协议。\",\"多种类型链路\",\"差错检测\",\"检测连接状态\",\"最大传送单元\",\"网络层地址协商：必须使通信的两个网络层的实体能够通过协商知道或能够配置彼此的网络层协议。\",\"数据压缩协商\",\"需要注意，在TCP/IP协议族中，可靠传输由运输层的TCP协议负责，因此数据链路层的PPP协议不需要进行纠错，不需要设置序号，也不需要进行流量控制。PPP协议不支持多点线路(即一个主站轮流和链路上的多个从站进行通信)，而只支持点对点的链路通信。此外，PPP协议只支持全双工链路。\",\"PPP协议的组成\",\"一个将IP数据报封装到串行链路的方法。\",\"一个用来建立、配置和测试数据链路连接的链路控制协议LCP。\",\"一套网络控制协议NCP。\",\"PPP协议的帧格式\",\"PPP协议的工作状态\",\"1、链路建立之后，LCP开始协商一些配置选项，即发送LCP的配置请求帧。这是一个PPP帧，其信息字段包含特定的配置请求。链路的另一端可以发送以下响应中的一种：\",\"配置确认帧：所有选项都接受。\",\"配置否认帧：所有选项都理解但不能接受。\",\"配置拒绝帧：选项有的无法识别或不能接受，需要协商。\",\"2、在网络层协议状态，PPP链路的两端的网络控制协议NCP根据网络层的不同协议互相交换网络层特定的网络控制分组。PPP协议两端的网络层可以运行不同的网络层协议，但仍然可以使用同一个PPP协议进行通信。\"]},\"976\":{\"h\":\"使用广播信道的数据链路层\"},\"977\":{\"h\":\"局域网的数据链路层\",\"t\":[\"特点：网络为一个单位所拥有，且地理范围和站点数目均有限。\",\"局域网的拓扑:\",\"（a）星形网。集线器和双绞线大量用于局域网。\",\"（b）环形网。\",\"（c）总线网。各站直接连接在总线上。\"]},\"978\":{\"h\":\"以太网的信道利用率\",\"t\":[\"​ 要提高以太网的信道利用率，就必须减小τ与To之比。在以太网中定义了参数a,它是以太网单程端到端时延τ与帧的发送时间To之比:\",\"​ 从上式可以看出，参数a的值应当尽可能小些。也就是说，当数据量一定时，以太网的连线的长度受到限制，同时以太网的帧长不能太短。\"]},\"979\":{\"h\":\"以太网的MAC层\",\"t\":[\"在局域网中，硬件地址又称为物理地址或MAC地址。是指局域网上的每一台计算机中固化在是适配器的ROM中的地址，也就是每一个网卡就有一个MAC地址。\",\"适配器有过滤地址，每从网络上收到一个MAC帧就先用硬件检查MAC帧中的目的地址。如果是发送本站的就收下，否则丢弃。“发送到本站的帧”包括：\",\"（1）单播帧（一对一）：收到的帧的MAC地址与本站的硬件地址相同。\",\"（2）广播帧（一对全体）：发送给局域网上所有站点的帧。\",\"（3）多播帧（一对多）：发送给本局域网上一部分站点的帧。\"]},\"980\":{\"h\":\"MAC帧的格式\",\"t\":[\"类型字段用来标志上一层使用的是什么协议。\",\"当数据字段的长度小于46个字节时，MAC子层就会在数据字段的后面加入一个整数字节的填充字段，以保证以太网的MAC帧长不小于64字节。当上层使用IP协议时，其首部会有一个总长度字段，所以网络层就把填充的整数字节丢弃。\",\"前同步码作用是使接收器的适配器在接收MAC帧时能迅速调整其时钟频率，使它与发送端的时钟同步。\",\"帧开始定界符的前6位与前同步码一样，后两位的11是为了告诉适配器：MAC帧的信息马上要来啦！\",\"MAC帧的FCS字段的检验范围不包括前同步码和帧开始定界符。\",\"在以太网上传送数据时是以帧为单位来传送的，且传送时各帧之间还必须有一定的间隙。因此，接收端只要找到帧开始定界符，后面连续到达的比特流都属于同一个MAC帧。以太网不需要使用帧结束定界符，也不需要使用字节插入来保证透明传输。\"]},\"981\":{\"h\":\"MAC（硬件地址） vs IP地址\",\"t\":[\"IP 地址：IP地址是网络层以及以上各层使用的地址，互联网上的每一个网络和每一台主机分配一个 IP 地址。由于IP地址使用软件实现的，所以是逻辑地址。\",\"MAC地址：又称为物理地址、硬件地址，是数据链路层和物理层使用的地址。用来定义网络设备的位置，网卡在通讯时通过 MAC 地址相互识别。\",\"区别：\",\"分配依据不同：IP 地址的分配是基于网络拓扑，它可以自动分配；MAC 地址的分配是由网卡生产厂家烧入网卡的，具有全球唯一性。\",\"地址能否更改不同：IP 地址是可以更改的，MAC 地址虽然也可以更改，但一般不会更改，除非要用来绕过一些验证软件。\",\"此外，IP 地址为 32 位，MAC 地址为 48 位；IP 地址应用于 OSI 第三层，即网络层；MAC 地址应用在 OSI 第二层，即数据链路层。\"]},\"982\":{\"h\":\"MSS vs MTU\",\"t\":[\"MSS（Maximum Segment Size，最大分段大小）。假设MTU=1500，则MSS=1500-20（IP头）-20（TCP头）=1460byte。\",\"因为在网络编程中，我们要尽量避免出现 IP 分片(因为如果在IP层进行分片了话，如果其中的某片的数据丢失了，对于保证可靠性的TCP协议来说，会增大重传数据包的机率，而且只能重传整个TCP分组（进行IP分片前的数据包），因为TCP层是不知道IP层进行分片的细节的，也不关心)。对于 TCP 包来说，在建立三次握手的过程中，连接双方会相互通告 MSS，每次发送的 TCP 数据都不会超过双方 MSS 的最小值，所以就保证了 IP 数据包不会超过 MTU，避免了 IP 分片。\",\"MTU（Maximum Transmit Unit，最大传输单元）\",\"MTU 限制了数据链路层传输的数据帧大小，以太网的 MTU 是 1500 字节。如果传输层发送到网络层的数据 > 1500 字节，需要IP 分片。\",\"​ 网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务\"]},\"983\":{\"h\":\"网际协议IP\",\"t\":[\"IP地址的编址方法经过了三个历史阶段：分类的IP地址----> 子网的划分----> 构成超网\",\"与IP协议配套使用的还有三个协议：\",\"地址解析协议ARP\",\"网际控制报文协议ICMP\",\"网际组管理协议IGMP\",\"ARP在最下面是因为IP要经常使用这个协议，ICMP和IGMP画在这一层的上部，是因为它们要使用IP协议。\"]},\"984\":{\"h\":\"分类的IP地址\",\"t\":[\"​ IP地址 ::={<网络号>,<主机号>} （::=：表示**“定义为“**。）\",\"下图是各种IP地址的网络号字段和主机号字段：\",\"IP地址的一些特点：\",\"实际上IP地址是标志一台主机（或路由器）和一条链路的接口。当一台主机同时连两个网络时，就必须同时具有两个相应的IP地址，这种主机称为多归属主机。\",\"用转发器和网桥连接起来的若干个局域网仍为一个网络，因为这些局域网都具有同样的网络号。不同网络之间必须使用路由器进行互连。\"]},\"985\":{\"h\":\"将IP地址分类的好处\",\"t\":[\"IP地址管理机构在分配IP地址时只分配网络号。\",\"路由器仅根据目的主机所连接的网络号来转发分组，可以使路由表中的项目数大幅度减少，从而减少了路由表所占的存储空间以及查找路由表的时间。\"]},\"986\":{\"h\":\"地址解析协议ARP\",\"t\":[\"作用：从网络层使用的IP地址，解析出数据链路层使用的硬件地址。\",\"解决方法：在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常动态更新。\",\"过程\",\"当主机A要向主机B发送IP数据报时，先在其ARP高速缓存中查看有无主机B的IP地址。算法如下：\",\"若有，找到对应的硬件地址。再把这个地址写入MAC帧。\",\"若没有，（可能主机B新入网，或者主机A刚加上电，其缓存还是空的），那么：\",\"​ 1、ARP进程先在本局域网上广播发送一个ARP请求分组，为了求得主机B的硬件地址。\",\"​ 2、本局域网上的所有主机ARP进程都收到了这个请求分组。\",\"​ 3、若主机B接收到这个请求分组，则以单播的形式发送一个ARP响应分组，告诉主机A它的硬件地址。\",\"​ 4、主机A收到响应分组后，就将主机B的硬件地址写入ARP高速缓存中。（高速缓存中的每一个映射地址都设置有生存时间）\",\"ARP 欺骗：伪造 IP 地址和 MAC 地址实现 ARP 欺骗\",\"​ 一台计算机想和 PC0 和 PC1 通信，这台计算机使用 ARP 协议询问 PC0：你的 MAC 地址是多少？由于 ARP 协议是发送广播包来询问目标 MAC 地址，PC1 也能收到这条消息，在 PC1 中装了黑客软件，这时候 PC1 告诉它：PC0 的 MAC 地址是 M2，M2 就会将 M1 覆盖，那么传输数据时，就会将原本传送给 PC0 的数据传给 PC1，PC1 收到数据后将目标 MAC 地址改为 M1，再将数据传给 M1，相当于经过了M2 的转发。\"]},\"987\":{\"h\":\"IP数据报的格式\",\"t\":[\"​ IP层下面的每一种数据链路层协议都规定了一个数据帧中的数据字段的最大长度，这称为最大传送单元MTU。数据报的总长度（首部+数据部分）的长度不能超过MTU的值，最常用的以太网的MTU值是1500。\",\"​ 其中16位的标识、3位标志位（ 0、DF、MF）中的DF（Don’t Fragment）和MF（More Fragment） 以及13位的片偏移用来IP报文的分片和重组。\",\"分片举例：片偏移以8个字节为一个单位。\"]},\"988\":{\"h\":\"划分子网和构造超网\"},\"989\":{\"h\":\"划分子网\",\"t\":[\"就是在IP地址中又增加一个子网号字段，使两级IP地址变为三级IP地址。又称子网寻址或子网路由选择。IP地址 ::={<网络号>,<子网号>,<主机号>}\",\"具体思路：\",\"将一个网络划分为若干个子网，怎么分是该网络内部的事，对外仍然表现为一个网络。\",\"方法是从网络的主机号借用若干位来作为子网号，主机号也因此减少位数。\",\"先根据IP数据报的目的网络号找到连接本单位网络上的路由器，之后路由器再找到子网。\",\"子网掩码\",\"​ 从IP数据报的首部无法看出源主机或目的主机所连接的网络是否进行了子网划分，此时就应该使用子网掩码。（网络号全为1，主机号全为0，与IP地址按位与）。\",\"现在互联网的标准规定：\",\"​ 所有的网络都必须使用子网掩码，同时路由器的路由表中也必须有子网掩码这一栏。如果一个网络不划分子网，那么该网络的子网掩码就使用默认子网掩码。这样可以不用查找该地址的类别就能知道这是哪一类的IP地址，更便于查找路由表。\"]},\"990\":{\"h\":\"使用子网时分组的转发\",\"t\":[\"使用子网划分后，路由表必须包含以下三项内容：目的网络地址、子网掩码、下一跳地址。\",\"算法如下：\",\"从收到的数据报的首部中提取目的IP地址D。\",\"先判断是否为直接交付。对路由器直接相连的网络逐个检查：用各网络的子网掩码与D按位相与。匹配，交付；不匹配，\",\"若路由器有目的地址为D的特定主机路由，则传送给该路由，否则，\",\"对路由表的每一行中的子网掩码与D相与，若结果匹配，则跳转至下一路由器，否则，\",\"若有默认路由，则把数据报传送给该路由，否则，报告转发分组出错。\"]},\"991\":{\"h\":\"无分类编址CIDR（构造超网）\",\"t\":[\"IP地址 ::={<网络前缀>,<主机号>}\",\"最主要的特点有两个：\",\"CIDR消除了传统的A，B，C类地址以及划分子网的概念，把32位的IP地址划分为前后两个部分。（因此IP地址又回到了两级编址，只不过是无分类的两级编址）。CIDR还使用斜线记法，或成为CIDR记法，即在IP地址后面加上“/”，然后写上网络前缀所占的位数。\",\"CIRD把网络前缀都相同的连续的IP地址组成一个“CIDR地址“。\",\"为了更方便地进行路由选择，CIDR使用32位的地址掩码。IP地址“/”后面的数字，也就是地址掩码中1的个数。\",\"路由聚合：由于一个CIDR地址块中有很多地址，所以在路由表中就利用CIDR地址块来查找目的网络。路由聚合也称为构成超网。\",\"最长前缀匹配\",\"在使用CIDR时，由于采用网络前缀这种记法，路由表中的项目也要改变：由网络前缀和下一跳地址组成。\",\"但是在查找路由表时可能会得到不止一个匹配结果，此时应当从匹配结果中选择具有最长网络前缀的路由，叫做最长前缀匹配。又称为最长匹配或最佳匹配。\",\"使用二叉线索查找路由表\",\"二叉线索是一种特殊结构的树。每一个叶节点包含所对应别的网络前缀和子网掩码。\"]},\"992\":{\"h\":\"网际控制报文协议ICMP\",\"t\":[\"本质上还是一个IP数据报，只不过IP数据报的数据段部分被ICMP报文替代了而已。\",\"​ 主要用于补充 IP 传输数据报的过程中，发送主机无法确定数据报是否到达目标主机。。IP 协议是无连接的，因此其传输是不可靠的，不能保证 IP 数据报能够成功的到达目的主机，无法进行差错控制，当遇到 IP 数据无法访问目标时，会自动发送 ICMP 消息。\"]},\"993\":{\"h\":\"ICMP报文的种类\",\"t\":[\"差错报告报文\",\"终点不可达：当路由器或主机不能交付数据报时就向源点发送终点不可达报文。\",\"时间超过：当路由器收到生存时间为零的数据报时，除丢弃该数据外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据片时，就将已收到的数据报片丢弃，并向源点发送时间超过报文。\",\"参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据，并向源点发送参数问题报文。\",\"改变路由（重定向）：路由把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。\",\"对改变路由的解释： 在互联网的主机中也要有一个路由表。当主机要发送数据报时，首先是查找主机自己的路由表，看应当从哪一个接口把数据报发送出去。在互联网中主机的数量远大于路由器的数量，出于效率的考虑，这些主机不和连接在网络上的路由器定期交换路由信息。在主机刚开始工作时，一般都在路由表中设置一个默认路由器的IP地址。不管数据报发送到哪个目的地址，都一律先把数据报传送给这个默认路由器，而这个默认路由器知道到每一个目的网络的最佳路由(通过和其他路由器交换路由信息)。如果默认路由器发现主机发往某个目的地址的数据报的最佳路由应当经过网络上的另一个路由器R时，就用改变路由报文把这情况告诉主机。于是，该主机就在其路由表中增加一个项目:到某某目的地址应经过路由器R (而不是默认路由器)。 \",\"差错控制报文的内容：\",\"将需要进行差错报告的IP数据报的首部和数据字段的前8个字节提取出来，作为ICMP差错报告报文的数据字段。提取数据报前8个字节是为了得到运输层的端口号（对于TCP、UDP）以及运输层报文的发送序号（对于TCP）。\",\"再加上ICMP差错报告报文本来的前8个字节，构成ICMP差错报告报文。\",\"不应发送ICMP差错报告报文的情况：\",\"对ICMP差错报告报文，不再发送ICMP差错报告报文。\",\"对具有多播地址的数据报，不发送ICMP差错报告报文。\",\"对具有特殊地址（如0.0.0.0）的数据报，不发送ICMP差错报告报文。\",\"对第一个分片的数据报片的所有后序数据报片，都不发送ICMP差错报告报文。\",\"询问报文\",\"回送请求和回答：ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机发送ICMP回送回答报文。主要用来测试目的站是否可以到达以及了解其有关状态。\",\"时间戳请求和回答：ICMP时间戳请求报文是请某台主机回答当前的日期和时间。在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数表示从1900年1月1日到当前时刻有多少秒。主要用于时钟同步和时间测量。\"]},\"994\":{\"h\":\"应用：PING、Traceroute\",\"t\":[\"分组网间探测PING：用来测试两台主机之间的连通性。PING使用了ICMP回送请求与回送回答报文。PING是应用层直接使用网络层ICMP的一个例子，没有通过运输层的TCP/UDP。\",\"Traceroute：用来跟踪一个分组从源点到终点的路径。 Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。\"]},\"995\":{\"h\":\"VPN、NAT\",\"t\":[\"VPN\",\"利用公用的互联网作为本机构各专用网之间的通信载体，这样的专用网称为虚拟专用网VPN。\",\"VPN只是在效果上和真正的专用网一样。\",\"NAT\",\"NAT（Network Address Translation，网络地址转换），。\",\"装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。\",\"NAT地址转换表举例：\"]},\"996\":{\"h\":\"IPv4 vs IPv6\",\"t\":[\"地址空间不同，IPv4 中规定 IP 地址长度为 32，而 IPv6 中 IP 地址的长度为 128\",\"IPv4 最大的问题在于网络地址资源有限，它地址长度为 32，也就是最多有 2^32 次方台电脑可以连接到 Internet 上，而目前 IP 地址的需求量越来越大，它无法满足我们的需求。\",\"更高的安全性\",\"使用 IPv6 网络中用户可以对网络层的数据进行加密并对 IP 报文进行校验，极大的增强了网络安全。\",\"增强的组播支持以及对流的支持\",\"路由表大小不同，IPv6 的路由表相比 IPv4 的更小\"]},\"997\":{\"h\":\"存ip地址，用什么数据类型\",\"t\":[\"当存储IPv4地址时，应该使用32位的无符号整数（UNSIGNED INT）来存储IP地址，而不是使用字符串。\",\"节省空间，不管是数据存储空间，还是索引存储空间。通常，在保存IPv4地址时，一个IPv4最小需要7个字符，最大需要15个字符，所以，使用VARCHAR(15)即可。MySQL在保存变长的字符串时，还需要额外的一个字节来保存此字符串的长度。而如果使用无符号整数来存储，只需要4个字节即可。\",\"便于使用范围查询（BETWEEN...AND），且效率更高。\",\"缺点：不便于阅读，需要手动转换。MySQL提供了相应的函数来把字符串格式的IP转换成整数INET_ATON，以及把整数格式的IP转换成字符串的INET_NTOA。\",\"概述：\",\"运输层向上面的应用层提供通信服务。它属于面向通信部分的最高层，同时也是用户功能中的最底层。\",\"通信的真正端点并不是主机而是主机中的进程。\",\"复用：是指在发送方不同的应用进程都可以使用同一个传输层协议传送数据（需要加上适当的首部）。\",\"分用：是指在接收方的运输层可以把这些数据正确交付目的进程。\",\"网络层和运输层的一个明显区别：运输层提供应用进程间的逻辑通信。网络层提供主机间的逻辑通信。\"]},\"998\":{\"h\":\"传输层作用：\",\"t\":[\"​ 提供了应用程序之间的通信也就是端到端的通信，提供应用的多路复用/分用服务、可靠性传送。传输层还有寻址的功能，定位应用程序在哪里。以及流量的控制，防止接收端速度太慢造成溢出和丢包的现象。\"]},\"999\":{\"h\":\"传输层与网络层的区别\",\"t\":[\"​ 网络层和运输层的一个明显区别：运输层提供应用进程间的逻辑通信。网络层提供主机间的逻辑通信。\",\"​ 网络层提供了主机之间的逻辑通道。即把一个数据包从一个主机发到另一个主机上面。传输层提供了应用进程之间的端-端连接。我们知道一个电脑可能有多个进程同时在使用网络连接，那么网络包达到主机之后，传输层来使网络包网络包找到自己属于的进程。\",\"​ 传输层的复用和分用：\",\"复用：是指发送方不同的应用程序都可使用同一个传输层协议传送数据(需要加上适当的首部)\",\"分用：接收方的传输层在拨去报文的首部后能够把这些数据正确交付到目的应用进程，也就是传输层能够区分不同的进程的数据并且加以区分处理。\",\"​ 网络层的复用和分用：\",\"复用：网络层的复用是指发送方不同协议的数据都可以封装成IP数据报发送出去。\",\"分用：网络层的分用是指接收方的网络层在剥去首部后吧数据交给相应的协议。\"]},\"1000\":{\"h\":\"端口\",\"t\":[\"这种在协议栈层间的抽象的协议端口是软件端口，和路由器或交换机上的硬件端口是完全不同的概念。\",\"TCP/IP的运输层用一个16位端口号来标志一个端口。端口号只具有本地意义。\",\"运输层的端口号分为：服务器端使用的端口号和客户端使用的端口号。\",\"服务器端使用的端口号分为：系统端口号（0-1023，固定可查）；登记端口号（1024-49151）\",\"客户端使用的端口号（49151-65535）：仅在客户进程运行时才动态选择，又叫做短暂端口号。\"]},\"1001\":{\"h\":\"UDP&TCP：区别与应用场景\",\"t\":[\"区别\",\"TCP 是面向字节流的传输方式，UDP 是面向数据报的传输方式。\",\"TCP 是面向连接的、可靠传输、传输数据有序；UDP 是无连接的、不可靠传输、不保证传输数据的有序性。\",\"TCP不保存数据边界，UDP保留数据边界（不拆分、不合并，加了首部就下传）。\",\"TCP 连接只能是一对一的；UDP 支持一对一、一对多、多对一和多对多的交互通信。\",\"TCP传输速度相对UDP较慢。UDP 发送数据就是简单的把数据包封装一下，然后从网卡发出去就行了，数据包之间并没有状态上的联系，正因为 UDP 这种简单的处理方式，使得它的性能损耗非常少。对于 CPU 内存资源的占用也远小于 TCP，但是对于网络传输过程中产生的丢包，UDP 协议并不能保证，所以 UDP 在传输稳定上要弱于 TCP。\",\"TCP有流量控制和拥塞控制，UDP没有。\",\"应用场景\",\"TCP 传输数据稳定可靠，，需要准确无误的传输给对方，如：文件传输、接收邮件、远程登陆等。\",\"UDP 的优点是速度快，但可能产生丢包，所以，但是对少量丢包并没有太大要求的场景，比如：网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）等。\"]},\"1002\":{\"h\":\"UDP\",\"t\":[\"用户报数据协议UDP只在IP数据报服务之上增加了复用、分用和差错检测的功能。\",\"主要特点：\",\"UDP是无连接的，即发送数据之前不需要建立连接，减少了开销和发送数据之前的时延。\",\"UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态。\",\"UDP是面向报文的。对于应用层交下来的报文，既不合并也不拆分，保留这些报文的边界，在添加首部后就下交给网络层（所以不会产生粘包问题）。因此应用层必须选择合适大小的报文。\",\"UDP没有拥塞控制。这对某些允许网络拥塞时丢失一些数据，但不允许数据有太大时延的应用非常的合适。\",\"UDP支持一对一，一对多，多对一，多对多的交互通信。\",\"UDP的首部开销小：TCP20个字节，UDP8个字节。\",\"UDP首部格式\",\"由4个字段组成，每个字段都是2个字节。\",\"源端口：在需要对方回信时选用。不需要时可全用0。\",\"目的端口：在终点交付报文时必须使用。\",\"长度：UDP用户数据报的长度，其最小值是8（仅有首部）。\",\"检验和：检测UDP用户数据报在传输中是否有错，有错就丢弃。\",\"端口分用\",\"​ 当接收方UDP发现收到的报文中的目的端口号不正确，就丢弃该报文，并由网际控制报文协议ICMP发送端口不可达差错控制报文。\",\"伪首部\",\"​ UDP在计算检验和时，要在UDP用户数据报之前增加12个字节的伪首部。这个伪首部也仅用来计算检验和。\",\"​ UDP计算检验和与计算IP数据报首部检验和的方法相似，但UDP把首部和数据部分一起检验。\"]},\"1003\":{\"h\":\"UDP可以建立连接么\",\"t\":[\"​ UDP 中可以使用 connnet 操作建立连接，但 UDP 中 connect 操作与 TCP 中的 connect 操作有着本质区别。TCP 中调用 connect 会引起三次握手，客户端与服务器端建立连接。UDP 中调用 connect 仅仅是把对方的 ip 和 port 记录下来，UDP 中使用 connect 可以提高发送效率，udp 建立连接可以在一个连接中发送多个 udp 报文。\"]},\"1004\":{\"h\":\"UDP 如何保证可靠传输？\",\"t\":[\"通过自动重传请求ARQ可以在不可靠的传输网络上实现可靠的通信。\",\"可靠性由上层应用实现，所以要实现 UDP 可靠性传输，必须通过应用层来实现和控制。：\",\"添加 seq/ack 机制，确保数据发送到对端\",\"添加发送和接收缓冲区\",\"添加超时重传机制\",\"​ 发送端发送数据时，生成一个随机的 seq = x，然后每一片按照数据大小分配 seq。数据到达接收端后放入接收缓存，接收端发送一个 ack = x 的包，表示我已经收到了数据。发送端收到了 ack 包后，删除发送缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。\",\"其实，目前也有一些开源程序利用 UDP 来实现了可靠的数据传输，如：\",\"RUDP、RTP、UDT（UDT 建于 UDP 之上，并引入拥塞控制和数据可靠性控制机制）\",\"，改为，基于 UDP 主体将 TCP 的重要功能转移到用户空间来实现，从而绕开内核实现用户态的 TCP 协议，但是真正实现起来还是非常复杂的。\"]},\"1005\":{\"h\":\"TCP\"},\"1006\":{\"h\":\"粘包\",\"t\":[\"什么是粘包\",\"​ 我们知道，TCP是面向字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界。从TCP的首部格式也可以看出，没有表示数据长度的字段。\",\"​ 所以在使用TCP时，有了粘包和拆包的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。\",\"粘包是怎么产生的\",\"发送方产生粘包\",\"​ 采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过小时，TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。\",\"接收方产生粘包\",\"​ 接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度）\",\"怎么解决拆包和粘包\",\"一般有两个通用的解决方法：\",\"特殊字符控制。\",\"在包头首部添加数据报的长度。\",\"注意：UDP是面向报文的，没有缓冲，也没有包的拆分合并，所以没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。\"]},\"1007\":{\"h\":\"TCP的首部格式\",\"t\":[\"TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。报文段首部的前20个字节是固定的，后面有4n字节是根据需要而增加的选项（n是整数）。\",\"序号：在一个TCP连接中传送的字节流中的每一个字节都是按顺序编号。首部中序号字段值则是指本报文段所发送的数据的第一个字节的序号。\",\"确认号：是期望收到对方的下一个报文段的第一个数据字节的序号。\",\"数据偏移：它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，实际上是指出了TCP报文段的首部长度。\",\"窗口：指出了现在允许对方发送的数据量（从确认号开始），窗口值作为接收方让发送方设置其发送窗口的大小。\",\"检验和：检验范围包括首部和数据两部分，需要加上12个字节的伪首部。\",\"选项：最大报文段长度MSS，时间戳（包括时间戳值、时间戳回送回答）...\",\"确认ACK：TCP规定，在连接建立后所有传送的报文段都必须把ACK设置为1。\",\"同步SYN：在连接时用来同步序号。SYN置1就表示这是一个连接请求或连接接受报文。\",\"终止FIN：用来释放一个连接，当FIN=1表示此报文段的发送方的数据已发送完毕。\",\"紧急指针：仅在URG=1时才有意义，指明了本报文段中的紧急数据的字节数，即使窗口为0也可发送紧急数据。\"]},\"1008\":{\"h\":\"TCP的可靠传输\"},\"1009\":{\"h\":\"如何保证？\",\"t\":[\"应用数据被分割成 TCP 认为最适合发送的数据块。\",\"TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。\",\"校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。\",\"TCP 的接收端会丢弃重复的数据。\",\"流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）\",\"拥塞控制： 当网络拥塞时，减少数据的发送。\",\"ARQ 协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。\",\"超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。\"]},\"1010\":{\"h\":\"停止等待协议\",\"t\":[\"​ 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认迟到。\"]},\"1011\":{\"h\":\"ARQ(自动重传请求)\",\"t\":[\"停止等待 ARQ 协议：停止等待协议中的超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。\",\"连续 ARQ 协议：可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。\"]},\"1012\":{\"h\":\"超时重传时间的选择\",\"t\":[\"我们知道TCP的发送方在规定时间内没有收到确认就要重传已经发送的报文段，虽然听起来简单，但是重传时间的选择确实TCP最复杂的问题之一。\",\"对于重传时间的设置，TCP采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间RTT。\",\"TCP保留了一个RTT的一个加权平均往返时间RTTs，又称为平滑的往返时间。每得到一个新的RTT，就重新计算一次RTTs。（α一般为0.125） $$ \\\\text { 新的 } \\\\mathrm{RTT}{\\\\mathrm{S}}=(1-\\\\alpha) \\\\times\\\\left(\\\\text { 旧的 } \\\\mathrm{RTT}{\\\\mathrm{S}}\\\\right)+\\\\alpha \\\\times(\\\\text { 新的 RTT 样本 }) $$\",\"超时计时器设置的超时重传时间RTO，一般按照下面这个式子：\",\"$$ \\\\mathrm{RTO}=\\\\mathrm{RTT}{\\\\mathrm{S}}+4 \\\\times \\\\mathrm{RTT}{\\\\mathrm{D}} $$\"]},\"1013\":{\"h\":\"选择确认SACK\",\"t\":[\"​ 还有一个问题，就是若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据。选择确认（Selective ACK）就是一种可行的处理办法。\",\"工作原理\",\"​ 假设A向B发送数据，1-1000收到了，1001-1500没收到，1501-3000收到了...那么需要B向A发送没有收到的字节流的左右边界。\",\"​ 但是我们知道，TCP的首部中没有哪个字段能够提供上述这些字节块的边界信息。所以规定：如果要使用SACK，必须在建立TCP连接时就约定好，在首部的选项中加上允许SACK的选项。但是因为SACK文档没有指明发送方怎么响应SACK，因此大多数的实现还是重传所有未被确认的数据块。\"]},\"1014\":{\"h\":\"TCP的流量控制(点)\"},\"1015\":{\"h\":\"滑动窗口？\",\"t\":[\"​ TCP 利用滑动窗口实现流量控制的机制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。\",\"​ TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小代表接收方还有多大的缓冲区可以用于接收数据，发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另有一种情况：如果B向A发送了零窗口的报文段后不久，接收缓存又有了一些空间，于是B向A发送了rwnd=400的报文段，但是丢失了。此时A一直在等待B的非零窗口通知，B在等A的数据，陷入死锁。为解决这个问题，TCP为每一个连接设有一个持续计时器。只要TCP连接的一方收到一个对方的零窗口通知，就启动计时器。若计时器的时间到期，就发送一个零窗口的探测报文段（仅携带1字节的数据）。\",\"发送缓存用来暂时存放：准备发送的数据、已发送但尚未收到确认的数据。\",\"接收缓存用来暂时存放：按序到达，但尚未被应用程序读取的数据、未按序到达的数据。\",\"TCP通常对不按序到达的数据先存在缓存中，等到缺失的字节收到后，再按序交付上层的应用进程。\"]},\"1016\":{\"h\":\"TCP的传输效率\",\"t\":[\"控制TCP报文段发送的不同机制：\",\"缓存中存放的数据到达MSS（最大报文段长度）字节时，就组装成一个TCP报文段发送出去。\",\"由发送方的应用程序指明发送，即TCP支持的**推送（push）**操作。\",\"发送端的一个计时器期限到了，就把当前的缓存数据发送出去。\"]},\"1017\":{\"h\":\"Nagle算法\",\"t\":[\"在TCP的实现中广泛使用Nagle 算法。算法如下:\",\"​ 若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方收到对第一个确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。\",\"​ Nagle 算法还规定，当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。这样做，就可以有效地提高网络的吞吐量。\"]},\"1018\":{\"h\":\"糊涂窗口综合征\",\"t\":[\"​ 设想一种情况: TCP接收方的缓存已满，而应用进程一次只从接收缓存中读取1个字节(这样就使接收缓存空间仅腾出1个字节)，然后向发送方发送确认，并把窗口设置为1个字节(但发送的数据报是40字节长)。接着，发送方又发来1个字节的数据(请注意，发送方发送的IP数据报是41字节长)。接收方发回确认，仍然将窗口设置为1个字节。这样进行下去，使网络的效率很低。\",\"​ 要解决这个问题，可以让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。\",\"​ 上述两种方法可配合使用。使得在发送方不发送很小的报文段的同时，接收方也不要在缓存刚刚有了一点小的空间就急忙把这个很小的窗口大小信息通知给发送方。\"]},\"1019\":{\"h\":\"TCP的拥塞控制(总)\",\"t\":[\"​ 若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就会变坏，称为拥塞：∑对资源的需求>可用资源。所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。\",\"​ 拥塞控制和流量控制不同，前者是一个全局性的过程，相比之下，流量控制往往是指点对点通信量的控制。\",\"​ 为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。发送方控制拥塞窗口的原则：没有拥塞，窗口就大一点，反之，小一点。判断网络拥塞的依据就是出现了超时。\",\"​ TCP 的拥塞控制采用了四种算法，即：慢开始、拥塞避免、快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如：主动队列管理 AQM），以减少网络拥塞的发生。\",\"慢开始、拥塞避免\",\"算法思路：由小到大逐渐增大发送窗口。如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的负载情况。\",\"刚开始指数级增长，称为慢开始。（cwnd<ssthresh时）\",\"为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh。\",\"当cwnd>ssthresh时，cwnd不再进行指数级增长，而改为一个一个增加的线性增长阶段，称为拥塞避免。\",\"快重传\",\"目的：为了让发送方尽早知道发生了个别报文段的丢失。首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认。\",\"按照快重传算法，假设A给B发送了1,2,3,4...n个数据报，其中编号3的包始终没有收到，此时B就会重复确认编号2的号，意在告诉A，包3还没有收到。当A连续收到3个重复确认包2的ACk时，A将不再等待包3的计时器，而是快速重传包3。\",\"快恢复\",\"​ 在上图中的点4，发送方知道只是丢失了个别的报文段。于是不启动慢开始，而是快恢复。设置cwnd=ssthresh=cwnd/2=8，开始执行拥塞避免。\"]},\"1020\":{\"h\":\"超时事件就一定是网络拥塞么？\",\"t\":[\"​ 当然不一定，有可能是因为某个数据报出现了丢失或者损害，导致了这个数据包超时事件的发生。此时进行快重传。\"]},\"1021\":{\"h\":\"主动队列管理AQM\",\"t\":[\"TCP拥塞控制和网络层采取的策略有着密切的联系：假定路由器对于某些分组的处理时间特别长，会使得发送端重传。而重传会使TCP连接的发送端认为发生了拥塞，于是在实际并没有拥塞的情况下采取了拥塞控制。\",\"网络层的策略对TCP拥塞控制影响最大的就是路由器的分组丢弃策略。路由器按照FIFO处理分组，当队列满了的时候，就执行尾部丢弃策略。\",\"主动队列管理就是不要等到路由器丢弃队尾分组，要主动丢弃，这样就提醒了发送方放慢发送的速率。\"]},\"1022\":{\"h\":\"三次握手\",\"t\":[\"TCP三次握手 \",\"第一次client发送syn字段。\",\"第二次service发送ack+1字段和syn字段。\",\"第三次client发送ack字段。\",\"此过程统一了序列字段号，确认了双方的收发能力均正常。\",\"首先，服务器端创建传输控制块，进入LISTEN状态，等待连接。\",\"第一次握手（SYN）：客户端发送SYN报文（首部中的同步位SYN=1），同时选择一个初始序号seq=x（SYN报文段不能携带数据，但要消耗一个序号），进入SYN-SENT（同步已发送）状态。\",\"第二次握手（SYN+ACK）：服务器端收到请求报文段之后，若同意建立连接，则向客户端发送确认。该报文段SYN=1，ACK=1，确认号ack=x+1，同时也选择一个初始序号seq=y（该报文段同样不能携带数据，但同样要消耗一个序号）。此时服务器进入SYN-RCVD（同步收到）状态。\",\"第三次握手（ACK）（可以携带数据）：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。ACK报文段可以携带数据，如果不携带，则不消耗序号。此时TCP连接已经建立，A、B进入ESTAB-LISHED（已建立连接）状态。\",\"为什么需要三次握手？\",\"​ 。\",\"​ 客户端发送的连接请求（SYN报文）如果在网络中滞留，客户端等待一个超时重传时间之后，就会重新请求连接，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，假设不采用 ”三次握手“，那么只要服务器端发出确认，新的连接就建立了，但此时客户端并没有发出建立连接的请求，因此它会忽略服务器端发来的确认，也不会向服务器端发送数据，但服务器端却以为新的连接已经建立，它会一直等待客户端发送数据（也不会一直等，有一个保活计时器），浪费资源。\"]},\"1023\":{\"h\":\"为什么不能两（二）次握手\",\"t\":[\"​ 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一直等待客户端发送数据，浪费资源。\"]},\"1024\":{\"h\":\"为什么连接的时候是三次握手，关闭的时候却是四次握手？\",\"t\":[\"​ 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，\\\"你发的FIN报文我收到了\\\"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。\"]},\"1025\":{\"h\":\"半连接队列和全连接队列？\",\"t\":[\"​ 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。\"]},\"1026\":{\"h\":\"四次挥手\",\"t\":[\"TCP四次挥手\",\"第一次client发送 FIN 字段，表示想要关闭连接。\",\"第二次service发送 ack 字段，表示收到了client的关闭连接请求。\",\"第三次service在发送完要发送的数据后，发送 FIN 字段。\",\"第四次client发送 ack 字段，表示接受到service的消息。\",\"随后client会等待 2MSL 的时间，原因是怕最后一个 ACK 包对方没收到，那么对方在超时后将重发第三次挥手的 FIN 包，主动关闭端接到重发的 FIN 包后可以再发一个 ACK 应答包。.\",\"此时客户端、服务器都处于连接已建立状态。客户端的应用进程先向其TCP发出连接释放报文段，并停止发送数据，主动关闭TCP连接。\",\"第一次挥手（客户端FIN）：客户端发送一个FIN报文（终止控制位FIN置1），其序号为u（已传送数据的最后一个序号+1）。此时A进入FIN-WAIT-1（终止等待1）状态。FIN报文段即使不携带数据，也要消耗掉一个序号。\",\"第二次挥手（服务器ACK）：服务器收到连接释放报文后发出ACK报文，确认号ack=u+1，之后服务器B进入CLOSE-WAIT（关闭等待）状态。A收到B的确认后，A到B向的连接就释放了，此时TCP处于半关闭状态，也就是A已经没数据要发给B了，但B要发送数据，A还是得接收。此时A进入FIN-WAIT2状态。\",\"第三次挥手（服务器FIN）：等服务器发完数据后，发出FIN报文段，此时ack=u+1。B进入LAST-AC（最后确认）状态。\",\"第四次挥手（客户端ACK）：客户端收到服务器的连接释放报文段之后，还是得确认下。在确认报文中把ACK置1，因为前面发的FIN报文消耗了一个序号，所以seq=u+1。服务器收到后，当场CLOSE。但此时客户端进入TIME-WAIT（时间等待）状态。必须经过时间等待计时器设置的2MSL（最长报文段寿命），之后就CLOSE了。\",\"为什么客户端需要等待2MSL？\"]},\"1027\":{\"h\":\"为什么需要等待2MSL\",\"t\":[\"MSL 指 Maximum Segment Lifetime，TCP 报文最大生存时间。两个原因：\",\"​ 确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭\",\"为了保证 A 发送的最后一个 ACK 报文段能够到达 B。如果 A 在 TIME_WAIT 状态不等待一段时间，而是发送完 ACK 报文后立即释放连接，那么如果这个 ACK 报文段丢失，B 就无法按照正常步骤进入 CLOSED 状态。\",\"连接“化身”和报文迷走有关系，为了让旧连接的重复分节在网络中自然消失（让TCP报文得以正常消失）\",\"客户端在发送完最后一个 ACK 确认报文后，再经过 2MSL 时间，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，这样就可以避免上一次 TCP 连接的数据包影响到下一次的 TCP 连接。\"]},\"1028\":{\"h\":\"保活计时器的作用\",\"t\":[\"​ 除了时间等待计时器之外，TCP还有一个保活计时器。假如客户端主机突然坏了，服务器也不能一直等，所以设立一个计时器。\",\"​ 服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10 个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。\"]},\"1029\":{\"h\":\"在浏览器中输入 URL 地址到显示主页的过程？\",\"t\":[\"DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址；\",\"ARP协议：从 IP 地址，解析出硬件地址。\",\"TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；\",\"发送 HTTP 请求：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求；如果是HTTPs连接的话，看HTTPs的工作原理。\",\"服务器处理请求并返回 HTTP 报文。具体是服务器接收到这个请求，根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；\",\"浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。\",\"连接结束。\",\"Tomcat层面：\",\"​ 一个http请求到来，容器将请求封装为Servlet中的HttpServletRequest对象，调用init()方法，service()方法输出response，由容器包装为httpresponse返回给客户端。\"]},\"1030\":{\"h\":\"域名系统DNS\",\"t\":[\"域名系统DNS是互联网使用的命名系统，用来便于人们使用的机器名字转换成IP地址。（作用：根据域名查出IP地址）\",\"域名到IP地址的解析是由分布在互联网上的许多域名服务器程序共同完成的。运行域名服务器程序的机器称为域名服务器。\",\"域名结构：\",\"域名服务器：\",\"根域名服务器采用了任播技术(多个服务器使用的是同一个ip地址)，因此当DNS客户向某个根域名服务器的IP地址查询报文时，互联网上的路由器就能找到离这个DNS客户最近的一个根域名服务器。\"]},\"1031\":{\"h\":\"域名到IP地址的解析过程\",\"t\":[\"浏览器先查询hosts文件是否有与这个域名对应的ip地址，如果有则直接向这个ip地址发起http请求。\",\"如果没有，调用解析程序，成为一个DNS客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报方式（为了减少开销）发送给本地域名服务器。服务器查找到域名后，把对应的IP地址放在回答报文中返回。\",\"若本地域名服务器不能回答该请求，则此域名服务器就暂时成为了DNS中的另一个客户，并向根域名服务器发送查询请求。当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。\",\"DNS域名服务器根据域名的层级，进行分级查询。\"]},\"1032\":{\"h\":\"域名缓存\",\"t\":[\"​ 为了提高 DNS 查询效率，并减少因特网上的 DNS 查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名的记录。\",\"​ 由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如：每个项目两天）。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。\",\"​ 不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。\"]},\"1033\":{\"h\":\"DNS使用UDP还是TCP\",\"t\":[\"​ 其实 DNS 的整个过程是既使用 TCP 又使用 UDP。\",\"​ 当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据，域名服务器同步）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。\",\"​ 当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。\"]},\"1034\":{\"h\":\"万维网WWW\",\"t\":[\"万维网是一个大规模的、联机式的信息储藏所，简称web。\",\"提供分布式服务，用链接 的方法能方便地从互联网上的一个站点访问另一个站点。\",\"万维网是一个分布式的超媒体系统，是超文本系统的扩充。\"]},\"1035\":{\"h\":\"HTML、XML、JSON\",\"t\":[\"HTML超文本标记语言\",\"概述：\",\"目的：使任何一台计算机都能显示出任何一个万维网服务器上的页面。\",\"HTML不是应用层的协议，只是一门语言。\",\"XML可拓展标记语言\",\"概述：\",\"相比HTML，XML的设计宗旨的传输和储存数据，而不是数据显示。\",\"目的：为了便于不同平台、应用之间的数据共享和通信。为了弥补HTML的缺陷和局限性。\",\"HTML与XML的对比：\",\"JSON\",\"概述：\",\"全称是 JavaScript Object Notation，即 JavaScript对象标记法。是一种轻量级（Light-Meight)、基于文本的(Text-Based)、可读的(Human-Readable)格式。\",\"JSON 的名称中虽然带有JavaScript，但这是指其语法规则是参考JavaScript对象的，而不是指只能用于JavaScript 语言。\",\"语法格式：\",\"数组（Array）用方括号(“[]”)表示。\",\"对象（0bject）用大括号(“{}”)表示。\",\"名称/值对(name/value）组合成数组和对象。\",\"名称(name）置于双引号中，值（value）有字符串、数值、布尔值、null、对象和数组。\",\"并列的数据之间用逗号(“,”）分隔。\",\"相比XML：\",\"没有结束标签,长度更短,读写更快\",\"能够直接被JavaScript解释器解析\",\"可以使用数组\"]},\"1036\":{\"h\":\"统一资源定位符URL\",\"t\":[\"格式：<协议>://<主机>:<端口>/<路径>\",\"使用HTTP的URL：\",\"​ http://<主机>:<端口>/<路径>\",\"HTTP的默认端口号是80，通常可省略。\",\"若再省略<路径>项，则URL就指到主页。\"]},\"1037\":{\"h\":\"HTTP\",\"t\":[\"超文本传输协议概述：\",\"HTTP协议定义了浏览器怎样向万维网服务器请求文档，以及服务器怎样把文档传送给浏览器。\",\"从层次上看，HTTP是面向事务（一次链接是一次事务）的应用层协议，是万维网能够可靠地交换文件的重要基础。\",\"每一个网点都有一个服务器进程，它不断监听TCP的端口80，以便发现是否有浏览器向它发出连接建立请求。\",\"HTTP本身是无连接的，也就是说双方在交换HTTP报文之前，不需要建立HTTP连接。\",\"HTTP是无状态的，也就是说同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同，服务器不记得这个客户来过没。一般用cookie和session来弥补HTTP的无状态特性，不过也已经不能满足分布式的业务要求了，现在都是用token。\"]},\"1038\":{\"h\":\"HTTP的报文结构\",\"t\":[\"HTTP请求：请求行、请求头部、空行和请求体\",\"请求行：包括请求方法，访问的资源URL，使用的HTTP版本。GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。\",\"请求头：格式为属性名:属性值，服务端根据请求头获取客户端的信息，主要有cookie、host、connection、accept-language、accept-encoding、user-agent。\",\"请求体：用户的请求数据如用户名，密码等。\",\"POST /xxx HTTP/1.1 请求行 Accept:image/gif.image/jpeg 请求头部 Accept-Language:zh-cn Connection:Keep-Alive Host:localhost User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0) Accept-Encoding:gzip,deflate username=dabin 请求体 \",\"HTTP响应：状态行、响应头、空行和响应体\",\"状态行：协议版本，状态码及状态描述。\",\"响应头：响应头字段主要有connection、content-type、content-encoding、content-length、set-cookie、Last-Modified，、Cache-Control、Expires。\",\"响应体：服务器返回给客户端的内容。\",\"HTTP/1.1 200 OK 状态行 Server:Apache Tomcat/5.0.12 响应头 Date:Mon,6Oct2003 13:23:42 GMT Content-Length:112 <html> 响应体 <body>响应体</body> </html> \"]},\"1039\":{\"h\":\"HTTP的首部字段\",\"t\":[\"HTTP 首部字段\",\"说明\",\"Host\",\"浏览器指定请求的服务器的域名或端口号\",\"User-Agent\",\"浏览器表明自己的身份，是哪种浏览器\",\"Accept\",\"指定客户端能够接收的内容类型\",\"Accept-Language\",\"浏览器可接受的语言\",\"Accept-Encoding\",\"指定浏览器可以支持的 Web 服务器返回内容压缩编码类型\",\"Accept-Charset\",\"浏览器可以接受的字符编码集\",\"Connection\",\"指定与连接相关的属性，如：（Keep-Alive，长连接）\",\"在服务器生成并发送 Cookie 时，Cookie 会和 path 地址绑定，浏览器发送请求的路径与 Cookie 的 path 属性一致时，这个请求才会带上这个 Cookie。\"]},\"1040\":{\"h\":\"HTTP方法与状态码\",\"t\":[\"方法（操作）\",\"意义\",\"安全性\",\"OPTION\",\"请求一些选项的信息\",\"安全\",\"GET\",\"请求读取有URL所标志的信息\",\"安全\",\"POST\",\"给服务器添加信息\",\"不安全\",\"HEAD\",\"请求读取由URL所标志的信息的首部\",\"安全\",\"PUT\",\"在指明的URL下存储一个文档\",\"不安全\",\"DELETE\",\"删除指明的URL所标志的资源\",\"不安全\",\"TRACE\",\"用来进行环回测试的请求报文\",\"CONNECT\",\"用于代理服务器\",\"状态码分类：\",\"状态码\",\"意义\",\"类别\",\"1xx\",\"通知信息，如请求收到了或正在处理。\",\"信息性状态码\",\"2xx\",\"请求正常处理完毕\",\"成功状态码\",\"3xx\",\"重定向，需要进行附加操作以完成请求\",\"重定向状态码\",\"4xx\",\"客户端的差错，如请求中有一些错误的语法或不能完成。\",\"客户端错误状态码\",\"5xx\",\"服务器的差错，如服务器失效无法完成请求。\",\"服务器错误状态码\",\"HTTP 哪些常用的状态码及使用场景？\",\"101 切换请求协议，从 HTTP 切换到 WebSocket\",\"200 请求成功，有响应体\",\"301 永久重定向：会缓存 。指页面永久性转移，表示资源或页面永久性地转移到了另一个位置。\",\"302 临时重定向：不会缓存。指页面暂时性转移，表示资源或页面暂时转移到另一个位置，常被用作网址劫持，容易导致网站降权，严重时网站会被封掉，不推荐使用。\",\"304 协商缓存命中\",\"403 服务器禁止访问\",\"404 资源未找到\",\"400 请求错误\",\"500 服务器端错误\",\"503 服务器繁忙\"]},\"1041\":{\"h\":\"POST和GET的区别与应用场景\",\"t\":[\"GET 用于获取资源，而 POST 用于传输实体主体\",\"区别：\",\"参数：GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在请求的实体主体中。\",\"安全性：安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。 GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。\",\"幂等性：幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。所有的安全方法也都是幂等的。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。\",\"可缓存：请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。\"]},\"1042\":{\"h\":\"HTTP 1.0/1.1/2.0/3.0\",\"t\":[\"HTTP 1.0\",\"​ HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。（注意可以强制开启持续连接，在请求和响应头设置Connection：keep-alive,但是这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法）\",\"​ 在TCP第三次握手的时候，浏览器就可以把HTTP请求报文，作为第三次报文的数据，发给服务器。可以看到，1.0版本的缺点是每请求一个文档都要进行3次握手和一个HTTP响应报文，总共2个RTT的时间。1.1版本中的持续连接就弥补了这个缺点。\",\"HTTP 1.1\",\"​ 相比较于HTTP 1.0来说，最主要的改进就是引入了持续连接。所谓的持续连接就是服务器在发送响应后，仍在一段时间内保持这条连接，使同一个客户和该服务器可以继续在这条连接上传送HTTP报文，即TCP连接默认不关闭，可以被多个请求复用。\",\"持续连接/长链接：方式有两种：\",\"非流水线：客户在收到前一个响应之后才能发出下一个请求，因此每访问一次对象，会有1个RTT的花销，比非持续连接的两倍RTT好一点。但是在服务器发完一个对象后，此TCP连接就处于空闲状态，浪费了服务器资源。\",\"流水线：客户在收到前一个响应之前就能发出下一个请求，服务器就可连接发回响应报文。因此，使用流水线方式，客户访问所有的对象只需一个RTT时间。\",\"管道机制：1.1版本还引入了管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。\",\"缺点：虽然有了持久连接和管道机制，大大提升了HTTP的效率。但是服务端还是按顺序执行的，效率还有提升空间。\",\"HTTP 2\",\"新的二进制格式\",\"​ HTTP1.1 基于文本格式传输数据；HTTP 2.0采用二进制格式传输数据，解析更高效。\",\"多路复用\",\"​ 通过 单一的HTTP/2连接请求发起多重请求-响应消息，多个请求stream共享一个TCP连接。实现多路并行并不依赖于建立多个TCP连接。\",\"​ 在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。能这样做有一个前提，就是HTTP 2进行了二进制分帧，即 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码。比如说，服务器需要处理客户端的A、B两个请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分，接着回应B请求，完成后，再发送A请求剩下的部分。而这个负责拆分、组装请求和二进制帧的一层就叫做二进制分帧层。\",\"头部压缩\",\"​ HTTP1.1的header带有大量信息，而且每次都要重复发送；HTTP2.0 把header从数据中分离，并封装成头帧和数据帧，使用特定算法压缩头帧，有效减少头信息大小。并且 HTTP2.0 在客户端和服务器端记录了之前发送的键值对，对于相同的数据，不会重复发送。比如请求a发送了所有的头信息字段，请求b则只需要发送差异数据，这样可以减少冗余数据，降低开销。\",\"服务端推送\",\"​ HTTP2.0 允许服务器向客户端推送资源，无需客户端发送请求到服务器获取。也就是说，服务器事先把一些客户端可能询问的事情提前发送到客户端的缓存上。\",\"HTTP 3\",\"HTTP 2.0 虽然性能不错，：建立连接时间长、队头阻塞问题（本质上是 TCP 的问题）\",\"HTTP 3.0 基于 UDP 实现，实现了类似 TCP 的多路数据流、传输可靠性等功能，称为QUIC（Quick UDP Internet Connection，快速 UDP 互联网连接）协议。\",\"队头阻塞问题：HTTP2.0 协议的多路复用机制解决了 HTTP 层的队头阻塞问题，。TCP 协议在收到数据包之后，这部分数据可能是乱序到达的，但是 TCP 必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。QUIC 协议是基于 UDP 协议实现的，，流与流之间是互不影响的，当一个流出现丢包影响范围非常小，从而解决队头阻塞问题。\",\"0RTT 建链：简单来说，基于 TCP 协议和 TLS 协议的 HTTP2.0 在真正发送数据包之前需要花费一些时间（至少一个RTT）来完成握手和加密协商，完成之后才可以真正传输业务数据。但是 ，从而在连接延时有很大优势，可以节约数百毫秒的时间。\",\"前向纠错（FEC）：QUIC 每发送一组数据就对这组数据进行异或运算，并将结果作为一个 FEC 包发送出去，接收方收到这一组数据后，根据数据包和 FEC 包即可进行校验和纠错。\",\"连接迁移：网络切换几乎时时刻刻都在发生。TCP 协议使用五元组来表示一条唯一的连接，，这时必须创建新的 TCP 连接才能继续传输数据。QUIC 协议基于 UDP 实现，摒弃了五元组的概念，使用 64 位的随机数作为连接的 ID，并使用该 ID 表示连接。基于 QUIC 协议之下，我们在日常 4G/5G 和 WIFI 切换时，或者不同基站之间切换都不会重连，从而提高业务层的体验。\"]},\"1043\":{\"h\":\"HTTPS\"},\"1044\":{\"h\":\"原理\",\"t\":[\"​ HTTPS 是加密传输，加密过程中使用了三种手段：证书、对称加密和非对称加密。\",\"​ HTTPS 相比于 HTTP 多了一层 TSL（安全传输层协议，SSL的升级版），使用 HTTPS 通讯时，一开始时不会太快，因为它们一开始要证书验证和协商密钥。\",\"HTTPS 的整体过程分为证书验证和数据传输阶段，具体的交互过程如下：\",\"​ 服务器在使用HTTPS前需要去认证的CA机构申请一份数字证书。\",\"客户端向服务器发起 HTTPS 的请求，连接到服务器的 443 端口\",\"服务器将非对称加密的公钥以数字证书的形式回传给客户端(数字证书中包含证书持有者、证书有效期和服务器公钥)\",\"客户端验证证书是否有效(CA机构有自己的私钥对数字证书加密，客户端用CA的公钥对证书解密，因为CA是工信机构会内置到浏览器或者操作系统中，所以客户端会有公钥)，如果无效，则弹出警告提示；如果有效，在本地生成一个随机数(对称秘钥的对称加密)，同时使用证书中的公钥加密随机数(非对称加密)，并且发送给服务器\",\"服务端使用私钥对随机数进行解密，然后服务端使用随机数构造对称加密算法，对网页内容加密返回给浏览器\",\"浏览器根据本地存储的随机数进行解密，得到最终的网页内容\"]},\"1045\":{\"h\":\"HTTPS 一定安全吗？\",\"t\":[\"​ HTTPS 不一定安全，一些网站会使用自签名证书。自签名证书是指不受信任的任意机构或个人，使用工具自己签发的 SSL 证书。不是从公共证书机构（CA）那里申请来的证书，没有第三方监督审核，不受浏览器和操作系统信任，常被用于伪造证书进行中间人攻击，劫持 SSL 加密流量。\"]},\"1046\":{\"h\":\"使用 HTTPS 会被抓包吗？\",\"t\":[\"​ 会被抓包，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。\"]},\"1047\":{\"h\":\"SSL\",\"t\":[\"​ SSL（Secure Sockets Layer，安全套接字协议），在传输层与应用层之间利用数据加密技术保障传输数据的安全。在发送方，SSL 接收应用层的数据（如：HTTP 报文），对数据进行加密，然后把加了密的数据送往传输层。在接收方，SSL 从 TCP 套接字读取数据，解密后把数据交给应用层。\"]},\"1048\":{\"h\":\"HTTP 和 HTTPS 的区别？\",\"t\":[\"开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；\",\"资源消耗：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；\",\"端口不同：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443；\"]},\"1049\":{\"h\":\"动态主机配置协议DHCP\",\"t\":[\"​ 为了把协议软件做成通用可移植的，可把协议软件参数化。把协议软件中给这些参数赋值的动作叫做协议配置。例如，连接到互联网的计算机的协议软件需要配置IP地址、子网掩码、默认路由器IP地址、域名服务器IP地址。手动配置易错，所以使用动态主机配置协议DHCP，它提供了一种机制，称为即插即用联网。这种机制允许一台计算机加入新的网络获取IP地址而不用手工参与。\",\"​ 若每个网络上都设置有一个DHCP服务器，那样太多了，因此现在是每个网络至少有一个DHCP中继代理（通常是一台路由器）。DHCP报文是UDP用户数据报的数据。\",\"​ 租期：一般在租期时间的1/2时，客户端会向给它分配IP地址的DHCP服务器发送一个单播请求报文。如果服务器判断客户端可以继续使用，那么回复一个ACK报文。不过不能续租，则回复NAK报文。假如在1/2时续约失败，则会在7/8时，广播方请求报文进行续约，DHCP服务器处理同首次分配IP地址的流程。\",\"过程：\",\"DHCP采用客户服务器方式，需要IP地址的主机在启动时就向DHCP服务器广播发送发现报文（将目的IP全置为1），此时该主机就成为了DHCP客户。\",\"该主机还需将IP数据报的源IP全设为0。这样，本地网络的主机都能收到该广播报文，但只有DHCP服务器（中继代理）会回答（DHPC服务器一看源IP都是0的请求，就知道生意来了）。但是网络上的DHCP服务器太多会造成浪费，所以使用DHPC中继代理。DHCP中继代理收到请求后，以单播的形式向DHCP服务器转发此报文。\",\"DHCP服务器首先在其数据库中查找该主机的配置信息，若找到，返回该信息；若没有，则从服务器的IP地址池中获取一个地址分配给该计算机，DHCP回答报文叫做提供（offer）报文。（内容包括：ip地址、子网掩码、网关、ip的有效期等信息）\",\"我们知道，有可能不止一台DHCP中继代理都到了发现报文，主机也因此可能收到多个offer报文。所以主机会选择一个ip地址（一般是第一个收到的ip），并向对应的服务器发送一个request报文（意在告诉这台服务器，我看中这个ip了）。DHCP收到报文后，会给客户主机回复一个ACK报文，并把这个分配出去的ip进行登记。\"]},\"1050\":{\"h\":\"Cookie、Session、Token\",\"t\":[\"Cookie、Session、Token区别\"]},\"1051\":{\"h\":\"Cookie(保存在客户端)\",\"t\":[\"​ 由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。\",\"​ Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。\"]},\"1052\":{\"h\":\"Session(保存在服务端)\",\"t\":[\"​ Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。\",\"​ **如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。**Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。 ​ session有一个缺陷：session无法跨域，也就是说如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。总不能把Session在不同的机子上复制来复制去，解决方案是：\",\"使用Session Sticky，即让一个用户请求一直粘在一个服务器上。但是这台机器挂了就没办法了。\",\"使用一个单独的机器来存储Session id，所有的访问都经过一遍，这样还得把这个机器搞成集群，负担太大。\"]},\"1053\":{\"h\":\"Token\",\"t\":[\"基于Token的身份验证的过程如下:\",\"用户通过用户名和密码发送请求。\",\"程序验证。\",\"程序返回一个签名的token 给客户端。\",\"客户端储存token,并且每次用于每次发送请求。\",\"服务端验证token并返回数据。服务器端只需要保存token的密钥即可。\"]},\"1054\":{\"h\":\"被动攻击和主动攻击\",\"t\":[\"​ 计算机网络的通信面临两大类威胁，即被动攻击和主动攻击。\",\"被动攻击：\",\"是指攻击者网络上窃听他人的通信内容，通常称为截获。\",\"在被动攻击中，攻击者只是观察和分析某一个协议数据单元。\",\"主动攻击：\",\"篡改：故意篡改网络上发送的报文，包括彻底中断发送的报文，并把伪造的报文发给对方。\",\"恶意程序：包括计算机病毒、计算机蠕虫（一种通过网络通信将自身从一个结点发送到另一个节点并自动启动的程序）、特洛伊木马（执行的功能并非声称的功能）、逻辑炸弹（满足某种条件时执行特殊功能）、后门入侵（利用系统漏洞入侵系统）、流氓软件。\",\"拒绝服务DOS：指攻击者向互联网上的某个服务器不停发送大量分组，使该服务器无法提供正常服务。若从互联网上的成百上千个网络集中攻击一个网站，称为分布式拒绝服务DOS。\",\"SYN Flood（不握第三次手）： 又称 SYN 洪水攻击，也是拒绝服务攻击的一种，是一种曾经很经典的攻击方式。攻击者利用TCP协议的安全缺陷，不断发送一系列的SYN请求到目标系统，消耗服务器系统的资源，从而导致目标服务器不响应合法流量请求。（发生在TCP三次握手阶段，使用虚拟IP向服务器发送请求，但不再回应，也就是第三次手不握了，让服务器等待）。\"]},\"1055\":{\"h\":\"什么是安全的计算机网络？\",\"t\":[\"保密性：只有信息发送接收的双方能够懂得信息内容，为此需要使用各种密码技术。\",\"端点鉴别：必须能够鉴别发送方和接收方的真实身份。\",\"信息的完整性：需要保证信息没有被篡改过。\",\"运行的安全性：访问控制（对访问网路的权限进行控制）对系统安全性非常重要。\"]},\"1056\":{\"h\":\"对称加密 & 非对称加密\",\"t\":[\"​ 对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。\",\"​ 而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。\",\"​ 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢（对称加密的加密效率通常为非对称加密的千倍左右），所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。\"]},\"1057\":{\"h\":\"数字签名 & 数字证书\",\"t\":[\"数字签名\",\"​ 数字签名是非对称加密算法和摘要算法的一种应用，能够保证信息在传输过程中不被篡改，也能保证数据不被伪造。\",\"​ 使用时，发送方使用摘要算法获得发布内容的摘要，然后，然后。接收方接收到内容后，首先取出公钥解密数字签名，获得正文的摘要数据，然后使用相同的摘要算法计算发布内容的摘要，将计算的摘要与解密的摘要进行比较，若一致，则说明发布内容没有被篡改。\",\"​ 实际上，单一的数字签名应用，可能会存在安全风险。假设发送方为 A，接收方为 B，出现的一个不安全分子 M，，结果半道被 M 截获了， M 修改了发布内容，用自己的私钥生成了数字签名，然后将修改的发布内容、M 的数字签名、 M 的公钥发送给了了 B， B 接收时验证一样可通过，但实际上接收的已经是被篡改的数据。实际使用中，。\",\"数字证书\",\"​ 上面提到我们对数字签名进行验证时，需要用到公钥。如果公钥是伪造的，那我们无法验证数字签名了，也就根本不可能从数字签名确定对方的合法性了，。由一个统一的证书管理机构来管理所有需要发送数据方的公钥，对公钥进行认证和加密。。\",\"​ CA 机构使用自己的私钥对申请者的公钥加密，发送数据时，，对方拿到证书后，需要使用 CA 机构提供的 “统一密钥对” 中的公钥对证书解密，拿到发送方的公钥，然后解密发送方发过来的数字签名，重新计算摘要作对比，以验证数据内容的完整性。\"]},\"1058\":{\"h\":\"网络攻击\"},\"1059\":{\"h\":\"DNS劫持\",\"t\":[\"DNS劫持/域名劫持\"]},\"1060\":{\"h\":\"SYN攻击\",\"t\":[\"SYN FLOOD\",\"SYN 攻击利用 TCP 协议三次握手的原理，它的过程：\",\"Client 伪造大量的虚假 IP，向服务器端发送 SYN 包，也就是伪造第一次握手数据包\",\"服务器端在收到 SYN 包后，会返回响应，并进入 SYN_RECV 状态，等待客户端的确认\",\"但是伪造的 IP 肯定不会给予响应，于是服务器端认为数据包丢失，就会不断重发，直至超时\",\"​ 这些伪造的 SYN 包会长期占用半连接队列，当攻击的 SYN 包超过半连接队列的最大值时（设置 Backlog 参数），正常客户发送 SYN 数据包请求连接就会被服务器丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。\",\"防御方法\",\"对 SYN 包进行监视，如果发现某个 IP 发起了较多的攻击报文，采用防火墙或直接将这个 IP 列入黑名单即可\",\"无效连接监视释放，不停监视系统的半连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源\",\"降低 SYN timeout 时间，使得主机尽快释放半连接\",\"延缓 TCB 分配方法，消耗服务器资源主要是由于当 SYN 数据报文一到达，系统立即分配 TCB，从而占用了资源。而 SYN Flood 由于很难建立起正常连接，因此，当正常连接建立起来后再分配 TCB 则可以有效地减轻服务器资源的消耗。常见的方法是使用 SYN Cache 和 SYN Cookie 技术\"]},\"1061\":{\"h\":\"如何防止 cookie 被盗用？\",\"t\":[\"HttpOnly\",\"为了防止用户通过 js 修改伪造 cookie，可以设置 cookie 的 HttpOnly 属性为true，如果 cookie 中设置了 HttpOnly 属性，且为 true，那么通过 js 脚本将无法读取到 cookie 信息，这样就能有效的防止 XSS 攻击，防止 cookie 内容被盗窃。\",\"使用 https 协议替代普通 http 协议\",\"既然无法伪造 cookie 了，但还是可以通过抓包获取其它用户的 cookie，毕竟 cookie 是在网络中传输的，为了防止 cookie 被中间人劫持，我们就可以用 https 协议代替普通的 http 协议，这样恶意用户抓到的报文已经是密文了，也就不知道 cookie 了。\"]},\"1062\":{\"h\":\"SSL、TLS\",\"t\":[\"SSL/TLS是一种密码通信框架，是世界上使用最广泛的密码通信方法。SSL/TLS综合运用了密码学中的对称密码，消息认证码，公钥密码，数字签名，伪随机数生成器等，可以说是密码学中的集大成者。\",\"SSL(Secure Socket Layer)安全套接层，是1994年由Netscape公司设计的一套协议。\",\"TLS(Transport Layer Security)传输层安全是IETF在SSL3.0基础上设计的协议，实际上相当于SSL的后续版本。\",\"应用\",\"SSL/TLS是一个安全通信框架，上面可以承载HTTP协议或者SMTP/POP3协议等。\",\"TLS协议的架构\",\"TLS主要分为两层：\",\"底层的是TLS记录协议，主要负责使用对称密码对消息进行加密。\",\"上层的是TLS握手协议，主要分为握手协议，密码规格变更协议和应用数据协议4个部分： \",\"握手协议负责在客户端和服务器端商定密码算法和共享密钥，包括证书认证，是4个协议中最最复杂的部分。\",\"密码规格变更协议负责向通信对象传达变更密码方式的信号。\",\"警告协议负责在发生错误的时候将错误传达给对方。\",\"应用数据协议负责将TLS承载的应用数据传达给通信对象的协议。\"]},\"1063\":{\"h\":\"设计模式\"},\"1064\":{\"h\":\"设计模式六大原则\",\"t\":[\"最终目的：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。\",\"开放封闭原则\",\"思想：对拓展开放，对修改关闭。尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化\",\"优点：提高复用性、维护性。\",\"单一职责原则\",\"思想：一个类只干一件事，实现类要单一\",\"优点：降低类的复杂度。提高类的可读性。提高系统的可维护性。变更引起的风险降低。\",\"里氏替换原则\",\"思想：继承必须确保超类所拥有的性质在子类中仍然成立。通俗来讲就是：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。\",\"优点：通过重写父类的方法来完成新的功能写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。\",\"依赖倒置原则\",\"思想：高层不应该依赖低层，面向接口编程\",\"高层模块不应该依赖低层模块，两者都应该依赖其抽象\",\"抽象不应该依赖于具体实现\",\"具体实现应该依赖于抽象\",\"优点：依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。\",\"接口隔离原则\",\"思想：一个类对另一个类的依赖应该建立在最小的接口上。建立单一接口，不要建立臃肿庞大的接口，接口尽量细化，同时接口中的方法尽量少。\",\"优点：提高程序的灵活度，提高内聚，减少对外交互，使得最小的接口做最多的事情\",\"迪米特法则\",\"思想：一个类尽量减少自己对其它对象的依赖。如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。\",\"优点：高内聚，低耦合\",\"合成复用原则\",\"思想：在软件复用时，要尽量优先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\"]},\"1065\":{\"h\":\"单例模式\",\"t\":[\"单例模式，顾名思义就是保证一个类只有一个实例，避免一个全局使用的类频繁创建与销毁对象实例，减少了内存开销。\",\"实现\",\"大的方面可以分为 5 种：\",\"饿汉式（静态常量、静态代码块）\",\"懒汉式（静态代码块、线程不安全、同步方法、同步代码块）\",\"双层校验锁\",\"静态内部类\",\"枚举\"]},\"1066\":{\"h\":\"饿汉式\",\"t\":[\"类加载就会导致该单实例对象被创建。\",\"public class Singleton{ //1. 将构造方法私有化，以防外界通过该构造方法创建多个实例 private Singleton(){}; //2. 在本类内部创建对象实例 private final static Singleton uniqueInstance = new Singleton(); //3. 提供一个公有的静态方法， 返回实例对象 public static Singleton getInstance(){ return Singleton.uniqueInstance; } } \",\"public class Singleton{ //1.构造器私有化，外部不能new private Singleton(){}; //2. 本类内部创建对象实例 private static UniqueInstance; static{ uniqueInstance = new Singleton(); } //3. 提供一个公有的静态方法， 返回实例对象 public static Singleton getInstance(){ return Singleton.uniqueInstance; } } \"]},\"1067\":{\"h\":\"懒汉式\",\"t\":[\"提供一个静态的公有方法，当使用到该方法时，才去创建实例对象。\",\"public class Singleton { private static Singleton uniqueInstance; private Singleton() { } public static Singleton getUniqueInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } } \",\"public class Singleton { private static Singleton uniqueInstance; private Singleton() { } public static synchronized Singleton getUniqueInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } } \",\"public class Singleton { private static Singleton uniqueInstance; private Singleton() { } public static Singleton getUniqueInstance() { if (uniqueInstance == null) { synchronized(Singleton.class){ uniqueInstance = new Singleton(); } } return uniqueInstance; } } \",\"​ 在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 uniqueInstance = new Singleton(); 这条语句，只是先后的问题，那么就会进行两次实例化。\"]},\"1068\":{\"h\":\"双重检测锁（推荐使用）\",\"t\":[\"public class Singleton{ private static volatile Singleton uniqueInstance; private Singleton() { } //提供一个静态的公有方法， 加入双重检查代码， 解决线程安全问题, 同时解决懒加载问题 public static Singleton getUniqueInstance() { if (uniqueInstance == null) { synchronized(Singleton.class){ if (uniqueInstance == null) { uniqueInstance = new Singleton(); } } } return uniqueInstance; } } \",\"为什么两次 if 判断？\",\"外层判断提高效率，内层判断为了防止多次实例化对象\",\"为什么加 volatile？\",\"使用 volatile 的目的是：避免指令重排序\",\"双重检查锁定的问题是：\",\"​ singleton = new Singleton();该语句非原子操作，实际是三个步骤：给 singleton 分配内存；调用 Singleton 的构造函数来初始化成员变量；将给 singleton 对象指向分配的内存空间（此时 singleton 才不为 null）。\",\"​ 编译器有可能进行指令重排优化，可能分配内存并修改指针后未初始化 ，导致其它人拿到的对象就可能是个不完整的对象。举个例子，第一个线程初始化对象到一半，第二个线程来发现已经不是 null 了就直接返回了 实际上该对象此时还没有完全初始化 可能会出现这个问题。\"]},\"1069\":{\"h\":\"静态内部类（推荐使用）\",\"t\":[\"​ 静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。，并且没有任何性能影响和空间的浪费。 这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持，效率较高。\",\"public class Singleton { private Singleton() { } //写一个静态内部类,该类中有一个静态属性 Singleton private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getUniqueInstance() { return SingletonHolder.INSTANCE; } } \"]},\"1070\":{\"h\":\"枚举实现（推荐使用）\",\"t\":[\"​ 枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。\",\"public enum EnumSingleton { INSTANCE; public EnumSingleton getInstance(){ return INSTANCE; } } //完整版 public class User { //私有化构造函数 private User(){ } //定义一个静态枚举类 static enum SingletonEnum{ //创建一个枚举对象，该对象天生为单例 INSTANCE; private User user; //私有化枚举的构造函数 private SingletonEnum(){ user=new User(); } public User getInstnce(){ return user; } } //对外暴露一个获取User对象的静态方法 public static User getInstance(){ return SingletonEnum.INSTANCE.getInstnce(); } } \",\"。\"]},\"1071\":{\"h\":\"单例模式的优点\",\"t\":[\"在内存中只有一个对象，节省内存空间。\",\"避免频繁的创建销毁对象，可以提高性能。\",\"避免对共享资源的多重占用。\",\"可以全局访问。\"]},\"1072\":{\"h\":\"单例模式的缺点\",\"t\":[\"扩展困难，由于 getInstance 静态函数没有办法生成子类的实例。如果要拓展，只有重写那个类。\",\"隐式使用引起类结构不清晰。\",\"导致程序内存泄露的问题。\"]},\"1073\":{\"h\":\"单例模式的适用场景\",\"t\":[\"需要频繁实例化然后销毁的对象。\",\"创建对象时耗时过多或者耗资源过多，但又经常用到的对象。\",\"资源共享的情况下，避免由于资源操作时导致的性能或损耗等。\",\"控制资源的情况下，方便资源之间的互相通信。\"]},\"1074\":{\"h\":\"单例模式注意事项\",\"t\":[\"只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。\",\"不要做断开单例类对象与类中静态引用的危险操作。\",\"多线程使用单例使用共享资源时，注意线程安全问题。\"]},\"1075\":{\"h\":\"单例模式常见问题\",\"t\":[\"单例模式的对象长时间不用会被 jvm 垃圾收集器收集吗？\",\"除非人为地断开单例中静态引用到单例对象的连接，否则 jvm 垃圾收集器是不会回收单例对象的。\",\"jvm 卸载类的判定条件如下：\",\"该类所有的实例都已经被回收，也就是 java 堆中不存在该类的任何实例。\",\"加载该类的 ClassLoader 已经被回收。\",\"该类对应的 java.lang.Class 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。\",\"只有三个条件都满足，jvm 才会在垃圾收集的时候卸载类。显然，单例的类不满足条件一，因此单例类也不会被回收。\",\"在一个 jvm 中会出现多个单例吗？\",\"​ 在分布式系统、多个类加载器、以及序列化的情况下，会产生多个单例，这一点是无庸置疑的。那么在同一个 jvm 中，会不会产生单例呢？使用单例提供的 getInstance()方法只能得到同一个单例，除非是使用反射方式，将会得到新的单例。因此，在使用单例模式的时候，一定不要使用反射产生新的对象。\"]},\"1076\":{\"h\":\"工厂模式\",\"t\":[\"​ 如果创建对象时直接 new 对象，造成程序间耦合严重。在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。所以说，工厂模式最大优点是：解耦\"]},\"1077\":{\"h\":\"简单工厂模式\",\"t\":[\"​ 简单工厂把实例化的操作单独放到一个类中，这个类就称为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。要点：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节 。\",\"​ 这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。\",\"实现\",\"public interface Product { } \",\"public class ConcreteProduct implements Product { } \",\"public class ConcreteProduct1 implements Product { } \",\"public class ConcreteProduct2 implements Product { } \",\"以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。\",\"public class Client { public static void main(String[] args) { int type = 1; Product product; if (type == 1) { product = new ConcreteProduct1(); } else if (type == 2) { product = new ConcreteProduct2(); } else { product = new ConcreteProduct(); } // do something with the product } } \",\"以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。\",\"public class SimpleFactory { public Product createProduct(int type) { if (type == 1) { return new ConcreteProduct1(); } else if (type == 2) { return new ConcreteProduct2(); } return new ConcreteProduct(); } } \",\"public class Client { public static void main(String[] args) { SimpleFactory simpleFactory = new SimpleFactory(); Product product = simpleFactory.createProduct(1); // do something with the product } } \",\"不足：违反了开闭原则。工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂 。\",\"应用：\",\"JDK 类库中广泛使用了简单工厂模式，如工具类 java.text.DateFormat，它用于格式化一个本地日期或者时间\",\"Java 加密技术\"]},\"1078\":{\"h\":\"工厂方法模式\",\"t\":[\"和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂，核心工厂类不再负责产品的创建。\",\"优点：用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。\",\"缺点：类的个数容易过多，增加复杂度。抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。\"]},\"1079\":{\"h\":\"抽象工厂模式\",\"t\":[\"​ 前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。\",\"​ 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。\",\"定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。\",\"模式的结构\",\"AbstractFactory 抽象工厂：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。\",\"ConcreterFactory 具体工厂：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。\",\"AbstractProduct 抽象产品：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。\",\"Product 具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。\",\"优点\",\"可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。\",\"抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。\",\"缺点\",\"当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。\",\"应用场景与具体应用\",\"抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。\",\"当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。\",\"系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。\"]},\"1080\":{\"h\":\"工厂模式的退化\",\"t\":[\"当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；\",\"当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。\"]},\"1081\":{\"h\":\"代理模式\",\"t\":[\"给某对象提供一种代理以控制对这个对象的访问，代理对象可以扩展目标对象的功能。静态代理类在运行前就写好，而动态代理类是在 Java 运行时动态生成。\",\"在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\"]},\"1082\":{\"h\":\"静态代理\",\"t\":[\"​ 静态代理需要在运行之前就写好代理类，如果接口增加一个方法，目标类和代理都要实现该方法，增加代码维护复杂度，所以我们通过动态代理在运行期间动态生成业务类的代理类。\",\"//抽象角色 public interface SellTickets { void sell(); } //火车站（具有卖票功能，所以需要实现SellTickets） public class TrainStation implements SellTickets { public void sell() { System.out.println(\\\"火车站卖票\\\"); } } //代理角色：代售点 public class ProxyPoint implements SellTickets { private TrainStation station = new TrainStation(); //方法增强 public void sell() { System.out.println(\\\"代理点收取一些额外费用\\\"); station.sell(); } } //测试类：客户角色 public class Client { public static void main(String[] args) { ProxyPoint pp = new ProxyPoint(); pp.sell(); } } \"]},\"1083\":{\"h\":\"动态代理\",\"t\":[\"动态代理是一种较为高级的代理模式，它的典型应用就是Spring AOP。传统代理模式存在的问题：\",\"在传统的代理模式中，客户端通过 Proxy 调用 RealSubject 类的 request()方法，同时还在代理类中封装了其他方法(如 preRequest()和 postRequest())，可以处理一些其他问题。\",\"如果按照这种方法使用代理模式，那么真实主题角色必须是事先已经存在的，并将其作为代理对象的内部成员属性。如果一个真实主题角色必须对应一个代理主题角色，这将导致系统中的类个数急剧增加，因此需要想办法减少系统中类的个数，此外**，如何在事先不知道真实主题角色的情况下使用代理主题角色，这都是动态代理需要解决的问题。**\",\"JDK 官方提供了一个动态代理类 Proxy，它提供了一个创建代理对象的静态方法（newProxyInstance 方法）来获取代理对象。\",\"//客户角色，测试 public class Client { //获取代理对象 ProxyFactory factory = new ProxyFactory(); SellTickets proxyObject = factory.getProxyObject(); proxyObject.sell(); } \"]},\"1084\":{\"h\":\"CGLIB 代理\",\"t\":[\"静态代理和动态代理中，目标类和代理类都实现了同样的接口。。\",\"CGLIB 是第三方提供的包，它为没有实现接口的类提供代理，为 JDK 动态代理提供了很好的补充。\",\"CGLIB 代理类属于目标类的子类\",\"通过代理对象调用 sell（）方法，实质执行的是 intercept（）方法\"]},\"1085\":{\"h\":\"装饰器模式\",\"t\":[\"定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。\",\"装饰器模式的主要优点有：\",\"装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用\",\"通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果\",\"主要缺点：装饰器模式会增加许多子类。\",\"结构\",\"抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。\",\"具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。\",\"抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。\",\"具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。\"]},\"1086\":{\"h\":\"建造者模式\",\"t\":[\"定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。\",\"建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。如果创建简单对象，通常都是使用工厂模式进行创建，而如果创建复杂对象，就可以考虑使用建造者模式。\",\"优点：\",\"封装性好，构建和表示分离，客户端不必知道产品内部组成的细节\",\"扩展性好，各个具体的建造者相互独立，有利于系统的解耦\",\"结构\",\"多产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。\",\"抽象建造者（Builder）：包含创建产品各个子部件的抽象方法的接口，还包含一个返回产品方法 getResult()。\",\"具体建造者（Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。\",\"指挥者（Director）：调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。\",\"应用\",\"KFC 套餐：建造者模式可以用于描述 KFC 如何创建套餐：套餐是一个复杂对象，它一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、 可乐等）等组成部分，不同的套餐有不同的组成部分，而 KFC 的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。\",\"在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物。\",\"建造者模式应用实例\"]},\"1087\":{\"h\":\"模板方法模式\",\"t\":[\"​ 在面向对象程序设计过程中，常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。例如：去银行办理业务一般要经过以下 3 个流程：取号、排队、办理具体业务，其中取号、排队对每个客户是一样的，可以在父类中实现，提高代码复用性，但办理具体业务因人而异，可能是存款、取款或转账，可以延迟到子类中实现。\",\"定义：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。\",\"结构\",\"抽象类/抽象模板：负责给出一个算法的轮廓和骨架，它由一个模板方法和若干个基本方法构成。\",\"模板方法：定义算法骨架，按某种顺序调用其包含的基本方法。\",\"基本方法：是整个算法中的一个步骤，包含以下几种类型： \",\"抽象方法：在抽象类中声明，由具体子类实现。比如办理具体业务。\",\"具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。比如取号、排队。\",\"钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。\",\"具体子类/具体实现：\",\"​ 实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。\",\"JDK 源码解析\",\"InputStream 类就使用了模板方法模式。在 InputStream 类中定义了多个read()方法，如下：\",\"​ 在 InputStream 父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取 len 个字节数据。具体如何读取一个字节数据呢？由子类实现。如：FileInputStream 中实现了 read( ) 方法。\"]},\"1088\":{\"h\":\"策略模式\",\"t\":[\"​ 该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。\",\"优点：\",\"多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句，如 if...else 语句、switch...case 语句。\",\"缺点：\",\"客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。\",\"策略模式造成很多的策略类，增加维护难度。\",\"结构\",\"抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。\",\"具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。\",\"环境（Context）类：持有一个策略类的引用，最终给客户端调用。\"]},\"1089\":{\"h\":\"策略模式在 JDK 中的应用\",\"t\":[\"线程池中的拒绝策略\",\"​ 线程池的构造中有一个拒绝策略参数，默认是默认拒绝策略。其实这就是一个策略接口，可以在创建线程池的时候，传入不同的拒绝策略。\",\"比较器\",\"​ JDK 中大量使用了 Comparator 这个策略接口。集合排序我们比较熟悉的了，不同的排序规则其实就是不同的策略。这个策略模式使用了函数式编程接口，比较规则使用匿名内部类或者 Lambda 表达式就搞定了，不需要每个规则定义一个实现类，这样就大量省略策略类了。\"]},\"1090\":{\"h\":\"外观模式\",\"t\":[\"​ 在现实生活中，常常存在办事较复杂的例子，如办房产证或注册一家公司，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。软件设计也是这样，当一个系统的功能越来越强，子系统会越来越多，客户对系统的访问也变得越来越复杂。这时如果系统内部发生改变，客户端也要跟着改变，这违背了“开闭原则”，也违背了“迪米特法则”，所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标。\",\"​ 外观模式是“迪米特法则”的典型应用，现阶段各种第三方 SDK、开源类库，很大概率都会使用外观模式。\",\"定义\",\"​ 又叫作门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。\",\"结构\",\"外观（Facade）角色：为多个子系统对外提供一个共同的接口。\",\"子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。\",\"客户（Client）角色：通过一个外观角色访问各个子系统的功能。\",\"优点\",\"当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问\",\"当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性\",\"源码解析\",\"​ 使用 Tomcat 作为 web 容器时，当接收到浏览器发送过来的请求，Tomcat 会将请求信息封装成 ServletRequest 对象，ServletRequest 是一个接口，它还有一个子接口 HttpServletRequest，而我们知道该 request 对象肯定是一个 HttpServletRequest 对象的子实现类对象，实际上输出这个 request 对象发现是一个名为 RequestFacade 的类的对象。\"]},\"1091\":{\"h\":\"享元模式\",\"t\":[\"用于减少创建对象的数量，重用现有的同类对象，如果未找到匹配的对象，则创建新对象\",\"关键代码\",\"用 HashMap 存储这些对象，取值时如果 key = null，则新建对象；如果 key != null，说明集合中有，直接返回集合中的对象\",\"应用场景\",\"池技术：String 常量池、数据库连接池、缓冲池\",\"如：我们每次创建字符串对象时，都需要创建一个新的字符串对象的话，内存开销会很大，所以如果第一次创建了字符串对象 “devilzcl”，下次再创建相同的字符串 “devilzcl” 时，只是把它的引用指向 “devilzcl”，这样就实现了 “devilzcl” 字符串在内存中的共享。\"]},\"1092\":{\"h\":\"适配器模式\",\"t\":[\"两个不兼容的接口之间的桥梁，将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能够一起工作。\",\"适配器模式分为： & ，类适配器模式耦合度高，所以应用较少。它们两者都要定义一个适配器类来实现当前系统的业务接口，不同点在于：\",\"类适配器模式是现有组件库中已经存在的组件\",\"对象适配器模式是将现有组件库中已经实现的组件适配器类中\",\"适配器模式中包含的角色及其职责\",\"目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口\",\"适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口\",\"适配器（Adapter）类：它是一个转换器，通过，把适配者接口转换成目标接口\",\"应用场景\",\"以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致\",\"使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同\"]},\"1093\":{\"h\":\"事物\",\"t\":[\"​ 事物是抽象化的最终结果，分为结构事物、行为事物、分组事物和注释事物。\",\"结构事物\",\"行为事务\",\"分组事物\",\"注释事物\"]},\"1094\":{\"h\":\"图\",\"t\":[\"​ UML2.0 一共有 13 种图（UML1.5 定义了 9 种，UML2.0 增加了 4 种），分别是类图、对象图、构件图、部署图、活动图、状态图、用例图、时序图、协作图 9 种，以及包图、组合结构图、时间图、交互概览图 4 种。\"]},\"1095\":{\"h\":\"类间关系\",\"t\":[\"​ UML 将事物之间的联系归纳为 6 种，并用对应的图形类表示。下面根据类与类之间的耦合度从弱到强排列。UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。\"]},\"1096\":{\"h\":\"1.依赖关系（Dependency）\",\"t\":[\"​ 依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。\",\"​ 依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。\"]},\"1097\":{\"h\":\"2.关联关系（Association）\",\"t\":[\"​ 关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。\",\"​ 关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。\",\"​ 在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。如下是老师和学生的关系图，每个老师可以教多个学生，每个学生也可向多个老师学，他们是双向关联。\"]},\"1098\":{\"h\":\"3.聚合关系（Aggregation）\",\"t\":[\"​ 聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。\",\"​ 在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。\"]},\"1099\":{\"h\":\"4.组合关系（Composition）\",\"t\":[\"​ 组合关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 contains-a 关系。在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。\",\"​ 在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。\"]},\"1100\":{\"h\":\"5.泛化关系（Generalization）\",\"t\":[\"​ 泛化关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。\",\"​ 在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下所示。\"]},\"1101\":{\"h\":\"6.实现关系（Realization）\",\"t\":[\"​ 实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。\",\"​ 在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如下所示。\"]},\"1102\":{\"h\":\"project\"},\"1103\":{\"h\":\"0\",\"t\":[\"可以写点自己的项目\"]},\"1104\":{\"h\":\"\"},\"1105\":{\"h\":\"0 序\"},\"1106\":{\"h\":\"0 序\",\"t\":[\"操作系统\"]},\"1107\":{\"h\":\"\"},\"1108\":{\"h\":\"0 序\",\"t\":[\"把 python 单开一章是因为其有以下方向迥异的用途：\",\"deeplearning pytorch、tensorflow、keras、numpy 等制品库\",\"编写脚本处理代码、excel 表格等文件 pandas、re 等制品库 TODO:制品库待补充\"]},\"1109\":{\"h\":\"1 环境搭建\"},\"1110\":{\"h\":\"1.1 anaconda\"},\"1111\":{\"h\":\"1.1.1 conda 常用指令\"},\"1112\":{\"h\":\"服务端\"},\"1113\":{\"h\":\"服务端学习笔记\"},\"1114\":{\"h\":\"\"},\"1115\":{\"h\":\"0 序\",\"t\":[\"包含：\",\"github page 、github action bot\",\"vuepress\"]},\"1116\":{\"h\":\"Mysql\"},\"1117\":{\"h\":\"常见问题\",\"t\":[\"在 spring boot 集成 mysql 和 mybatis plus 时，若使用 mysql 的自增索引为主键，在 mapper.selectXXX(QueryWrapper)时会遇到数据映射错位的问题，例如表中 created_time 字段无法映射到 DO 的 createdTime 字段。\",\"解决方案：使用雪花 id 生成器代替 mysql 的自增索引作为主键\"]},\"1118\":{\"h\":\"Sql\"},\"1119\":{\"h\":\"语法\",\"t\":[\"-- 加锁 select ... for update -- 解决并发 insert into ... select \"]},\"1120\":{\"h\":\"Git\"},\"1121\":{\"h\":\"0 intro\",\"t\":[\"对于这一工作中最常用的版本管理工具，总是一边学一边用。现在觉得还是要懂一些复杂指令\",\"git 的四个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository 或 Git Directory)、git 仓库(Remote Directory)，文件在这四个区域之间的转换关系如下： \"]},\"1122\":{\"h\":\"1 Github\"},\"1123\":{\"h\":\"建立电脑和 github 之间的 ssh 连接\",\"t\":[\"见网站建设 > Github Pages\"]},\"1124\":{\"h\":\"ssh: connect to host github.com port 22: Connection refused\",\"t\":[\"这个问题是因为使用 ssh 连接 github 时，由于 github.com 的域名被污染（因为科学上网等原因），解决方案如下：\",\"修改 C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts 文件，添加一行：140.82.113.4 github.com\",\"刷新 DNS 缓存：命令提示符输入以下命令ipconfig /flushdns，按回车键\"]},\"1125\":{\"h\":\"2 开发分支和主分支之间的合并\"},\"1126\":{\"h\":\"早间操作：同步主分支到本地开发分支\",\"t\":[\"​ 切换到主分支并拉取最新代码\",\"git checkout dev-trunk git pull origin dev-trunk # 拉取远端最新 dev-trunk \",\"切回开发分支并合并主分支\",\"git checkout feature-wangjx git merge dev-trunk # 将 dev-trunk 合并到当前分支 \",\"​​ 处理可能的冲突\",\"若存在冲突，用 git status 查看冲突文件\",\"手动编辑文件解决冲突后标记为已解决：\",\"git add <冲突文件路径> git commit -m \\\"解决与 dev-trunk 的合并冲突\\\" # 提交冲突解决 \"]},\"1127\":{\"h\":\"晚间操作：推送开发分支并合并到主分支\",\"t\":[\"目标 ​​：将本地 feature-wangjx 的修改推送到远端，并触发向 dev-trunk 的合并\",\"​​ 提交本地开发分支的修改\",\"git add . # 添加所有修改到暂存区 git commit -m \\\"功能开发完成\\\" # 提交本地修改 \",\"​​ 推送本地分支到远端\",\"git push origin feature-wangjx # 推送本地分支到远端同名分支 \",\"​​ 发起合并请求（推荐方式）\",\"通过 Git 平台（GitHub/GitLab）创建 Pull Request，将 feature-wangjx 合并到 dev-trunk\",\"或通过命令行（需权限）：\",\"git checkout dev-trunk git pull origin dev-trunk # 再次确保主分支最新 git merge feature-wangjx # 合并开发分支 git push origin dev-trunk # 推送合并后的主分支 \"]},\"1128\":{\"h\":\"\"},\"1129\":{\"h\":\"0 序\",\"t\":[\"介绍一些实用开发小工具。\"]},\"1130\":{\"h\":\"1 FastStone Capture\",\"t\":[\"功能：支持截图并进行简单编辑\",\"使用场景：文档撰写、前端测绘、线上交流\",\"推荐指数：⭐\"]},\"1131\":{\"h\":\"2 沉浸式翻译\"},\"1132\":{\"h\":\"\"},\"1133\":{\"h\":\"0 序\",\"t\":[\"Markdown 官方教程\",\"Markdown 基本语法\"]},\"1134\":{\"h\":\"1 进阶\",\"t\":[\"想用 markdown 写一些酷酷的东西\",\"vuepress 内置了 markdown-it 插件来实现语法扩展。\",\"此外，vuepress 还内置了一些其他的 markdown 扩展，例如 emoji、目录、代码块，甚至在 Markdown 中直接使用 Vue 组件。更多内容见Markdown > 语法扩展\"]},\"1135\":{\"h\":\"\"},\"1136\":{\"h\":\"0 序\",\"t\":[\"maven 插件安装失败，maven 右侧边栏飘红问题解决方案：\",\"进入 org.maven.plugins 目录，删除现有插件，科学上网，然后再 maven reload 重新安装插件\"]},\"1137\":{\"h\":\"pnpm\"},\"1138\":{\"h\":\"0 intro\",\"t\":[\"pnpm 官方文档\",\"官方文档的 CLI 比较有用\"]},\"1139\":{\"h\":\"1 package.json\",\"t\":[\"node.js 官方 package.json 指南\",\"使用 pnpm 将 vuepress 的版本锁定在2.0.0rc.17\",\"其余依赖插件版本：\",\"\\\"devDependencies\\\": { \\\"@vuepress/bundler-vite\\\": \\\"2.0.0-rc.18\\\", \\\"@vuepress/plugin-slimsearch\\\": \\\"2.0.0-rc.61\\\", \\\"@vuepress/theme-default\\\": \\\"2.0.0-rc.61\\\", \\\"nodejs-jieba\\\": \\\"^0.2.1\\\", \\\"sass-embedded\\\": \\\"1.81.0\\\", \\\"vue\\\": \\\"^3.5.13\\\", \\\"vue-router\\\": \\\"^4.5.0\\\", \\\"vuepress\\\": \\\"2.0.0-rc.18\\\" } \",\"每次更新 package.json 中的版本号后运行pnpm update执行更新，更多 CLI 见页首的官方文档\"]},\"1140\":{\"h\":\"1.1 软件包版本\",\"t\":[\"在上面的描述中，已经看到类似以下的版本号：〜3.0.0 或 ^0.13.0。 它们是什么意思，还可以使用哪些其他的版本说明符？\",\"该符号指定了软件包能从该依赖接受的更新。\",\"鉴于使用了 semver（语义版本控制），所有的版本都有 3 个数字，第一个是主版本，第二个是次版本，第三个是补丁版本，详见规则。\",\"还可以在范围内组合以上大部分内容，例如：1.0.0 || >=1.1.0 <1.2.0，即使用 1.0.0 或从 1.1.0 开始但低于 1.2.0 的版本。\"]},\"1141\":{\"h\":\"2 镜像源地址配置\"},\"1142\":{\"h\":\"图像超分辨率重建\"},\"1143\":{\"h\":\"镜像源配置\",\"t\":[\"conda 镜像源配置参考此文章 https://blog.csdn.net/SUNYUAN0627/article/details/130181974 pip 镜像源配置参考此文章 https://blog.csdn.net/weixin_57950978/article/details/142653359\",\"# 配置镜像源 ## conda镜像源 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ ## pip镜像源 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple ## pip镜像源配置文件位置 C:\\\\Users\\\\jxwang\\\\AppData\\\\Roaming\\\\pip\\\\pip.ini # 设置搜索时显示通道地址 conda config --set show_channel_urls yes \"]},\"1144\":{\"h\":\"环境搭建\",\"t\":[\"# 创建虚拟环境 conda create -n BasicSR python=3.6 \",\"遇到问题 AttributeError: module 'lib' has no attribute 'X509_V_FLAG_CB_ISSUER_CHECK'\",\"解决方案\",\"pip uninstall pyOpenSSL pip install pyOpenSSL pip install pyOpenSSL --upgrade --可选 \",\"# 继续创建虚拟环境 conda create -n BasicSR python=3.6 # 切换虚拟环境 conda activate BasicSR # 进入项目路径 cd C:/Users/jxwang/Desktop/superresolution/BasicSR-master # 安装 requirements.txt pip install -r requirements.txt \",\"报错Exception: Building py-lmdb from source on Windows requires the \\\"patch-ng\\\" python module.\",\"解决方案\",\"# 安装 patch-ng pip install patch-ng # 继续安装 requirements.txt pip install -r requirements.txt \",\"遇到问题: D:\\\\ProgramData\\\\Anaconda3\\\\envs\\\\BasicSR\\\\include\\\\pyconfig.h(59): fatal error C1083: 无法打开包括文件: “io.h”: No such file or directory\",\"解决方案： 安装 visual studio 时勾选 C++/CLI 支持、windows 10 sdk \",\"# 继续安装requirements.txt pip install -r requirements.txt # 安装完成后就可以预测图片了 cd C:/Users/jxwang/Desktop/superresolution/BasicSR-master/inference python inference_swinir.py --input ../datasets/Set1 --patch_size 48 --model_path ../experiments/pretrained_models/SwinIR/001_classicalSR_DF2K_s64w8_SwinIR-M_x4.pth --output ../result/SwinIR_SRX8_DIV2K/Set1 \"]},\"1145\":{\"h\":\"使用 GPU 进行预测\",\"t\":[\"CPU 预测较慢，使用 GPU 预测图片。需要安装 CUDA cudnn pytorch-GPU，太费事了，文档如下：\",\"深度学习环境配置超详细教程\"]},\"1146\":{\"h\":\"\"},\"1147\":{\"h\":\"1 项目搭建\"},\"1148\":{\"h\":\"1.1 文档地址\",\"t\":[\"vue3.5.13 文档：vue\",\"vue-router4.5.0 文档：vue-router\",\"vite6.0.5 文档：vite\",\"pinia2.3.0 文档：pinia\",\"Vue.volar2.2.0 vscode 插件\",\"Visual Studio Code 1.90.2(user setup)\",\"less less\",\"i18n (language support)\",\"Ant Design5.0 ant design\"]},\"1149\":{\"h\":\"1.2 Visual Studio Code Plugins\",\"t\":[\"vscode 插件下载地址\"]},\"1150\":{\"h\":\"1.2.1 volar\",\"t\":[\"Vue.volar2.2.0 (Vue 官方推荐 Vue 插件)，不好用，推荐用 prettier 格式化 vue 代码。\"]},\"1151\":{\"h\":\"1.2.2 prettier\",\"t\":[\"Prettier - Code format 下载地址\",\"下载安装后，按如下方式修改格式化 vue 文件所使用的软件，js、json 等文件的格式化方式同样可在此设置\"]},\"1152\":{\"h\":\"1.2.3 copilot\",\"t\":[\"前端神器，代码自动补全，注释生成代码，代码生成注释\"]},\"1153\":{\"h\":\"\"},\"1154\":{\"h\":\"1 基础\"},\"1155\":{\"h\":\"元素的 ref 引用\",\"t\":[\"定义了 ref 属性的元素<element-a ref='elementARef'>会在挂载时注入对应名称的 ref 响应式变量const elementARef = ref(null)。即使对应名称的 ref 响应式变量定义在 hooks 内部也不影响注入。\",\"父组件可以通过子组件的 ref 访问子组件 defineExpose 暴露的函数/元素/变量\"]},\"1156\":{\"h\":\"计算属性\",\"t\":[\"直接修改 computed(()=>return )的值是无效的，因为即使修改了也会马上被计算覆盖\",\"computed 计算出的值是一个 ref 对象，访问其值需要.value，但是貌似也有例外\"]},\"1157\":{\"h\":\"监听\",\"t\":[\"watch 监听对象的属性的时候，需要()=>a.b.c 这样，直接 watch(a.b.c)监听不到\",\"watch 想监听对象内部的变化，需要加上{ deep: true }，否则监听不到内部变化\",\"Vue 会确保在 watch 触发监听器回调函数时，所有的 props 都已经更新到了最新的状态。\",\"watch(,,{immediate:true})可以使监听器在监听的变量初始化时立即执行一次，适合于监听懒加载的 drawer、modal 等组件的 open 事件\"]},\"1158\":{\"h\":\"2 深入组件\"},\"1159\":{\"h\":\"依赖注入\",\"t\":[\"注意：像以下这样在 async 函数内提供变量是无效的：\",\"import {onMonted} from 'vue' const init = async()=>{ await getInitEnums() provide('enumsData',enumsData)} onMonted(()=>{init()}) \",\"正确的注入就直接在变量定义之后 provide 就好了，inject 之后默认就是响应式的\"]},\"1160\":{\"h\":\"3 风格指南\"},\"1161\":{\"h\":\"hooks 风格封装\",\"t\":[\"将有复用价值的 script setup 内容（可以包含一些变量和函数）封装成一个 js，放在 hooks 目录中\"]},\"1162\":{\"h\":\"script setup 风格代码组织顺序\",\"t\":[\"<script setup> // 1. 导入声明 // 2. 接收 props 和 emit // 使用hooks // 3. 定义响应式状态 // 4. 定义计算属性 // 5. 定义侦听器 // 6. 定义方法 // 7. 定义生命周期钩子 // 8. 提供/注入 (如果适用) // 9. 使用插槽 (如果适用) // 10. 使用 attrs (如果适用) <script> \"]},\"1163\":{\"h\":\"组织项目的注意事项\",\"t\":[\"注意从 vue 文件抽象出可以复用的 hooks 的时机\",\"子组件中需要与其他组件共享的数据最好用 computed 计算属性与父组件双向绑定，不然代码很多 props 和 defineExpose 会很乱\",\"使用 Echarts 绘图时注意 chart-container 的宽高问题，在容器宽高渲染完成后渲染（Echart 容器），就不会高度宽度塌陷\"]},\"1164\":{\"h\":\"4 常见问题\"},\"1165\":{\"h\":\"import { watch } from 'less'\",\"t\":[\"问题描述：见标题\",\"问题分析：引用错了\"]},\"1166\":{\"h\":\"\"},\"1167\":{\"h\":\"常用指令\",\"t\":[\"购买了一台阿里云的 99 服务器实例，也是圆梦了 🌸 Alibaba Cloud Linux 基于 centos，安装包管理工具是 yum(2)或 dnf(3)\"]},\"1168\":{\"h\":\"安装 cmake\",\"t\":[\"dnf install cmake ## 报错 ssl.c:55:10: fatal error: openssl/ssl.h: No such file or directory 55 | #include <openssl/ssl.h> ## 清除已安装文件 make distclean ## 安装ssl dnf install openssl \"]},\"1169\":{\"h\":\"建一个用户\"},\"1170\":{\"h\":\"装一个 redis\",\"t\":[\"基本上参照 github 的教程去装https://github.com/redis/redis，里面有一些步骤比如设置python venv，不知道是干嘛的，好像不做这个操作也可以装上\",\"## 获取源码 wget -O redis-8.0.2.tar.gz https://github.com/redis/redis/archive/refs/tags/8.0.2.tar.gz ## 解压 tar -xzvf redis-8.0.2.tar.gz cd redis-8.0.2 make \"]},\"1171\":{\"h\":\"\"},\"1172\":{\"h\":\"安装部署\"},\"1173\":{\"h\":\"设计模式\",\"t\":[\"学习一些常用设计模式\"]},\"1174\":{\"h\":\"\"},\"1175\":{\"h\":\"docker\"},\"1176\":{\"h\":\"docker 部署 mysql\"},\"1177\":{\"h\":\"部署过程\",\"t\":[\"## 拉取 docker 镜像 docker pull mysql:latest ## 创建配置目录与优化配置文件 mkdir -p ~/mysql/config # 配置文件目录 mkdir -p ~/mysql/data # 数据目录（自动创建，无需手动操作） mkdir -p ~/mysql/mysql-files ## 创建优化后的MySQL配置文件（适合2核2G服务器） cat > ~/mysql/config/my.cnf << EOF [mysqld] # 基础设置 port = 3306 bind-address = 0.0.0.0 # 允许外部连接 default-storage-engine = InnoDB # 字符集设置（新增！解决密码验证问题） character-set-server = utf8mb4 collation-server = utf8mb4_unicode_ci # 内存优化（关键参数！） innodb_buffer_pool_size = 512M # 缓冲池大小，占物理内存的30% innodb_log_file_size = 64M # 日志文件大小 innodb_log_buffer_size = 8M # 日志缓冲区 key_buffer_size = 16M # MyISAM索引缓存 sort_buffer_size = 2M # 排序缓冲区 read_buffer_size = 1M # 读取缓冲区 join_buffer_size = 2M # 连接缓冲区 max_connections = 100 # 限制最大连接数 max_allowed_packet = 16M # 最大允许数据包大小 # 性能优化 innodb_flush_log_at_trx_commit = 2 # 牺牲一点持久性换取性能 sync_binlog = 1 # 改为1以确保数据安全（原为0） innodb_thread_concurrency = 4 # 限制InnoDB线程数（2核服务器建议4） # 日志设置（可选） slow_query_log = 1 slow_query_log_file = /var/lib/mysql/slow.log long_query_time = 2 EOF ## 使用 Docker 命令启动 MySQL docker run -itd --name mysql-myblog -p 3306:3306 -e MYSQL_ROOT_PASSWORD=208941 --mount type=bind,source=\\\"$(pwd)\\\"/mysql/config/my.cnf,target=/etc/mysql/my.cnf --mount type=bind,source=\\\"$(pwd)\\\"/mysql/data,target=/var/lib/mysql --mount type=bind,source=\\\"$(pwd)\\\"/mysql/mysql-files,target=/var/lib/mysql-files mysql ## 启动失败删除mysql容器 docker stop mysql-myblog && docker rm mysql-myblog ## 启动成功登录mysql docker exec -it mysql-myblog mysql -u root -p \"]},\"1178\":{\"h\":\"常见问题\",\"t\":[\"Access denied\",\"[root@iZwz9b5a76d7cz6z7r9v4gZ ~]# docker exec -it mysql-myblog mysql -u root -p Enter password: ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES) \",\"问题解决：一般是~/mysql/config/my.cnf 配置文件没指定字符集，和系统字符集不匹配\"]},\"1179\":{\"h\":\"docker 部署 rocketmq\",\"t\":[\"docker 部署 rocketmq 地址： https://rocketmq.apache.org/zh/docs/quickStart/02quickstartWithDocker/\"]},\"1180\":{\"h\":\"Python Learning\"},\"1181\":{\"h\":\"1 环境搭建\"},\"1182\":{\"h\":\"1.1 conda 指令\",\"t\":[\"# 激活 conda activate your-envname # 失效 conda deactivate your-envname \"]},\"1183\":{\"h\":\"1.2 依赖库安装\"},\"1184\":{\"h\":\"1.2.1 临时指定镜像源下载依赖库\",\"t\":[\"全局配置镜像源时，因为清华镜像源地址有更新，导致一直下载不动，临时使用以下指令从镜像源下载依赖库： 使用阿里云镜像源： pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com xlrd==1.2.0\"]},\"1185\":{\"h\":\"1.2.2 配置全局镜像源\"},\"1186\":{\"h\":\"1.3 环境迁移\",\"t\":[\"只需将配置好的 conda 环境(ananconda/env/XXX)整个目录复制即可\"]},\"1187\":{\"h\":\"2 python 正则表达式\"},\"1188\":{\"h\":\"2.1 re.match 函数\",\"t\":[\"re.match 尝试从字符串的起始位置匹配一个模式，如果起始位置匹配不成功，则返回 None，用的不多\",\"函数语法：\",\"re.macth(pattern, string, flags=0) \",\"函数参数说明：\",\"参数\",\"描述\",\"pattern\",\"匹配的正则表达式\",\"string\",\"要匹配的字符串\",\"flag\",\"标志位，用于控制正则表达式的匹配方式，如：是否区分大小写。多行匹配等等。参见：正则表达式修饰符 - 可选标志\",\"匹配成功 re.match 方法返回一个匹配的对象，否则返回 None\"]},\"1189\":{\"h\":\"2.2 re.search 函数\",\"t\":[\"re.search扫描整个字符串并返回第一个成功的匹配\"]},\"1190\":{\"h\":\"2.3 正则表达式修饰符 - 可选标志\",\"t\":[\"注：多个标志位可通过按位 OR(|)指定。如 re.I|re.M。\",\"部分 re module 中的函数使用以下标志位作为可选入参：\",\"short name\",\"long name\",\"description\",\"A\",\"ASCII\",\"使得\\\\w, \\\\W, \\\\b, \\\\B, \\\\d, \\\\D 等字符类别匹配对应的 ASCII 字符类别（而不是默认的整个 Unicode 类别）\",\"I\",\"IGNORECASE\",\"Perform case-insensitive matching. 忽略大小写（印刷术时期大小写字母分别放在上下抽屉）\",\"L\",\"LOCALE\",\"使 \\\\w, \\\\W, \\\\b, \\\\B 基于当前的语言环境\",\"M\",\"MULTILINE\",\"多行匹配，使 ^ 和 $ 能作用于行首和行尾\",\"S\",\"DOTALL\",\"使 . 匹配包括换行在内的所有字符（还挺形象）\",\"X\",\"VERBOSE\",\"忽略空格和注释，使正则表达式更美观\",\"U\",\"UNICODE\",\"默认。使 \\\\w, \\\\W, \\\\b, \\\\B, \\\\d, \\\\D 等字符类别匹配整个 Unicode 字符类别\"]},\"1191\":{\"h\":\"\"},\"1192\":{\"h\":\"redis-window 部署运行\",\"t\":[\"## 打开redis客户端 redis-cli.exe -h 127.0.0.1 -p 6379 \"]},\"1193\":{\"h\":\"Regular Expression\"},\"1194\":{\"h\":\"参考菜鸟教程正则表达式\"},\"1195\":{\"h\":\"GitHub Pages 部署\"},\"1196\":{\"h\":\"1 github 配置\"},\"1197\":{\"h\":\"1.1 设置正确的 base 选项\",\"t\":[\"如果你准备发布到 https://<USERNAME>.github.io/ ，你可以省略这一步，因为 base 默认就是 \\\"/\\\" 。\",\"如果你准备发布到 https://<USERNAME>.github.io/<REPO>/ ，也就是说你的仓库地址是 https://github.com/<USERNAME>/<REPO> ，则将 base 设置为 \\\"/<REPO>/\\\"。\"]},\"1198\":{\"h\":\"1.2 选择你想要使用的 CI 工具\",\"t\":[\"这里我们以 GitHub Actions 为例。创建 .github/workflows/docs.yml 文件来配置工作流。\"]},\"1199\":{\"h\":\"1.3 github action 权限配置\",\"t\":[\"在 settings >> Actions >> General 中配置 github action 工作流的读写权限。\"]},\"1200\":{\"h\":\"1.4 github page 配置\",\"t\":[\"在 settings >> Pages >> Build and deployment 中配置 github page 主页对应的代码分支（vuepress 编译出的 docs 目录）。\"]},\"1201\":{\"h\":\"2 github push 不上去的问题\",\"t\":[\"有时执行 git push 的时候会报错 443 超时，可以检查一下是否开启了全局代理(Global)，可以开启全局代理，用 git bash push 代码。\"]},\"1202\":{\"h\":\"2.1 配置本地 github ssh 彻底解决 git push 不上去的问题\",\"t\":[\"windows:\",\"ssh-keygen -t rsa -b 4096 -C \\\"610798187@qq.com\\\" \",\"安装过程中一直点击 enter 即可，完成后代开 C:\\\\User\\\\XXX\\\\.ssh\\\\id_rsa.pub\",\"将文件内的内容复制进个人 setting 的 SSH and GPG keys 的 SSH keys 中即可\",\"然后进入仓库用这个 url clone 项目\",\"然后就可以解决代码 push 443 的问题了\",\"附：git page 上现实的 contributor 为以下 git 配置\",\"git config --global user.name \\\"frozen-midsummer\\\" git config --global user.email \\\"610798187@qq.com\\\" \",\"附：\",\"git 连接的远程仓库地址位于.git/config 文件中\"]},\"1203\":{\"h\":\"2.2 参考博文：\",\"t\":[\"如何使用 SSH 连接到 Github\"]},\"1204\":{\"h\":\"3 VS Code 开发 GitHub page 技巧\",\"t\":[\"VS Code 自定义 Markdown 粘贴图片的位置\"]},\"1205\":{\"h\":\"5 F&Q\"},\"1206\":{\"h\":\"20250106 文件夹下的 README.md 无法在 github bot 上编译出 index.html\",\"t\":[\"问题描述：\",\"docs\\\\serverside\\\\pythonlearning\\\\README.md 无法正常在 github 流水线上编译出 index.html，修改文件名为 README1.md 之后可以正常编译出 README1.html。本地不修改文件名也可正常编译出 index.html\",\"问题原因：不详\",\"解决方案：后续新建目录时为目录下的 index markdown 文件起一个包含语义的文件名（新学的英语，semantic）\"]},\"1207\":{\"h\":\"VuePress\"},\"1208\":{\"h\":\"0 Intro.\",\"t\":[\"个人快速建站离不开 VuePress 方便快捷的开发方式.\",\"VuePress 中文文档地址\",\"VuePress 生态系统(包含页首 yaml 配置)\",\"VuePress config.js 配置文档地址\",\"GitHub Pages 部署\"]},\"1209\":{\"h\":\"1 插件\",\"t\":[\"推荐使用import { slimsearchPlugin } from '@vuepress/plugin-slimsearch'进行全局内容查询，使用import { cut } from \\\"nodejs-jieba\\\"进行分词。\"]},\"1210\":{\"h\":\"2 样式\",\"t\":[\"默认主题使用 SASS 作为 CSS 预处理器，参考文档地址\",\"用户可以通过 Palette 文件来自定义样式变量，通过 style 文件来添加额外的样式。地址为.vuepress/styles/palette.scss 和 .vuepress/styles/index.scss\"]},\"1211\":{\"h\":\"3 F&Q\"},\"1212\":{\"h\":\"Cannot find node_modules\\\\nodejs-jieba\\\\build\\\\Release\\\\jieba.node\",\"t\":[\"问题描述：本地调试时运行 pnpm install 之后报错： error Error: Cannot find module '.pnpm\\\\nodejs-jieba@0.2.1_encoding@0.1.13\\\\node_modules\\\\nodejs-jieba\\\\build\\\\Release\\\\jieba.node'\",\"问题分析： 通常是 nodejs-jieba 版本太低了，或者 pnpm install 的时候没有等待 jieba.node 构建结束\",\"解决方案： 删除 node_modules 目录，pnpm add node-jieba@latest >> pnpm install\"]},\"1213\":{\"h\":\"DDDLearning\",\"t\":[\"DDD(Domain Driven Design)Learning\"]},\"1214\":{\"h\":\"DDD Learning\"},\"1215\":{\"h\":\"1 战略设计\",\"t\":[\"主要的过程大致包括业务场景分析、领域建模、划分边界上下文三个阶段。\"]},\"1216\":{\"h\":\"1.1 业务分析\",\"t\":[\"主要包括：\",\"用例分析法\",\"事件风暴法\",\"四色建模法。\",\"一般使用事件风暴法\",\"事件风暴过程需要问题驱动，一般通过提问的方式来驱动交流。\",\"事件风暴主要完成以下两个目标：\",\"a. 分析业务中的事件，搞清楚事件发生的前因后果\",\"即什么动作会导致当前事件的发生，当前事件发生后又会有什么后果\",\"注意不但要关注正常的业务流程，也要关注异常的业务流程\",\"b. 寻找业务逻辑和业务规则\",\"对业务涉及到的参与者、动作以及事件进行全面的梳理\"]},\"1217\":{\"h\":\"1.2 领域建模\",\"t\":[\"领域建模是整个 DDD 的核心，DDD 领域模型可细分为两步骤：\",\"第一步是发散，产生很多实体（entity, 与 DO 的区别是 entity 是类似充血的的对象，可以定义方法/行为）、命令、事件等领域对象（DomainObject）\",\"第二步是收敛，我们从不同的维度对之发散的产物进行聚类形成聚合，建立最终领域模型， 这是一个收敛的过程。\"]},\"1218\":{\"h\":\"1.2.1 发散阶段：领域对象分析\",\"t\":[\"领域对象分析，也就是对实体、值对象（Value Object）、领域事件（Domain Events）、领域命令的分析。\"]},\"1219\":{\"h\":\"1.2.2 收敛阶段：构建业务聚合\",\"t\":[\"完成领域对象分析之后，我们需要构建业务聚合，想要构建聚合，那么首先就要在实体中找到聚合根。\",\"聚合根的主要特点有：\",\"聚合根一定是实体，那么它具有全局唯一的标识 （？注：标识是一个类似 ID 的东西，收敛出的业务聚合内的类都继承这个聚合根实体？）\",\"聚合根是具备生命周期的（这个后续再看解释）\",\"聚合根需要专门的模块来进行管理（？？）\"]},\"1220\":{\"h\":\"1.3 划分边界上下文\",\"t\":[\"得到整个业务流程中的所有聚合之后，我们需要将聚合划分到更具业务语义的上下文中\"]},\"1221\":{\"h\":\"1.3.1 域的拆分\",\"t\":[\"域是否是 domain？域和上下文的关系是什么？\",\"就是将业务拆分成多个子域，比如电商系统可以包含商品子域、订单子域、用户子域等等。域的翻译是 domain，但此处“域的拆分”中的域是指业务进行上下文拆分之后形成的 domain/子域，每个子域都可以作为一个独立的微服务进行设计和开发，从而实现更好的业务解耦和系统扩展性。\",\"域和上下文的关系：上下文更像是一个环境、位置的概念，域是上下文中的一块内容。\",\"文档解释：限界上下文是业务的边界的划分，这个边界可以是一个领域或者多个领域的集合。复杂业务需要多个域编排完成一个复杂业务流程。限界上下文可以作为微服务划分的方法。其本质还是高内聚低耦合，只是限界上下文只是站在更高的层面来进行划分。如何进行划分，我的方法是一个界限上下文必须支持一个完整的业务流程，保证这个业务流程所涉及的领域都在一个限界上下文中。\"]},\"1222\":{\"h\":\"1.3.2 防腐\",\"t\":[\"一个上下文通过一些适配（adapter）和转换与另一个上下文交互。\"]},\"1223\":{\"h\":\"1.3.3 限界上下文之间的映射关系\"},\"1224\":{\"h\":\"2 战略设计\",\"t\":[\"经历了战略设计之后，我们构建了领域模型（先发散后收敛，构建聚合），划分了边界上下文，接下来将领域模型映射到工程结构，实现代码的开发落地。在这个阶段还有一些细节需要明确。\"]},\"1225\":{\"h\":\"2.1 领域服务设计\",\"t\":[\"需要哪些领域服务，领域服务依赖哪些属性，依赖哪些实体，依赖哪些值对象，这些都是需要在战术设计阶段明确下来。\"]},\"1226\":{\"h\":\"2.2 领域分层\",\"t\":[\"在领域分层方面，可以按照 cola 分层结构来进行，这个后面结合 cola 框架进行说明。\"]},\"1227\":{\"h\":\"2.3 代码结构\",\"t\":[\"当我们把领域对象进行进一步的细化之后，同时把对应的领域服务敲定之后，我们可以把这些分析后的内容映射成工程分层后的代码了。\"]},\"1228\":{\"h\":\"3 DDD 基本概念\"},\"1229\":{\"h\":\"3.2 事件\",\"t\":[\"一般采用 发布-订阅 模式。代码层面可以通过事件总线或消息队列间接通信。\"]},\"1230\":{\"h\":\"3.3 实体（Entity）\",\"t\":[\"实体具有唯一标识（例如审批单编号），有生命周期且具有延续性（我理解为审批单不随属性的变化而变化）。实体代码应该包括属性和行为，也就是我们说的充血模型，但是实体在复杂场景下需要编排领域服务，会导致事务过长影响性能。所以使用充血模型的时候，在行为里面只涉及业务逻辑的内存操作，不涉及过长的数据库事务。\"]},\"1231\":{\"h\":\"3.4 值对象（Value Object）\",\"t\":[\"值对象没有唯一标识，没有生命周期，不可修改，当值对象发生改变时只能替换（例如 String 的实现）。\"]},\"1232\":{\"h\":\"3.5 聚合和聚合根\",\"t\":[\"多个实体和值对象组成的集合叫聚合，聚合内部一定高内聚。聚合里面一定有一个实体是聚合根。\",\"作用：保证内部实体的一致性。外部操作聚合内部的实体时，只需要操作聚合根。\",\"聚合与领域可以是一对一的关系，也可以是一对多的关系。\"]},\"1233\":{\"h\":\"3.6 限界上下文，域，聚合，实体，值对象的关系\",\"t\":[\"领域包含限界上下文，限界上下文包含子域，子域包含聚合，聚合包含实体和值对象。\"]},\"1234\":{\"h\":\"3.7 实体和事件的关系\",\"t\":[\"在事件风暴中，我们会分析领域内的业务动作和行为，实体执行命令/做出行为会触发事件。\"]},\"1235\":{\"h\":\"4 DDD 代码实践\"},\"1236\":{\"h\":\"4.1 DDD 规范\",\"t\":[\"DDD 的代码实践中，规范大于技巧，DDD 架构可以避免引入一些其他概念，系统只有域，域服务，聚合根，实体，值对象，事件来构建系统。\"]},\"1237\":{\"h\":\"4.2 工程结构\"},\"1238\":{\"h\":\"4.2.1 application 模块\",\"t\":[\"CRQS 模式 command 和 query 分离\",\"重点做跨域的编排工作，无业务逻辑\"]},\"1239\":{\"h\":\"4.2.2 domain 模块\",\"t\":[\"域服务、聚合根、值对象、领域参数、仓库（repository，与持久化存储（如数据库）交互，一般包括增删改查方法）定义\"]},\"1240\":{\"h\":\"4.2.2.1 聚合根\",\"t\":[\"以 base-sever 中的 Counterparty 子域为例，交易对手是这个子域中的实体，但是这个子域中只有一个实体，所以没有聚合根。\",\"以下文档中给出的聚合根实践中，实体是聚合根中的一个属性。\",\"DDD 领域驱动设计内容分享(二)：为什么需要 DDD？_领域驱动设计 ddd-CSDN 博客\"]},\"1241\":{\"h\":\"4.3 代码示例\"},\"1242\":{\"h\":\"4.3.1 domainService 示例\",\"t\":[\"领域层不依赖基础层的实现：coordinationRepository 只是接口，在领域层定义好，由基础层依赖领域层实现这个接口。ps：这个已经讲的很清楚了，领域层只定义接口访问基础设施层，接口由基础设施层去实现，将业务逻辑和技术（Mybatis, redis, MQ, ...）解耦。\",\"业务逻辑和技术解耦：域服务这层通过调用 coordinationRepository 和聚合根将业务逻辑和技术解耦。\",\"聚合根的方法无副作用：聚合根的方法只对聚合根内部实体属性的改变，不做持久化动作，可反复测试。ps：这一点很重要，DDD 中最重要的就是规范，聚合根的方法不做持久化，放到域服务里面做持久化。\",\"模型与数据分离：\",\"改变模型：caseAggregate.handle(handleParam.getFollowerValue())。ps：就是只操作内存中的变量。\",\"改变数据：coordinationRepository.save(caseAggregate)；事务是在 save 方法上。ps：就是做持久化。\"]},\"1243\":{\"h\":\"4.3.2 Aggregate, Entity 示例\",\"t\":[\"规范大于技巧：DDD 架构可以避免引入一些其他概念，系统只有域，域服务，聚合根，实体，值对象，事件来构建系统。\"]},\"1244\":{\"h\":\"5 F&Q\"},\"1245\":{\"h\":\"5.1\",\"t\":[\"聚合根怎样将聚合内的值对象和实体聚合在一起？DomainService 如何将散落的服务聚合在一起？\",\"柏安的理解：有 ID 的 entity 就算聚合根，这个聚合根要存库，所有聚合根外的操作，都透过这个聚合根处理。\",\"领域内的其余 Entity 都透过这个聚合根访问聚合内部。即 Entity 声明为聚合根的一个 private final 属性，Entity 的方法声明为聚合根的方法，可以抛出聚合根异常。\"]},\"1246\":{\"h\":\"5.2\",\"t\":[\"实体既然是聚合根中的一个属性，那如果只有聚合根存库的话，实体中的属性全部展开？\"]},\"1247\":{\"h\":\"工厂模式\",\"t\":[\"UtEnumeration 接口改造为 Factory 模式(不就是 codeOf 方法吗)：\",\"class UtEnumerationFactory implements EnumerationFactory{ @Overide public <E extends Enum<E> & UtEnumeration<T>,T> E createUtEnumeration(T t,Class<E> clazz){ } } \"]},\"1248\":{\"h\":\"Mapstruct\"},\"1249\":{\"h\":\"0 Intro\",\"t\":[\"在 DDD 架构中，mapstruct 是一款实用工具，将 source 类映射为 target 类，本文以 UT2 与 SP11 之间的报文映射为例总结 mapstruct 的使用心得\"]},\"1250\":{\"h\":\"1 基础语法\"},\"1251\":{\"h\":\"1.1 java 表达式\"},\"1252\":{\"h\":\"1.2 不同变量类型的映射\"},\"1253\":{\"h\":\"1.3 枚举映射\"},\"1254\":{\"h\":\"1.4 多对一映射\"},\"1255\":{\"h\":\"1.4.1 基本多对一映射\",\"t\":[\"其实没啥好写的，问 AI 就行\",\"@Mapper(componentModel=SPRING) public interface testConvertor{ @Mapping(target=\\\"name\\\",expression=\\\"java(source1.getName()+source2.getName())\\\") Target toTarget(Source1 source1, Source2 source2); } \"]},\"1256\":{\"h\":\"1.4.2 服务类传入\",\"t\":[\"@Mapper(componentModel=SPRING) public interface testConvertor{ @Mapping(target=\\\"name\\\",expression=\\\"java(source1.getName()+source2.getName())\\\") Target toTarget(Source1 source1, @Context SourceService); } \"]},\"1257\":{\"h\":\"1.5 before&after Mapping\",\"t\":[\"@AfterMapping default void afterMapping(@MappingTarget Target target, @Context SourceService sourceService){ if(target!=null){ /** * 映射过程 */ } } \"]},\"1258\":{\"h\":\"2 项目应用\"},\"1259\":{\"h\":\"2.1 UT2 与 SP11 之间枚举值的映射\",\"t\":[\"由于 SP11 与 UT2 采取不同的数据字典，SP11 更倾向于 IMIX 报文风格；而 UT2 采用宽表的设计，数据字典更大、更通用。本节采用 mapstruct 编写 convertor 类统一完成两个系统之间的枚举映射，并进行相应的空值保护。\"]},\"1260\":{\"h\":\"2.1.1 枚举接口\",\"t\":[\"所有枚举继承此枚举接口，为 code 转枚举和枚举转 code 做了空值保护\",\"public interface UtEnumeration<T>{ T code(); String describe(); static <E extends Enum<E> & UtEnumeration<T>,T> E codeOf(T code, Class<E> clazz) { if(code==null){ return null; } EnumSet<E> allEnums = EnumSet.allOf(clazz); return allEnums.stream() .filter(e -> e.code().equals(code)) .findFirst() .orElseThrow(() -> new IllegalArgumentException(String.format(\\\"枚举：[%s]不存在枚举项：[%s]\\\",clazz.getName(),code))); } static <E extends UtEnumeration<T>,T> T getCodeOrDefault(E value){ return Optional.ofNullable(value) .map(UtEnumeration::code) .orElse(null); } } \"]},\"1261\":{\"h\":\"2.1.2 枚举类\",\"t\":[\"@RequiredArgsConstructor @Getter class enum Sp11Enunm implements Sp11Enumeration<String>{ SP11_A(\\\"Sp11A\\\",\\\"sp11a\\\"), SP11_B(\\\"Sp11B\\\",\\\"sp11b\\\"); private final String code; private final String desc; public static Sp11Enunm utCodeOf(String ut2){ if(StringUtils.isEmpty(ut2)){ return null; } Ut2Enum ut2Enum = UtEnumeration.codeOf(ut2,Ut2Enum.class); switch(ut2Enum){ case UT2_A: return SP11_A; case UT2_B: return SP11_B; default: throw new IllegalArgumentException(String.format(\\\"枚举Ut2Enunm:[%s]无法映射到系统内枚举[%s]\\\",ut2,\\\"Sp11Enunm\\\")); } } } @RequiredArgsConstructor @Getter class enum Ut2Enum implements UtEnumeration<String>{ UT2_A(\\\"Ut2A\\\",\\\"ut2a\\\"), UT2_B(\\\"Ut2B\\\",\\\"ut2b\\\"); private final String code; private final String desc; public static String getCodeBySpEnum(Sp11Enunm sp11Enum){ if(sp11Enum==null){ return null; } switch(sp11Enum){ case SP11_A: return UT2_A.code(); case SP11_B: return UT2_B.code(); default: throw new IllegalArgumentException(String.format(\\\"枚举Sp11Enunm:[%s]无法映射到报盘枚举[%s]\\\",sp11Enum.code(),\\\"Ut2Enunm\\\")); } } } \"]},\"1262\":{\"h\":\"Java Learning\"},\"1263\":{\"h\":\"Spring Cloud\",\"t\":[\"jrescloud3.0 开发框架知识库\"]},\"1264\":{\"h\":\"编码规范\",\"t\":[\"hundsun java 代码规范\"]},\"1265\":{\"h\":\"maven pom\"},\"1266\":{\"h\":\"常见问题\",\"t\":[\"Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasour\",\"解决方案：\",\"问题在于引入类路径中的配置文件时，忽略了 resource 路径下的配置文件\",\"原 pom.xml 配置文件：\",\"<build> <resources> <resource> <directory>src/main/java</directory> <includes> <include>**/*.xml</include> </includes> <filtering>false</filtering> </resource> </resources> </build> \",\"修改后的 pom.xml 配置文件：\",\"<build> <resources> <resource> <directory>src/main/resources</directory> <includes> <include>**/*.yml</include> <include>**/*.properties</include> <include>**/*.xml</include> </includes> <filtering>false</filtering> </resource> <resource> <directory>src/main/java</directory> <includes> <include>**/*.xml</include> </includes> <filtering>false</filtering> </resource> </resources> </build> \"]},\"1267\":{\"h\":\"Plant UML\"},\"1268\":{\"h\":\"1 安装部署\"},\"1269\":{\"h\":\"1.1 下载 PlantUML 和 Graphviz\",\"t\":[\"PlantUML 的 IDEA 插件用于在 IDEA 上编写 PlantUML 脚本，Graphviz 用于 PlantUML 脚本的渲染和图像化输出。\",\"PlantUML IDEA 插件下载地址\",\"Graphviz 下载地址\"]},\"1270\":{\"h\":\"1.2 配置 PlantUML Integration\",\"t\":[\"idea 插件的配置如下所示（主要是配置 Graphviz 的地址）：\"]},\"1271\":{\"h\":\"2 PlantUML 文档\",\"t\":[\"PlantUML 是一个画图脚本语言，用它可以快速地画出：\",\"类图：http://plantuml.com/class-diagram\",\"流程图：http://plantuml.com/activity-diagram-beta\",\"时序图：http://plantuml.com/sequence-diagram\",\"用例图：http://plantuml.com/use-case-diagram\",\"状态图：http://plantuml.com/state-diagram\",\"组件图：http://plantuml.com/component-diagram\"]},\"1272\":{\"h\":\"3 PlantUML 应用\"},\"1273\":{\"h\":\"3.1 为文件夹生成类图\",\"t\":[\"这个很简单，安装并配置完 idea 插件后，右击文件夹，点这个：\"]},\"1274\":{\"h\":\"3.2 生成时序图\",\"t\":[\"主要是写.puml 脚本。写完之后右键右侧的预览赋值图像到剪切板即可。\"]},\"1275\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"柏安的理解\",{\"1\":{\"1245\":1}}],[\"示例\",{\"0\":{\"1242\":1,\"1243\":1}}],[\"博客\",{\"1\":{\"1240\":1}}],[\"域服务这层通过调用\",{\"1\":{\"1242\":1}}],[\"域服务\",{\"1\":{\"1236\":1,\"1239\":1,\"1243\":1}}],[\"域\",{\"0\":{\"1233\":1}}],[\"域是上下文中的一块内容\",{\"1\":{\"1221\":1}}],[\"域是否是\",{\"1\":{\"1221\":1}}],[\"域和上下文的关系\",{\"1\":{\"1221\":1}}],[\"域和上下文的关系是什么\",{\"1\":{\"1221\":1}}],[\"域的翻译是\",{\"1\":{\"1221\":1}}],[\"域的拆分\",{\"0\":{\"1221\":1},\"1\":{\"1221\":1}}],[\"域名劫持\",{\"1\":{\"1059\":1}}],[\"域名解析\",{\"1\":{\"1033\":1}}],[\"域名缓存\",{\"0\":{\"1032\":1}}],[\"域名到ip地址的解析过程\",{\"0\":{\"1031\":1}}],[\"域名到ip地址的解析是由分布在互联网上的许多域名服务器程序共同完成的\",{\"1\":{\"1030\":1}}],[\"域名服务器ip地址\",{\"1\":{\"1049\":1}}],[\"域名服务器同步\",{\"1\":{\"1033\":1}}],[\"域名服务器应为每项内容设置计时器并处理超过合理时间的项\",{\"1\":{\"1032\":1}}],[\"域名服务器\",{\"1\":{\"1030\":1}}],[\"域名结构\",{\"1\":{\"1030\":1}}],[\"域名系统dns是互联网使用的命名系统\",{\"1\":{\"1030\":1}}],[\"域名系统dns\",{\"0\":{\"1030\":1},\"1\":{\"962\":1}}],[\"领域内的其余\",{\"1\":{\"1245\":1}}],[\"领域层只定义接口访问基础设施层\",{\"1\":{\"1242\":1}}],[\"领域层不依赖基础层的实现\",{\"1\":{\"1242\":1}}],[\"领域驱动设计\",{\"1\":{\"1240\":1}}],[\"领域驱动设计内容分享\",{\"1\":{\"1240\":1}}],[\"领域参数\",{\"1\":{\"1239\":1}}],[\"领域包含限界上下文\",{\"1\":{\"1233\":1}}],[\"领域分层\",{\"0\":{\"1226\":1}}],[\"领域服务依赖哪些属性\",{\"1\":{\"1225\":1}}],[\"领域服务设计\",{\"0\":{\"1225\":1}}],[\"领域命令的分析\",{\"1\":{\"1218\":1}}],[\"领域事件\",{\"1\":{\"1218\":1}}],[\"领域对象分析\",{\"0\":{\"1218\":1},\"1\":{\"1218\":1}}],[\"领域模型可细分为两步骤\",{\"1\":{\"1217\":1}}],[\"领域建模是整个\",{\"1\":{\"1217\":1}}],[\"领域建模\",{\"0\":{\"1217\":1},\"1\":{\"1215\":1}}],[\"领导者状态\",{\"1\":{\"820\":1}}],[\"领导分派的\",{\"1\":{\"696\":1}}],[\"战略设计\",{\"0\":{\"1215\":1,\"1224\":1}}],[\"粘贴图片的位置\",{\"1\":{\"1204\":1}}],[\"粘包是怎么产生的\",{\"1\":{\"1006\":1}}],[\"粘包\",{\"0\":{\"1006\":1}}],[\"技巧\",{\"0\":{\"1204\":1}}],[\"技术\",{\"0\":{\"805\":1},\"1\":{\"719\":1,\"1060\":1}}],[\"技术维护卡表状态\",{\"1\":{\"250\":1}}],[\"彻底解决\",{\"0\":{\"1202\":1}}],[\"印刷术时期大小写字母分别放在上下抽屉\",{\"1\":{\"1190\":1}}],[\"忽略了\",{\"1\":{\"1266\":1}}],[\"忽略空格和注释\",{\"1\":{\"1190\":1}}],[\"忽略大小写\",{\"1\":{\"1190\":1}}],[\"忽略不存在的文件\",{\"1\":{\"424\":1}}],[\"激活\",{\"1\":{\"1182\":1}}],[\"牺牲一点持久性换取性能\",{\"1\":{\"1177\":1}}],[\"镜像\",{\"1\":{\"1177\":1}}],[\"镜像源配置参考此文章\",{\"1\":{\"1143\":2}}],[\"镜像源配置\",{\"0\":{\"1143\":1}}],[\"镜像源地址配置\",{\"0\":{\"1141\":1}}],[\"拉取\",{\"1\":{\"1177\":1}}],[\"拉取远端最新\",{\"1\":{\"1126\":1}}],[\"学习一些常用设计模式\",{\"1\":{\"1173\":1}}],[\"学校包含老师\",{\"1\":{\"1098\":1}}],[\"学校与老师的关系\",{\"1\":{\"1098\":1}}],[\"好像不做这个操作也可以装上\",{\"1\":{\"1170\":1}}],[\"好处是\",{\"1\":{\"405\":1}}],[\"好处\",{\"1\":{\"184\":1}}],[\"🌸\",{\"1\":{\"1167\":1}}],[\"🍷\",{\"1\":{\"18\":1}}],[\"购买了一台阿里云的\",{\"1\":{\"1167\":1}}],[\"绘图时注意\",{\"1\":{\"1163\":1}}],[\"风格代码组织顺序\",{\"0\":{\"1162\":1}}],[\"风格封装\",{\"0\":{\"1161\":1}}],[\"风格指南\",{\"0\":{\"1160\":1}}],[\"风险\",{\"1\":{\"669\":1}}],[\"太费事了\",{\"1\":{\"1145\":1}}],[\"详见规则\",{\"1\":{\"1140\":1}}],[\"详解\",{\"1\":{\"903\":1}}],[\"鉴于使用了\",{\"1\":{\"1140\":1}}],[\"鉴权方法\",{\"1\":{\"804\":1}}],[\"鉴权等功能\",{\"1\":{\"804\":1}}],[\"见标题\",{\"1\":{\"1165\":1}}],[\"见页首的官方文档\",{\"1\":{\"1139\":1}}],[\"见网站建设\",{\"1\":{\"1123\":1}}],[\"科学上网\",{\"1\":{\"1136\":1}}],[\"沉浸式翻译\",{\"0\":{\"1131\":1}}],[\"介绍一些实用开发小工具\",{\"1\":{\"1129\":1}}],[\"介绍一些常用开发工具\",{\"1\":{\"16\":1}}],[\"需权限\",{\"1\":{\"1127\":1}}],[\"需要哪些领域服务\",{\"1\":{\"1225\":1}}],[\"需要\",{\"1\":{\"1157\":1}}],[\"需要安装\",{\"1\":{\"1145\":1}}],[\"需要频繁实例化然后销毁的对象\",{\"1\":{\"1073\":1}}],[\"需要保证信息没有被篡改过\",{\"1\":{\"1055\":1}}],[\"需要保证自己存储全部已经提交的日志条目\",{\"1\":{\"878\":1}}],[\"需要消耗更多的\",{\"1\":{\"1048\":1}}],[\"需要交费\",{\"1\":{\"1048\":1}}],[\"需要加上\",{\"1\":{\"1157\":1}}],[\"需要加上12个字节的伪首部\",{\"1\":{\"1007\":1}}],[\"需要加上适当的首部\",{\"1\":{\"997\":1,\"999\":1}}],[\"需要准确无误的传输给对方\",{\"1\":{\"1001\":1}}],[\"需要ip地址的主机在启动时就向dhcp服务器广播发送发现报文\",{\"1\":{\"1049\":1}}],[\"需要ip\",{\"1\":{\"982\":1}}],[\"需要协商\",{\"1\":{\"975\":1}}],[\"需要注意\",{\"1\":{\"975\":1}}],[\"需要注意的是intercept方法里面\",{\"1\":{\"726\":1}}],[\"需要注意的是\",{\"1\":{\"352\":1,\"383\":1}}],[\"需要发送的整块数据称为一个报文\",{\"1\":{\"960\":1}}],[\"需要先遍历链表一次确定长度\",{\"1\":{\"927\":1}}],[\"需要先从磁盘读入内存\",{\"1\":{\"489\":1}}],[\"需要事先知道关键字的分布情况\",{\"1\":{\"923\":1}}],[\"需要把重复的全部去掉\",{\"1\":{\"890\":1}}],[\"需要把所有元素都应用函数才能比较\",{\"1\":{\"533\":1}}],[\"需要监控服务器请求连接数\",{\"1\":{\"869\":1}}],[\"需要引入一个全局唯一的transaction\",{\"1\":{\"863\":1}}],[\"需要引入分布式事务\",{\"1\":{\"585\":1}}],[\"需要写入到log文件中\",{\"1\":{\"850\":1}}],[\"需要考虑消息的处理\",{\"1\":{\"841\":1}}],[\"需要支持应用相关的规范\",{\"1\":{\"825\":1}}],[\"需要外在提供相应的元素\",{\"1\":{\"797\":1}}],[\"需要独立的容器运行吗\",{\"0\":{\"780\":1}}],[\"需要程序通过配置文件手工初始化spring的情况\",{\"1\":{\"736\":1}}],[\"需要程序员提前给代码做出错误解决方案\",{\"1\":{\"385\":1}}],[\"需要经常请教业务和架构师\",{\"1\":{\"693\":1}}],[\"需要手动转换\",{\"1\":{\"997\":1}}],[\"需要手动开启配置\",{\"1\":{\"752\":1}}],[\"需要手动将一个从节点晋升为主节点\",{\"1\":{\"675\":1}}],[\"需要手动把一台从服务器切换为主服务器\",{\"1\":{\"657\":1}}],[\"需要更多的\",{\"1\":{\"671\":1}}],[\"需要为该\",{\"1\":{\"668\":1}}],[\"需要人工介入\",{\"1\":{\"660\":1}}],[\"需要重启的时候\",{\"1\":{\"656\":1}}],[\"需要等待机器重启或者手动切换前端的\",{\"1\":{\"656\":1}}],[\"需要修复\",{\"1\":{\"651\":1}}],[\"需要的存储空间就越大\",{\"1\":{\"645\":1}}],[\"需要依靠客户端来实现往集群中分片写入数据\",{\"1\":{\"610\":1}}],[\"需要迁移旧的数据\",{\"1\":{\"587\":1}}],[\"需要水平切分\",{\"1\":{\"585\":1}}],[\"需要找回数据\",{\"1\":{\"576\":1}}],[\"需要将数据页读入内存\",{\"1\":{\"574\":1}}],[\"需要说明的是\",{\"1\":{\"574\":1}}],[\"需要用到公钥\",{\"1\":{\"1057\":1}}],[\"需要用shwo\",{\"1\":{\"558\":1}}],[\"需要用户进程自己去读取数据\",{\"1\":{\"380\":1}}],[\"需要查找下一个记录\",{\"1\":{\"555\":1}}],[\"需要扫描两次\",{\"1\":{\"549\":1}}],[\"需要扫描两遍索引树\",{\"1\":{\"549\":1}}],[\"需要对树进行一个分裂\",{\"1\":{\"538\":1}}],[\"需要创建索引的情况\",{\"0\":{\"531\":1}}],[\"需要给这个表加表锁\",{\"1\":{\"514\":1}}],[\"需要满足非唯一的辅助索引条件\",{\"1\":{\"496\":1}}],[\"需要执行修复操作\",{\"1\":{\"492\":1}}],[\"需要逐行删除\",{\"1\":{\"483\":1}}],[\"需要很小的数据存储空间\",{\"1\":{\"467\":1}}],[\"需要使用\",{\"1\":{\"362\":1,\"566\":1,\"718\":2,\"1057\":1}}],[\"需要使用加锁等机制\",{\"1\":{\"219\":1}}],[\"需要通过网络来表达调用的语义和传达调用参数\",{\"1\":{\"801\":1}}],[\"需要通过内部类的方式维持嵌套的可读性\",{\"1\":{\"361\":1}}],[\"需要通过传入外部类引用的方式才能访问\",{\"1\":{\"361\":1}}],[\"需要确保回调立即被当做垃圾回收的最佳方法是只保存它的弱引用\",{\"1\":{\"304\":1}}],[\"需要调用close方法来释放与数据库的连接\",{\"1\":{\"304\":1}}],[\"需要进行附加操作以完成请求\",{\"1\":{\"1040\":1}}],[\"需要进行数据迁移\",{\"1\":{\"660\":1}}],[\"需要进行大量的标记和清除动作\",{\"1\":{\"244\":1}}],[\"需要进行址段的划分\",{\"1\":{\"198\":1}}],[\"需要多深的操作数栈就已经被分析计算出来\",{\"1\":{\"191\":1}}],[\"需要继承\",{\"1\":{\"185\":1}}],[\"需要一个classloader对象来调用该方法\",{\"1\":{\"183\":1}}],[\"需要触发其初始化\",{\"1\":{\"174\":1}}],[\"需要由操作系统保存当前线程的状态\",{\"1\":{\"144\":1}}],[\"需要同步\",{\"1\":{\"131\":1}}],[\"需要所有线程都到达\",{\"1\":{\"121\":1}}],[\"需要从故障前的位置继续消费\",{\"1\":{\"860\":1}}],[\"需要从同步队列中取消该\",{\"1\":{\"111\":1}}],[\"需要从主从重新读取最新的数据\",{\"1\":{\"72\":1}}],[\"需要在客户端配置代理服务器进行指定网站访问\",{\"1\":{\"826\":1}}],[\"需要在\",{\"1\":{\"94\":1}}],[\"需要其他线程释放\",{\"1\":{\"38\":1}}],[\"晚间操作\",{\"0\":{\"1127\":1}}],[\"晚期绑定\",{\"1\":{\"194\":1}}],[\"早间操作\",{\"0\":{\"1126\":1}}],[\"早期绑定\",{\"1\":{\"194\":1}}],[\"汽车和船实现了交通工具\",{\"1\":{\"1101\":1}}],[\"箭头从实现类指向接口\",{\"1\":{\"1101\":1}}],[\"箭头从子类指向父类\",{\"1\":{\"1100\":1}}],[\"箭头从使用类指向被关联的类\",{\"1\":{\"1097\":1}}],[\"箭头从使用类指向被依赖的类\",{\"1\":{\"1096\":1}}],[\"嘴也就不存在了\",{\"1\":{\"1099\":1}}],[\"菱形指向整体\",{\"1\":{\"1098\":1,\"1099\":1}}],[\"老师依然存在\",{\"1\":{\"1098\":1}}],[\"老年代空间不足时\",{\"1\":{\"243\":1}}],[\"老年代收集\",{\"1\":{\"240\":1}}],[\"丈夫和妻子等\",{\"1\":{\"1097\":1}}],[\"师傅和徒弟\",{\"1\":{\"1097\":1}}],[\"泛化关系用带空心三角箭头的实线来表示\",{\"1\":{\"1100\":1}}],[\"泛化关系是对象之间耦合度最大的一种关系\",{\"1\":{\"1100\":1}}],[\"泛化关系\",{\"0\":{\"1100\":1}}],[\"泛化关系和实现关系\",{\"1\":{\"1095\":1}}],[\"泛型信息只存在于代码编译阶段\",{\"1\":{\"345\":1}}],[\"泛型是通过类型擦除来实现的\",{\"1\":{\"345\":1}}],[\"泛型\",{\"0\":{\"345\":1}}],[\"池技术\",{\"1\":{\"1091\":1}}],[\"享元模式\",{\"0\":{\"1091\":1}}],[\"钩子方法\",{\"1\":{\"1087\":1}}],[\"办理具体业务\",{\"1\":{\"1087\":1}}],[\"服装\",{\"1\":{\"1086\":1}}],[\"服务类传入\",{\"0\":{\"1256\":1}}],[\"服务不会中断\",{\"1\":{\"834\":1}}],[\"服务的机器发起投票对比\",{\"1\":{\"820\":1}}],[\"服务的锁\",{\"1\":{\"672\":1}}],[\"服务挂了\",{\"1\":{\"815\":1}}],[\"服务之间如何进行通信\",{\"1\":{\"815\":1}}],[\"服务容器负责启动\",{\"1\":{\"811\":1}}],[\"服务消费者和提供者\",{\"1\":{\"811\":1}}],[\"服务消费者在启动时\",{\"1\":{\"811\":1}}],[\"服务消费者从提供者地址列表中\",{\"1\":{\"810\":1}}],[\"服务消费者\",{\"1\":{\"810\":1,\"811\":1}}],[\"服务关键节点\",{\"0\":{\"810\":1}}],[\"服务自动注册和发现\",{\"1\":{\"809\":1}}],[\"服务治理方便\",{\"1\":{\"806\":1}}],[\"服务化治理效率大大提高\",{\"1\":{\"805\":1}}],[\"服务动态扩展等都方便操作\",{\"1\":{\"805\":1}}],[\"服务下线\",{\"1\":{\"805\":1}}],[\"服务注册发现\",{\"1\":{\"805\":1}}],[\"服务注册与发现的服务管理中心\",{\"1\":{\"801\":1}}],[\"服务端学习笔记\",{\"0\":{\"1113\":1}}],[\"服务端\",{\"0\":{\"1112\":1}}],[\"服务端验证token并返回数据\",{\"1\":{\"1053\":1}}],[\"服务端使用私钥对随机数进行解密\",{\"1\":{\"1044\":1}}],[\"服务端推送\",{\"1\":{\"1042\":1}}],[\"服务端根据请求头获取客户端的信息\",{\"1\":{\"1038\":1}}],[\"服务端就认为客户端出了故障\",{\"1\":{\"1028\":1}}],[\"服务端就发送一个探测报文段\",{\"1\":{\"1028\":1}}],[\"服务端序列化\",{\"1\":{\"804\":1}}],[\"服务端收到客户端发过的消息后\",{\"1\":{\"804\":1}}],[\"服务端也通过查表来确定客户端需要调用的函数\",{\"1\":{\"804\":1}}],[\"服务端都会启动一个线程去处理该客户端的请求\",{\"1\":{\"377\":1}}],[\"服务掉线分为主动下线和心跳检测\",{\"1\":{\"802\":1}}],[\"服务运行容器\",{\"1\":{\"801\":1}}],[\"服务提供者在启动时\",{\"1\":{\"811\":1}}],[\"服务提供者\",{\"1\":{\"801\":1,\"810\":1}}],[\"服务集成\",{\"1\":{\"801\":1}}],[\"服务出现问题\",{\"1\":{\"644\":1}}],[\"服务器实例\",{\"1\":{\"1167\":1}}],[\"服务器把客户端信息以某种形式记录在服务器上\",{\"1\":{\"1052\":1}}],[\"服务器还可以根据需要修改cookie的内容\",{\"1\":{\"1051\":1}}],[\"服务器检查该cookie\",{\"1\":{\"1051\":1}}],[\"服务器单从网络连接上无从知道客户身份\",{\"1\":{\"1051\":1}}],[\"服务器将非对称加密的公钥以数字证书的形式回传给客户端\",{\"1\":{\"1044\":1}}],[\"服务器在使用https前需要去认证的ca机构申请一份数字证书\",{\"1\":{\"1044\":1}}],[\"服务器事先把一些客户端可能询问的事情提前发送到客户端的缓存上\",{\"1\":{\"1042\":1}}],[\"服务器需要处理客户端的a\",{\"1\":{\"1042\":1}}],[\"服务器就可连接发回响应报文\",{\"1\":{\"1042\":1}}],[\"服务器不跟踪每个客户也不记录过去的请求\",{\"1\":{\"1042\":1}}],[\"服务器不记得这个客户来过没\",{\"1\":{\"1037\":1}}],[\"服务器完成请求处理后立即断开tcp连接\",{\"1\":{\"1042\":1}}],[\"服务器可能把这个数据存储到数据库中\",{\"1\":{\"1041\":1}}],[\"服务器可以为客户端提供只读操作的服务\",{\"1\":{\"656\":1}}],[\"服务器繁忙\",{\"1\":{\"1040\":1}}],[\"服务器禁止访问\",{\"1\":{\"1040\":1}}],[\"服务器错误状态码\",{\"1\":{\"1040\":1}}],[\"服务器返回内容压缩编码类型\",{\"1\":{\"1039\":1}}],[\"服务器返回给客户端的内容\",{\"1\":{\"1038\":1}}],[\"服务器返回监控其运行状态\",{\"1\":{\"657\":1}}],[\"服务器的状态也是一样的\",{\"1\":{\"1041\":1}}],[\"服务器的差错\",{\"1\":{\"1040\":1}}],[\"服务器的响应与第一次被访问时的相同\",{\"1\":{\"1037\":1}}],[\"服务器的数据\",{\"1\":{\"661\":1}}],[\"服务器查询域名\",{\"1\":{\"1033\":1}}],[\"服务器查找到域名后\",{\"1\":{\"1031\":1}}],[\"服务器每收到一次客户的数据\",{\"1\":{\"1028\":1}}],[\"服务器也不能一直等\",{\"1\":{\"1028\":1}}],[\"服务器也可以在共享状态上达成一致\",{\"1\":{\"873\":1}}],[\"服务器收到后\",{\"1\":{\"1026\":1}}],[\"服务器收到连接释放报文后发出ack报文\",{\"1\":{\"1026\":1}}],[\"服务器fin\",{\"1\":{\"1026\":1}}],[\"服务器ack\",{\"1\":{\"1026\":1}}],[\"服务器ack级别设置为0\",{\"1\":{\"856\":1}}],[\"服务器ack级别设置为\",{\"1\":{\"856\":1}}],[\"服务器都处于连接已建立状态\",{\"1\":{\"1026\":1}}],[\"服务器都存储相同的数据\",{\"1\":{\"659\":1,\"678\":1}}],[\"服务器会把此种状态下请求连接放在一个队列里\",{\"1\":{\"1025\":1}}],[\"服务器第一次收到客户端的\",{\"1\":{\"1025\":1}}],[\"服务器方式\",{\"1\":{\"960\":1}}],[\"服务器处理请求并返回\",{\"1\":{\"959\":1,\"1029\":1}}],[\"服务器集群举例\",{\"1\":{\"874\":1}}],[\"服务器压力一样\",{\"1\":{\"869\":1}}],[\"服务器列表记录的节点\",{\"1\":{\"861\":1}}],[\"服务器启动时期的\",{\"1\":{\"820\":1}}],[\"服务器启动后\",{\"1\":{\"759\":1}}],[\"服务器中存放的最新数据版本号\",{\"1\":{\"820\":1}}],[\"服务器有四种状态\",{\"1\":{\"820\":1}}],[\"服务器上应用提供的函数\",{\"1\":{\"801\":1}}],[\"服务器上\",{\"1\":{\"801\":1,\"836\":1,\"861\":1}}],[\"服务器关闭后\",{\"1\":{\"759\":1}}],[\"服务器时\",{\"1\":{\"671\":1}}],[\"服务器进行监控\",{\"1\":{\"657\":1}}],[\"服务器响应\",{\"1\":{\"657\":1,\"676\":1}}],[\"服务器接收到的所有写命令都记录到日志中\",{\"1\":{\"649\":1}}],[\"服务器服务\",{\"1\":{\"647\":1}}],[\"服务器宕机等意外情况\",{\"1\":{\"646\":1}}],[\"服务器运行过程中的错误信息\",{\"1\":{\"566\":1}}],[\"服务器端在收到\",{\"1\":{\"1060\":1}}],[\"服务器端只需要保存token的密钥即可\",{\"1\":{\"1053\":1}}],[\"服务器端只会从\",{\"1\":{\"613\":1}}],[\"服务器端错误\",{\"1\":{\"1040\":1}}],[\"服务器端收到请求报文段之后\",{\"1\":{\"1022\":1}}],[\"服务器端创建传输控制块\",{\"1\":{\"1022\":1}}],[\"服务器端使用的端口号分为\",{\"1\":{\"1000\":1}}],[\"服务器端使用的端口号和客户端使用的端口号\",{\"1\":{\"1000\":1}}],[\"服务器端的操作从而自动执行一些操作等\",{\"1\":{\"759\":1}}],[\"服务器端不断地从\",{\"1\":{\"613\":1}}],[\"服务器端会进行查询优化处理\",{\"1\":{\"489\":1}}],[\"服务器端都会对应一个处理线程\",{\"1\":{\"380\":1}}],[\"服务器先会查询缓存\",{\"1\":{\"489\":1}}],[\"服务器\",{\"1\":{\"452\":1,\"661\":1,\"676\":1,\"820\":9}}],[\"服务\",{\"1\":{\"197\":1,\"672\":1,\"801\":1,\"820\":1}}],[\"人物角色包括人体\",{\"1\":{\"1086\":1}}],[\"背景等组成部分\",{\"1\":{\"1086\":1}}],[\"背景色等一起发生改变时\",{\"1\":{\"1079\":1}}],[\"鸡肉卷等\",{\"1\":{\"1086\":1}}],[\"套餐是一个复杂对象\",{\"1\":{\"1086\":1}}],[\"套餐\",{\"1\":{\"1086\":1}}],[\"套接字读取数据\",{\"1\":{\"1047\":1}}],[\"套接字\",{\"1\":{\"149\":1,\"611\":1}}],[\"火车站卖票\",{\"1\":{\"1082\":1}}],[\"火车站\",{\"1\":{\"1082\":1}}],[\"洗衣机\",{\"1\":{\"1079\":1}}],[\"违反了开闭原则\",{\"1\":{\"1077\":1}}],[\"卸载类的判定条件如下\",{\"1\":{\"1075\":1}}],[\"私有化枚举的构造函数\",{\"1\":{\"1070\":1}}],[\"私有化构造函数\",{\"1\":{\"1070\":1}}],[\"私有方法\",{\"1\":{\"194\":1,\"274\":1,\"275\":1}}],[\"枚举sp11enunm\",{\"1\":{\"1261\":1}}],[\"枚举ut2enunm\",{\"1\":{\"1261\":1}}],[\"枚举类\",{\"0\":{\"1261\":1}}],[\"枚举类实现单例模式是极力推荐的单例实现模式\",{\"1\":{\"1070\":1}}],[\"枚举接口\",{\"0\":{\"1260\":1}}],[\"枚举映射\",{\"0\":{\"1253\":1}}],[\"枚举实现\",{\"0\":{\"1070\":1}}],[\"枚举\",{\"1\":{\"1065\":1,\"1260\":1}}],[\"懒汉式\",{\"0\":{\"1067\":1},\"1\":{\"1065\":1}}],[\"饿汉式\",{\"0\":{\"1066\":1},\"1\":{\"1065\":1}}],[\"迪米特法则\",{\"1\":{\"1064\":1,\"1090\":2}}],[\"毕竟\",{\"1\":{\"1061\":1}}],[\"毕竟有上下文的切换\",{\"1\":{\"613\":1}}],[\"防腐\",{\"0\":{\"1222\":1}}],[\"防御方法\",{\"1\":{\"1060\":1}}],[\"防止包丢失\",{\"1\":{\"1009\":1}}],[\"防止接收端速度太慢造成溢出和丢包的现象\",{\"1\":{\"998\":1}}],[\"防止缓存穿透\",{\"1\":{\"882\":1}}],[\"防止\",{\"1\":{\"745\":1,\"1061\":1}}],[\"防止单个哨兵宕机\",{\"1\":{\"676\":1}}],[\"防止死锁\",{\"1\":{\"667\":1}}],[\"防止同一时间大量数据过期现象发生\",{\"1\":{\"642\":1}}],[\"防止幻读\",{\"1\":{\"491\":1}}],[\"防止内存溢出\",{\"1\":{\"235\":1}}],[\"防止对本地系统的破坏\",{\"1\":{\"186\":1}}],[\"防止源码泄露\",{\"1\":{\"180\":1}}],[\"攻击\",{\"1\":{\"1061\":1}}],[\"攻击利用\",{\"1\":{\"1060\":1}}],[\"攻击者利用tcp协议的安全缺陷\",{\"1\":{\"1054\":1}}],[\"攻击者只是观察和分析某一个协议数据单元\",{\"1\":{\"1054\":1}}],[\"拿到发送方的公钥\",{\"1\":{\"1057\":1}}],[\"拿到内存\",{\"1\":{\"168\":1}}],[\"截获了\",{\"1\":{\"1057\":1}}],[\"洪水攻击\",{\"1\":{\"1054\":1}}],[\"拒绝服务dos\",{\"1\":{\"1054\":1}}],[\"拒绝策略\",{\"0\":{\"60\":1},\"1\":{\"58\":1,\"60\":1}}],[\"恶意程序\",{\"1\":{\"1054\":1}}],[\"篡改\",{\"1\":{\"1054\":1}}],[\"租期\",{\"1\":{\"1049\":1}}],[\"劫持\",{\"1\":{\"1045\":1}}],[\"证书有效期和服务器公钥\",{\"1\":{\"1044\":1}}],[\"证书\",{\"1\":{\"1044\":1,\"1045\":1}}],[\"摒弃了五元组的概念\",{\"1\":{\"1042\":1}}],[\"摒弃了rset\",{\"1\":{\"267\":1}}],[\"浪费了服务器资源\",{\"1\":{\"1042\":1}}],[\"浪费资源\",{\"1\":{\"1022\":1,\"1023\":1}}],[\"幂等的\",{\"1\":{\"1041\":1}}],[\"幂等性\",{\"0\":{\"856\":1},\"1\":{\"856\":4,\"863\":1,\"1041\":1}}],[\"密码规格变更协议负责向通信对象传达变更密码方式的信号\",{\"1\":{\"1062\":1}}],[\"密码规格变更协议和应用数据协议4个部分\",{\"1\":{\"1062\":1}}],[\"密码等\",{\"1\":{\"1038\":1}}],[\"密集型也能用\",{\"1\":{\"57\":1}}],[\"密集型\",{\"1\":{\"57\":1}}],[\"布尔值\",{\"1\":{\"1035\":1}}],[\"布隆过滤器就是其中的\",{\"1\":{\"882\":1}}],[\"布隆过滤器说某个元素不在\",{\"1\":{\"882\":1}}],[\"布隆过滤器说某个元素存在\",{\"1\":{\"882\":1}}],[\"布隆过滤器的error\",{\"1\":{\"645\":1}}],[\"布隆过滤器的initial\",{\"1\":{\"645\":1}}],[\"布隆过滤器也可以用来解决此类问题\",{\"1\":{\"645\":1}}],[\"布隆过滤器本质上是由长度为\",{\"1\":{\"645\":1}}],[\"布隆过滤器\",{\"0\":{\"645\":1,\"882\":1},\"1\":{\"641\":1}}],[\"联机式的信息储藏所\",{\"1\":{\"1034\":1}}],[\"联合查询\",{\"1\":{\"556\":1}}],[\"联合索引\",{\"0\":{\"551\":1}}],[\"联合使用\",{\"1\":{\"235\":3}}],[\"许多主机在启动时从本地服务器下载名字和地址的全部数据库\",{\"1\":{\"1032\":1}}],[\"许多同步类的实现都依赖于它\",{\"1\":{\"109\":1}}],[\"顶级域名服务器在收到本地域名服务器的查询请求后\",{\"1\":{\"1031\":1}}],[\"化身\",{\"1\":{\"1027\":1}}],[\"半连接队列和全连接队列\",{\"0\":{\"1025\":1}}],[\"半双工的\",{\"1\":{\"149\":1}}],[\"∑对资源的需求>可用资源\",{\"1\":{\"1019\":1}}],[\"糊涂窗口综合征\",{\"0\":{\"1018\":1}}],[\"陷入死锁\",{\"1\":{\"1015\":1}}],[\"陷入指令\",{\"1\":{\"135\":1}}],[\"陷入指令是唯一一个只能在用户态\",{\"1\":{\"134\":1}}],[\"滑动窗口的大小代表接收方还有多大的缓冲区可以用于接收数据\",{\"1\":{\"1015\":1}}],[\"滑动窗口\",{\"0\":{\"1015\":1}}],[\"点这个\",{\"1\":{\"1273\":1}}],[\"点\",{\"0\":{\"1014\":1}}],[\"点对点信道的数据链路层的协议数据单元\",{\"1\":{\"971\":1}}],[\"点对点信道\",{\"1\":{\"968\":1}}],[\"点对点协议ppp\",{\"0\":{\"975\":1},\"1\":{\"962\":1}}],[\"样式\",{\"0\":{\"1210\":1}}],[\"样式就会穿透到选择器的所有后代组件\",{\"1\":{\"24\":1}}],[\"样本\",{\"1\":{\"1012\":1}}],[\"α一般为0\",{\"1\":{\"1012\":1}}],[\"α=填入表的记录个数\",{\"1\":{\"925\":1}}],[\"凡位于发送窗口内的分组可以连续发送出去\",{\"1\":{\"1011\":1}}],[\"凡是在\",{\"1\":{\"624\":1}}],[\"凡是与内核态有关的操作\",{\"1\":{\"135\":1}}],[\"拥塞避免\",{\"1\":{\"1019\":2}}],[\"拥塞控制窗口的大小取决于网络的拥塞程度\",{\"1\":{\"1019\":1}}],[\"拥塞控制和流量控制不同\",{\"1\":{\"1019\":1}}],[\"拥塞控制\",{\"1\":{\"1009\":1}}],[\"拥有和\",{\"1\":{\"661\":1}}],[\"拥有\",{\"1\":{\"335\":1}}],[\"拥有更高的并发性\",{\"1\":{\"40\":1}}],[\"认为刚才发送过的分组丢失了\",{\"1\":{\"1011\":1}}],[\"认为最适合发送的数据块\",{\"1\":{\"1009\":1}}],[\"认为内存足够大\",{\"1\":{\"484\":1}}],[\"紧急指针\",{\"1\":{\"1007\":1}}],[\"紧接着的2个字节代表访问标志\",{\"1\":{\"287\":1}}],[\"紧接着主\",{\"1\":{\"286\":1}}],[\"紧接着魔数的4个字节存储的是class文件的版本号\",{\"1\":{\"285\":1}}],[\"窗口就大一点\",{\"1\":{\"1019\":1}}],[\"窗口值作为接收方让发送方设置其发送窗口的大小\",{\"1\":{\"1007\":1}}],[\"窗口\",{\"1\":{\"1007\":1}}],[\"登记端口号\",{\"1\":{\"1000\":1}}],[\"登录验证\",{\"1\":{\"759\":1}}],[\"登录\",{\"1\":{\"459\":1}}],[\"极大的增强了网络安全\",{\"1\":{\"996\":1}}],[\"极端情况可能出现大量的过期\",{\"1\":{\"632\":1}}],[\"询问报文\",{\"1\":{\"993\":1}}],[\"终点不可达\",{\"1\":{\"993\":1}}],[\"终止等待1\",{\"1\":{\"1026\":1}}],[\"终止控制位fin置1\",{\"1\":{\"1026\":1}}],[\"终止fin\",{\"1\":{\"1007\":1}}],[\"终止所有事务执行\",{\"1\":{\"665\":1}}],[\"终止当前事务\",{\"1\":{\"665\":1}}],[\"终止\",{\"1\":{\"38\":1}}],[\"交易对手是这个子域中的实体\",{\"1\":{\"1240\":1}}],[\"交互\",{\"1\":{\"1239\":1}}],[\"交互概览图\",{\"1\":{\"1094\":1}}],[\"交付\",{\"1\":{\"990\":1}}],[\"交换两个数\",{\"0\":{\"947\":1}}],[\"交换\",{\"1\":{\"931\":5,\"933\":1}}],[\"交换信息\",{\"1\":{\"820\":2}}],[\"交换结果\",{\"1\":{\"820\":1}}],[\"匹配包括换行在内的所有字符\",{\"1\":{\"1190\":1}}],[\"匹配成功\",{\"1\":{\"1188\":1}}],[\"匹配的正则表达式\",{\"1\":{\"1188\":1}}],[\"匹配\",{\"1\":{\"990\":1}}],[\"片偏移以8个字节为一个单位\",{\"1\":{\"987\":1}}],[\"伪随机数生成器等\",{\"1\":{\"1062\":1}}],[\"伪首部\",{\"1\":{\"1002\":1}}],[\"伪造大量的虚假\",{\"1\":{\"1060\":1}}],[\"伪造\",{\"1\":{\"986\":1}}],[\"伪代码\",{\"1\":{\"304\":1}}],[\"欺骗\",{\"1\":{\"986\":2}}],[\"星形网\",{\"1\":{\"977\":1}}],[\"局域网的拓扑\",{\"1\":{\"977\":1}}],[\"局域网的数据链路层\",{\"0\":{\"977\":1}}],[\"局部变量\",{\"1\":{\"234\":1,\"304\":1}}],[\"局部变量表不用放this\",{\"1\":{\"227\":1}}],[\"局部变量表中的变量是重要的垃圾回收根节点\",{\"1\":{\"192\":1}}],[\"局部变量表的容量以变量槽\",{\"1\":{\"192\":1}}],[\"局部变量表\",{\"0\":{\"192\":1}}],[\"局部性原理是虚拟内存技术的基础\",{\"1\":{\"158\":1}}],[\"局部性原理\",{\"0\":{\"158\":1,\"543\":1}}],[\"透明性\",{\"1\":{\"975\":1}}],[\"透明传输\",{\"0\":{\"973\":1},\"1\":{\"961\":1}}],[\"差错控制报文的内容\",{\"1\":{\"993\":1}}],[\"差错报告报文\",{\"1\":{\"993\":1}}],[\"差错检测\",{\"0\":{\"974\":1},\"1\":{\"975\":1}}],[\"差错校验\",{\"1\":{\"961\":1}}],[\"帧开始定界符的前6位与前同步码一样\",{\"1\":{\"980\":1}}],[\"帧定界可以使用特殊的帧定界符\",{\"1\":{\"972\":1}}],[\"帧\",{\"1\":{\"971\":1}}],[\"光纤到户ftth\",{\"1\":{\"968\":1}}],[\"光纤同轴混合网\",{\"1\":{\"968\":1}}],[\"宽带接入技术\",{\"0\":{\"968\":1}}],[\"码分复用cdm\",{\"1\":{\"967\":1}}],[\"码的唯一性\",{\"1\":{\"369\":1}}],[\"波分复用wdm\",{\"1\":{\"967\":1}}],[\"电器厂既生产电视机又生产洗衣机或空调\",{\"1\":{\"1079\":1}}],[\"电器特性\",{\"1\":{\"966\":1}}],[\"电视机厂只生产电视机\",{\"1\":{\"1079\":1}}],[\"电梯调度算法\",{\"1\":{\"163\":1}}],[\"尺寸\",{\"1\":{\"966\":1}}],[\"沙漏计时器形状的tcp\",{\"1\":{\"964\":1}}],[\"沙箱主要限制系统资源访问\",{\"1\":{\"186\":1}}],[\"沙箱机制就是将java代码限定在jvm特定的运行范围内\",{\"1\":{\"186\":1}}],[\"沙箱安全机制\",{\"0\":{\"186\":1}}],[\"⽹络层负责将数据从⼀个设备传输到另⼀个设备\",{\"1\":{\"961\":1}}],[\"⾼效\",{\"1\":{\"961\":1}}],[\"七层协议\",{\"1\":{\"961\":1}}],[\"七\",{\"0\":{\"961\":1}}],[\"首部字段\",{\"1\":{\"1039\":1}}],[\"首部中的同步位syn=1\",{\"1\":{\"1022\":1}}],[\"首部中序号字段值则是指本报文段所发送的数据的第一个字节的序号\",{\"1\":{\"1007\":1}}],[\"首部+数据部分\",{\"1\":{\"987\":1}}],[\"首部和尾部的一个重要作用就是帧定界\",{\"1\":{\"972\":1}}],[\"首部又称为包头\",{\"1\":{\"960\":1}}],[\"首先取出公钥解密数字签名\",{\"1\":{\"1057\":1}}],[\"首先是查找主机自己的路由表\",{\"1\":{\"993\":1}}],[\"首先是这一天\",{\"1\":{\"892\":1}}],[\"首先就是要统计每个查询出现的次数\",{\"1\":{\"893\":1}}],[\"首先就会调用\",{\"1\":{\"114\":1}}],[\"首先可以根据数据值或者把数据hash\",{\"1\":{\"891\":1}}],[\"首先我们将\",{\"1\":{\"886\":1}}],[\"首先引入依赖\",{\"1\":{\"882\":1}}],[\"首先注册中心挂掉也要分两种情况\",{\"1\":{\"803\":1}}],[\"首先用成员变量来保存存入的真实对象\",{\"1\":{\"725\":1}}],[\"首先会尝试进行增量同步\",{\"1\":{\"655\":1}}],[\"首先应该在业务上精简业务对象\",{\"1\":{\"637\":1}}],[\"首先分析语句\",{\"1\":{\"559\":1}}],[\"首先保证符合条件的记录上加上排它锁\",{\"1\":{\"506\":1}}],[\"首先执行前会校验该用户有没有权限\",{\"1\":{\"490\":1}}],[\"首先要求接收方不要等待自己发送数据时才进行捎带确认\",{\"1\":{\"1019\":1}}],[\"首先要提取关键字\",{\"1\":{\"490\":1}}],[\"首先要去\",{\"1\":{\"72\":1}}],[\"首先讲讲为什么要有主键\",{\"1\":{\"464\":1}}],[\"首先根据\",{\"1\":{\"410\":1}}],[\"首先调用\",{\"1\":{\"406\":1}}],[\"首先比较\",{\"1\":{\"400\":1}}],[\"首先对\",{\"1\":{\"397\":1,\"398\":1}}],[\"首先一个\",{\"1\":{\"380\":1}}],[\"首先检查父类中是否有该方法\",{\"1\":{\"355\":1}}],[\"首先必须定义一个接口\",{\"1\":{\"349\":1}}],[\"首先标记出所有需要回收的对象\",{\"1\":{\"244\":1,\"246\":1}}],[\"首先在根节点进行二分查找\",{\"1\":{\"538\":1}}],[\"首先在\",{\"1\":{\"219\":1}}],[\"首先\",{\"1\":{\"156\":1,\"201\":1,\"501\":1,\"576\":1,\"630\":1,\"754\":1,\"820\":4,\"838\":1,\"1022\":1}}],[\"首先定位到\",{\"1\":{\"129\":1}}],[\"首先将\",{\"1\":{\"398\":1}}],[\"首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用\",{\"1\":{\"214\":1}}],[\"首先将数据分成\",{\"1\":{\"129\":1}}],[\"首先将线程池的状态设为\",{\"1\":{\"59\":1}}],[\"客户可以通过外观角色访问它\",{\"1\":{\"1090\":1}}],[\"客户对系统的访问也变得越来越复杂\",{\"1\":{\"1090\":1}}],[\"客户角色\",{\"1\":{\"1082\":1,\"1083\":1}}],[\"客户类往往有多个\",{\"1\":{\"1077\":1}}],[\"客户类不再需要知道有哪些子类以及应当实例化哪个子类\",{\"1\":{\"1077\":1}}],[\"客户来访的时候只需要查询客户档案表就可以了\",{\"1\":{\"1052\":1}}],[\"客户明细表\",{\"1\":{\"1052\":1}}],[\"客户访问所有的对象只需一个rtt时间\",{\"1\":{\"1042\":1}}],[\"客户在收到前一个响应之前就能发出下一个请求\",{\"1\":{\"1042\":1}}],[\"客户在收到前一个响应之后才能发出下一个请求\",{\"1\":{\"1042\":1}}],[\"客户\",{\"1\":{\"960\":1,\"1090\":1}}],[\"客户端也要跟着改变\",{\"1\":{\"1090\":1}}],[\"客户端也正在客户那边实际部署\",{\"1\":{\"696\":1}}],[\"客户端必须理解所有策略算法的区别\",{\"1\":{\"1088\":1}}],[\"客户端不必知道产品内部组成的细节\",{\"1\":{\"1086\":1}}],[\"客户端不需要连接集群所有节点\",{\"1\":{\"659\":1}}],[\"客户端储存token\",{\"1\":{\"1053\":1}}],[\"客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了\",{\"1\":{\"1052\":1}}],[\"客户端浏览器访问服务器的时候\",{\"1\":{\"1052\":1}}],[\"客户端浏览器会把cookie保存起来\",{\"1\":{\"1051\":1}}],[\"客户端请求服务器\",{\"1\":{\"1051\":1}}],[\"客户端会向给它分配ip地址的dhcp服务器发送一个单播请求报文\",{\"1\":{\"1049\":1}}],[\"客户端用ca的公钥对证书解密\",{\"1\":{\"1044\":1}}],[\"客户端验证证书是否有效\",{\"1\":{\"1044\":1}}],[\"客户端向服务器发起\",{\"1\":{\"1044\":1}}],[\"客户端可以同时发送多个请求\",{\"1\":{\"1042\":1}}],[\"客户端错误状态码\",{\"1\":{\"1040\":1}}],[\"客户端在发送完最后一个\",{\"1\":{\"1027\":1}}],[\"客户端在做远程过程调用时\",{\"1\":{\"804\":1}}],[\"客户端ack\",{\"1\":{\"1026\":1}}],[\"客户端fin\",{\"1\":{\"1026\":1}}],[\"客户端共发出了两个连接请求报文段\",{\"1\":{\"1023\":1}}],[\"客户端等待一个超时重传时间之后\",{\"1\":{\"1022\":1}}],[\"客户端收到服务器的连接释放报文段之后\",{\"1\":{\"1026\":1}}],[\"客户端收到\",{\"1\":{\"1022\":1}}],[\"客户端收到消息后\",{\"1\":{\"804\":1}}],[\"客户端发送一个fin报文\",{\"1\":{\"1026\":1}}],[\"客户端发送一条查询\",{\"1\":{\"489\":1}}],[\"客户端发送的连接请求\",{\"1\":{\"1022\":1}}],[\"客户端发送syn报文\",{\"1\":{\"1022\":1}}],[\"客户端使用的端口号\",{\"1\":{\"1000\":1}}],[\"客户端的差错\",{\"1\":{\"1040\":1}}],[\"客户端的应用进程先向其tcp发出连接释放报文段\",{\"1\":{\"1026\":1}}],[\"客户端的请求\",{\"1\":{\"830\":1}}],[\"客户端的信创适配\",{\"1\":{\"687\":1}}],[\"客户端通过\",{\"1\":{\"825\":1,\"1083\":1}}],[\"客户端注册监听它关心的目录节点\",{\"1\":{\"817\":1}}],[\"客户端之间如何去访问\",{\"1\":{\"815\":1}}],[\"客户端调用远程服务方法时调用的是\",{\"1\":{\"804\":1}}],[\"客户端跟服务端是不同的进程\",{\"1\":{\"804\":1}}],[\"客户端怎么把方法参数值传给远程函数呢\",{\"1\":{\"804\":1}}],[\"客户端\",{\"1\":{\"715\":1,\"804\":2,\"822\":1}}],[\"客户端与服务器端建立连接\",{\"1\":{\"1003\":1}}],[\"客户端与zookeeper\",{\"1\":{\"818\":1}}],[\"客户端与zookeeper断开连接后\",{\"1\":{\"818\":1}}],[\"客户端与\",{\"1\":{\"659\":1}}],[\"客户端与数据库server层建立\",{\"1\":{\"489\":1}}],[\"客户端仍然可以提交查询或修改请求\",{\"1\":{\"656\":1}}],[\"客户端代理\",{\"1\":{\"586\":1}}],[\"客户端和浏览器都可以同时发送多个请求或回应\",{\"1\":{\"1042\":1}}],[\"客户端和\",{\"1\":{\"380\":1}}],[\"边缘部分\",{\"1\":{\"960\":1}}],[\"边缘触发和水平触发\",{\"0\":{\"613\":1}}],[\"边缘触发\",{\"1\":{\"381\":1}}],[\"报告转发分组出错\",{\"1\":{\"990\":1}}],[\"报文风格\",{\"1\":{\"1259\":1}}],[\"报文的最大长度\",{\"1\":{\"1033\":1}}],[\"报文后立即释放连接\",{\"1\":{\"1027\":1}}],[\"报文段丢失\",{\"1\":{\"1027\":1}}],[\"报文段能够到达\",{\"1\":{\"1027\":1}}],[\"报文段首部的前20个字节是固定的\",{\"1\":{\"1007\":1}}],[\"报文最大生存时间\",{\"1\":{\"1027\":1}}],[\"报文之后\",{\"1\":{\"1022\":1}}],[\"报文或用户数据报\",{\"1\":{\"1006\":1}}],[\"报文进行校验\",{\"1\":{\"996\":1}}],[\"报文\",{\"1\":{\"959\":1,\"1003\":1,\"1022\":1,\"1029\":1,\"1047\":1,\"1049\":1}}],[\"报错exception\",{\"1\":{\"1144\":1}}],[\"报错\",{\"1\":{\"481\":1,\"1168\":1}}],[\"浏览器把请求的网址连同该cookie一同提交给服务器\",{\"1\":{\"1051\":1}}],[\"浏览器根据本地存储的随机数进行解密\",{\"1\":{\"1044\":1}}],[\"浏览器根据其请求到的资源\",{\"1\":{\"959\":1,\"1029\":1}}],[\"浏览器就可以把http请求报文\",{\"1\":{\"1042\":1}}],[\"浏览器的每次请求都需要与服务器建立一个tcp连接\",{\"1\":{\"1042\":1}}],[\"浏览器发送请求的路径与\",{\"1\":{\"1039\":1}}],[\"浏览器可以接受的字符编码集\",{\"1\":{\"1039\":1}}],[\"浏览器可接受的语言\",{\"1\":{\"1039\":1}}],[\"浏览器表明自己的身份\",{\"1\":{\"1039\":1}}],[\"浏览器指定请求的服务器的域名或端口号\",{\"1\":{\"1039\":1}}],[\"浏览器先查询hosts文件是否有与这个域名对应的ip地址\",{\"1\":{\"1031\":1}}],[\"浏览器等\",{\"1\":{\"961\":1}}],[\"浏览器解析并渲染视图\",{\"1\":{\"959\":1,\"1029\":1}}],[\"浏览器解析渲染页面\",{\"1\":{\"959\":1,\"1029\":1}}],[\"浏览器向服务器发送\",{\"1\":{\"959\":1,\"1029\":1}}],[\"浏览器向服务器请求建立链接\",{\"1\":{\"959\":1,\"1029\":1}}],[\"浏览器获得域名对应的\",{\"1\":{\"959\":1,\"1029\":1}}],[\"浏览器查询\",{\"1\":{\"959\":1,\"1029\":1}}],[\"乘进res\",{\"1\":{\"949\":1}}],[\"奇数的二进制的最后一位肯定是1\",{\"1\":{\"946\":1}}],[\"奇数\",{\"1\":{\"946\":1}}],[\"奇数台\",{\"1\":{\"819\":1}}],[\"待排序的序列为正序或者逆序\",{\"1\":{\"935\":1}}],[\"待调用\",{\"1\":{\"37\":1}}],[\"治\",{\"1\":{\"934\":1}}],[\"希尔排序\",{\"0\":{\"933\":1}}],[\"希望系统停顿时间尽可能短\",{\"1\":{\"259\":1}}],[\"冒泡排序\",{\"0\":{\"930\":1}}],[\"走到链表尾的\",{\"1\":{\"927\":1}}],[\"走到第一个\",{\"1\":{\"101\":1}}],[\"走\",{\"1\":{\"927\":1}}],[\"折叠法\",{\"1\":{\"923\":1}}],[\"抽取关键字的一部分来做某些运算\",{\"1\":{\"923\":1}}],[\"抽象策略\",{\"1\":{\"1088\":1}}],[\"抽象方法\",{\"1\":{\"1087\":1}}],[\"抽象模板\",{\"1\":{\"1087\":1}}],[\"抽象建造者\",{\"1\":{\"1086\":1}}],[\"抽象装饰\",{\"1\":{\"1085\":1}}],[\"抽象构件\",{\"1\":{\"1085\":1}}],[\"抽象角色\",{\"1\":{\"1082\":1}}],[\"抽象产品\",{\"1\":{\"1079\":1}}],[\"抽象产品只能生产一种产品\",{\"1\":{\"1078\":1}}],[\"抽象工厂增强了程序的可扩展性\",{\"1\":{\"1079\":1}}],[\"抽象工厂\",{\"1\":{\"1079\":1}}],[\"抽象工厂模式退化成工厂方法模式\",{\"1\":{\"1080\":1}}],[\"抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件\",{\"1\":{\"1079\":1}}],[\"抽象工厂模式有多个抽象产品\",{\"1\":{\"1079\":1}}],[\"抽象工厂模式与工厂方法模式最大的区别在于\",{\"1\":{\"1079\":1}}],[\"抽象工厂模式\",{\"0\":{\"1079\":1}}],[\"抽象不应该依赖于具体实现\",{\"1\":{\"1064\":1}}],[\"抽象类是为了简化接口的实现\",{\"1\":{\"362\":1}}],[\"抽象类是对类的抽象\",{\"1\":{\"362\":2}}],[\"抽象类和接口的选择\",{\"1\":{\"362\":1}}],[\"抽象类中抽象方法就是为了重写\",{\"1\":{\"362\":1}}],[\"抽象类中的成员权限可以是\",{\"1\":{\"362\":1}}],[\"抽象类中可以有抽象方法\",{\"1\":{\"362\":1}}],[\"抽象类中可以定义构造函数\",{\"1\":{\"362\":1}}],[\"抽象类\",{\"0\":{\"362\":1},\"1\":{\"736\":1,\"1087\":1}}],[\"抽象队列同步器\",{\"1\":{\"109\":1}}],[\"抽象队列式同步器\",{\"0\":{\"109\":1}}],[\"叶子结点\",{\"1\":{\"920\":1}}],[\"叶子节点之间使用双向指针连接\",{\"1\":{\"920\":1}}],[\"叶子节点存储主键值\",{\"1\":{\"549\":1}}],[\"叶子节点的data域存放的是数据记录的地址\",{\"1\":{\"547\":1}}],[\"阶的\",{\"1\":{\"919\":1}}],[\"阶段\",{\"1\":{\"244\":1,\"647\":1}}],[\"别返回\",{\"1\":{\"912\":1,\"913\":1}}],[\"别的线程并不能获取到当前线程的副本值\",{\"1\":{\"39\":1,\"41\":1}}],[\"右击文件夹\",{\"1\":{\"1273\":1}}],[\"右侧边栏飘红问题解决方案\",{\"1\":{\"1136\":1}}],[\"右侧边界左移\",{\"1\":{\"912\":1}}],[\"右移>>\",{\"1\":{\"943\":1}}],[\"右移\",{\"0\":{\"944\":1},\"1\":{\"943\":2}}],[\"右孩子的下标是\",{\"1\":{\"937\":1}}],[\"右边的索引\",{\"1\":{\"934\":1}}],[\"右旋操作保持二叉树的平衡\",{\"1\":{\"916\":1}}],[\"右\",{\"1\":{\"908\":2}}],[\"右连接\",{\"1\":{\"485\":1}}],[\"弹出栈打印\",{\"1\":{\"908\":2}}],[\"令这一位为1\",{\"1\":{\"903\":1}}],[\"理性的看一下题\",{\"1\":{\"902\":1}}],[\"理论情况下\",{\"1\":{\"882\":1}}],[\"理论是对\",{\"1\":{\"871\":1}}],[\"理论上无上限\",{\"1\":{\"829\":1}}],[\"理论上时间复杂度可以达到\",{\"1\":{\"645\":1}}],[\"理论上就只能采用较为复杂的空闲列表来分配内存\",{\"1\":{\"218\":1}}],[\"理论最优\",{\"1\":{\"160\":1}}],[\"千万别被2000千万这个数字唬住\",{\"1\":{\"902\":1}}],[\"千万级大表的优化\",{\"0\":{\"561\":1}}],[\"腾讯面试题\",{\"0\":{\"901\":1}}],[\"腾讯等\",{\"1\":{\"824\":1}}],[\"采取不同的数据字典\",{\"1\":{\"1259\":1}}],[\"采取赋值方法\",{\"1\":{\"935\":1}}],[\"采取和a相同的方式将\",{\"1\":{\"896\":1}}],[\"采用宽表的设计\",{\"1\":{\"1259\":1}}],[\"采用防火墙或直接将这个\",{\"1\":{\"1060\":1}}],[\"采用散列技术将记录存储在一块连续的存储空间中\",{\"1\":{\"922\":1}}],[\"采用2\",{\"1\":{\"900\":1}}],[\"采用分布式的架构来处理\",{\"1\":{\"895\":1}}],[\"采用trie树\",{\"1\":{\"894\":1}}],[\"采用一致性哈希算法\",{\"1\":{\"880\":1}}],[\"采用适当的方式来使系统达到最终一致性\",{\"1\":{\"871\":1}}],[\"采用独立的进程\",{\"1\":{\"834\":1}}],[\"采用直连方式\",{\"1\":{\"803\":1}}],[\"采用哈希槽分区\",{\"1\":{\"679\":1}}],[\"采用双机主备架构\",{\"1\":{\"675\":1}}],[\"采用主从部署结构\",{\"1\":{\"675\":1}}],[\"采用主从复制\",{\"1\":{\"579\":1}}],[\"采用单个\",{\"1\":{\"674\":1}}],[\"采用去中心化思想\",{\"1\":{\"660\":1}}],[\"采用去中心化的思想\",{\"1\":{\"659\":1}}],[\"采用多级缓存\",{\"1\":{\"642\":1}}],[\"采用渐进式\",{\"1\":{\"623\":1}}],[\"采用的是\",{\"1\":{\"618\":1}}],[\"采用int\",{\"1\":{\"617\":1}}],[\"采用非阻塞\",{\"1\":{\"604\":1}}],[\"采用了第二种方案进行同步ack之后\",{\"1\":{\"853\":1}}],[\"采用了单线程\",{\"1\":{\"604\":1}}],[\"采用了分段锁策略\",{\"1\":{\"128\":1}}],[\"采用链表的方式解决哈希冲突\",{\"1\":{\"537\":1}}],[\"采用force\",{\"1\":{\"536\":1}}],[\"采用三个文件组织一张表\",{\"1\":{\"493\":1}}],[\"采用两个文件组织一张表\",{\"1\":{\"493\":1}}],[\"采用可以替换的插件式架构\",{\"1\":{\"488\":1}}],[\"采用程序信号的格式显示程序状况\",{\"1\":{\"426\":1}}],[\"采用在本地内存中实现的元空间\",{\"1\":{\"203\":1}}],[\"采用cas+synchronized保证线程安全\",{\"1\":{\"130\":1}}],[\"采用\",{\"1\":{\"1\":1,\"40\":2,\"130\":1,\"619\":1,\"745\":1,\"1006\":1}}],[\"借助小根堆\",{\"1\":{\"893\":1}}],[\"借助于\",{\"1\":{\"94\":1}}],[\"雪域之鹰\",{\"1\":{\"892\":1}}],[\"及相应的频率\",{\"1\":{\"892\":1}}],[\"及以前的版本\",{\"1\":{\"525\":1}}],[\"近似统计\",{\"1\":{\"891\":1}}],[\"词的大小不超过16字节\",{\"0\":{\"894\":1}}],[\"词的大小不超过16个字节\",{\"1\":{\"889\":1}}],[\"词的大小为16个字节\",{\"1\":{\"889\":1}}],[\"词法分析\",{\"1\":{\"490\":1}}],[\"划分了边界上下文\",{\"1\":{\"1224\":1}}],[\"划分边界上下文\",{\"0\":{\"1220\":1}}],[\"划分边界上下文三个阶段\",{\"1\":{\"1215\":1}}],[\"划分子网\",{\"0\":{\"989\":1}}],[\"划分子网和构造超网\",{\"0\":{\"988\":1}}],[\"划分子集分别统计\",{\"1\":{\"891\":1}}],[\"划分为2^16个区域\",{\"1\":{\"886\":1}}],[\"划分为2^8个区域\",{\"1\":{\"886\":1}}],[\"划分中\",{\"1\":{\"200\":1}}],[\"求每对小文件中相同的\",{\"1\":{\"896\":1}}],[\"求取hash\",{\"1\":{\"896\":1}}],[\"求前n小\",{\"1\":{\"885\":1}}],[\"求余数\",{\"1\":{\"659\":1}}],[\"海量数据分布在100台电脑中\",{\"1\":{\"891\":1}}],[\"海量数据前n大\",{\"1\":{\"885\":1}}],[\"海量数据问题\",{\"0\":{\"881\":1}}],[\"海量日志数据\",{\"0\":{\"892\":1},\"1\":{\"884\":1}}],[\"判重\",{\"1\":{\"883\":1}}],[\"判断网络拥塞的依据就是出现了超时\",{\"1\":{\"1019\":1}}],[\"判断其是否是一个有效的二叉搜索树\",{\"1\":{\"956\":1}}],[\"判断一个数的奇偶性\",{\"0\":{\"946\":1}}],[\"判断一个程序是否存在线程安全问题\",{\"1\":{\"48\":1}}],[\"判断元素是否进行过交换\",{\"1\":{\"930\":1}}],[\"判断指定元素是否存在\",{\"1\":{\"882\":1}}],[\"判断请求的数据是否有效避免直接绕过缓存请求数据库\",{\"1\":{\"882\":1}}],[\"判断给定数据是否存在\",{\"1\":{\"882\":1}}],[\"判断有没有冲突\",{\"1\":{\"574\":2}}],[\"判断目前的数据结构是链表还是红黑树\",{\"1\":{\"397\":1}}],[\"判断两个对象是否相等\",{\"1\":{\"340\":1}}],[\"判断两个类是否相同\",{\"0\":{\"166\":1}}],[\"判断对象不再被使用的算法\",{\"1\":{\"232\":1}}],[\"判断对象对应的类是否加载\",{\"0\":{\"214\":1}}],[\"判断是否获取锁的方式很简单\",{\"1\":{\"668\":1}}],[\"判断是否有\",{\"1\":{\"398\":1}}],[\"判断是否需要进行初始化\",{\"1\":{\"131\":1}}],[\"判断是否持有独占锁\",{\"1\":{\"109\":1}}],[\"判断容器是否发生变化根据\",{\"1\":{\"129\":1}}],[\"判断\",{\"1\":{\"101\":1,\"118\":1,\"578\":1,\"807\":1,\"1068\":1}}],[\"黑名单功能等等\",{\"1\":{\"882\":1}}],[\"邮箱的垃圾邮件过滤\",{\"1\":{\"882\":1}}],[\"邮箱等系统的过滤\",{\"1\":{\"645\":1}}],[\"倒排索引\",{\"0\":{\"888\":1},\"1\":{\"881\":1}}],[\"倒计时器\",{\"0\":{\"118\":1}}],[\"归并之后这样不能保证找到真正的第100个\",{\"1\":{\"891\":1}}],[\"归并排序就可以了\",{\"1\":{\"895\":1}}],[\"归并排序按照出现次数进行排序\",{\"1\":{\"895\":1}}],[\"归并排序\",{\"0\":{\"934\":1},\"1\":{\"881\":1,\"894\":1,\"895\":1,\"897\":1}}],[\"归根结底\",{\"1\":{\"536\":1}}],[\"往顺时针的方向的找到第一个节点\",{\"1\":{\"880\":1}}],[\"往往指的就是数据库事务\",{\"1\":{\"518\":1}}],[\"往往会比\",{\"1\":{\"442\":1}}],[\"赢得选举的条件是\",{\"1\":{\"877\":1}}],[\"赢得了选举\",{\"1\":{\"876\":1}}],[\"周期性发送心跳来保证自己的\",{\"1\":{\"877\":1}}],[\"投票给\",{\"1\":{\"874\":1}}],[\"投票的结果由\",{\"1\":{\"657\":1}}],[\"健壮性\",{\"1\":{\"873\":1}}],[\"仍在一段时间内保持这条连接\",{\"1\":{\"1042\":1}}],[\"仍需要保持系统整体\",{\"1\":{\"871\":1}}],[\"仍然将窗口设置为1个字节\",{\"1\":{\"1018\":1}}],[\"仍然会出错\",{\"1\":{\"891\":1}}],[\"仍然能够对外提供服务\",{\"1\":{\"870\":1}}],[\"仍然有可能引起系统的崩溃\",{\"1\":{\"681\":1}}],[\"仍然有新任务这时会执行拒绝策略\",{\"1\":{\"58\":1}}],[\"仍然需要保证服务还是可用的\",{\"1\":{\"644\":1}}],[\"仍然正常处理客户端请求\",{\"1\":{\"615\":1}}],[\"仍然存在\",{\"1\":{\"427\":1}}],[\"仍然不可以包含静态代码块\",{\"1\":{\"362\":1}}],[\"仍然还有停顿\",{\"1\":{\"254\":1}}],[\"漏掉消息\",{\"1\":{\"866\":1}}],[\"送的消息没有收到ack\",{\"1\":{\"866\":1}}],[\"启用幂等性\",{\"1\":{\"856\":1}}],[\"启动失败删除mysql容器\",{\"1\":{\"1177\":1}}],[\"启动kafka的幂等性\",{\"1\":{\"866\":1}}],[\"启动一个新的worker进程\",{\"1\":{\"837\":1}}],[\"启动后\",{\"1\":{\"833\":1}}],[\"启动后会通过\",{\"1\":{\"801\":1}}],[\"启动时同步数据给\",{\"1\":{\"820\":1}}],[\"启动类上面的注解是\",{\"1\":{\"777\":1}}],[\"启动类加载器是绝不可能认识\",{\"1\":{\"185\":1}}],[\"启动类加载器现在在jvm内部和java类库共同协作实现的类加载器\",{\"1\":{\"181\":1}}],[\"启动类加载器\",{\"0\":{\"176\":1},\"1\":{\"175\":1}}],[\"启动成功登录mysql\",{\"1\":{\"1177\":1}}],[\"启动成功连接到\",{\"1\":{\"662\":1}}],[\"启动成功之后\",{\"1\":{\"655\":1}}],[\"启动\",{\"0\":{\"781\":1},\"1\":{\"656\":1,\"820\":5}}],[\"迟迟不能够与leader进行同步\",{\"1\":{\"853\":1}}],[\"副本同步队列\",{\"1\":{\"853\":1}}],[\"副本replication\",{\"1\":{\"845\":1}}],[\"物流系统是否成功\",{\"1\":{\"840\":1}}],[\"物流系统耦合在一起\",{\"1\":{\"840\":1}}],[\"物理层使用的中间设备叫做转发器\",{\"1\":{\"965\":1}}],[\"物理层\",{\"1\":{\"961\":2,\"962\":1}}],[\"物理上是在文件系统的\",{\"1\":{\"568\":1}}],[\"物理上是在\",{\"1\":{\"568\":1}}],[\"物理上不连续\",{\"1\":{\"260\":1}}],[\"物理分区\",{\"1\":{\"203\":1}}],[\"物理地址\",{\"1\":{\"153\":1}}],[\"权衡的结果\",{\"1\":{\"871\":1}}],[\"权重越高被分配的客户端越多\",{\"1\":{\"832\":1}}],[\"权重\",{\"1\":{\"832\":1}}],[\"权限配置\",{\"0\":{\"1199\":1}}],[\"权限控制等\",{\"1\":{\"715\":1}}],[\"权限等操作\",{\"1\":{\"490\":1}}],[\"权限校验\",{\"1\":{\"489\":2}}],[\"权限表存放在mysql数据库里\",{\"1\":{\"458\":1}}],[\"权限表\",{\"0\":{\"458\":1}}],[\"权限没有要求\",{\"1\":{\"212\":1}}],[\"权限必须是public\",{\"1\":{\"212\":1}}],[\"遇到问题\",{\"1\":{\"1144\":2}}],[\"遇到自己订阅的则消费\",{\"1\":{\"859\":1}}],[\"遇到阻塞\",{\"1\":{\"831\":1}}],[\"遇到异常\",{\"1\":{\"195\":1}}],[\"综上\",{\"1\":{\"830\":1}}],[\"综合了解释执行和即时编译两者的优点\",{\"1\":{\"283\":1}}],[\"动作以及事件进行全面的梳理\",{\"1\":{\"1216\":1}}],[\"动静分离目前实现方案分两种\",{\"1\":{\"827\":1}}],[\"动静分离\",{\"1\":{\"827\":1}}],[\"动态的给一个对象扩展功能\",{\"1\":{\"1085\":1}}],[\"动态的向某个对象提供它所需要的其他对象\",{\"1\":{\"718\":1}}],[\"动态地给该对象增加一些职责\",{\"1\":{\"1085\":1}}],[\"动态地将横切逻辑和业务编织在一起\",{\"1\":{\"715\":1,\"725\":1}}],[\"动态主机配置协议dhcp\",{\"0\":{\"1049\":1},\"1\":{\"962\":1}}],[\"动态分配\",{\"1\":{\"869\":1}}],[\"动态分派与重写有关\",{\"1\":{\"278\":1}}],[\"动态分派\",{\"0\":{\"278\":1}}],[\"动态分派的那个例子里有体现\",{\"1\":{\"275\":1}}],[\"动态跟静态文件混合在一起发布\",{\"1\":{\"827\":1}}],[\"动态跟踪代码\",{\"1\":{\"313\":1}}],[\"动态决定该创建哪一个产品类\",{\"1\":{\"737\":1}}],[\"动态字符串的优点\",{\"1\":{\"624\":1}}],[\"动态字符串\",{\"0\":{\"624\":1}}],[\"动态代理提供了很好的补充\",{\"1\":{\"1084\":1}}],[\"动态代理是一种较为高级的代理模式\",{\"1\":{\"1083\":1}}],[\"动态代理来生成\",{\"1\":{\"725\":1}}],[\"动态代理模式只能代理接口而不能代理类\",{\"1\":{\"725\":1}}],[\"动态代理模式\",{\"1\":{\"725\":1}}],[\"动态代理的优势在于可以很方便的对代理类的函数进行统一的处理\",{\"1\":{\"723\":1,\"724\":1}}],[\"动态代理的应用\",{\"1\":{\"349\":1}}],[\"动态代理与静态代理\",{\"0\":{\"723\":1}}],[\"动态代理\",{\"0\":{\"349\":1,\"1083\":1},\"1\":{\"725\":1,\"759\":1}}],[\"动态加载类\",{\"1\":{\"348\":1}}],[\"动态加载类过多\",{\"1\":{\"206\":1}}],[\"动态调用点和动态常量\",{\"1\":{\"286\":1}}],[\"动态创建和销毁\",{\"1\":{\"268\":1}}],[\"动态对象年龄判断\",{\"1\":{\"220\":1}}],[\"动态\",{\"1\":{\"194\":2}}],[\"动态连接\",{\"0\":{\"194\":1},\"1\":{\"190\":1,\"191\":1}}],[\"动态为接口替换实现类\",{\"1\":{\"185\":1}}],[\"动态链接就是在编译的时候不直接拷贝可执行代码\",{\"1\":{\"161\":1}}],[\"动态链接库和静态链接库\",{\"0\":{\"161\":1}}],[\"动态规划\",{\"0\":{\"12\":1}}],[\"淘宝\",{\"1\":{\"824\":1}}],[\"淘汰机制\",{\"1\":{\"607\":1}}],[\"京东\",{\"1\":{\"824\":1}}],[\"百度面试题\",{\"1\":{\"893\":1}}],[\"百度\",{\"0\":{\"893\":1},\"1\":{\"824\":1}}],[\"均匀\",{\"1\":{\"922\":1}}],[\"均成为追随者状态\",{\"1\":{\"820\":1}}],[\"均会进入时长不等的阻塞状态\",{\"1\":{\"660\":1}}],[\"均会加锁\",{\"1\":{\"501\":1}}],[\"胜出\",{\"1\":{\"820\":2}}],[\"台服务器\",{\"1\":{\"820\":1}}],[\"参考文档地址\",{\"1\":{\"1210\":1}}],[\"参考博文\",{\"0\":{\"1203\":1}}],[\"参考菜鸟教程正则表达式\",{\"0\":{\"1194\":1}}],[\"参见\",{\"1\":{\"1188\":1}}],[\"参与投票\",{\"1\":{\"820\":1}}],[\"参数问题\",{\"1\":{\"993\":1}}],[\"参数a的值应当尽可能小些\",{\"1\":{\"978\":1}}],[\"参数文件\",{\"1\":{\"820\":1}}],[\"参数请求将被拒绝\",{\"1\":{\"807\":1}}],[\"参数说明注释中已经说明\",{\"1\":{\"726\":1}}],[\"参数来定义快照的周期\",{\"1\":{\"647\":1}}],[\"参数binlog\",{\"1\":{\"571\":1}}],[\"参数\",{\"1\":{\"563\":1,\"568\":1,\"1041\":1,\"1060\":1,\"1188\":1}}],[\"参数相同\",{\"1\":{\"426\":1}}],[\"参数或常驻服务的标示\",{\"1\":{\"426\":1}}],[\"参数等\",{\"1\":{\"369\":1}}],[\"参数个数不同或者二者都不同\",{\"1\":{\"359\":1}}],[\"参数个数不同甚至是参数顺序不同\",{\"1\":{\"359\":1}}],[\"参数个数\",{\"1\":{\"359\":1}}],[\"参数类型\",{\"1\":{\"359\":1}}],[\"参数类型不同\",{\"1\":{\"359\":2}}],[\"参数列表\",{\"1\":{\"359\":1}}],[\"参数设置\",{\"1\":{\"262\":1}}],[\"参数的\",{\"1\":{\"38\":4}}],[\"参数2\",{\"1\":{\"31\":1}}],[\"参数1\",{\"1\":{\"31\":1}}],[\"竞选状态\",{\"1\":{\"820\":1}}],[\"角色\",{\"1\":{\"819\":1,\"820\":1,\"1085\":4,\"1090\":3}}],[\"角度考虑\",{\"1\":{\"583\":1}}],[\"端点鉴别\",{\"1\":{\"1055\":1}}],[\"端连接\",{\"1\":{\"999\":1}}],[\"端会对某个\",{\"1\":{\"817\":1}}],[\"端口不同\",{\"1\":{\"1048\":1}}],[\"端口分用\",{\"1\":{\"1002\":1}}],[\"端口\",{\"0\":{\"1000\":1},\"1\":{\"1044\":1}}],[\"端口信息等注册到\",{\"1\":{\"801\":1}}],[\"端口号只具有本地意义\",{\"1\":{\"1000\":1}}],[\"端口号\",{\"1\":{\"662\":1}}],[\"广播方请求报文进行续约\",{\"1\":{\"1049\":1}}],[\"广播\",{\"1\":{\"1001\":1}}],[\"广播通信\",{\"1\":{\"1001\":1}}],[\"广播帧\",{\"1\":{\"979\":1}}],[\"广播信道\",{\"1\":{\"968\":1}}],[\"广播调用所有提供者\",{\"1\":{\"813\":1}}],[\"广义指令\",{\"1\":{\"135\":1}}],[\"挑一个响应速度最快的服务器\",{\"1\":{\"812\":1}}],[\"挑选备选的\",{\"1\":{\"677\":1}}],[\"轮训这类的策略只能适用与每个节点的数据都是相同的场景\",{\"1\":{\"880\":1}}],[\"轮询的方式会导致每个consumer所承载的分区数量不一致\",{\"1\":{\"859\":1}}],[\"轮询策略\",{\"1\":{\"859\":1}}],[\"轮询\",{\"1\":{\"812\":1,\"832\":1,\"852\":1,\"869\":1}}],[\"轮流执行一个时间片\",{\"1\":{\"150\":1}}],[\"暴露的函数\",{\"1\":{\"1155\":1}}],[\"暴露自己的\",{\"1\":{\"811\":1}}],[\"暴露服务的服务提供方\",{\"1\":{\"810\":1}}],[\"暴力攻击\",{\"1\":{\"641\":1}}],[\"智能容错和负载均衡\",{\"1\":{\"809\":1}}],[\"尤为注意的就是增加或者修改\",{\"1\":{\"807\":1}}],[\"尤其是无法保证commit的信息被精确消费\",{\"1\":{\"864\":1}}],[\"尤其是使用临时表进行排序会操作时\",{\"1\":{\"478\":1}}],[\"尤其当字段多\",{\"1\":{\"746\":1}}],[\"支付系统\",{\"1\":{\"840\":2}}],[\"支付问题\",{\"1\":{\"807\":1}}],[\"支付扣款成功\",{\"1\":{\"807\":1}}],[\"支持截图并进行简单编辑\",{\"1\":{\"1130\":1}}],[\"支持一对一\",{\"1\":{\"1001\":1}}],[\"支持长链接\",{\"1\":{\"805\":1}}],[\"支持数组\",{\"1\":{\"785\":1}}],[\"支持数据的持久化\",{\"1\":{\"610\":1}}],[\"支持对象关系组件维护\",{\"1\":{\"746\":1}}],[\"支持对象与数据库的\",{\"1\":{\"746\":1}}],[\"支持的数据库\",{\"1\":{\"746\":1}}],[\"支持的两种持久化机制\",{\"1\":{\"646\":1}}],[\"支持编写动态\",{\"1\":{\"746\":1}}],[\"支持预编译\",{\"1\":{\"745\":1}}],[\"支持当前事务的情况\",{\"1\":{\"740\":1}}],[\"支持面向切面的编程\",{\"1\":{\"717\":1}}],[\"支持面向缓冲区的\",{\"1\":{\"377\":1}}],[\"支持主从复制\",{\"1\":{\"656\":1}}],[\"支持发布订阅模型\",{\"1\":{\"610\":1}}],[\"支持更多的编程语言\",{\"1\":{\"610\":1}}],[\"支持更复杂的应用场景\",{\"1\":{\"610\":1}}],[\"支持更丰富的数据类型\",{\"1\":{\"610\":1}}],[\"支持可以嵌入到\",{\"1\":{\"607\":1}}],[\"支持网络\",{\"1\":{\"603\":1}}],[\"支持行级锁和表级锁\",{\"1\":{\"493\":1}}],[\"支持行锁\",{\"1\":{\"491\":1}}],[\"支持事务\",{\"1\":{\"493\":1}}],[\"支持真正的在线热备份\",{\"1\":{\"491\":1}}],[\"支持\",{\"1\":{\"488\":1,\"493\":2,\"1144\":1}}],[\"支持快速随机访问\",{\"1\":{\"391\":1}}],[\"支持多粒度锁\",{\"1\":{\"514\":1}}],[\"支持多重继承\",{\"1\":{\"336\":1}}],[\"支持多线程并发收集\",{\"1\":{\"258\":1}}],[\"支持多个条件变量\",{\"1\":{\"109\":1}}],[\"支持锁降级\",{\"1\":{\"125\":1}}],[\"支持响应中断\",{\"1\":{\"94\":1}}],[\"支持延时获取元素的无界阻塞队列\",{\"1\":{\"62\":1}}],[\"支持优先级排序的无界阻塞队列\",{\"1\":{\"62\":1}}],[\"支持阻塞的插入和移除\",{\"1\":{\"62\":1}}],[\"握手协议负责在客户端和服务器端商定密码算法和共享密钥\",{\"1\":{\"1062\":1}}],[\"握手\",{\"1\":{\"805\":1}}],[\"⾸先\",{\"1\":{\"805\":1}}],[\"了\",{\"1\":{\"805\":1}}],[\"问\",{\"1\":{\"803\":1,\"1255\":1}}],[\"问题在于引入类路径中的配置文件时\",{\"1\":{\"1266\":1}}],[\"问题原因\",{\"1\":{\"1206\":1}}],[\"问题解决\",{\"1\":{\"1178\":1}}],[\"问题解析\",{\"1\":{\"893\":1}}],[\"问题分析\",{\"1\":{\"1165\":1,\"1212\":1}}],[\"问题描述\",{\"1\":{\"1165\":1,\"1206\":1,\"1212\":1}}],[\"问题实例\",{\"1\":{\"883\":1,\"884\":1,\"885\":1,\"886\":1,\"889\":1,\"890\":1,\"891\":1}}],[\"问题八\",{\"0\":{\"696\":1}}],[\"问题七\",{\"0\":{\"695\":1}}],[\"问题六\",{\"0\":{\"694\":1}}],[\"问题五\",{\"0\":{\"693\":1}}],[\"问题四\",{\"0\":{\"692\":1}}],[\"问题三\",{\"0\":{\"691\":1}}],[\"问题二\",{\"0\":{\"690\":1}}],[\"问题一\",{\"0\":{\"689\":1}}],[\"问题便可解决\",{\"1\":{\"585\":1}}],[\"问题排查的手段\",{\"0\":{\"557\":1}}],[\"问题是一旦索引改了名字\",{\"1\":{\"536\":1}}],[\"问题如何快速定位\",{\"0\":{\"201\":1}}],[\"问题\",{\"1\":{\"106\":2,\"407\":1,\"815\":1}}],[\"告诉client端\",{\"1\":{\"1024\":1}}],[\"告诉它\",{\"1\":{\"986\":1}}],[\"告诉主机a它的硬件地址\",{\"1\":{\"986\":1}}],[\"告诉\",{\"1\":{\"802\":1}}],[\"告诉spring你是个什么东西\",{\"1\":{\"718\":1}}],[\"赶紧更新\",{\"1\":{\"802\":1}}],[\"心跳检测是处理服务非正常下线\",{\"1\":{\"802\":1}}],[\"聚合包含实体和值对象\",{\"1\":{\"1233\":1}}],[\"聚合与领域可以是一对一的关系\",{\"1\":{\"1232\":1}}],[\"聚合里面一定有一个实体是聚合根\",{\"1\":{\"1232\":1}}],[\"聚合内部一定高内聚\",{\"1\":{\"1232\":1}}],[\"聚合和聚合根\",{\"0\":{\"1232\":1}}],[\"聚合根怎样将聚合内的值对象和实体聚合在一起\",{\"1\":{\"1245\":1}}],[\"聚合根的方法不做持久化\",{\"1\":{\"1242\":1}}],[\"聚合根的方法只对聚合根内部实体属性的改变\",{\"1\":{\"1242\":1}}],[\"聚合根的方法无副作用\",{\"1\":{\"1242\":1}}],[\"聚合根的主要特点有\",{\"1\":{\"1219\":1}}],[\"聚合根\",{\"0\":{\"1240\":1},\"1\":{\"1236\":1,\"1239\":1,\"1243\":1}}],[\"聚合根需要专门的模块来进行管理\",{\"1\":{\"1219\":1}}],[\"聚合根是具备生命周期的\",{\"1\":{\"1219\":1}}],[\"聚合根一定是实体\",{\"1\":{\"1219\":1}}],[\"聚合关系可以用带空心菱形的实线来表示\",{\"1\":{\"1098\":1}}],[\"聚合关系也是通过成员对象来实现的\",{\"1\":{\"1098\":1}}],[\"聚合关系是关联关系的一种\",{\"1\":{\"1098\":1}}],[\"聚合关系和组合关系\",{\"1\":{\"1097\":1}}],[\"聚合关系\",{\"0\":{\"1098\":1},\"1\":{\"1095\":1}}],[\"聚合\",{\"0\":{\"799\":1,\"1233\":1}}],[\"聚簇索引的叶子节点存储了一行完整的数据\",{\"1\":{\"549\":1}}],[\"聚簇索引的叶子节点保存了行数据\",{\"1\":{\"545\":1}}],[\"聚簇索引就是按照每张表的主键构造一颗b+树\",{\"1\":{\"547\":1}}],[\"聚簇索引不是人为创建的\",{\"1\":{\"546\":1}}],[\"聚簇索引和非聚簇索引\",{\"0\":{\"546\":1}}],[\"聚簇索引\",{\"1\":{\"545\":1,\"546\":1,\"547\":1}}],[\"短路优先\",{\"1\":{\"798\":1}}],[\"短作业优先\",{\"1\":{\"150\":1}}],[\"坐标是jar包的唯一标识\",{\"1\":{\"795\":1}}],[\"坐标\",{\"0\":{\"795\":1}}],[\"安装并配置完\",{\"1\":{\"1273\":1}}],[\"安装过程中一直点击\",{\"1\":{\"1202\":1}}],[\"安装部署\",{\"0\":{\"1172\":1,\"1268\":1}}],[\"安装ssl\",{\"1\":{\"1168\":1}}],[\"安装包管理工具是\",{\"1\":{\"1167\":1}}],[\"安装完成后就可以预测图片了\",{\"1\":{\"1144\":1}}],[\"安装\",{\"0\":{\"1168\":1},\"1\":{\"793\":1,\"1144\":3}}],[\"安全套接层\",{\"1\":{\"1062\":1}}],[\"安全套接字协议\",{\"1\":{\"1047\":1}}],[\"安全传输层协议\",{\"1\":{\"1044\":1}}],[\"安全的\",{\"1\":{\"1041\":1}}],[\"安全性\",{\"1\":{\"1040\":1,\"1041\":1}}],[\"安全外壳协议ssh\",{\"1\":{\"962\":1}}],[\"安全方面的特性\",{\"1\":{\"825\":1}}],[\"安全控制\",{\"1\":{\"719\":1}}],[\"安全特性\",{\"1\":{\"672\":1}}],[\"安全\",{\"1\":{\"461\":1,\"596\":1,\"750\":1,\"873\":1,\"1040\":3}}],[\"安全限制\",{\"1\":{\"348\":1}}],[\"测试\",{\"1\":{\"1083\":1}}],[\"测试类\",{\"1\":{\"1082\":1}}],[\"测试也比较直接\",{\"1\":{\"805\":1}}],[\"测试项目\",{\"1\":{\"793\":1}}],[\"测试网络联通\",{\"1\":{\"435\":1}}],[\"松耦合应用的单元测试可以很容易的进行\",{\"1\":{\"770\":1}}],[\"您可以节省任何更改\",{\"1\":{\"769\":1}}],[\"独立运行\",{\"1\":{\"768\":1}}],[\"独占\",{\"1\":{\"296\":1}}],[\"独占式获取锁的流程\",{\"0\":{\"124\":1}}],[\"独占模式\",{\"1\":{\"115\":1}}],[\"独占或共享\",{\"1\":{\"109\":1}}],[\"独占锁即一次只能有一个线程使用资源\",{\"1\":{\"821\":1}}],[\"独占锁\",{\"1\":{\"821\":1}}],[\"独占锁的概念是如果有一个线程已经获取到了锁\",{\"1\":{\"81\":1}}],[\"独占锁与共享锁\",{\"1\":{\"81\":1}}],[\"产品级别的应用\",{\"1\":{\"767\":1}}],[\"产生很多实体\",{\"1\":{\"1217\":1}}],[\"产生的一系列危害\",{\"1\":{\"643\":1}}],[\"产生虚拟表vt11\",{\"1\":{\"487\":1}}],[\"产生虚拟表vt10\",{\"1\":{\"487\":1}}],[\"产生虚拟表vt9\",{\"1\":{\"487\":1}}],[\"产生虚拟表vt6\",{\"1\":{\"487\":1}}],[\"产生虚拟表vt5\",{\"1\":{\"487\":1}}],[\"产生虚表vt1\",{\"1\":{\"487\":1}}],[\"产生最终哈希值\",{\"1\":{\"405\":1}}],[\"产生死锁的四个必要条件是什么\",{\"1\":{\"98\":1}}],[\"约定大于配置\",{\"1\":{\"767\":1}}],[\"约4kb\",{\"1\":{\"542\":1}}],[\"答\",{\"1\":{\"767\":1,\"803\":1}}],[\"答案是\",{\"1\":{\"555\":1}}],[\"答案是不能\",{\"1\":{\"88\":1}}],[\"嵌入式tomcat将重新启动\",{\"1\":{\"769\":1}}],[\"嵌入式开发\",{\"1\":{\"354\":1}}],[\"嵌入的tomcat\",{\"1\":{\"767\":1}}],[\"渲染了对应的视图之后执行\",{\"1\":{\"759\":1}}],[\"渲染数据\",{\"1\":{\"755\":1}}],[\"审计日志\",{\"1\":{\"759\":1}}],[\"敏感字符过滤\",{\"1\":{\"759\":1}}],[\"拦截未登陆用户\",{\"1\":{\"759\":1}}],[\"拦截器主要用于client的定制化控制逻辑\",{\"1\":{\"867\":1}}],[\"拦截器可以将请求拦截下来\",{\"1\":{\"759\":1}}],[\"拦截器\",{\"0\":{\"759\":1,\"867\":1},\"1\":{\"759\":2,\"867\":2}}],[\"拦截掉\",{\"1\":{\"641\":1}}],[\"哪一个位置已经存储的\",{\"1\":{\"884\":1}}],[\"哪个方法执行\",{\"1\":{\"756\":1}}],[\"哪些常用的状态码及使用场景\",{\"1\":{\"1040\":1}}],[\"哪些可降级\",{\"1\":{\"644\":1}}],[\"哪些列或常量被用于查询索引列上的值\",{\"1\":{\"556\":1}}],[\"填充\",{\"1\":{\"755\":1}}],[\"填入表中的元素个数\",{\"1\":{\"399\":1}}],[\"附\",{\"1\":{\"1202\":2}}],[\"附注\",{\"1\":{\"755\":1}}],[\"附加信息\",{\"0\":{\"196\":1}}],[\"捕获\",{\"1\":{\"755\":1}}],[\"简称web\",{\"1\":{\"1034\":1}}],[\"简洁\",{\"1\":{\"785\":1}}],[\"简化配置\",{\"1\":{\"768\":1}}],[\"简化maven配置\",{\"1\":{\"767\":1}}],[\"简化开发\",{\"1\":{\"754\":1,\"768\":1}}],[\"简化了开发\",{\"1\":{\"746\":1}}],[\"简单工厂把实例化的操作单独放到一个类中\",{\"1\":{\"1077\":1}}],[\"简单工厂模式\",{\"0\":{\"1077\":1}}],[\"简单\",{\"1\":{\"975\":1}}],[\"简单来讲\",{\"1\":{\"820\":1}}],[\"简单来说就是在关系型数据库和对象之间做一个映射\",{\"1\":{\"747\":1}}],[\"简单来说\",{\"1\":{\"488\":1,\"518\":1,\"683\":1,\"816\":1,\"1042\":1}}],[\"简单点说就是\",{\"1\":{\"733\":1}}],[\"简单地说\",{\"1\":{\"653\":1}}],[\"简单的说\",{\"1\":{\"685\":1}}],[\"简单的数据类型更好\",{\"1\":{\"535\":1}}],[\"简单的问题可以用面向过程的思路来解决\",{\"1\":{\"354\":1}}],[\"简单而言\",{\"1\":{\"304\":1}}],[\"简单而高效\",{\"1\":{\"254\":1}}],[\"简单说\",{\"1\":{\"36\":1}}],[\"驱动程序\",{\"1\":{\"744\":1}}],[\"观察状态\",{\"1\":{\"820\":1}}],[\"观察者模式\",{\"1\":{\"742\":1}}],[\"观察是不是\",{\"1\":{\"562\":1}}],[\"纯pojo切面\",{\"1\":{\"728\":1}}],[\"真实对象的类加载器\",{\"1\":{\"725\":1}}],[\"真的挂了\",{\"1\":{\"642\":1}}],[\"思想\",{\"1\":{\"1064\":7}}],[\"思想的实现一般都是基于代理模式\",{\"1\":{\"725\":1}}],[\"思路\",{\"1\":{\"559\":1}}],[\"织入\",{\"1\":{\"721\":1}}],[\"声明为聚合根的一个\",{\"1\":{\"1245\":1}}],[\"声明优先\",{\"1\":{\"798\":1}}],[\"声明式事务属于无侵入式\",{\"1\":{\"739\":1}}],[\"声明式事务实现又有两种方式\",{\"1\":{\"739\":1}}],[\"声明式事务\",{\"1\":{\"739\":2}}],[\"声明类似于\",{\"1\":{\"721\":1}}],[\"声明切入点与通知间的关系\",{\"1\":{\"719\":1}}],[\"声明时就要确定长度\",{\"1\":{\"372\":1}}],[\"制品库待补充\",{\"1\":{\"1108\":1}}],[\"制定代理的逻辑类\",{\"1\":{\"727\":1}}],[\"制定学习和工作计划\",{\"1\":{\"689\":1}}],[\"制作成通知→在配置文件中\",{\"1\":{\"719\":1}}],[\"横切关注点的一个特点是\",{\"1\":{\"719\":1}}],[\"横切\",{\"1\":{\"719\":1}}],[\"托管了类的产生过程\",{\"1\":{\"718\":1}}],[\"何时构造\",{\"1\":{\"718\":1}}],[\"何为索引\",{\"0\":{\"528\":1}}],[\"何为数据库事务\",{\"0\":{\"518\":1}}],[\"装一个\",{\"0\":{\"1170\":1}}],[\"装备等组成部分\",{\"1\":{\"1086\":1}}],[\"装饰器是继承的有力补充\",{\"1\":{\"1085\":1}}],[\"装饰器模式会增加许多子类\",{\"1\":{\"1085\":1}}],[\"装饰器模式的主要优点有\",{\"1\":{\"1085\":1}}],[\"装饰器模式\",{\"0\":{\"1085\":1}}],[\"装饰器模式执行主体是原类\",{\"1\":{\"716\":1}}],[\"装饰器模式关注于在对象上动态添加新行为\",{\"1\":{\"716\":1}}],[\"装有nat软件的路由器叫做nat路由器\",{\"1\":{\"995\":1}}],[\"装填因子\",{\"1\":{\"925\":1}}],[\"装置名称\",{\"1\":{\"441\":1}}],[\"充当打印机\",{\"1\":{\"713\":1}}],[\"延缓\",{\"1\":{\"1060\":1}}],[\"延误到连接释放以后的某个时间才到达服务端\",{\"1\":{\"1023\":1}}],[\"延时不能太久\",{\"1\":{\"868\":1}}],[\"延时执行\",{\"1\":{\"56\":1}}],[\"延迟注入\",{\"1\":{\"712\":1}}],[\"题\",{\"0\":{\"703\":1}}],[\"较为重要的参数\",{\"1\":{\"702\":1}}],[\"较难支持在线扩容\",{\"1\":{\"656\":1,\"658\":1}}],[\"职业生涯规划\",{\"0\":{\"697\":1}}],[\"积极与后端开发沟通\",{\"1\":{\"695\":1}}],[\"公钥密码\",{\"1\":{\"1062\":1}}],[\"公钥可以随意发布\",{\"1\":{\"1056\":1}}],[\"公共溢出区法\",{\"1\":{\"924\":1}}],[\"公共函数\",{\"1\":{\"692\":1}}],[\"公平模式\",{\"1\":{\"117\":1}}],[\"公平模式和非公平模式\",{\"1\":{\"117\":1}}],[\"公平锁和非公平锁就这两点区别\",{\"1\":{\"114\":1}}],[\"公平锁和非公平锁只有两处不同\",{\"1\":{\"114\":1}}],[\"公平锁与非公平锁\",{\"0\":{\"114\":1}}],[\"公平锁使用\",{\"1\":{\"96\":1}}],[\"公平锁\",{\"1\":{\"94\":1,\"113\":1}}],[\"公平锁的概念是如果当前一个线程已经获取到锁了\",{\"1\":{\"81\":1}}],[\"供其他项目使用\",{\"1\":{\"793\":1}}],[\"供后续查阅\",{\"1\":{\"691\":1}}],[\"供程序执行额外的动作\",{\"1\":{\"250\":1}}],[\"文本框\",{\"1\":{\"1079\":1}}],[\"文档解释\",{\"1\":{\"1221\":1}}],[\"文档\",{\"0\":{\"1271\":1},\"1\":{\"1148\":4}}],[\"文档地址\",{\"0\":{\"1148\":1}}],[\"文档如下\",{\"1\":{\"1145\":1}}],[\"文档撰写\",{\"1\":{\"1130\":1}}],[\"文档检索系统\",{\"1\":{\"888\":1}}],[\"文档占据了中心的位置\",{\"1\":{\"888\":1}}],[\"文档记录学习和调试过程\",{\"1\":{\"689\":1}}],[\"文件来添加额外的样式\",{\"1\":{\"1210\":1}}],[\"文件来自定义样式变量\",{\"1\":{\"1210\":1}}],[\"文件来配置工作流\",{\"1\":{\"1198\":1}}],[\"文件起一个包含语义的文件名\",{\"1\":{\"1206\":1}}],[\"文件夹下的\",{\"0\":{\"1206\":1}}],[\"文件抽象出可以复用的\",{\"1\":{\"1163\":1}}],[\"文件所使用的软件\",{\"1\":{\"1151\":1}}],[\"文件在这四个区域之间的转换关系如下\",{\"1\":{\"1121\":1}}],[\"文件传输\",{\"1\":{\"1001\":1}}],[\"文件传输协议ftp\",{\"1\":{\"962\":1}}],[\"文件及图片等静态资源的引用\",{\"1\":{\"959\":1,\"1029\":1}}],[\"文件载入上下文定义信息\",{\"1\":{\"712\":1}}],[\"文件发送给\",{\"1\":{\"662\":1}}],[\"文件比\",{\"1\":{\"652\":1}}],[\"文件破坏了怎么办\",{\"1\":{\"651\":1}}],[\"文件也还是安全的\",{\"1\":{\"651\":1}}],[\"文件也不会变小\",{\"1\":{\"525\":1}}],[\"文件会变小\",{\"1\":{\"651\":1}}],[\"文件过大\",{\"0\":{\"651\":1}}],[\"文件是一个紧凑的二进制压缩文件\",{\"1\":{\"648\":1}}],[\"文件并发送给从节点\",{\"1\":{\"647\":1}}],[\"文件事件分派器\",{\"1\":{\"611\":1}}],[\"文件事件处理器的结构包含\",{\"1\":{\"611\":1}}],[\"文件里的\",{\"1\":{\"525\":1}}],[\"文件名与数据文件的名字是一样的\",{\"1\":{\"848\":1}}],[\"文件名\",{\"1\":{\"431\":1,\"432\":2,\"433\":2}}],[\"文件或链接文件等等\",{\"1\":{\"430\":1}}],[\"文件或目录名称\",{\"1\":{\"441\":1}}],[\"文件或目录\",{\"1\":{\"424\":1}}],[\"文件属性与权限\",{\"0\":{\"430\":1}}],[\"文件内容查看\",{\"0\":{\"428\":1}}],[\"文件实际上是一个文本文件\",{\"1\":{\"427\":1}}],[\"文件真正删除的条件是与之相关的所有硬连接文件均被删除\",{\"1\":{\"427\":1}}],[\"文件的末尾\",{\"1\":{\"651\":3}}],[\"文件的内容和增量的\",{\"1\":{\"653\":1}}],[\"文件的内容写入到临时文件\",{\"1\":{\"651\":1}}],[\"文件的内存缓冲区\",{\"1\":{\"650\":2}}],[\"文件的问题\",{\"1\":{\"648\":1}}],[\"文件的四种状态\",{\"1\":{\"449\":1}}],[\"文件的数据块及目录的连接才会被释放\",{\"1\":{\"427\":1}}],[\"文件的规范\",{\"1\":{\"170\":1}}],[\"文件与目录管理\",{\"0\":{\"418\":1}}],[\"文件路径\",{\"1\":{\"369\":1}}],[\"文件\",{\"1\":{\"348\":1,\"416\":1,\"428\":4,\"430\":1,\"433\":1,\"571\":1,\"647\":2,\"651\":3,\"653\":1,\"655\":1,\"662\":2,\"784\":1,\"825\":1,\"959\":1,\"1029\":1,\"1124\":1}}],[\"文件系统最小存储单元是块\",{\"1\":{\"539\":1}}],[\"文件系统的限制\",{\"1\":{\"442\":1}}],[\"文件系统\",{\"0\":{\"818\":1},\"1\":{\"186\":1,\"442\":1,\"816\":1}}],[\"文件格式校验\",{\"1\":{\"170\":1}}],[\"文件格式验证\",{\"1\":{\"170\":1}}],[\"文件中保存一条set\",{\"1\":{\"651\":1}}],[\"文件中必须保存全部的\",{\"1\":{\"651\":1}}],[\"文件中\",{\"1\":{\"24\":1,\"571\":1,\"1202\":1}}],[\"遭遇技术栈之外的\",{\"1\":{\"689\":1}}],[\"择校\",{\"1\":{\"689\":1}}],[\"搜集资料\",{\"1\":{\"689\":1}}],[\"搜索右边界\",{\"0\":{\"913\":1}}],[\"搜索右边界同理\",{\"1\":{\"912\":1}}],[\"搜索左边界\",{\"0\":{\"912\":1},\"1\":{\"912\":1}}],[\"搜索二叉树\",{\"1\":{\"898\":1}}],[\"搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来\",{\"0\":{\"893\":1}}],[\"搜索引擎\",{\"1\":{\"888\":1}}],[\"搜索提交历史\",{\"1\":{\"449\":1}}],[\"搜索命令\",{\"0\":{\"434\":1}}],[\"考虑的是怎么才能在连接各种计算机的传输媒体上传输数据比特流\",{\"1\":{\"966\":1}}],[\"考虑采取分而治之的方法\",{\"1\":{\"896\":1}}],[\"考虑到丢失日志量的可控性\",{\"1\":{\"571\":1}}],[\"考察学习能力\",{\"0\":{\"696\":1}}],[\"考察前瞻性\",{\"0\":{\"695\":1}}],[\"考察创新性\",{\"0\":{\"694\":1}}],[\"考察协作力\",{\"0\":{\"693\":1}}],[\"考察说服力\",{\"0\":{\"692\":1}}],[\"考察计划性\",{\"0\":{\"691\":1}}],[\"考察领导力\",{\"0\":{\"690\":1}}],[\"考察目的性\",{\"0\":{\"689\":1}}],[\"法则\",{\"1\":{\"688\":1}}],[\"宝洁八大问\",{\"0\":{\"688\":1}}],[\"感谢您的聆听\",{\"1\":{\"687\":1}}],[\"尊敬的面试官您好\",{\"1\":{\"687\":1}}],[\"针对字符串\",{\"1\":{\"884\":1}}],[\"针对这一点\",{\"1\":{\"858\":1}}],[\"针对application\",{\"1\":{\"779\":1}}],[\"针对设置了过期时间的key\",{\"1\":{\"706\":1}}],[\"针对\",{\"1\":{\"683\":1}}],[\"针对不同的程序\",{\"1\":{\"57\":1}}],[\"迁移给另一个节点\",{\"1\":{\"682\":1}}],[\"迁移所有操作都是同步操作\",{\"1\":{\"660\":1}}],[\"讲个服务器使用\",{\"1\":{\"681\":1}}],[\"讲讲\",{\"0\":{\"377\":1}}],[\"环境迁移\",{\"0\":{\"1186\":1}}],[\"环境搭建\",{\"0\":{\"1109\":1,\"1144\":1,\"1181\":1}}],[\"环境\",{\"1\":{\"1088\":1,\"1186\":1}}],[\"环境角色使用这个接口调用不同的算法\",{\"1\":{\"1088\":1}}],[\"环形网\",{\"1\":{\"977\":1}}],[\"环绕通知\",{\"1\":{\"722\":1}}],[\"环如下\",{\"1\":{\"681\":1}}],[\"环倾斜所带来的影响就越小\",{\"1\":{\"681\":1}}],[\"环上的节点就越多\",{\"1\":{\"681\":1}}],[\"环的倾斜在极端情况下\",{\"1\":{\"681\":1}}],[\"环的倾斜\",{\"1\":{\"681\":2}}],[\"环\",{\"1\":{\"681\":1}}],[\"校验和\",{\"1\":{\"1009\":1}}],[\"校验后对\",{\"1\":{\"679\":1}}],[\"校对工作等\",{\"1\":{\"127\":1}}],[\"冷备\",{\"1\":{\"678\":1}}],[\"冷热数据分离\",{\"1\":{\"587\":1}}],[\"轻量\",{\"1\":{\"717\":1}}],[\"轻量级锁变重量级锁\",{\"0\":{\"89\":1}}],[\"轻量级锁对使用者是透明的\",{\"1\":{\"87\":1}}],[\"轻量级锁的使用场景是\",{\"1\":{\"87\":1}}],[\"轻量级锁的概念是如果锁已经被持有了\",{\"1\":{\"81\":1}}],[\"轻量级锁\",{\"0\":{\"87\":1},\"1\":{\"84\":1,\"86\":2}}],[\"轻量级锁等技术来减少锁操作的开销\",{\"1\":{\"82\":1}}],[\"轻松突破\",{\"1\":{\"676\":1}}],[\"架构中\",{\"1\":{\"1249\":1}}],[\"架构可以避免引入一些其他概念\",{\"1\":{\"1236\":1,\"1243\":1}}],[\"架构\",{\"1\":{\"870\":1}}],[\"架构简单\",{\"1\":{\"674\":1}}],[\"架构下很有可能有\",{\"1\":{\"71\":1}}],[\"便于使用范围查询\",{\"1\":{\"997\":1}}],[\"便于统一管理\",{\"1\":{\"746\":1}}],[\"便于减少系统的重复代码\",{\"1\":{\"719\":1}}],[\"便于减少系统重复代码\",{\"1\":{\"715\":1}}],[\"便于项目的扩展\",{\"1\":{\"718\":1}}],[\"便于内存的优化\",{\"1\":{\"718\":1}}],[\"便会开始解锁所有\",{\"1\":{\"672\":1}}],[\"便可获得字符串长度\",{\"1\":{\"624\":1}}],[\"便可以将事务规则应用到业务逻辑中\",{\"1\":{\"739\":1}}],[\"便可以收到通知\",{\"1\":{\"381\":1}}],[\"便可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本\",{\"1\":{\"249\":1}}],[\"便可返回干其他事了\",{\"1\":{\"72\":1}}],[\"减轻gc线程回收内存的压力\",{\"1\":{\"713\":1}}],[\"减去第三步的时间差\",{\"1\":{\"672\":1}}],[\"减少对外交互\",{\"1\":{\"1064\":1}}],[\"减少数据的发送\",{\"1\":{\"1009\":1}}],[\"减少数据库负担\",{\"1\":{\"585\":1}}],[\"减少不必要的排序\",{\"1\":{\"936\":1}}],[\"减少了网络开销\",{\"1\":{\"805\":1}}],[\"减少出错\",{\"1\":{\"754\":1}}],[\"减少修改字符串长度时所需的内存重分配次数\",{\"1\":{\"624\":1}}],[\"减少索引的维护压力\",{\"1\":{\"564\":1}}],[\"减少io次数\",{\"1\":{\"564\":1}}],[\"减少\",{\"1\":{\"560\":2,\"563\":1}}],[\"减少无效数据的查询\",{\"1\":{\"560\":1}}],[\"减少回表次数\",{\"1\":{\"553\":1}}],[\"减少开销\",{\"1\":{\"551\":1}}],[\"减少死锁产生概率\",{\"1\":{\"516\":1}}],[\"减少连接的表\",{\"1\":{\"516\":1}}],[\"减少同时占用太多资源的情况\",{\"1\":{\"516\":1}}],[\"减少锁竞争\",{\"1\":{\"516\":1}}],[\"减少gc\",{\"1\":{\"309\":1}}],[\"减少了内存开销\",{\"1\":{\"1065\":1}}],[\"减少了内核和用户空间大量的数据拷贝和内存分配\",{\"1\":{\"612\":1}}],[\"减少了开销和发送数据之前的时延\",{\"1\":{\"1002\":1}}],[\"减少了代码量\",{\"1\":{\"746\":1}}],[\"减少了线程切换时上下文的切换和竞争\",{\"1\":{\"604\":1}}],[\"减少了线程上下文切换的开销\",{\"1\":{\"30\":1}}],[\"减少了磁盘io提升数据库性能\",{\"1\":{\"585\":1}}],[\"减少了binlog日志量\",{\"1\":{\"572\":1}}],[\"减少了碰撞的可能\",{\"1\":{\"405\":1}}],[\"减少了平均周转时间\",{\"1\":{\"150\":1}}],[\"减少内存开销\",{\"1\":{\"131\":1}}],[\"减少内存的使用\",{\"1\":{\"42\":1}}],[\"减少获得锁和释放锁带来的性能消耗\",{\"1\":{\"86\":1}}],[\"减少切换次数\",{\"1\":{\"28\":1,\"139\":1}}],[\"坑\",{\"1\":{\"669\":2}}],[\"搞清楚事件发生的前因后果\",{\"1\":{\"1216\":1}}],[\"搞一个\",{\"1\":{\"668\":1}}],[\"搞两个数据库\",{\"1\":{\"668\":1}}],[\"搞定\",{\"1\":{\"651\":1}}],[\"谣言传播\",{\"1\":{\"660\":1}}],[\"距离最后一次有效回复\",{\"1\":{\"657\":1}}],[\"哨兵的作用和原理\",{\"0\":{\"677\":1}}],[\"哨兵也是一台\",{\"1\":{\"676\":1}}],[\"哨兵\",{\"0\":{\"676\":1},\"1\":{\"657\":10}}],[\"哨兵直接也会相互通信\",{\"1\":{\"657\":1}}],[\"哨兵可以和\",{\"1\":{\"657\":1}}],[\"哨兵可以有多个\",{\"1\":{\"657\":1}}],[\"哨兵是一个独立的进程\",{\"1\":{\"657\":1}}],[\"哨兵会自动选举\",{\"1\":{\"657\":1,\"675\":1}}],[\"哨兵模式都具有\",{\"1\":{\"658\":1}}],[\"哨兵模式是基于主从模式的\",{\"1\":{\"658\":1}}],[\"哨兵模式的优缺点\",{\"0\":{\"658\":1}}],[\"哨兵模式的工作\",{\"1\":{\"657\":1}}],[\"哨兵模式的作用\",{\"1\":{\"657\":1}}],[\"哨兵模式\",{\"0\":{\"657\":1}}],[\"哨兵模式和集群\",{\"1\":{\"654\":1}}],[\"宕机了\",{\"1\":{\"659\":1,\"683\":1}}],[\"宕机哨兵之间会进行决策选举新的\",{\"1\":{\"657\":1}}],[\"宕机\",{\"1\":{\"657\":3,\"675\":1}}],[\"宕机前有部分数据未能及时同步到从机\",{\"1\":{\"656\":1}}],[\"费事费力\",{\"1\":{\"657\":1,\"676\":1}}],[\"剧增从而宕机\",{\"1\":{\"656\":1}}],[\"断线了\",{\"1\":{\"656\":1}}],[\"阅读性较差\",{\"1\":{\"653\":1}}],[\"兼容性差\",{\"1\":{\"653\":1}}],[\"策略模式在\",{\"0\":{\"1089\":1}}],[\"策略模式造成很多的策略类\",{\"1\":{\"1088\":1}}],[\"策略模式属于对象行为模式\",{\"1\":{\"1088\":1}}],[\"策略模式\",{\"0\":{\"1088\":1}}],[\"策略\",{\"1\":{\"650\":3}}],[\"手中\",{\"1\":{\"650\":1}}],[\"手动编辑文件解决冲突后标记为已解决\",{\"1\":{\"1126\":1}}],[\"手动配置易错\",{\"1\":{\"1049\":1}}],[\"手动实现布隆过滤器\",{\"1\":{\"882\":1}}],[\"手动触发分别对应\",{\"1\":{\"647\":1}}],[\"手动指定g1收集器\",{\"1\":{\"262\":1}}],[\"手动选择垃圾回收器\",{\"1\":{\"253\":1}}],[\"手动删除\",{\"1\":{\"45\":1}}],[\"掉的话\",{\"1\":{\"649\":1}}],[\"灾难恢复等场景\",{\"1\":{\"648\":1}}],[\"线上交流\",{\"1\":{\"1130\":1}}],[\"线上环境不建议使用\",{\"1\":{\"647\":1}}],[\"线程将注册的监听事件发送给\",{\"1\":{\"822\":1}}],[\"线程中创建\",{\"1\":{\"822\":1}}],[\"线程中的所有操作都先行发生于对此线程的终止检测\",{\"1\":{\"75\":1,\"102\":1}}],[\"线程1此时创建了singleton对象\",{\"1\":{\"714\":1}}],[\"线程模型\",{\"0\":{\"611\":1}}],[\"线程处理多个\",{\"1\":{\"604\":1}}],[\"线程处理\",{\"1\":{\"604\":1}}],[\"线程会通知所有的salve节点\",{\"1\":{\"469\":1,\"580\":1}}],[\"线程会进入阻塞队列\",{\"1\":{\"58\":1}}],[\"线程不安全\",{\"1\":{\"407\":1,\"1065\":1}}],[\"线程安全\",{\"1\":{\"407\":1}}],[\"线程安全问题\",{\"0\":{\"735\":1},\"1\":{\"407\":1}}],[\"线程安全的\",{\"1\":{\"108\":2}}],[\"线程安全的实现方式\",{\"1\":{\"48\":1}}],[\"线程二把\",{\"1\":{\"406\":1}}],[\"线程之间值的传递都需要通过主内存来完成\",{\"1\":{\"337\":1}}],[\"线程内部调用了\",{\"1\":{\"822\":1}}],[\"线程内部都有一个\",{\"1\":{\"39\":1,\"41\":1}}],[\"线程内似表现为串行的语义\",{\"1\":{\"295\":1}}],[\"线程持有的锁\",{\"1\":{\"225\":1}}],[\"线程按照cpu使用率排序\",{\"1\":{\"201\":1}}],[\"线程共享\",{\"1\":{\"199\":1,\"203\":1}}],[\"线程恢复等功能都需要依赖这个计数器来完成\",{\"1\":{\"189\":1}}],[\"线程私有\",{\"1\":{\"188\":1,\"189\":1,\"190\":1,\"197\":1}}],[\"线程上下文类加载器\",{\"0\":{\"179\":1}}],[\"线程上下文切换和进程上下文切换最主要的区别\",{\"1\":{\"145\":1}}],[\"线程上下文切换过程\",{\"1\":{\"144\":1}}],[\"线程上下文切换的时机\",{\"1\":{\"144\":1}}],[\"线程上下文切换\",{\"0\":{\"144\":1}}],[\"线程切换不需要\",{\"1\":{\"145\":1}}],[\"线程自己调用了\",{\"1\":{\"144\":1}}],[\"线程使用\",{\"1\":{\"142\":1}}],[\"线程同步\",{\"0\":{\"142\":1}}],[\"线程相关\",{\"0\":{\"140\":1}}],[\"线程控制块\",{\"1\":{\"136\":1}}],[\"线程完成一个记录一个\",{\"1\":{\"121\":1}}],[\"线程也不会陷入阻塞\",{\"1\":{\"105\":1}}],[\"线程结束前对变量的写\",{\"1\":{\"102\":1}}],[\"线程对\",{\"1\":{\"102\":1}}],[\"线程对变量的所有操作都必须在工作空间进行\",{\"1\":{\"74\":1}}],[\"线程对变量的所有操作\",{\"1\":{\"66\":1,\"294\":1,\"337\":1}}],[\"线程解锁\",{\"1\":{\"102\":1}}],[\"线程拿到了一个未初始化完毕的单例\",{\"1\":{\"101\":1}}],[\"线程再次获取锁\",{\"1\":{\"96\":1}}],[\"线程阻塞\",{\"1\":{\"86\":1}}],[\"线程竞争不使用自旋\",{\"1\":{\"86\":1}}],[\"线程一直不能获取锁的时候会自旋消耗\",{\"1\":{\"86\":1}}],[\"线程试图获取锁也就是对象监视器monitor的持有权\",{\"1\":{\"82\":1}}],[\"线程终止规则\",{\"1\":{\"75\":2,\"102\":2}}],[\"线程启动规则\",{\"1\":{\"75\":1,\"102\":1}}],[\"线程是否安全的主要依据\",{\"1\":{\"75\":1}}],[\"线程是稀缺资源\",{\"1\":{\"53\":1}}],[\"线程通信必须经过主内存\",{\"1\":{\"74\":1}}],[\"线程读写数据的流程\",{\"1\":{\"73\":1}}],[\"线程读取共享变量时\",{\"1\":{\"69\":1}}],[\"线程写入共享变量时\",{\"1\":{\"69\":1}}],[\"线程工厂\",{\"1\":{\"58\":1}}],[\"线程空闲的时间达到该值后会被销毁\",{\"1\":{\"58\":1}}],[\"线程空闲时间\",{\"1\":{\"58\":1}}],[\"线程数过多和队列的大小都会影响此项数据\",{\"1\":{\"64\":1}}],[\"线程数\",{\"1\":{\"57\":2}}],[\"线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝\",{\"1\":{\"337\":1}}],[\"线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝\",{\"1\":{\"66\":1}}],[\"线程的切换虚拟内存空间依然是相同的\",{\"1\":{\"145\":1}}],[\"线程的通信由\",{\"1\":{\"74\":1}}],[\"线程的初始化\",{\"1\":{\"64\":1}}],[\"线程的\",{\"1\":{\"57\":2,\"144\":1}}],[\"线程池处理\",{\"1\":{\"804\":1}}],[\"线程池处理任务的流程\",{\"0\":{\"54\":1}}],[\"线程池中的拒绝策略\",{\"1\":{\"1089\":1}}],[\"线程池中的线程数一般怎么设置\",{\"0\":{\"64\":1}}],[\"线程池中线程执行任务的性质\",{\"1\":{\"64\":1}}],[\"线程池彻底终止\",{\"1\":{\"63\":1}}],[\"线程池的构造中有一个拒绝策略参数\",{\"1\":{\"1089\":1}}],[\"线程池的生命周期\",{\"0\":{\"63\":1}}],[\"线程池的好处\",{\"0\":{\"53\":1}}],[\"线程池会返回一个\",{\"1\":{\"61\":1}}],[\"线程池能够容纳同时执行的线程最大数\",{\"1\":{\"58\":1}}],[\"线程池创建多少线程合适\",{\"0\":{\"57\":1}}],[\"线程池\",{\"0\":{\"52\":1},\"1\":{\"713\":1}}],[\"线程暂停\",{\"1\":{\"51\":1}}],[\"线程依然运行的前提下\",{\"1\":{\"46\":1}}],[\"线程隔离\",{\"1\":{\"39\":1}}],[\"线程间变量值的传递均需要通过主内存来完成\",{\"1\":{\"294\":1}}],[\"线程间变量值的传递需要通过主内存来完成\",{\"1\":{\"66\":1}}],[\"线程间共享\",{\"1\":{\"188\":1}}],[\"线程间通信方式\",{\"0\":{\"141\":1}}],[\"线程间交换数据\",{\"0\":{\"127\":1}}],[\"线程间的切换和调度成本远远小于进程\",{\"1\":{\"30\":1}}],[\"线程间切换开销较小\",{\"1\":{\"28\":1,\"139\":1}}],[\"线程可以看作是轻量级的进程\",{\"1\":{\"30\":1}}],[\"线程没有自己独立的地址空间\",{\"1\":{\"28\":1,\"139\":1}}],[\"线程\",{\"0\":{\"38\":1,\"139\":1},\"1\":{\"28\":1,\"34\":1,\"73\":2,\"89\":1,\"101\":1,\"102\":2,\"139\":1,\"144\":1,\"406\":1,\"470\":3,\"581\":3,\"822\":1}}],[\"父组件可以通过子组件的\",{\"1\":{\"1155\":1}}],[\"父节点和两个孩子中较大的比较\",{\"1\":{\"937\":1}}],[\"父节点的下标\",{\"1\":{\"937\":1}}],[\"父pom配置\",{\"1\":{\"800\":1}}],[\"父子进程会共享相同的物理页面\",{\"1\":{\"647\":1}}],[\"父进程在接收到信号之后\",{\"1\":{\"651\":1}}],[\"父进程一边将它们累积到一个内存缓存中\",{\"1\":{\"651\":1}}],[\"父进程继续处理\",{\"1\":{\"647\":1}}],[\"父进程更新统计信息\",{\"1\":{\"647\":1}}],[\"父进程\",{\"1\":{\"647\":1}}],[\"父进程判断当前是否存在正在执行的子进程\",{\"1\":{\"647\":1}}],[\"父类\",{\"0\":{\"358\":1},\"1\":{\"363\":3}}],[\"父类引用指向子类对象\",{\"1\":{\"355\":1}}],[\"父类索引用于确定这个类的父类的全限定名\",{\"1\":{\"288\":1}}],[\"父类索引与接口索引集合\",{\"0\":{\"288\":1}}],[\"父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节\",{\"1\":{\"1087\":1}}],[\"父类中调用这个虚函数\",{\"1\":{\"275\":1}}],[\"父类中的方法\",{\"1\":{\"274\":1}}],[\"父类方法4种\",{\"1\":{\"275\":1}}],[\"父类方法\",{\"1\":{\"194\":1}}],[\"父类加载器为启动类加载器\",{\"1\":{\"177\":1}}],[\"父类的<clinit>\",{\"1\":{\"173\":1}}],[\"爬虫\",{\"1\":{\"645\":1}}],[\"误报的可能性就越大\",{\"1\":{\"882\":1}}],[\"误判率也可以忽略不计了\",{\"1\":{\"645\":1}}],[\"误判率下\",{\"1\":{\"645\":1}}],[\"误判\",{\"1\":{\"645\":1}}],[\"误删\",{\"1\":{\"427\":1}}],[\"算得一个证书索引值\",{\"1\":{\"645\":1}}],[\"算法思路\",{\"1\":{\"1019\":1}}],[\"算法思想\",{\"1\":{\"892\":1}}],[\"算法还规定\",{\"1\":{\"1017\":1}}],[\"算法如下\",{\"1\":{\"986\":1,\"990\":1,\"1017\":1}}],[\"算法保证在给定的一个任期最少要有一个\",{\"1\":{\"876\":1}}],[\"算法将时间划分为任意长度的任期\",{\"1\":{\"876\":1}}],[\"算法更易理解和实现的分布式一致性算法\",{\"1\":{\"872\":1}}],[\"算法在国际上被公认的非常难以理解和实现\",{\"1\":{\"872\":1}}],[\"算法诞生于\",{\"1\":{\"872\":1}}],[\"算法中的权重越大\",{\"1\":{\"820\":1}}],[\"算法对于节点的增减都只需重定位环空间中的一小部分数据\",{\"1\":{\"681\":1}}],[\"算法可以随意更改\",{\"1\":{\"588\":1}}],[\"算法找到其在数组中的存储位置\",{\"1\":{\"396\":1}}],[\"算法来实现同步\",{\"1\":{\"410\":1}}],[\"算法来决定其在数组中的位置\",{\"1\":{\"396\":1}}],[\"算法来更新数据\",{\"1\":{\"144\":1}}],[\"算法分为\",{\"1\":{\"244\":1}}],[\"算法\",{\"0\":{\"246\":1,\"873\":1,\"905\":1},\"1\":{\"144\":1,\"680\":1,\"820\":1,\"852\":1,\"872\":1,\"1006\":1,\"1017\":1}}],[\"算法实现相对复杂\",{\"1\":{\"869\":1}}],[\"算法实现\",{\"1\":{\"103\":1}}],[\"严重者引起网络堵塞甚至系统瘫痪\",{\"1\":{\"1060\":1}}],[\"严重时网站会被封掉\",{\"1\":{\"1040\":1}}],[\"严重影响性能\",{\"1\":{\"741\":1}}],[\"严重的时候会接触发集群内的故障转移\",{\"1\":{\"660\":1}}],[\"严重错误等\",{\"1\":{\"644\":1}}],[\"严格的来说\",{\"1\":{\"825\":1}}],[\"严格的说这个不算内存泄漏\",{\"1\":{\"303\":1}}],[\"严格来说\",{\"1\":{\"302\":1}}],[\"警告协议负责在发生错误的时候将错误传达给对方\",{\"1\":{\"1062\":1}}],[\"警告\",{\"1\":{\"644\":1}}],[\"失效\",{\"1\":{\"1182\":1}}],[\"失效后进行了大量的计算\",{\"1\":{\"643\":1}}],[\"失败重传\",{\"1\":{\"961\":1}}],[\"失败自动恢复\",{\"1\":{\"813\":1}}],[\"失败自动切换\",{\"1\":{\"813\":1}}],[\"失败安全\",{\"1\":{\"813\":1}}],[\"失败立即报错\",{\"1\":{\"813\":1}}],[\"失败了就只能放弃或稍后重试\",{\"1\":{\"669\":1}}],[\"失败状态\",{\"1\":{\"520\":1}}],[\"失败进而导致另一次完全\",{\"1\":{\"259\":1}}],[\"失败则自旋保证成功\",{\"1\":{\"131\":1}}],[\"失败后\",{\"1\":{\"114\":1}}],[\"失败\",{\"1\":{\"87\":1,\"89\":1}}],[\"起码能保证我们的服务还是能正常工作的\",{\"1\":{\"642\":1}}],[\"起来\",{\"1\":{\"355\":1}}],[\"挂了整个nginx就废了\",{\"1\":{\"837\":1}}],[\"挂了\",{\"1\":{\"674\":1,\"683\":1,\"803\":1}}],[\"挂掉\",{\"1\":{\"659\":1}}],[\"挂掉这种情况发生\",{\"1\":{\"642\":1}}],[\"挂掉了\",{\"1\":{\"642\":1}}],[\"挂到当前线程的底下\",{\"1\":{\"39\":1}}],[\"恰好将这部分数据全部删除\",{\"1\":{\"642\":1}}],[\"龙虾三少\",{\"1\":{\"641\":1}}],[\"映射文件\",{\"1\":{\"749\":1}}],[\"映射不完整\",{\"1\":{\"659\":1}}],[\"映射关系\",{\"1\":{\"638\":1,\"880\":1}}],[\"映射过程\",{\"1\":{\"156\":1,\"1257\":1}}],[\"惰性过期\",{\"1\":{\"632\":1}}],[\"惰性空间\",{\"1\":{\"624\":1}}],[\"带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景\",{\"1\":{\"880\":1}}],[\"带链表长度计数器\",{\"1\":{\"626\":1}}],[\"带缓冲线程池\",{\"1\":{\"56\":1}}],[\"升级\",{\"1\":{\"625\":1}}],[\"升级为红黑树后头插法就不适用了\",{\"1\":{\"403\":1}}],[\"视频等\",{\"1\":{\"624\":1}}],[\"视图view是一个接口\",{\"1\":{\"755\":1}}],[\"视图解析器\",{\"1\":{\"755\":1,\"756\":1}}],[\"视图\",{\"1\":{\"488\":1,\"748\":1,\"754\":2,\"755\":1}}],[\"图像超分辨率重建\",{\"0\":{\"1142\":1}}],[\"图\",{\"0\":{\"1094\":1}}],[\"图片文件等等\",{\"1\":{\"825\":1}}],[\"图片\",{\"1\":{\"624\":1}}],[\"图中的\",{\"1\":{\"801\":1}}],[\"图中\",{\"1\":{\"85\":1}}],[\"杜绝缓冲区溢出\",{\"1\":{\"624\":1}}],[\"杜绝所有的并发\",{\"1\":{\"501\":1}}],[\"额外空间复杂度\",{\"1\":{\"930\":1,\"931\":1,\"932\":1,\"934\":1,\"937\":1}}],[\"额外空间大小由\",{\"1\":{\"624\":1}}],[\"额外的故意等待\",{\"1\":{\"563\":1}}],[\"缩减键值对象\",{\"1\":{\"637\":1}}],[\"缩容不会考虑\",{\"1\":{\"623\":1}}],[\"缩短查询时间\",{\"1\":{\"585\":1}}],[\"满足开闭原则\",{\"1\":{\"1079\":1}}],[\"满足某种条件时执行特殊功能\",{\"1\":{\"1054\":1}}],[\"满足以下两种情况时会触发哈希扩容\",{\"1\":{\"623\":1}}],[\"满了则扩容\",{\"1\":{\"397\":1}}],[\"期间\",{\"1\":{\"623\":1,\"647\":1}}],[\"期望值\",{\"1\":{\"110\":1}}],[\"省的比较了\",{\"1\":{\"922\":1}}],[\"省略和注册中心的交互\",{\"1\":{\"803\":1}}],[\"省内存的原因\",{\"1\":{\"622\":1}}],[\"省去了重新计算索引值的时间\",{\"1\":{\"406\":1}}],[\"省去了不必要的上下文切换的开销\",{\"1\":{\"81\":1}}],[\"碰撞处理\",{\"1\":{\"884\":1}}],[\"碰撞\",{\"1\":{\"622\":1}}],[\"范围内\",{\"1\":{\"617\":1}}],[\"范围切分\",{\"1\":{\"588\":1}}],[\"渐进式\",{\"0\":{\"615\":1},\"1\":{\"622\":1,\"623\":2}}],[\"⽬的是告诉我们有数据需要读取\",{\"1\":{\"613\":1}}],[\"⽬的就是为了有⼀块完整的内存空间供垃圾回收器进⾏拷⻉\",{\"1\":{\"200\":1}}],[\"搭配非阻塞\",{\"1\":{\"613\":1}}],[\"搭建的个人笔记网站\",{\"1\":{\"1\":1}}],[\"⼤⼤提⾼了检测的效率\",{\"1\":{\"612\":1}}],[\"脚本的渲染和图像化输出\",{\"1\":{\"1269\":1}}],[\"脚本将无法读取到\",{\"1\":{\"1061\":1}}],[\"脚本\",{\"1\":{\"610\":1,\"1269\":1,\"1274\":1}}],[\"脚本初始化\",{\"1\":{\"458\":1}}],[\"形式的键值对\",{\"1\":{\"607\":1}}],[\"形成类\",{\"1\":{\"354\":1}}],[\"形成了副本的隔离\",{\"1\":{\"39\":1,\"41\":1}}],[\"说说有哪些本地缓存解决方案\",{\"0\":{\"607\":1}}],[\"说明集合中有\",{\"1\":{\"1091\":1}}],[\"说明此时待排序的数组中只有一个数\",{\"1\":{\"934\":1}}],[\"说明查询它的用户越多\",{\"1\":{\"893\":1}}],[\"说明该元素不在布隆过滤器中\",{\"1\":{\"882\":1}}],[\"说明该记录正在被修改\",{\"1\":{\"513\":1}}],[\"说明当前数据时被改过了\",{\"1\":{\"72\":1}}],[\"说明当前\",{\"1\":{\"72\":3}}],[\"说明\",{\"1\":{\"60\":1,\"75\":1,\"102\":1,\"368\":1,\"384\":1,\"385\":1,\"416\":1,\"566\":1,\"626\":1,\"721\":1,\"812\":1,\"813\":1,\"832\":1,\"961\":1,\"1039\":1}}],[\"集成\",{\"1\":{\"1117\":1}}],[\"集中器常使用这个统计时分复用\",{\"1\":{\"967\":1}}],[\"集线器和双绞线大量用于局域网\",{\"1\":{\"977\":1}}],[\"集线器\",{\"1\":{\"962\":1}}],[\"集群包括若干服务器\",{\"1\":{\"874\":1}}],[\"集群整体是否还能响应客户端的读写请求\",{\"1\":{\"870\":1}}],[\"集群的性能\",{\"1\":{\"860\":1}}],[\"集群的机制是只要超过半数的节点正常\",{\"1\":{\"819\":1}}],[\"集群中数据最完整\",{\"1\":{\"820\":1}}],[\"集群中的每个节点都会定期地向集群中其它节点发送\",{\"1\":{\"683\":1}}],[\"集群中的节点分为主节点\",{\"1\":{\"683\":1}}],[\"集群已经运行过一段时间\",{\"1\":{\"820\":1}}],[\"集群就能正常提供服务\",{\"1\":{\"819\":1}}],[\"集群就会开始执行故障转移\",{\"1\":{\"683\":1}}],[\"集群最少需要机器数\",{\"1\":{\"819\":1}}],[\"集群管理\",{\"1\":{\"816\":1}}],[\"集群容错方案\",{\"1\":{\"813\":1}}],[\"集群容错几种方法\",{\"0\":{\"813\":1}}],[\"集群\",{\"1\":{\"808\":1}}],[\"集群各节点之间的通讯协议\",{\"1\":{\"684\":1}}],[\"集群扩容通过来实现\",{\"1\":{\"682\":1}}],[\"集群如何扩容\",{\"0\":{\"682\":1}}],[\"集群没有使用一致性\",{\"1\":{\"679\":1}}],[\"集群节点最小配置\",{\"1\":{\"678\":1}}],[\"集群通过分片\",{\"1\":{\"678\":1}}],[\"集群内部通过投票机制竞选一个领头的\",{\"1\":{\"677\":1}}],[\"集群部署简单\",{\"1\":{\"676\":1}}],[\"集群是由若干\",{\"1\":{\"676\":1}}],[\"集群和分布式区别\",{\"0\":{\"808\":1}}],[\"集群和\",{\"1\":{\"676\":1}}],[\"集群仍可用\",{\"1\":{\"660\":1,\"678\":1}}],[\"集群都会进入\",{\"1\":{\"659\":1}}],[\"集群引入了主从模式\",{\"1\":{\"659\":1}}],[\"集群模式的优缺点\",{\"0\":{\"660\":1}}],[\"集群模式\",{\"0\":{\"659\":1},\"1\":{\"659\":1,\"678\":1,\"819\":1}}],[\"集群数据同步等是由额外线程执行的\",{\"1\":{\"604\":1}}],[\"集\",{\"1\":{\"612\":1}}],[\"集合排序我们比较熟悉的了\",{\"1\":{\"1089\":1}}],[\"集合的一种实现方式\",{\"1\":{\"625\":1}}],[\"集合的遍历\",{\"0\":{\"391\":1}}],[\"集合工具的内部类\",{\"1\":{\"409\":1}}],[\"集合工具类\",{\"1\":{\"388\":1}}],[\"集合时\",{\"1\":{\"399\":1}}],[\"集合中的\",{\"1\":{\"399\":1}}],[\"集合中数据元素之间没有关联\",{\"1\":{\"391\":1}}],[\"集合中元素可以通过\",{\"1\":{\"391\":1}}],[\"集合通过\",{\"1\":{\"391\":1}}],[\"集合无法直接使用\",{\"1\":{\"391\":1}}],[\"集合下所有实现都可以采用\",{\"1\":{\"391\":1}}],[\"集合都继承了\",{\"1\":{\"391\":1}}],[\"集合类\",{\"1\":{\"342\":1}}],[\"集合\",{\"0\":{\"387\":1},\"1\":{\"342\":2,\"391\":3,\"612\":1}}],[\"聊天室\",{\"1\":{\"603\":1}}],[\"限界上下文包含子域\",{\"1\":{\"1233\":1}}],[\"限界上下文\",{\"0\":{\"1233\":1}}],[\"限界上下文之间的映射关系\",{\"0\":{\"1223\":1}}],[\"限界上下文可以作为微服务划分的方法\",{\"1\":{\"1221\":1}}],[\"限界上下文是业务的边界的划分\",{\"1\":{\"1221\":1}}],[\"限制innodb线程数\",{\"1\":{\"1177\":1}}],[\"限制最大连接数\",{\"1\":{\"1177\":1}}],[\"限制了数据链路层传输的数据帧大小\",{\"1\":{\"982\":1}}],[\"限流\",{\"1\":{\"642\":1}}],[\"限于成本\",{\"1\":{\"606\":1}}],[\"限时优惠活动信息等业务场景\",{\"1\":{\"603\":1}}],[\"限时业务的运行使用\",{\"1\":{\"603\":1}}],[\"限定优化\",{\"1\":{\"486\":1}}],[\"评价表\",{\"1\":{\"601\":1}}],[\"评价系统数据库设计与实现\",{\"1\":{\"601\":1}}],[\"评论一张表\",{\"1\":{\"601\":1}}],[\"评论系统设计\",{\"0\":{\"601\":1}}],[\"``反引号可以\",{\"1\":{\"596\":1}}],[\"致使非法数据侵入系统\",{\"1\":{\"595\":1}}],[\"致使有序\",{\"1\":{\"78\":1}}],[\"刷盘频率\",{\"1\":{\"708\":1}}],[\"刷盘机制\",{\"0\":{\"707\":1}}],[\"刷新\",{\"1\":{\"1124\":1}}],[\"刷新频率\",{\"1\":{\"707\":1}}],[\"刷新邻接页\",{\"1\":{\"496\":1}}],[\"刷页\",{\"0\":{\"593\":1}}],[\"抖\",{\"1\":{\"592\":1}}],[\"天然水平扩展\",{\"1\":{\"588\":1}}],[\"天然便于水平扩展\",{\"1\":{\"587\":1}}],[\"路由把改变路由报文发送给主机\",{\"1\":{\"993\":1}}],[\"路由表大小不同\",{\"1\":{\"996\":1}}],[\"路由表中的项目也要改变\",{\"1\":{\"991\":1}}],[\"路由表必须包含以下三项内容\",{\"1\":{\"990\":1}}],[\"路由聚合也称为构成超网\",{\"1\":{\"991\":1}}],[\"路由聚合\",{\"1\":{\"991\":1}}],[\"路由更像在操作⽅向盘\",{\"1\":{\"961\":1}}],[\"路由则是根据\",{\"1\":{\"961\":1}}],[\"路由器按照fifo处理分组\",{\"1\":{\"1021\":1}}],[\"路由器仅根据目的主机所连接的网络号来转发分组\",{\"1\":{\"985\":1}}],[\"路由器计算出了下⼀个⽬的地\",{\"1\":{\"961\":1}}],[\"路由器怎么知道这个\",{\"1\":{\"961\":1}}],[\"路由器\",{\"1\":{\"960\":1}}],[\"路由\",{\"1\":{\"804\":1}}],[\"路由规则是对3取模\",{\"1\":{\"587\":1}}],[\"路径下的配置文件\",{\"1\":{\"1266\":1}}],[\"路径\",{\"1\":{\"421\":1}}],[\"路径的写法\",{\"1\":{\"418\":2}}],[\"余数为1的放到第二个库\",{\"1\":{\"587\":1}}],[\"余数为0的放到第一个库\",{\"1\":{\"587\":1}}],[\"围路由设计的复杂点主要体现在分段大小的选取上\",{\"1\":{\"587\":1}}],[\"业务逻辑和技术解耦\",{\"1\":{\"1242\":1}}],[\"业务逻辑层的实现具体要调用到自己已经定义好的dao的接口上\",{\"1\":{\"763\":1}}],[\"业务分析\",{\"0\":{\"1216\":1}}],[\"业务流程的不同会有不同的控制器\",{\"1\":{\"764\":1}}],[\"业务层service层\",{\"1\":{\"761\":1}}],[\"业务层\",{\"0\":{\"763\":1},\"1\":{\"754\":1}}],[\"业务处理的主要流程是核心关注点\",{\"1\":{\"719\":1}}],[\"业务数据大小如何\",{\"1\":{\"606\":1}}],[\"业务数据常用吗\",{\"1\":{\"606\":1}}],[\"业务功能上只提供热点数据的查询\",{\"1\":{\"587\":1}}],[\"业务清晰\",{\"1\":{\"585\":1}}],[\"网关\",{\"1\":{\"1049\":1}}],[\"网卡在通讯时通过\",{\"1\":{\"981\":1}}],[\"网线\",{\"1\":{\"962\":1}}],[\"网际组管理协议igmp\",{\"1\":{\"983\":1}}],[\"网际控制报文协议icmp\",{\"0\":{\"992\":1},\"1\":{\"962\":1,\"983\":1}}],[\"网际协议ip\",{\"0\":{\"983\":1},\"1\":{\"962\":1}}],[\"网易\",{\"1\":{\"824\":1}}],[\"网易的ddb等等都是这种架构的实现\",{\"1\":{\"586\":1}}],[\"网络攻击\",{\"0\":{\"1058\":1}}],[\"网络\",{\"1\":{\"1046\":1}}],[\"网络切换几乎时时刻刻都在发生\",{\"1\":{\"1042\":1}}],[\"网络性能就会变坏\",{\"1\":{\"1019\":1}}],[\"网络语音电话\",{\"1\":{\"1001\":1}}],[\"网络中用户可以对网络层的数据进行加密并对\",{\"1\":{\"996\":1}}],[\"网络地址转换\",{\"1\":{\"995\":1}}],[\"网络号全为1\",{\"1\":{\"989\":1}}],[\"网络为一个单位所拥有\",{\"1\":{\"977\":1}}],[\"网络接口层\",{\"1\":{\"964\":1}}],[\"网络协议\",{\"1\":{\"962\":1}}],[\"网络层的策略对tcp拥塞控制影响最大的就是路由器的分组丢弃策略\",{\"1\":{\"1021\":1}}],[\"网络层的分用是指接收方的网络层在剥去首部后吧数据交给相应的协议\",{\"1\":{\"999\":1}}],[\"网络层的复用是指发送方不同协议的数据都可以封装成ip数据报发送出去\",{\"1\":{\"999\":1}}],[\"网络层的复用和分用\",{\"1\":{\"999\":1}}],[\"网络层提供了主机之间的逻辑通道\",{\"1\":{\"999\":1}}],[\"网络层提供主机间的逻辑通信\",{\"1\":{\"997\":1,\"999\":1}}],[\"网络层和运输层的一个明显区别\",{\"1\":{\"997\":1,\"999\":1}}],[\"网络层向上只提供简单灵活的\",{\"1\":{\"982\":1}}],[\"网络层地址协商\",{\"1\":{\"975\":1}}],[\"网络层以上使用的中间设备叫做网关\",{\"1\":{\"965\":1}}],[\"网络层使用的中间设备叫做路由器\",{\"1\":{\"965\":1}}],[\"网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送\",{\"1\":{\"961\":1}}],[\"网络层\",{\"1\":{\"960\":1,\"961\":2,\"962\":1,\"964\":1}}],[\"网络传输层需要把调用的id和序列化后的参数传给服务端\",{\"1\":{\"804\":1}}],[\"网络框架\",{\"1\":{\"685\":1}}],[\"网络断了之后\",{\"1\":{\"663\":1}}],[\"网络io\",{\"1\":{\"585\":1}}],[\"网络io瓶颈\",{\"1\":{\"584\":1}}],[\"网络带宽不够\",{\"1\":{\"584\":1}}],[\"网络时间\",{\"1\":{\"440\":1}}],[\"网络命令\",{\"0\":{\"435\":1}}],[\"网络连接在内核中以文件描述符\",{\"1\":{\"381\":1}}],[\"网络连接地址\",{\"1\":{\"369\":1}}],[\"网络连接和io连接等\",{\"1\":{\"304\":1}}],[\"网络等中获取对象的二进制流\",{\"1\":{\"212\":1}}],[\"网络等\",{\"1\":{\"186\":1}}],[\"网络甚至机顶盒进行加载\",{\"1\":{\"180\":1}}],[\"靠近表尾的方向\",{\"1\":{\"630\":1}}],[\"靠近表头方向\",{\"1\":{\"630\":1}}],[\"靠\",{\"1\":{\"585\":1}}],[\"靠外键进行约束的场景会受到影响\",{\"1\":{\"585\":1}}],[\"拆分成多个子业务部署在多个服务器上\",{\"1\":{\"808\":1}}],[\"拆分后\",{\"1\":{\"585\":1}}],[\"拆分会带来逻辑\",{\"1\":{\"561\":1}}],[\"订单子域\",{\"1\":{\"1221\":1}}],[\"订单系统和库存系统\",{\"1\":{\"840\":1}}],[\"订单\",{\"1\":{\"807\":1}}],[\"订单一个库\",{\"1\":{\"585\":1}}],[\"订阅模式\",{\"1\":{\"844\":1}}],[\"订阅给定的一个或多个频道的信息\",{\"1\":{\"673\":1}}],[\"订阅该消息类型的全部\",{\"1\":{\"673\":1}}],[\"订阅自己感兴趣的消息类型\",{\"1\":{\"673\":1}}],[\"订阅者可以通过\",{\"1\":{\"673\":1}}],[\"订阅\",{\"1\":{\"477\":1,\"816\":1,\"1229\":1}}],[\"垂直分表\",{\"1\":{\"585\":1}}],[\"垂直分库\",{\"1\":{\"585\":1}}],[\"垂直切分一定程度的提升io\",{\"1\":{\"585\":1}}],[\"垂直切分常见的有两种垂直分库和垂直分表\",{\"1\":{\"585\":1}}],[\"垂直切分\",{\"1\":{\"585\":1}}],[\"垂直拆分的优缺点\",{\"1\":{\"585\":1}}],[\"垂直拆分\",{\"1\":{\"561\":1}}],[\"突然宕机\",{\"1\":{\"820\":1}}],[\"突然发生某些预先不可知的异常事件\",{\"1\":{\"134\":1}}],[\"突破io\",{\"1\":{\"585\":1}}],[\"崩溃\",{\"1\":{\"584\":1}}],[\"崩溃恢复\",{\"1\":{\"491\":1}}],[\"ｎ\",{\"1\":{\"582\":1}}],[\"涉及的线程\",{\"0\":{\"581\":1}}],[\"机构提供的\",{\"1\":{\"1057\":1}}],[\"机构使用自己的私钥对申请者的公钥加密\",{\"1\":{\"1057\":1}}],[\"机械特性\",{\"1\":{\"966\":1}}],[\"机器的性能如果没有问题\",{\"1\":{\"843\":1}}],[\"机器部署在一起\",{\"1\":{\"657\":1}}],[\"机器发送命令\",{\"1\":{\"657\":1}}],[\"机器异常重启了\",{\"1\":{\"578\":1}}],[\"机器挂了\",{\"1\":{\"578\":1}}],[\"机制的好处\",{\"0\":{\"834\":1}}],[\"机制的\",{\"1\":{\"342\":1}}],[\"机制\",{\"1\":{\"103\":1,\"523\":1,\"604\":1,\"647\":1,\"745\":1,\"807\":1,\"1004\":1}}],[\"承诺说半个月内可以恢复\",{\"1\":{\"576\":1}}],[\"怎样让数据库恢复某时刻状态\",{\"0\":{\"576\":1}}],[\"怎么分是该网络内部的事\",{\"1\":{\"989\":1}}],[\"怎么在海量数据中找出重复次数最多的一个\",{\"0\":{\"897\":1}}],[\"怎么在自定义端口上运行springboot应用程序\",{\"0\":{\"786\":1}}],[\"怎么办呢\",{\"1\":{\"1051\":1}}],[\"怎么办\",{\"1\":{\"815\":1}}],[\"怎么开发starter\",{\"0\":{\"773\":1}}],[\"怎么样设定重定向和转发的\",{\"0\":{\"758\":1}}],[\"怎么解决拆包和粘包\",{\"1\":{\"1006\":1}}],[\"怎么解决\",{\"0\":{\"757\":1}}],[\"怎么定义bean\",{\"0\":{\"730\":1}}],[\"怎么扩容\",{\"0\":{\"638\":1}}],[\"怎么保证\",{\"0\":{\"635\":1}}],[\"怎么保证值不会重复的\",{\"1\":{\"413\":1}}],[\"怎么加快插入速度\",{\"0\":{\"565\":1}}],[\"怎么执行是最好的结果呢\",{\"1\":{\"490\":1}}],[\"怎么实现有序的\",{\"1\":{\"412\":2}}],[\"怎么实现动态代理\",{\"1\":{\"349\":1}}],[\"瓶颈的场景里\",{\"1\":{\"571\":1}}],[\"追加写\",{\"1\":{\"571\":1,\"576\":1}}],[\"顺带将这个索引位置上的所有键值对拷贝到哈希表\",{\"1\":{\"615\":1}}],[\"顺带将这个事务的\",{\"1\":{\"568\":1}}],[\"顺序读取10个文件\",{\"1\":{\"895\":1}}],[\"顺序读文件中\",{\"1\":{\"894\":1}}],[\"顺序\",{\"1\":{\"867\":1}}],[\"顺序写之所以快\",{\"1\":{\"850\":1}}],[\"顺序写能够到600m\",{\"1\":{\"850\":1}}],[\"顺序写的方式\",{\"1\":{\"850\":1}}],[\"顺序写磁盘\",{\"1\":{\"850\":1}}],[\"顺序节点\",{\"1\":{\"823\":1}}],[\"顺序的索引\",{\"1\":{\"533\":1}}],[\"顺序加锁\",{\"1\":{\"98\":1}}],[\"秒钟发送一次\",{\"1\":{\"1028\":1}}],[\"秒杀请求直接进消息队列\",{\"1\":{\"840\":1}}],[\"秒一次改为每秒一次\",{\"1\":{\"657\":1,\"677\":1}}],[\"秒一次的频率向集群中的所有\",{\"1\":{\"657\":1}}],[\"秒内数据集存在\",{\"1\":{\"647\":1}}],[\"秒\",{\"1\":{\"568\":1}}],[\"留在\",{\"1\":{\"568\":1}}],[\"混合持久化\",{\"0\":{\"708\":1}}],[\"混合持久化结合了\",{\"1\":{\"653\":1}}],[\"混合了\",{\"1\":{\"566\":1}}],[\"混合收集\",{\"1\":{\"240\":1}}],[\"飙升\",{\"1\":{\"562\":1}}],[\"水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力\",{\"1\":{\"585\":1}}],[\"水平分库分表\",{\"1\":{\"585\":1}}],[\"水平分表\",{\"1\":{\"584\":1,\"585\":1}}],[\"水平切分分为库内分表和分库分表\",{\"1\":{\"585\":1}}],[\"水平切分是必然的选择\",{\"1\":{\"585\":1}}],[\"水平切分是将同一个表中的记录拆分到多个结构相同的表中\",{\"1\":{\"585\":1}}],[\"水平切分\",{\"1\":{\"585\":1}}],[\"水平切分和垂直切分\",{\"0\":{\"585\":1}}],[\"水平拆分的优缺点\",{\"1\":{\"585\":1}}],[\"水平拆分可以大大减少单表数据量\",{\"1\":{\"585\":1}}],[\"水平拆分\",{\"1\":{\"561\":1}}],[\"水平触发\",{\"1\":{\"381\":1}}],[\"部署运行\",{\"0\":{\"1192\":1}}],[\"部署过程\",{\"0\":{\"1177\":1}}],[\"部署图\",{\"1\":{\"1094\":1}}],[\"部署方式有单机模式\",{\"1\":{\"819\":1}}],[\"部署方便\",{\"1\":{\"674\":1,\"805\":1}}],[\"部署在多个服务器上\",{\"1\":{\"808\":1}}],[\"部署相对\",{\"1\":{\"676\":1}}],[\"部署架构主要包括两部分\",{\"1\":{\"676\":1}}],[\"部署\",{\"0\":{\"1176\":1,\"1179\":1,\"1195\":1},\"1\":{\"561\":1,\"1179\":1,\"1208\":1}}],[\"部分对象不能脱离整体对象而存在\",{\"1\":{\"1099\":1}}],[\"部分对象也将不存在\",{\"1\":{\"1099\":1}}],[\"部分\",{\"1\":{\"801\":2,\"1190\":1}}],[\"部分web请求\",{\"1\":{\"759\":1}}],[\"部分节点不可用时\",{\"1\":{\"660\":1,\"678\":1}}],[\"部分表无法join\",{\"1\":{\"585\":1}}],[\"部分提交状态\",{\"1\":{\"520\":1}}],[\"部分工作可以和应用程序同时执行\",{\"1\":{\"261\":1}}],[\"部分收集\",{\"1\":{\"240\":1}}],[\"部分页暂时存储在外部磁盘上\",{\"1\":{\"157\":1}}],[\"微服务架构需要解决的问题\",{\"1\":{\"815\":1}}],[\"微乎其微\",{\"1\":{\"555\":1}}],[\"微内核\",{\"0\":{\"133\":1},\"1\":{\"133\":1}}],[\"张\",{\"1\":{\"553\":1}}],[\"辅助数组\",{\"1\":{\"934\":1}}],[\"辅助\",{\"1\":{\"549\":1}}],[\"辅助索引可以不是\",{\"1\":{\"547\":1}}],[\"辅助索引叶子节点存储的不再是行的物理位置\",{\"1\":{\"547\":1}}],[\"辅助索引访问数据总是需要二次查找\",{\"1\":{\"547\":1,\"548\":1}}],[\"辅助索引\",{\"1\":{\"545\":1,\"548\":1}}],[\"辅以责任链模式\",{\"1\":{\"185\":1}}],[\"寻址更像在导航\",{\"1\":{\"961\":1}}],[\"寻找业务逻辑和业务规则\",{\"1\":{\"1216\":1}}],[\"寻找第\",{\"0\":{\"936\":1}}],[\"寻找热门查询\",{\"1\":{\"890\":1}}],[\"寻找最优秀的垃圾收集器的过程仍然在继续\",{\"1\":{\"254\":1}}],[\"寻道时间指的是磁臂移动到指定磁道所需要的时间\",{\"1\":{\"543\":1}}],[\"旋转延迟就是1\",{\"1\":{\"543\":1}}],[\"旋转延迟就是我们经常听说的磁盘转速\",{\"1\":{\"543\":1}}],[\"旋转延迟\",{\"1\":{\"543\":1}}],[\"旋转等操作来维护平衡性\",{\"1\":{\"538\":1}}],[\"树中虽然有\",{\"1\":{\"921\":1}}],[\"树中本来就规定没有\",{\"1\":{\"921\":1}}],[\"树中本来就是同一层的\",{\"1\":{\"921\":1}}],[\"树中真正贡献高度\",{\"1\":{\"921\":1}}],[\"树中如果根节点为\",{\"1\":{\"921\":1}}],[\"树到红黑树的转化已经解释过\",{\"1\":{\"921\":1}}],[\"树和\",{\"1\":{\"920\":1}}],[\"树还是有缺陷的\",{\"1\":{\"919\":1}}],[\"树一次全部装入内存\",{\"1\":{\"919\":1}}],[\"树具有以下特点\",{\"1\":{\"919\":1}}],[\"树都是\",{\"1\":{\"919\":1}}],[\"树是一种平衡的多路查找树\",{\"1\":{\"919\":1}}],[\"树不支持查询范围的快速查找\",{\"1\":{\"916\":1}}],[\"树从树根开始\",{\"1\":{\"555\":1}}],[\"树搜索有可能会在非叶子结点结束\",{\"1\":{\"541\":1}}],[\"树内节点不存储\",{\"1\":{\"541\":1}}],[\"树的输入\",{\"0\":{\"956\":1}}],[\"树的任一节点到空链接距离相同\",{\"1\":{\"921\":1}}],[\"树的阶为\",{\"1\":{\"919\":1}}],[\"树的阶\",{\"1\":{\"919\":1}}],[\"树的特例\",{\"1\":{\"919\":1}}],[\"树的叶子节点使用指针顺序连接在一起\",{\"1\":{\"541\":1}}],[\"树的查询效率更加稳定\",{\"1\":{\"541\":1}}],[\"树的高度越来越高\",{\"1\":{\"541\":1}}],[\"树的层级更少所以查询数据更快\",{\"1\":{\"541\":1}}],[\"树的基础上\",{\"1\":{\"538\":1}}],[\"树可以大幅减少\",{\"1\":{\"919\":1}}],[\"树可以存放\",{\"1\":{\"539\":1}}],[\"树可存多少行数据\",{\"1\":{\"539\":1}}],[\"树高为2\",{\"1\":{\"539\":1}}],[\"树能存多少数据\",{\"0\":{\"539\":1}}],[\"树\",{\"0\":{\"916\":1,\"918\":2,\"919\":1},\"1\":{\"538\":1,\"539\":1,\"541\":1,\"548\":1,\"549\":1,\"895\":1,\"919\":2}}],[\"树进行了优化\",{\"1\":{\"538\":1}}],[\"树索引之上再创建一个哈希索引\",{\"1\":{\"537\":1}}],[\"哈希环上的节点分布的就越均匀\",{\"1\":{\"880\":1}}],[\"哈希环上的相邻节点容易受到过大影响\",{\"1\":{\"880\":1}}],[\"哈希算法是对节点的数量进行取模运算\",{\"1\":{\"880\":1}}],[\"哈希算法在面对节点数量变化时\",{\"1\":{\"880\":1}}],[\"哈希算法最简单的做法就是进行取模运算\",{\"1\":{\"880\":1}}],[\"哈希槽是如何映射到\",{\"0\":{\"680\":1}}],[\"哈希节点\",{\"1\":{\"623\":1}}],[\"哈希表查找\",{\"0\":{\"922\":1}}],[\"哈希表的负载因子>5\",{\"1\":{\"623\":1}}],[\"哈希表的负载因子>=1\",{\"1\":{\"623\":1}}],[\"哈希表的最大好处\",{\"1\":{\"614\":1}}],[\"哈希表使用链地址法解决哈希冲突\",{\"1\":{\"623\":1}}],[\"哈希表中有存放哈希节点的数组\",{\"1\":{\"623\":1}}],[\"哈希表\",{\"1\":{\"615\":1,\"623\":1,\"922\":1}}],[\"哈希\",{\"0\":{\"615\":1}}],[\"哈希桶中的键值对元素保存了\",{\"1\":{\"614\":1}}],[\"哈希索引数据并不是按照索引值顺序存储的\",{\"1\":{\"537\":1,\"541\":1}}],[\"哈希索引能以\",{\"1\":{\"537\":1}}],[\"哈希索引将所有数据行的\",{\"1\":{\"537\":1}}],[\"哈希索引\",{\"0\":{\"537\":1},\"1\":{\"537\":1,\"548\":1}}],[\"哈希码\",{\"1\":{\"225\":1}}],[\"明确知道只会返回一条记录\",{\"1\":{\"535\":1}}],[\"含义\",{\"1\":{\"556\":1}}],[\"含有序列\",{\"1\":{\"823\":1}}],[\"含有\",{\"1\":{\"535\":1}}],[\"含属性与隐藏档\",{\"1\":{\"419\":1}}],[\"越界指当p1指向了右半部分或者当p2大于r之后\",{\"1\":{\"934\":1}}],[\"越界的情况\",{\"1\":{\"912\":1,\"913\":1}}],[\"越界问题\",{\"1\":{\"372\":1}}],[\"越大的term表示任期越新\",{\"1\":{\"876\":1}}],[\"越复杂的sql\",{\"1\":{\"597\":1}}],[\"越先执行\",{\"1\":{\"556\":1}}],[\"越靠近根节点的记录查找时间越短\",{\"1\":{\"541\":1}}],[\"越小的数据类型通常在磁盘\",{\"1\":{\"535\":1}}],[\"越小的数据类型通常更好\",{\"1\":{\"535\":1}}],[\"隐式使用引起类结构不清晰\",{\"1\":{\"1072\":1}}],[\"隐式字符编码转换\",{\"1\":{\"534\":1}}],[\"隐式类型转换\",{\"1\":{\"534\":1}}],[\"隐式泄漏\",{\"1\":{\"303\":1}}],[\"干净页\",{\"1\":{\"592\":1}}],[\"干净\",{\"1\":{\"533\":1}}],[\"频分复用fdm\",{\"1\":{\"967\":1}}],[\"频繁切换上下文带来的损耗\",{\"1\":{\"835\":1}}],[\"频繁执行成本过高\",{\"1\":{\"648\":1}}],[\"频繁需要写入数据库\",{\"1\":{\"606\":1}}],[\"频繁变化导致索引也频繁变化\",{\"1\":{\"532\":1}}],[\"频繁更新的字段不要使用索引\",{\"1\":{\"532\":1}}],[\"频繁作为查询的条件的字段\",{\"1\":{\"531\":1}}],[\"频率很高的消息\",{\"1\":{\"149\":1}}],[\"串行化\",{\"1\":{\"524\":1}}],[\"串行级别下的快照读会退化成当前读\",{\"1\":{\"499\":1}}],[\"丢弃帧\",{\"1\":{\"961\":1}}],[\"丢弃阻塞队列中靠最前的任务\",{\"1\":{\"60\":1}}],[\"丢失修改\",{\"1\":{\"521\":1}}],[\"持续连接\",{\"1\":{\"1042\":1}}],[\"持久层\",{\"0\":{\"762\":1},\"1\":{\"754\":1}}],[\"持久化顺序节点create\",{\"1\":{\"818\":1}}],[\"持久化目录节点create\",{\"1\":{\"818\":1}}],[\"持久化的优点\",{\"1\":{\"653\":1}}],[\"持久化方式的选择\",{\"0\":{\"653\":1}}],[\"持久化方式\",{\"1\":{\"649\":1}}],[\"持久化功能则自动执行\",{\"1\":{\"647\":1}}],[\"持久化机制\",{\"1\":{\"647\":1}}],[\"持久化过程由子进程负责\",{\"1\":{\"647\":1}}],[\"持久化命令\",{\"1\":{\"623\":1}}],[\"持久化\",{\"1\":{\"571\":1,\"642\":1,\"646\":1,\"647\":2,\"653\":1}}],[\"持久化到磁盘\",{\"1\":{\"568\":3}}],[\"持久性\",{\"1\":{\"519\":1}}],[\"持久性是为了保障一致性的手段\",{\"1\":{\"519\":1}}],[\"持有一个策略类的引用\",{\"1\":{\"1088\":1}}],[\"持有时间过长的情况\",{\"1\":{\"298\":1}}],[\"持有这个引用是为了支持方法调用过程中的动态连接\",{\"1\":{\"194\":1}}],[\"持有读锁的情况下去获取写锁\",{\"1\":{\"125\":1}}],[\"构件图\",{\"1\":{\"1094\":1}}],[\"构建聚合\",{\"1\":{\"1224\":1}}],[\"构建业务聚合\",{\"0\":{\"1219\":1}}],[\"构建结束\",{\"1\":{\"1212\":1}}],[\"构建和表示分离\",{\"1\":{\"1086\":1}}],[\"构建出高可靠\",{\"1\":{\"697\":1}}],[\"构建出高价值\",{\"1\":{\"697\":1}}],[\"构成icmp差错报告报文\",{\"1\":{\"993\":1}}],[\"构成超网\",{\"1\":{\"983\":1}}],[\"构成的数组\",{\"1\":{\"875\":1}}],[\"构成\",{\"1\":{\"630\":1}}],[\"构成这个逻辑上的整体的这些数据库操作遵循\",{\"1\":{\"518\":1}}],[\"构成一个逻辑上的整体\",{\"1\":{\"518\":1}}],[\"构造一份完整的套餐\",{\"1\":{\"1086\":1}}],[\"构造超网\",{\"0\":{\"991\":1}}],[\"构造树需要的结点类\",{\"1\":{\"956\":1}}],[\"构造出最初的大顶堆\",{\"1\":{\"937\":1}}],[\"构造器私有化\",{\"1\":{\"1066\":1}}],[\"构造器私有化的类不能被继承\",{\"1\":{\"355\":1}}],[\"构造器依赖注入通过容器触发一个类的构造器来实现的\",{\"1\":{\"730\":1}}],[\"构造器依赖注入\",{\"1\":{\"730\":1}}],[\"构造哨兵模式与集群\",{\"1\":{\"655\":1,\"661\":1}}],[\"构造函数调用和系统内存等信息\",{\"1\":{\"313\":1}}],[\"构造函数\",{\"1\":{\"223\":1,\"363\":2}}],[\"构造方法的参数是给线程指定名字\",{\"1\":{\"31\":1}}],[\"偶数的二进制的最后一位肯定是0\",{\"1\":{\"946\":1}}],[\"偶数\",{\"1\":{\"946\":1}}],[\"偶尔回滚事务的成本会低于读取数据时锁定数据的成本\",{\"1\":{\"513\":1}}],[\"偶然发生\",{\"1\":{\"303\":1}}],[\"乐观并发控制相信事务之间的数据竞争的概率是比较小的\",{\"1\":{\"513\":1}}],[\"乐观锁机制\",{\"1\":{\"665\":1}}],[\"乐观锁并不会使用数据库提供的锁机制\",{\"1\":{\"513\":1}}],[\"乐观锁认为数据一般情况下不会造成冲突\",{\"1\":{\"513\":1}}],[\"乐观锁适用于写比较少的情况下\",{\"1\":{\"104\":1}}],[\"乐观锁适用于多读的应用类型\",{\"1\":{\"103\":1}}],[\"乐观锁一定比悲观锁效率高么\",{\"1\":{\"104\":1}}],[\"乐观锁\",{\"0\":{\"103\":1},\"1\":{\"513\":1}}],[\"乐观锁的概念认为当前线程在操作数据的过程中不会有其他线程修改数据\",{\"1\":{\"81\":1}}],[\"悲观锁实际上是采取了\",{\"1\":{\"513\":1}}],[\"悲观锁\",{\"1\":{\"513\":1}}],[\"悲观锁与乐观锁\",{\"0\":{\"513\":1}}],[\"悲观锁认为共享变量一定会有其他线程来修改\",{\"1\":{\"81\":1}}],[\"肯定不会给予响应\",{\"1\":{\"1060\":1}}],[\"肯定是根据频率最大堆排序\",{\"1\":{\"904\":1}}],[\"肯定是不行的\",{\"1\":{\"511\":1}}],[\"肯定属于java中很基础的类型了\",{\"1\":{\"185\":1}}],[\"删了一列\",{\"1\":{\"511\":1}}],[\"删除现有插件\",{\"1\":{\"1136\":1}}],[\"删除指明的url所标志的资源\",{\"1\":{\"1040\":1}}],[\"删除发送缓冲区对应的数据\",{\"1\":{\"1004\":1}}],[\"删除数据时通过左旋\",{\"1\":{\"916\":1}}],[\"删除的基本数据结构\",{\"1\":{\"884\":1}}],[\"删除的节点等待\",{\"1\":{\"392\":1}}],[\"删除节点\",{\"1\":{\"823\":1}}],[\"删除一次或删除多次都是把数据删除\",{\"1\":{\"807\":1}}],[\"删除一个空的目录\",{\"1\":{\"418\":1}}],[\"删除操作\",{\"1\":{\"807\":1}}],[\"删除操作都是\",{\"1\":{\"622\":1}}],[\"删除target文件夹\",{\"1\":{\"793\":1}}],[\"删除等\",{\"1\":{\"754\":1}}],[\"删除任意实现类都不会导致程序编译出错\",{\"1\":{\"718\":1}}],[\"删除对应的子节点释放锁\",{\"1\":{\"668\":1}}],[\"删除这\",{\"1\":{\"632\":1}}],[\"删除索引\",{\"1\":{\"527\":2}}],[\"删除速度\",{\"1\":{\"483\":1}}],[\"删除表的所有数据\",{\"1\":{\"483\":1}}],[\"删除表的全部或一部分数据\",{\"1\":{\"483\":1}}],[\"删除内容\",{\"1\":{\"483\":1}}],[\"删除远程分支\",{\"1\":{\"451\":1}}],[\"删除远程tag\",{\"1\":{\"450\":1}}],[\"删除分支\",{\"1\":{\"451\":1}}],[\"删除本地tag\",{\"1\":{\"450\":1}}],[\"删除工作区文件\",{\"1\":{\"447\":1}}],[\"删除文件\",{\"0\":{\"447\":1}}],[\"删除文件或目录\",{\"1\":{\"418\":1}}],[\"删除其中任何一个都不会影响另外一个的访问\",{\"1\":{\"427\":1}}],[\"删除当前光标到行尾\",{\"1\":{\"417\":1}}],[\"删除当前光标到行首\",{\"1\":{\"417\":1}}],[\"删除后\",{\"1\":{\"414\":1}}],[\"删除元素时可以通过remove\",{\"1\":{\"392\":1}}],[\"删除从\",{\"1\":{\"301\":1}}],[\"删除\",{\"1\":{\"301\":1,\"501\":1,\"622\":1,\"623\":1,\"752\":1,\"883\":1,\"973\":1,\"1212\":1}}],[\"⾏锁实际上是作⽤在索引之上的\",{\"1\":{\"508\":1}}],[\"刚开始指数级增长\",{\"1\":{\"1019\":1}}],[\"刚好\",{\"1\":{\"617\":1}}],[\"刚好就比\",{\"1\":{\"414\":1}}],[\"刚刚那个说的不对\",{\"1\":{\"508\":1}}],[\"扫描行数是怎么判断的呢\",{\"1\":{\"536\":1}}],[\"扫描行数是影响执行代价的因素之一\",{\"1\":{\"536\":1}}],[\"扫描行数并不是唯一的判断标准\",{\"1\":{\"536\":1}}],[\"扫描算法\",{\"1\":{\"163\":1}}],[\"扫表的时候\",{\"1\":{\"506\":1}}],[\"级别的缓存\",{\"1\":{\"752\":2}}],[\"级别\",{\"1\":{\"556\":1,\"759\":1}}],[\"级别下幻读的问题\",{\"1\":{\"523\":1}}],[\"级别下\",{\"1\":{\"523\":1}}],[\"级别下如何解决幻读\",{\"0\":{\"523\":1}}],[\"级别下当前读存在的幻读问题\",{\"1\":{\"505\":1}}],[\"级联执行\",{\"1\":{\"463\":1}}],[\"间隙锁\",{\"0\":{\"504\":1},\"1\":{\"504\":1,\"506\":1}}],[\"间接造就了它被程序员滥用的局面\",{\"1\":{\"295\":1}}],[\"隔离性之后\",{\"1\":{\"519\":1}}],[\"隔离性\",{\"1\":{\"519\":1}}],[\"隔离级别\",{\"1\":{\"522\":2,\"741\":2}}],[\"隔离级别才有\",{\"1\":{\"505\":1}}],[\"隔离级别都有\",{\"1\":{\"503\":1}}],[\"隔离加载类\",{\"1\":{\"180\":1}}],[\"幻读的情形\",{\"1\":{\"523\":2}}],[\"幻读或不可重复读\",{\"1\":{\"522\":1,\"741\":1}}],[\"幻读与不可重复读类似\",{\"1\":{\"521\":1}}],[\"幻读\",{\"1\":{\"499\":2,\"521\":1,\"522\":1,\"523\":1}}],[\"⽆⾮就是read\",{\"1\":{\"499\":1}}],[\"⽐对版本\",{\"1\":{\"499\":1}}],[\"铺垫到这了\",{\"1\":{\"499\":1}}],[\"入队列\",{\"1\":{\"941\":1}}],[\"入参\",{\"1\":{\"755\":1}}],[\"入缓存\",{\"1\":{\"643\":1}}],[\"入缓冲池的页\",{\"1\":{\"495\":1}}],[\"入栈\",{\"1\":{\"190\":1}}],[\"步\",{\"1\":{\"927\":1}}],[\"步骤\",{\"1\":{\"922\":1}}],[\"步骤乱序了\",{\"1\":{\"101\":1}}],[\"步之后\",{\"1\":{\"490\":1}}],[\"版本太低了\",{\"1\":{\"1212\":1}}],[\"版本\",{\"1\":{\"648\":1}}],[\"版本的不断迭代\",{\"1\":{\"648\":1}}],[\"版本以后\",{\"1\":{\"618\":1}}],[\"版本以前当元素数量小于\",{\"1\":{\"618\":1}}],[\"版本中引入了\",{\"1\":{\"511\":1}}],[\"版本与事务时间戳关联\",{\"1\":{\"499\":1}}],[\"版本后删除了缓存的功能\",{\"1\":{\"490\":1}}],[\"版本开始就被当做默认存储引擎了\",{\"1\":{\"488\":1}}],[\"版本库\",{\"1\":{\"444\":1}}],[\"递增的情况\",{\"1\":{\"486\":1}}],[\"递归结束的条件\",{\"1\":{\"934\":1}}],[\"递归实际利用的是栈结构\",{\"1\":{\"934\":1}}],[\"递归子文件夹\",{\"1\":{\"443\":1}}],[\"递归更改文件属组\",{\"1\":{\"431\":1}}],[\"递归删除节点\",{\"1\":{\"823\":1}}],[\"递归删除\",{\"1\":{\"424\":1}}],[\"递归持续复制\",{\"1\":{\"423\":1}}],[\"递归创建起来\",{\"1\":{\"422\":1}}],[\"递归调用右半数组\",{\"1\":{\"935\":1}}],[\"递归调用左半数组\",{\"1\":{\"935\":1}}],[\"递归调用\",{\"1\":{\"297\":1}}],[\"递归扫描整个堆里的对象图\",{\"1\":{\"264\":1}}],[\"行为事务\",{\"1\":{\"1093\":1}}],[\"行为事物\",{\"1\":{\"1093\":1}}],[\"行为\",{\"1\":{\"688\":1,\"1217\":1}}],[\"行为模型应该总是通过接口而不是抽象类定义\",{\"1\":{\"362\":1}}],[\"行这样的数据\",{\"1\":{\"539\":1}}],[\"行级锁是\",{\"1\":{\"509\":1}}],[\"行级锁操作时只锁某一行\",{\"1\":{\"493\":1}}],[\"行锁\",{\"0\":{\"509\":1}}],[\"行锁的选择\",{\"0\":{\"506\":1}}],[\"行锁和间隙锁组合起来\",{\"0\":{\"505\":1}}],[\"行\",{\"1\":{\"484\":1,\"498\":1}}],[\"行返回给客户端\",{\"1\":{\"484\":1}}],[\"杭州\",{\"1\":{\"484\":4}}],[\"固定可查\",{\"1\":{\"1000\":1}}],[\"固定大小的几个文件\",{\"1\":{\"568\":1}}],[\"固定大小线程池\",{\"1\":{\"56\":1}}],[\"固定长度的\",{\"1\":{\"477\":1}}],[\"固定长度类型\",{\"1\":{\"477\":1}}],[\"格林威治时间\",{\"1\":{\"475\":1}}],[\"格式化\",{\"1\":{\"1150\":1}}],[\"格式为属性名\",{\"1\":{\"1038\":1}}],[\"格式等\",{\"1\":{\"755\":1}}],[\"格式无法兼容高版本\",{\"1\":{\"648\":1}}],[\"格式\",{\"1\":{\"426\":2,\"653\":2,\"1035\":1,\"1036\":1}}],[\"日午夜\",{\"1\":{\"475\":1}}],[\"日志设置\",{\"1\":{\"1177\":1}}],[\"日志缓冲区\",{\"1\":{\"1177\":1}}],[\"日志分别存储到1024\",{\"1\":{\"892\":1}}],[\"日志分析工具\",{\"0\":{\"271\":1}}],[\"日志复制\",{\"0\":{\"878\":1}}],[\"日志记录\",{\"1\":{\"719\":1}}],[\"日志管理\",{\"1\":{\"715\":1}}],[\"日志对象\",{\"1\":{\"713\":1}}],[\"日志很小\",{\"1\":{\"653\":1}}],[\"日志不再是全量的日志\",{\"1\":{\"653\":1}}],[\"日志不断变大\",{\"1\":{\"651\":1}}],[\"日志文件大小\",{\"1\":{\"1177\":1}}],[\"日志文件存在一起\",{\"1\":{\"653\":1}}],[\"日志文件的输出路径\",{\"1\":{\"270\":1}}],[\"日志没有被写入\",{\"1\":{\"578\":1}}],[\"日志只能用于归档\",{\"1\":{\"577\":1}}],[\"日志恢复到更改之前的状态\",{\"1\":{\"570\":1}}],[\"日志写到\",{\"1\":{\"568\":1}}],[\"日志满了时\",{\"1\":{\"568\":1}}],[\"日志格式\",{\"1\":{\"566\":1}}],[\"日志\",{\"0\":{\"875\":1},\"1\":{\"563\":1,\"571\":1,\"653\":1}}],[\"月毕业后就职于恒生电子股份有限公司至今\",{\"1\":{\"687\":1}}],[\"月\",{\"1\":{\"475\":1}}],[\"月饼体积可认为是文件内容大小\",{\"1\":{\"442\":1}}],[\"精度为秒\",{\"1\":{\"475\":1}}],[\"剩下的服务器是\",{\"1\":{\"874\":1}}],[\"剩下\",{\"1\":{\"473\":1}}],[\"剩余的空间不得被其他文件使用\",{\"1\":{\"442\":1}}],[\"浮点数\",{\"0\":{\"473\":1}}],[\"申请证书\",{\"1\":{\"1048\":1}}],[\"申请空间\",{\"1\":{\"623\":1}}],[\"申请到\",{\"1\":{\"468\":1}}],[\"申请内存时只需要调用一次内存分配函数\",{\"1\":{\"617\":1}}],[\"申请内存\",{\"1\":{\"153\":1}}],[\"逻辑炸弹\",{\"1\":{\"1054\":1}}],[\"逻辑时钟\",{\"1\":{\"820\":1}}],[\"逻辑分类\",{\"0\":{\"548\":1}}],[\"逻辑里\",{\"1\":{\"468\":1}}],[\"逻辑地址\",{\"1\":{\"153\":1}}],[\"效果不受影响\",{\"1\":{\"467\":1}}],[\"效率较高\",{\"1\":{\"1069\":1}}],[\"效率较差\",{\"1\":{\"283\":1}}],[\"效率还有提升空间\",{\"1\":{\"1042\":1}}],[\"效率很高\",{\"1\":{\"830\":1,\"885\":1}}],[\"效率很低\",{\"1\":{\"391\":1,\"541\":1}}],[\"效率下降\",{\"1\":{\"627\":1}}],[\"效率更高\",{\"1\":{\"617\":1,\"829\":2}}],[\"效率可能极差\",{\"1\":{\"541\":1}}],[\"效率低下\",{\"1\":{\"393\":1}}],[\"效率低\",{\"1\":{\"372\":1}}],[\"效率将会降低\",{\"1\":{\"246\":1}}],[\"效率高\",{\"1\":{\"233\":1,\"477\":1,\"613\":1}}],[\"影响性能\",{\"1\":{\"641\":1}}],[\"影响插入效率\",{\"1\":{\"466\":1}}],[\"影响系统性能的主要因素有\",{\"1\":{\"440\":1}}],[\"条命令都是多余的\",{\"1\":{\"651\":1}}],[\"条命令\",{\"1\":{\"651\":1}}],[\"条这样的记录\",{\"1\":{\"539\":1}}],[\"条这样的数据记录\",{\"1\":{\"539\":1}}],[\"条结果停止搜索\",{\"1\":{\"535\":1}}],[\"条数据\",{\"1\":{\"464\":1}}],[\"条件一个一个的增加\",{\"1\":{\"904\":1}}],[\"条件\",{\"1\":{\"772\":1}}],[\"条件的记录\",{\"1\":{\"555\":1}}],[\"条件的主键\",{\"1\":{\"484\":2}}],[\"条件过滤\",{\"1\":{\"487\":1}}],[\"条件为止\",{\"1\":{\"484\":1}}],[\"条件变量来实现等待\",{\"1\":{\"109\":1}}],[\"条件队列\",{\"1\":{\"94\":1}}],[\"拼接到\",{\"1\":{\"461\":1,\"596\":1,\"750\":1}}],[\"拼接代理类源码\",{\"1\":{\"349\":1}}],[\"稍后再移入\",{\"1\":{\"453\":1}}],[\"稍后收集器将对f\",{\"1\":{\"236\":1}}],[\"推送合并后的主分支\",{\"1\":{\"1127\":1}}],[\"推送本地分支到远端同名分支\",{\"1\":{\"1127\":1}}],[\"推送本地分支到远端\",{\"1\":{\"1127\":1}}],[\"推送开发分支并合并到主分支\",{\"0\":{\"1127\":1}}],[\"推送\",{\"1\":{\"1016\":1}}],[\"推送所有分支到远程仓库\",{\"1\":{\"452\":1}}],[\"推荐用\",{\"1\":{\"1150\":1}}],[\"推荐指数\",{\"1\":{\"1130\":1}}],[\"推荐方式\",{\"1\":{\"1127\":1}}],[\"推荐使用import\",{\"1\":{\"1209\":1}}],[\"推荐使用\",{\"0\":{\"1068\":1,\"1069\":1,\"1070\":1}}],[\"推荐在数据量不多的时候使用\",{\"1\":{\"625\":1}}],[\"推荐冗余10\",{\"1\":{\"478\":1}}],[\"推荐设置为整个堆大小的3\",{\"1\":{\"322\":1}}],[\"推荐给线程起个名字\",{\"1\":{\"31\":2}}],[\"仓库\",{\"1\":{\"1121\":1,\"1239\":1}}],[\"仓库克隆一份到自己的电脑上\",{\"1\":{\"452\":1}}],[\"仓库则有四个工作区域\",{\"1\":{\"444\":1}}],[\"合成复用原则\",{\"1\":{\"1064\":1}}],[\"合索引\",{\"1\":{\"550\":1}}],[\"合并开发分支\",{\"1\":{\"1127\":1}}],[\"合并到\",{\"1\":{\"1127\":1}}],[\"合并到当前分支\",{\"1\":{\"1126\":1}}],[\"合并相邻的有序序列\",{\"1\":{\"934\":1}}],[\"合并相邻的有序子序列\",{\"1\":{\"934\":1}}],[\"合并\",{\"1\":{\"538\":1}}],[\"合并进当前分支\",{\"1\":{\"451\":1}}],[\"合并指定分支到当前分支\",{\"1\":{\"451\":1}}],[\"合理\",{\"1\":{\"668\":1}}],[\"合理设置批量大小\",{\"1\":{\"564\":1}}],[\"合理设置线程池线程数量\",{\"1\":{\"309\":1}}],[\"合理设计索引\",{\"1\":{\"516\":1}}],[\"合理利用多线程机制可以大大提高系统整体的并发能力以及性能\",{\"1\":{\"30\":1}}],[\"绑在一起\",{\"1\":{\"450\":1}}],[\"绑定\",{\"1\":{\"381\":1}}],[\"绑定是一个字段\",{\"1\":{\"194\":1}}],[\"按如下方式修改格式化\",{\"1\":{\"1151\":1}}],[\"按回车键\",{\"1\":{\"1124\":1}}],[\"按某种顺序调用其包含的基本方法\",{\"1\":{\"1087\":1}}],[\"按序到达\",{\"1\":{\"1015\":1}}],[\"按位异或\",{\"1\":{\"943\":1}}],[\"按位非\",{\"1\":{\"943\":1}}],[\"按位或\",{\"1\":{\"943\":1}}],[\"按位与\",{\"1\":{\"943\":1}}],[\"按后端服务器的响应时间来分配请求\",{\"1\":{\"832\":1}}],[\"按编号依次启动\",{\"1\":{\"820\":1}}],[\"按权重设置随机概率\",{\"1\":{\"812\":1}}],[\"按从小到大排列\",{\"1\":{\"630\":1}}],[\"按一般大老们的经验\",{\"1\":{\"587\":1}}],[\"按日期将不同月甚至是日的数据分散到不同的库中\",{\"1\":{\"587\":1}}],[\"按层搜索到叶子节点\",{\"1\":{\"555\":1}}],[\"按底层数据结构分类\",{\"1\":{\"548\":1}}],[\"按是否建立在主键上分类\",{\"1\":{\"548\":1}}],[\"按常规功能\",{\"0\":{\"548\":1}}],[\"按物理分类\",{\"0\":{\"547\":1}}],[\"按锁粒度划分\",{\"0\":{\"507\":1}}],[\"按提交次数排序\",{\"1\":{\"449\":1}}],[\"按照快重传算法\",{\"1\":{\"1019\":1}}],[\"按照通信方式可分为\",{\"1\":{\"960\":1}}],[\"按照第一列从小到大排列\",{\"1\":{\"938\":1}}],[\"按照hash\",{\"1\":{\"895\":1}}],[\"按照handleradapter\",{\"1\":{\"756\":1}}],[\"按照某种规则过滤不符合要求的消息\",{\"1\":{\"867\":1}}],[\"按照range的方式进行分配\",{\"1\":{\"859\":1}}],[\"按照分区字典对分区和消费者进行排序\",{\"1\":{\"859\":1}}],[\"按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件\",{\"1\":{\"647\":1}}],[\"按照新的\",{\"1\":{\"623\":1}}],[\"按照时间区间或id区间来切分\",{\"1\":{\"587\":1}}],[\"按照业务将表进行分类\",{\"1\":{\"561\":1}}],[\"按照从最佳到最坏类型排序\",{\"1\":{\"556\":1}}],[\"按照锁的实现分为\",{\"1\":{\"500\":1}}],[\"按照锁粒度来区分\",{\"1\":{\"500\":1}}],[\"按照排序结果取前\",{\"1\":{\"484\":1}}],[\"按照我的理解来说\",{\"1\":{\"464\":1}}],[\"按照继承关系从下往上依次对c的各个父类进行第二步的搜索和验证过程\",{\"1\":{\"278\":1}}],[\"按照各进程到达就绪队列的顺序\",{\"1\":{\"150\":1}}],[\"按照进程到达的先后顺序执行\",{\"1\":{\"150\":1}}],[\"按照\",{\"1\":{\"144\":1,\"892\":1}}],[\"按照线程在队列中的排队顺序\",{\"1\":{\"113\":1}}],[\"按照程序的顺序\",{\"1\":{\"75\":1,\"102\":1}}],[\"替代xml配置文件\",{\"1\":{\"743\":1}}],[\"替代上一次提交\",{\"1\":{\"448\":1}}],[\"替换操作是原子的\",{\"1\":{\"647\":1}}],[\"替换成正常的\",{\"1\":{\"622\":1}}],[\"替换阶段是sql解析阶段\",{\"1\":{\"596\":1}}],[\"替换\",{\"1\":{\"131\":1}}],[\"替换为指向锁记录的指针\",{\"1\":{\"87\":1}}],[\"替换后\",{\"1\":{\"18\":1}}],[\"停止等待\",{\"1\":{\"1011\":1}}],[\"停止等待协议中的超时重传是指只要超过一段时间仍然没有收到确认\",{\"1\":{\"1011\":1}}],[\"停止等待协议是为了实现可靠传输的\",{\"1\":{\"1010\":1}}],[\"停止等待协议\",{\"0\":{\"1010\":1}}],[\"停止写入可能也意味着停止读取\",{\"1\":{\"491\":1}}],[\"停止追踪指定文件\",{\"1\":{\"447\":1}}],[\"停顿时间\",{\"1\":{\"310\":1}}],[\"停顿时间要求的同时\",{\"1\":{\"261\":1}}],[\"添加所有修改到暂存区\",{\"1\":{\"1127\":1}}],[\"添加一行\",{\"1\":{\"1124\":1}}],[\"添加超时重传机制\",{\"1\":{\"1004\":1}}],[\"添加发送和接收缓冲区\",{\"1\":{\"1004\":1}}],[\"添加到集合中的元素越多\",{\"1\":{\"882\":1}}],[\"添加到自己的日志后面\",{\"1\":{\"878\":1}}],[\"添加到自己的日志末尾后\",{\"1\":{\"878\":1}}],[\"添加到自己的\",{\"1\":{\"875\":1}}],[\"添加\",{\"1\":{\"776\":1,\"1004\":1}}],[\"添加mybatis的starter\",{\"1\":{\"776\":1}}],[\"添加对应的物理分页语句和物理分页参数\",{\"1\":{\"753\":1}}],[\"添加监视锁\",{\"1\":{\"665\":1}}],[\"添加了新的混合持久化方式\",{\"1\":{\"653\":1}}],[\"添加索引\",{\"1\":{\"527\":1}}],[\"添加文件需要add\",{\"1\":{\"447\":1}}],[\"添加每个变化前\",{\"1\":{\"447\":1}}],[\"添加当前目录的所有文件到暂存区\",{\"1\":{\"447\":1}}],[\"添加指定目录到暂存区\",{\"1\":{\"447\":1}}],[\"添加指定文件到暂存区\",{\"1\":{\"447\":1}}],[\"添加jvm参数\",{\"0\":{\"317\":1}}],[\"展示的文件大小要大一些\",{\"1\":{\"442\":1}}],[\"展示文件内容的大小\",{\"1\":{\"442\":1}}],[\"展示文件占用的磁盘空间\",{\"1\":{\"442\":1}}],[\"检验范围包括首部和数据两部分\",{\"1\":{\"1007\":1}}],[\"检验和\",{\"1\":{\"1002\":1,\"1007\":1}}],[\"检索的条件\",{\"1\":{\"888\":1}}],[\"检索元素是否在给定大集合中的数据结构\",{\"1\":{\"882\":1}}],[\"检查是否与bloom\",{\"1\":{\"896\":1}}],[\"检查哨兵是否正常运行\",{\"1\":{\"657\":1}}],[\"检查约束\",{\"1\":{\"460\":1}}],[\"检查磁盘空间使用量\",{\"1\":{\"441\":1}}],[\"检测udp用户数据报在传输中是否有错\",{\"1\":{\"1002\":1}}],[\"检测连接状态\",{\"1\":{\"975\":1}}],[\"检测死锁可以使用\",{\"1\":{\"98\":1}}],[\"检测\",{\"1\":{\"98\":1}}],[\"英文全称\",{\"1\":{\"441\":2}}],[\"英文全拼\",{\"1\":{\"418\":8}}],[\"$$\",{\"1\":{\"1012\":4}}],[\"$\",{\"0\":{\"461\":1,\"596\":1,\"750\":1},\"1\":{\"439\":1,\"445\":3,\"446\":4,\"447\":7,\"448\":6,\"449\":21,\"450\":9,\"451\":15,\"452\":8,\"453\":11,\"461\":2,\"596\":2,\"750\":2,\"1177\":3,\"1190\":1}}],[\"$path\",{\"1\":{\"434\":1}}],[\"统一密钥对\",{\"1\":{\"1057\":1}}],[\"统一资源定位符url\",{\"0\":{\"1036\":1}}],[\"统一逻辑时钟后\",{\"1\":{\"820\":1}}],[\"统一编码处理\",{\"1\":{\"759\":1}}],[\"统一为\",{\"1\":{\"619\":1}}],[\"统一回收所有未被标记的对象\",{\"1\":{\"244\":1}}],[\"统一回收掉所有被标记的对象\",{\"1\":{\"244\":1}}],[\"统计复用又称为异步时分复用\",{\"1\":{\"967\":1}}],[\"统计时分复用stdm\",{\"1\":{\"967\":1}}],[\"统计每个词出现的次数\",{\"1\":{\"899\":1}}],[\"统计每个\",{\"1\":{\"893\":1}}],[\"统计其中出现次数最多的前n个数据\",{\"0\":{\"898\":1},\"1\":{\"891\":1}}],[\"统计不同号码的个数\",{\"1\":{\"883\":1}}],[\"统计类需求\",{\"1\":{\"867\":1}}],[\"统计消费者和提供者在内存中累计调用次数和调用时间\",{\"1\":{\"810\":1}}],[\"统计网站在线人数\",{\"1\":{\"759\":1}}],[\"统计这些页面上的不同值\",{\"1\":{\"536\":1}}],[\"统计输出信息的行数\",{\"1\":{\"443\":1}}],[\"统计\",{\"0\":{\"443\":1}}],[\"统计命令\",{\"0\":{\"439\":1}}],[\"立刻升级为\",{\"1\":{\"820\":1}}],[\"立刻显示出档名以及目前显示的行数\",{\"1\":{\"429\":1}}],[\"立即返回结果\",{\"1\":{\"565\":1}}],[\"立即杀死进程\",{\"1\":{\"436\":1}}],[\"杀死进程\",{\"1\":{\"436\":1}}],[\"杀进程\",{\"1\":{\"426\":1}}],[\"撤销\",{\"0\":{\"453\":1}}],[\"撤销权限\",{\"1\":{\"433\":1}}],[\"撤销操作\",{\"1\":{\"417\":1}}],[\"离开\",{\"1\":{\"429\":1}}],[\"硬件地址\",{\"0\":{\"981\":1},\"1\":{\"981\":1}}],[\"硬件地址又称为物理地址或mac地址\",{\"1\":{\"979\":1}}],[\"硬件资源等的瓶颈\",{\"1\":{\"585\":1}}],[\"硬盘上的存储空间是根据实际字符长度来分配存储空间\",{\"1\":{\"478\":1}}],[\"硬盘空间\",{\"1\":{\"440\":1}}],[\"硬盘等\",{\"1\":{\"134\":1}}],[\"硬连接的作用是允许一个文件拥有多个有效路径名\",{\"1\":{\"427\":1}}],[\"硬连接指通过索引节点来进行连接\",{\"1\":{\"427\":1}}],[\"硬连接\",{\"1\":{\"427\":1}}],[\"号是过期的\",{\"1\":{\"876\":1}}],[\"号比其他人小\",{\"1\":{\"876\":1}}],[\"号\",{\"1\":{\"426\":1,\"876\":2}}],[\"备份常用\",{\"1\":{\"423\":1}}],[\"帮助不是很大\",{\"1\":{\"585\":1}}],[\"帮助你直接将所需要的目录\",{\"1\":{\"422\":1}}],[\"帮助编译器和\",{\"1\":{\"338\":1}}],[\"亦即是\",{\"1\":{\"420\":2}}],[\"~arr\",{\"1\":{\"931\":5}}],[\"~\",{\"1\":{\"419\":1,\"420\":1,\"443\":1,\"943\":1,\"1177\":4,\"1178\":1}}],[\"~127\",{\"1\":{\"368\":1}}],[\"连续\",{\"1\":{\"1011\":1}}],[\"连续分片可能存在数据热点\",{\"1\":{\"587\":1}}],[\"连续分片可快速定位分片进行快速查询\",{\"1\":{\"587\":1}}],[\"连进来导致\",{\"1\":{\"562\":1}}],[\"连\",{\"1\":{\"523\":1}}],[\"连带从表相关行的外键值一起修改\",{\"1\":{\"463\":1}}],[\"连带从表的相关行一起删除\",{\"1\":{\"463\":1}}],[\"连同文件的属性一起复制过去\",{\"1\":{\"423\":1}}],[\"连同隐藏文件\",{\"1\":{\"419\":1}}],[\"连接缓冲区\",{\"1\":{\"1177\":1}}],[\"连接到\",{\"1\":{\"1203\":1}}],[\"连接到互联网的计算机的协议软件需要配置ip地址\",{\"1\":{\"1049\":1}}],[\"连接到服务器的\",{\"1\":{\"1044\":1}}],[\"连接到新的\",{\"1\":{\"676\":1}}],[\"连接才能继续传输数据\",{\"1\":{\"1042\":1}}],[\"连接迁移\",{\"1\":{\"1042\":1}}],[\"连接的远程仓库地址位于\",{\"1\":{\"1202\":1}}],[\"连接的数据包影响到下一次的\",{\"1\":{\"1027\":1}}],[\"连接的每一方都有固定大小的缓冲空间\",{\"1\":{\"1009\":1}}],[\"连接的sql\",{\"1\":{\"485\":1}}],[\"连接只能是一对一的\",{\"1\":{\"1001\":1}}],[\"连接双方会相互通告\",{\"1\":{\"982\":1}}],[\"连接结束\",{\"1\":{\"959\":1,\"1029\":1}}],[\"连接建立起来后\",{\"1\":{\"959\":1,\"1029\":1}}],[\"连接建立后\",{\"1\":{\"490\":1}}],[\"连接断开不一定会话失效\",{\"1\":{\"818\":1}}],[\"连接点\",{\"1\":{\"721\":1}}],[\"连接集群中任何一个可用节点即可\",{\"1\":{\"659\":1}}],[\"连接应答处理器\",{\"1\":{\"611\":1}}],[\"连接数据库步骤\",{\"0\":{\"744\":1}}],[\"连接数\",{\"1\":{\"585\":1}}],[\"连接器会到权限表中查询该用户的所有权限\",{\"1\":{\"490\":1}}],[\"连接器主要和身份认证和权限相关的功能相关\",{\"1\":{\"490\":1}}],[\"连接器\",{\"1\":{\"489\":1,\"490\":1}}],[\"连接查询\",{\"0\":{\"485\":1}}],[\"连接打开\",{\"1\":{\"377\":1}}],[\"连接\",{\"0\":{\"169\":1,\"214\":1,\"1123\":1},\"1\":{\"435\":1,\"489\":1,\"655\":1,\"959\":1,\"1027\":2,\"1029\":1,\"1124\":1}}],[\"连接和初始化过程都是在程序运行期间完成的\",{\"1\":{\"165\":1}}],[\"连接单词\",{\"1\":{\"26\":1}}],[\"底下时\",{\"1\":{\"418\":1}}],[\"底层的是tls记录协议\",{\"1\":{\"1062\":1}}],[\"底层结构与\",{\"1\":{\"410\":1}}],[\"底层采用一个\",{\"1\":{\"396\":1}}],[\"底层就是一个数组结构\",{\"1\":{\"396\":1}}],[\"底层原理\",{\"0\":{\"396\":1}}],[\"底层原理属于\",{\"1\":{\"82\":1}}],[\"底层数据结构必须满足键值存储\",{\"1\":{\"620\":1}}],[\"底层数据结构是红黑树\",{\"1\":{\"412\":1}}],[\"底层数据结构是数组+链表\",{\"1\":{\"410\":1}}],[\"底层数据结构\",{\"0\":{\"621\":1},\"1\":{\"395\":1}}],[\"底层调用的是\",{\"1\":{\"393\":1}}],[\"底层调用操作系统提供给用户的读写\",{\"1\":{\"379\":1}}],[\"底层是基于双向链表实现\",{\"1\":{\"392\":1}}],[\"底层是基于数组实现的\",{\"1\":{\"392\":1}}],[\"底层实现是双向链表\",{\"1\":{\"391\":1}}],[\"输入格式\",{\"1\":{\"956\":1}}],[\"输入实例\",{\"1\":{\"955\":1}}],[\"输入描述\",{\"1\":{\"955\":1}}],[\"输入是一串数字\",{\"1\":{\"955\":1}}],[\"输入例子\",{\"1\":{\"953\":1}}],[\"输入\",{\"1\":{\"951\":1,\"952\":1,\"956\":1}}],[\"输入关键字\",{\"1\":{\"417\":1}}],[\"输出例子\",{\"1\":{\"953\":1}}],[\"输出答案\",{\"1\":{\"951\":1,\"953\":1}}],[\"输出\",{\"1\":{\"951\":1,\"952\":1,\"955\":1,\"956\":1}}],[\"输出当前文件夹下的文件信息\",{\"1\":{\"443\":1}}],[\"输出行号\",{\"1\":{\"428\":1}}],[\"输出所有参数的名称和默认值\",{\"1\":{\"316\":1}}],[\"输出虚拟机进程启动时传递给\",{\"1\":{\"312\":1}}],[\"输出全类名\",{\"1\":{\"312\":1}}],[\"输出结果\",{\"1\":{\"277\":1}}],[\"输出gc发生的时间戳\",{\"1\":{\"325\":1}}],[\"输出gc的时间戳\",{\"1\":{\"270\":2}}],[\"输出gc详细日志\",{\"1\":{\"270\":1}}],[\"输出gc日志信息\",{\"1\":{\"325\":1}}],[\"输出gc日志\",{\"1\":{\"270\":1}}],[\"输出完成\",{\"1\":{\"148\":1}}],[\"输出请求而变成等待外部设备传输信息的状态\",{\"1\":{\"148\":1}}],[\"组织项目的注意事项\",{\"0\":{\"1163\":1}}],[\"组装请求和二进制帧的一层就叫做二进制分帧层\",{\"1\":{\"1042\":1}}],[\"组合关系用带实心菱形的实线来表示\",{\"1\":{\"1099\":1}}],[\"组合关系也是关联关系的一种\",{\"1\":{\"1099\":1}}],[\"组合关系\",{\"0\":{\"1099\":1},\"1\":{\"1095\":1}}],[\"组合结构图\",{\"1\":{\"1094\":1}}],[\"组合成数组和对象\",{\"1\":{\"1035\":1}}],[\"组合了\",{\"1\":{\"777\":1}}],[\"组合键\",{\"0\":{\"417\":1}}],[\"组成\",{\"1\":{\"543\":1,\"645\":1}}],[\"组件图\",{\"1\":{\"1271\":1}}],[\"组件\",{\"0\":{\"116\":1},\"1\":{\"1134\":1}}],[\"放数据的速度\",{\"1\":{\"1006\":1}}],[\"放入到一个独立的字典中\",{\"1\":{\"632\":1}}],[\"放在哪儿\",{\"0\":{\"860\":1}}],[\"放在独立的服务器上\",{\"1\":{\"827\":1}}],[\"放在\",{\"1\":{\"603\":1,\"1161\":1}}],[\"放锁动作不会省略\",{\"1\":{\"501\":1}}],[\"放不下\",{\"1\":{\"455\":1}}],[\"放置系统执行过程中经常变化的文件\",{\"1\":{\"416\":1}}],[\"放置\",{\"1\":{\"416\":1}}],[\"放到域服务里面做持久化\",{\"1\":{\"1242\":1}}],[\"放到合适的位置\",{\"1\":{\"937\":1}}],[\"放到新的\",{\"1\":{\"406\":1}}],[\"放到物理内存映射文件的数据就不归应用程序控制了\",{\"1\":{\"378\":1}}],[\"意在告诉这台服务器\",{\"1\":{\"1049\":1}}],[\"意在告诉a\",{\"1\":{\"1019\":1}}],[\"意义\",{\"1\":{\"943\":1,\"1040\":2}}],[\"意外\",{\"1\":{\"649\":1}}],[\"意向排他锁\",{\"1\":{\"514\":1}}],[\"意向共享锁\",{\"1\":{\"514\":1}}],[\"意向锁的作用就是\",{\"1\":{\"514\":1}}],[\"意向锁的作用\",{\"1\":{\"514\":1}}],[\"意向锁是由存储引擎自己维护的\",{\"1\":{\"514\":1}}],[\"意向锁就是其中一种不与行级锁冲突的表级锁\",{\"1\":{\"514\":1}}],[\"意向锁\",{\"0\":{\"514\":1}}],[\"意思是先从\",{\"1\":{\"416\":1}}],[\"意味着索引的二叉树级别少\",{\"1\":{\"532\":1}}],[\"意味着不必每次都去计算新的哈希码\",{\"1\":{\"369\":1}}],[\"意味着需要获取共享变量最新结果\",{\"1\":{\"105\":1}}],[\"意味着全部是救急线程\",{\"1\":{\"56\":1}}],[\"根域名服务器通常是把自己知道的顶级域名服务器的\",{\"1\":{\"1031\":1}}],[\"根域名服务器采用了任播技术\",{\"1\":{\"1030\":1}}],[\"根节点必为黑色\",{\"1\":{\"921\":1}}],[\"根节点入栈\",{\"1\":{\"908\":2}}],[\"根\",{\"1\":{\"908\":2}}],[\"根目录\",{\"1\":{\"416\":2}}],[\"根据域名查出ip地址\",{\"1\":{\"1030\":1}}],[\"根据路径参数映射到特定的请求处理器进行处理\",{\"1\":{\"959\":1,\"1029\":1}}],[\"根据数组构造二叉树\",{\"1\":{\"956\":1}}],[\"根据数据包和\",{\"1\":{\"1042\":1}}],[\"根据数据库现状创建的\",{\"1\":{\"651\":1}}],[\"根据数据范围切分\",{\"1\":{\"587\":1}}],[\"根据实际内存大小和文件大小判断\",{\"1\":{\"904\":1}}],[\"根据实际的基础环境配置\",{\"1\":{\"675\":1}}],[\"根据哈希函数的性质\",{\"1\":{\"897\":1}}],[\"根据得到的哈希值\",{\"1\":{\"882\":1}}],[\"根据权重\",{\"1\":{\"869\":1}}],[\"根据权重分配\",{\"1\":{\"832\":1}}],[\"根据ip地址进行hash计算\",{\"1\":{\"869\":1}}],[\"根据服务器当前的请求处理情况\",{\"1\":{\"869\":1}}],[\"根据机器的性能来增加或缩小线程池的大小\",{\"1\":{\"843\":1}}],[\"根据节点提交的反馈进行下一步操作\",{\"1\":{\"816\":1}}],[\"根据业务生成一个全局唯一\",{\"1\":{\"807\":1}}],[\"根据业务背景选择垃圾回收器\",{\"1\":{\"309\":1}}],[\"根据客户端传递来的服务信息和参数\",{\"1\":{\"804\":1}}],[\"根据一定的策略\",{\"1\":{\"801\":1}}],[\"根据用户请求找到具体哪个类\",{\"1\":{\"756\":1}}],[\"根据用户所期望的停顿时间来制定回收计划\",{\"1\":{\"264\":1}}],[\"根据用户所选用的垃圾收集器以及当前回收的内存区域不同\",{\"1\":{\"234\":1}}],[\"根据返回的\",{\"1\":{\"755\":1}}],[\"根据你的配置\",{\"1\":{\"755\":1}}],[\"根据获得的\",{\"1\":{\"755\":1}}],[\"根据获取不到锁的线程如何处理划分可以分为轻量级锁和重量级锁\",{\"1\":{\"81\":1}}],[\"根据属性名称进行注入\",{\"1\":{\"743\":1}}],[\"根据属性类型进行自动装配\",{\"1\":{\"743\":1}}],[\"根据该槽信息定位到对应的实例\",{\"1\":{\"680\":1}}],[\"根据键值对的\",{\"1\":{\"680\":1}}],[\"根据投票机制选取新的\",{\"1\":{\"677\":1}}],[\"根据父进程内存生成临时快照文件\",{\"1\":{\"647\":1}}],[\"根据表内数据内在的逻辑关系\",{\"1\":{\"585\":1}}],[\"根据表统计信息以及索引选用情况\",{\"1\":{\"556\":1}}],[\"根据刷新机制\",{\"1\":{\"568\":1}}],[\"根据主键值再到聚簇索引中得到完整的行记录\",{\"1\":{\"549\":1}}],[\"根据索引找到叶子中的主键值\",{\"1\":{\"549\":1}}],[\"根据同样的原理我们可以算出一个高度为\",{\"1\":{\"539\":1}}],[\"根据执行计划调用存储引擎的\",{\"1\":{\"489\":1}}],[\"根据group\",{\"1\":{\"487\":1}}],[\"根据关键词\",{\"1\":{\"449\":1}}],[\"根据不同的情况来进行插入\",{\"1\":{\"397\":1}}],[\"根据全限定类名获得某个类的\",{\"1\":{\"348\":1}}],[\"根据经验\",{\"1\":{\"265\":1}}],[\"根据虚拟机当前运行状态的不同\",{\"1\":{\"222\":1}}],[\"根据传入的类的全限定名返回一个class对象\",{\"1\":{\"183\":1}}],[\"根据进程请求访问磁盘的先后顺序进行调度\",{\"1\":{\"163\":1}}],[\"根据\",{\"1\":{\"131\":1,\"412\":1,\"611\":1}}],[\"根据抢锁规则的设计划分可以分为公平锁和非公平锁\",{\"1\":{\"81\":1}}],[\"根据默认是否有其它线程修改数据划分可以分为乐观锁和悲观锁\",{\"1\":{\"81\":1}}],[\"请注意\",{\"1\":{\"1018\":1}}],[\"请将其转换成单链表格式之后\",{\"1\":{\"955\":1}}],[\"请给出思想\",{\"0\":{\"899\":1}}],[\"请你统计最热门的10个查询串\",{\"1\":{\"893\":1}}],[\"请问怎么设计和实现\",{\"1\":{\"890\":1}}],[\"请不要使用\",{\"1\":{\"411\":1}}],[\"请求b则只需要发送差异数据\",{\"1\":{\"1042\":1}}],[\"请求报文的\",{\"1\":{\"1041\":1}}],[\"请求错误\",{\"1\":{\"1040\":1}}],[\"请求成功\",{\"1\":{\"1040\":1}}],[\"请求正常处理完毕\",{\"1\":{\"1040\":1}}],[\"请求读取由url所标志的信息的首部\",{\"1\":{\"1040\":1}}],[\"请求读取有url所标志的信息\",{\"1\":{\"1040\":1}}],[\"请求一些选项的信息\",{\"1\":{\"1040\":1}}],[\"请求体\",{\"1\":{\"1038\":2}}],[\"请求头\",{\"1\":{\"1038\":1}}],[\"请求头部\",{\"1\":{\"1038\":2}}],[\"请求行\",{\"1\":{\"1038\":3}}],[\"请求后\",{\"1\":{\"814\":1}}],[\"请求依次经过监控\",{\"1\":{\"804\":1}}],[\"请求就到了服务端\",{\"1\":{\"804\":1}}],[\"请求被随机分配到各个服务器\",{\"1\":{\"869\":1}}],[\"请求被\",{\"1\":{\"755\":1}}],[\"请求都会产生一个新的\",{\"1\":{\"734\":1}}],[\"请求和主机全量同步\",{\"1\":{\"656\":1}}],[\"请求和实际的\",{\"1\":{\"380\":1}}],[\"请求全部走数据库\",{\"1\":{\"642\":1}}],[\"请求的数据太多\",{\"1\":{\"584\":1}}],[\"请求给服务器\",{\"1\":{\"489\":1}}],[\"请求是否会被阻塞\",{\"1\":{\"380\":1}}],[\"请求时\",{\"1\":{\"379\":1}}],[\"请求过多时\",{\"1\":{\"379\":1}}],[\"请求\",{\"1\":{\"379\":3,\"647\":1,\"661\":1,\"877\":1,\"959\":2,\"1029\":2}}],[\"请求访问的磁道可能会很分散\",{\"1\":{\"163\":1}}],[\"请求分页存储管理与基本分页存储管理的主要区别\",{\"1\":{\"159\":1}}],[\"请求获取\",{\"1\":{\"38\":1}}],[\"马上能读到\",{\"1\":{\"411\":1}}],[\"左移<<\",{\"0\":{\"944\":1}}],[\"左移\",{\"1\":{\"943\":2}}],[\"左孩子的位置\",{\"1\":{\"937\":1}}],[\"左边的索引\",{\"1\":{\"934\":1}}],[\"左边才停止\",{\"1\":{\"912\":1}}],[\"左小右大\",{\"1\":{\"919\":1}}],[\"左侧边界右移\",{\"1\":{\"913\":1}}],[\"左连接\",{\"1\":{\"485\":1}}],[\"左右的机器\",{\"1\":{\"895\":1}}],[\"左右\",{\"1\":{\"411\":1,\"539\":1}}],[\"左闭右闭二选一\",{\"1\":{\"5\":1}}],[\"左闭右开\",{\"1\":{\"5\":1}}],[\"象添加到新容器里\",{\"1\":{\"411\":1}}],[\"象的内存\",{\"1\":{\"411\":1}}],[\"旧的\",{\"1\":{\"1012\":1}}],[\"旧的对象和新写入的对象\",{\"1\":{\"411\":1}}],[\"旧值在从表里存在便阻止修改\",{\"1\":{\"463\":1}}],[\"旧数组容量\",{\"1\":{\"406\":1}}],[\"脏页\",{\"1\":{\"592\":1}}],[\"脏页与干净页\",{\"0\":{\"592\":1}}],[\"脏读\",{\"1\":{\"411\":1,\"521\":1,\"522\":1}}],[\"脏⻚\",{\"1\":{\"247\":1}}],[\"免除了指令重排序\",{\"1\":{\"409\":1}}],[\"粒度比较大\",{\"1\":{\"409\":1}}],[\"亿个关键字\",{\"1\":{\"919\":1}}],[\"亿以上\",{\"1\":{\"882\":1}}],[\"亿长度的数组\",{\"1\":{\"405\":1}}],[\"亿的映射空间\",{\"1\":{\"405\":1}}],[\"^4\",{\"1\":{\"1139\":1}}],[\"^3\",{\"1\":{\"1139\":1}}],[\"^0\",{\"1\":{\"1139\":1,\"1140\":1}}],[\"^\",{\"1\":{\"405\":1,\"443\":1,\"943\":1,\"947\":11,\"1190\":1}}],[\"头和嘴的关系\",{\"1\":{\"1099\":1}}],[\"头部压缩\",{\"1\":{\"1042\":1}}],[\"头插\",{\"1\":{\"623\":1}}],[\"头插法在并发下\",{\"1\":{\"403\":1}}],[\"头节点是成功获取到同步状态的节点\",{\"1\":{\"122\":1}}],[\"扩缩容的条件⭐\",{\"1\":{\"623\":1}}],[\"扩容\",{\"1\":{\"625\":1}}],[\"扩容的新数组是\",{\"1\":{\"623\":1}}],[\"扩容大小为第一个大于等于\",{\"1\":{\"623\":1}}],[\"扩容等问题\",{\"1\":{\"589\":1}}],[\"扩容时可能造成元素间形成一个循环链表\",{\"1\":{\"409\":1}}],[\"扩容时会调用\",{\"1\":{\"402\":1}}],[\"扩容成功\",{\"1\":{\"406\":1}}],[\"扩容机制\",{\"0\":{\"406\":1}}],[\"扩容可能造成循环链表\",{\"1\":{\"403\":1}}],[\"扩展困难\",{\"1\":{\"1072\":1}}],[\"扩展\",{\"1\":{\"883\":1,\"884\":1,\"885\":1,\"888\":1,\"890\":1,\"1134\":1}}],[\"扩展性好\",{\"1\":{\"1086\":1}}],[\"扩展性差\",{\"1\":{\"840\":1}}],[\"扩展性强\",{\"1\":{\"349\":1}}],[\"扩展了\",{\"1\":{\"712\":1}}],[\"扩展等\",{\"1\":{\"585\":1}}],[\"扩展机制被移除\",{\"1\":{\"181\":1}}],[\"扩展加载源\",{\"1\":{\"180\":1}}],[\"扩展类加载器重命名为平台加载器\",{\"1\":{\"181\":1}}],[\"扩展类加载器\",{\"0\":{\"177\":1},\"1\":{\"175\":1}}],[\"红⿊树查询和插⼊时间复杂度\",{\"1\":{\"401\":1}}],[\"红黑树中的红节点是和黑色父节点绑定的\",{\"1\":{\"921\":1}}],[\"红黑树等来进行统计次数\",{\"1\":{\"898\":1}}],[\"红黑树是个高效的数据结构\",{\"1\":{\"612\":1}}],[\"红黑树每个节点出度最多为2\",{\"1\":{\"541\":1}}],[\"红黑树就按照树的查找方式返回值\",{\"1\":{\"398\":1}}],[\"红黑树\",{\"0\":{\"921\":1},\"1\":{\"395\":1,\"398\":1,\"408\":1,\"410\":1,\"630\":1}}],[\"红黑树的根节点\",{\"1\":{\"130\":1,\"131\":1}}],[\"插件后\",{\"1\":{\"1273\":1}}],[\"插件的配置如下所示\",{\"1\":{\"1270\":1}}],[\"插件用于在\",{\"1\":{\"1269\":1}}],[\"插件下载地址\",{\"1\":{\"1149\":1,\"1269\":1}}],[\"插件安装失败\",{\"1\":{\"1136\":1}}],[\"插件来实现语法扩展\",{\"1\":{\"1134\":1}}],[\"插件\",{\"0\":{\"1209\":1},\"1\":{\"882\":1,\"1148\":1,\"1150\":1}}],[\"插件运行\",{\"1\":{\"781\":1}}],[\"插入排序\",{\"0\":{\"932\":1}}],[\"插入失败\",{\"1\":{\"807\":1}}],[\"插入速度非常快速\",{\"1\":{\"630\":1}}],[\"插入新的哈希表\",{\"1\":{\"623\":1}}],[\"插入新的记录时\",{\"1\":{\"466\":1}}],[\"插入语句\",{\"0\":{\"599\":1}}],[\"插入这个值\",{\"1\":{\"574\":2}}],[\"插入删除操作会破坏平衡树的平衡性\",{\"1\":{\"538\":1}}],[\"插入了一些数据时\",{\"1\":{\"521\":1}}],[\"插入\",{\"1\":{\"501\":1}}],[\"插入使两次读不一样\",{\"1\":{\"501\":1}}],[\"插入缓冲\",{\"1\":{\"496\":1}}],[\"插入到虚拟表vt8中\",{\"1\":{\"487\":1}}],[\"插入时使用头插法\",{\"1\":{\"398\":1}}],[\"插⼊时间复杂度\",{\"1\":{\"401\":1}}],[\"念这个\",{\"1\":{\"399\":1}}],[\"≤\",{\"1\":{\"398\":1}}],[\"键必须唯一和可排序这三个需求\",{\"1\":{\"620\":1}}],[\"键是根据\",{\"1\":{\"408\":1}}],[\"键值越短越好\",{\"1\":{\"637\":1}}],[\"键值始终唯一\",{\"1\":{\"408\":1}}],[\"键值类型自带的哈希函数\",{\"1\":{\"405\":1}}],[\"键值对链表\",{\"1\":{\"623\":1}}],[\"键值对结构组织\",{\"0\":{\"614\":1}}],[\"键值对\",{\"1\":{\"396\":2}}],[\"键入p\",{\"1\":{\"201\":2}}],[\"队头阻塞问题\",{\"1\":{\"1042\":2}}],[\"队首\",{\"1\":{\"394\":1}}],[\"队尾\",{\"1\":{\"394\":1}}],[\"队列具有先进先出\",{\"1\":{\"941\":1}}],[\"队列\",{\"0\":{\"939\":1,\"941\":1},\"1\":{\"942\":1}}],[\"队列来完成获取资源线程的排队工作\",{\"1\":{\"110\":1}}],[\"队列是一个虚拟的双向队列\",{\"1\":{\"110\":1}}],[\"队列锁实现的\",{\"1\":{\"110\":1}}],[\"队列的特性和栈是相反的\",{\"1\":{\"941\":1}}],[\"队列的大小应该通过前期计算线程池任务的条数\",{\"1\":{\"64\":1}}],[\"队列的默认和最大长度为\",{\"1\":{\"62\":1}}],[\"队列竞争锁\",{\"1\":{\"37\":1}}],[\"小一点\",{\"1\":{\"1019\":1}}],[\"小概率会误判\",{\"1\":{\"882\":1}}],[\"小事务发生锁冲突的概率也更小\",{\"1\":{\"516\":1}}],[\"小时开机\",{\"1\":{\"452\":1}}],[\"小顶堆\",{\"1\":{\"394\":1}}],[\"小端模式\",{\"1\":{\"347\":1}}],[\"容错性\",{\"1\":{\"672\":1}}],[\"容量跟随服务器限制明显\",{\"1\":{\"609\":1}}],[\"容量规划\",{\"1\":{\"589\":1}}],[\"容易导致网站降权\",{\"1\":{\"1040\":1}}],[\"容易发生雪崩式的连锁反应\",{\"1\":{\"880\":1}}],[\"容易因为节点分部不均匀而造成数据倾斜问题\",{\"1\":{\"681\":1}}],[\"容易面临跨分片查询的复杂问题\",{\"1\":{\"587\":1}}],[\"容易产生prem区的oom\",{\"1\":{\"206\":1}}],[\"容器时\",{\"1\":{\"1090\":1}}],[\"容器将请求封装为servlet中的httpservletrequest对象\",{\"1\":{\"959\":1,\"1029\":1}}],[\"容器中\",{\"1\":{\"771\":1}}],[\"容器中的\",{\"1\":{\"755\":1}}],[\"容器中bean实例化阶段\",{\"1\":{\"737\":1}}],[\"容器创建\",{\"1\":{\"729\":1}}],[\"容器去创建一个对象b注入到对象\",{\"1\":{\"718\":1}}],[\"容器后\",{\"1\":{\"718\":1}}],[\"容器启动时\",{\"1\":{\"712\":1}}],[\"容器只能保证数据的最终一致性\",{\"1\":{\"411\":1}}],[\"容器\",{\"1\":{\"393\":1,\"411\":1,\"717\":1,\"718\":1,\"736\":1,\"1163\":1}}],[\"慢开始\",{\"1\":{\"1019\":2}}],[\"慢很多\",{\"1\":{\"652\":1}}],[\"慢查询\",{\"0\":{\"559\":1}}],[\"慢查询日志\",{\"1\":{\"557\":1,\"566\":1}}],[\"慢\",{\"0\":{\"701\":1},\"1\":{\"393\":1,\"483\":1,\"652\":1}}],[\"快恢复\",{\"1\":{\"1019\":1}}],[\"快重传\",{\"1\":{\"1019\":1}}],[\"快重传和快恢复\",{\"1\":{\"1019\":1}}],[\"快排的最坏情况为\",{\"1\":{\"935\":1}}],[\"快很多\",{\"1\":{\"720\":1}}],[\"快照发送完毕后\",{\"1\":{\"655\":1}}],[\"快照读不复存在都是当前读\",{\"1\":{\"501\":1}}],[\"快照读的幻读问题由\",{\"1\":{\"505\":1}}],[\"快照读的实现是基于多版本并发控制\",{\"1\":{\"499\":1}}],[\"快照读的前提是隔离级别不是串行级别\",{\"1\":{\"499\":1}}],[\"快照读\",{\"1\":{\"499\":2,\"523\":2}}],[\"快速幂\",{\"0\":{\"949\":1}}],[\"快速排序\",{\"0\":{\"935\":1},\"1\":{\"892\":1}}],[\"快速查找\",{\"1\":{\"884\":1}}],[\"快速查找系统数据库中\",{\"1\":{\"434\":1}}],[\"快速\",{\"1\":{\"881\":1,\"895\":1,\"897\":1,\"1042\":1}}],[\"快速失败\",{\"1\":{\"813\":1}}],[\"快速创建独立运行的spring项目与主流框架集成\",{\"1\":{\"768\":1}}],[\"快速创建线程池\",{\"1\":{\"56\":1}}],[\"快速恢复缓存数据\",{\"1\":{\"642\":1}}],[\"快速的查找特性\",{\"1\":{\"603\":1}}],[\"快\",{\"1\":{\"393\":1,\"408\":1,\"483\":1}}],[\"迭代器直接通过\",{\"1\":{\"391\":1}}],[\"迭代器遍历比\",{\"1\":{\"391\":1}}],[\"迭代器遍历快\",{\"1\":{\"391\":1}}],[\"迭代器\",{\"1\":{\"391\":1,\"622\":1}}],[\"遍历文件b\",{\"1\":{\"896\":1}}],[\"遍历文件a\",{\"1\":{\"896\":1}}],[\"遍历索引树\",{\"1\":{\"556\":1}}],[\"遍历排序结果\",{\"1\":{\"484\":1}}],[\"遍历\",{\"0\":{\"907\":1},\"1\":{\"391\":3}}],[\"降级\",{\"1\":{\"804\":1}}],[\"降序\",{\"1\":{\"390\":1}}],[\"降低类的复杂度\",{\"1\":{\"1064\":1}}],[\"降低对象之间的耦合\",{\"1\":{\"1064\":1}}],[\"降低开销\",{\"1\":{\"1042\":1}}],[\"降低网络开销\",{\"1\":{\"805\":1}}],[\"降低耦合度\",{\"1\":{\"718\":1}}],[\"降低模块间的耦合度\",{\"1\":{\"715\":1}}],[\"降低运维成本\",{\"1\":{\"660\":1,\"678\":1}}],[\"降低的内存的可用性\",{\"1\":{\"656\":1}}],[\"降低\",{\"1\":{\"637\":1,\"1060\":1}}],[\"降低查询速度\",{\"1\":{\"584\":1}}],[\"降低效率\",{\"1\":{\"532\":1}}],[\"降低了压力\",{\"1\":{\"684\":1}}],[\"降低了系统的可用性\",{\"1\":{\"656\":1}}],[\"降低了开销\",{\"1\":{\"499\":1}}],[\"降低了锁粒度\",{\"1\":{\"409\":1}}],[\"降低程序耦合度\",{\"1\":{\"355\":1}}],[\"降低停顿时间是\",{\"1\":{\"261\":1}}],[\"降低线程创建和销毁造成的消耗\",{\"1\":{\"53\":1}}],[\"降低资源消耗\",{\"1\":{\"53\":1}}],[\"建一个用户\",{\"0\":{\"1169\":1}}],[\"建造者\",{\"1\":{\"1086\":1}}],[\"建造者模式应用实例\",{\"1\":{\"1086\":1}}],[\"建造者模式可以用于描述\",{\"1\":{\"1086\":1}}],[\"建造者模式注重零部件的组装过程\",{\"1\":{\"1086\":1}}],[\"建造者模式\",{\"0\":{\"1086\":1}}],[\"建链\",{\"1\":{\"1042\":1}}],[\"建于\",{\"1\":{\"1004\":1}}],[\"建立最终领域模型\",{\"1\":{\"1217\":1}}],[\"建立电脑和\",{\"0\":{\"1123\":1}}],[\"建立单一接口\",{\"1\":{\"1064\":1}}],[\"建立起连接的就会放在全连接队列中\",{\"1\":{\"1025\":1}}],[\"建立连接时间长\",{\"1\":{\"1042\":1}}],[\"建立连接可以在一个连接中发送多个\",{\"1\":{\"1003\":1}}],[\"建立连接阶段\",{\"1\":{\"662\":1}}],[\"建立及管理会话\",{\"1\":{\"961\":1}}],[\"建立大顶堆的过程\",{\"1\":{\"937\":1}}],[\"建立大顶堆是\",{\"1\":{\"937\":1}}],[\"建立一个\",{\"1\":{\"817\":1}}],[\"建立一个双向链表\",{\"1\":{\"414\":1}}],[\"建立好dao之后再建立service层\",{\"1\":{\"763\":1}}],[\"建立代理对象和真实对象\",{\"1\":{\"725\":1}}],[\"建立合适的索引\",{\"1\":{\"584\":1}}],[\"建立到联合索引里去\",{\"1\":{\"550\":1}}],[\"建立了连接\",{\"1\":{\"1023\":1}}],[\"建立了联合索引\",{\"1\":{\"535\":1}}],[\"建立了前后遍历关系\",{\"1\":{\"391\":1}}],[\"建立索引的列不为\",{\"1\":{\"535\":1}}],[\"建立索引的几大原则⭐\",{\"0\":{\"533\":1}}],[\"建立\",{\"1\":{\"533\":1,\"662\":1}}],[\"建立主键或者唯一索引优化\",{\"1\":{\"486\":1}}],[\"建立追踪关系\",{\"1\":{\"451\":1}}],[\"建立副本\",{\"1\":{\"48\":1}}],[\"建议采用pull的方式\",{\"1\":{\"843\":1}}],[\"建议总是使用\",{\"1\":{\"526\":1}}],[\"建议使用\",{\"1\":{\"390\":1}}],[\"建议实现\",{\"1\":{\"390\":1}}],[\"受检异常\",{\"1\":{\"385\":1}}],[\"举个最简单的例子\",{\"1\":{\"807\":1}}],[\"举个例子\",{\"1\":{\"101\":1,\"172\":1,\"514\":1,\"718\":1,\"731\":1,\"1068\":1}}],[\"举一个形象的例子\",{\"1\":{\"442\":1}}],[\"举例\",{\"1\":{\"384\":1,\"385\":1}}],[\"捷足先登了\",{\"1\":{\"383\":1}}],[\"情况发生\",{\"1\":{\"665\":1}}],[\"情况\",{\"1\":{\"383\":3,\"688\":1}}],[\"触发监听器回调函数时\",{\"1\":{\"1157\":1}}],[\"触发重写时\",{\"1\":{\"708\":1}}],[\"触发机制\",{\"1\":{\"647\":1}}],[\"触发器\",{\"1\":{\"488\":1}}],[\"触发模式\",{\"1\":{\"381\":1}}],[\"触发gc\",{\"1\":{\"262\":1}}],[\"万维网是一个分布式的超媒体系统\",{\"1\":{\"1034\":1}}],[\"万维网是一个大规模的\",{\"1\":{\"1034\":1}}],[\"万维网www\",{\"0\":{\"1034\":1}}],[\"万一\",{\"1\":{\"642\":1}}],[\"万左右的连接\",{\"1\":{\"381\":1}}],[\"万能\",{\"1\":{\"295\":1}}],[\"虽说连接数有上限\",{\"1\":{\"381\":1}}],[\"虽然在\",{\"1\":{\"1067\":1}}],[\"虽然性能不错\",{\"1\":{\"1042\":1}}],[\"虽然有了持久连接和管道机制\",{\"1\":{\"1042\":1}}],[\"虽然听起来简单\",{\"1\":{\"1012\":1}}],[\"虽然应用层和\",{\"1\":{\"1006\":1}}],[\"虽然总数是1千万\",{\"1\":{\"890\":1,\"893\":1}}],[\"虽然没有一种单一网络能够适应所有用户的需求\",{\"1\":{\"965\":1}}],[\"虽然没有自己动手写过\",{\"1\":{\"804\":1}}],[\"虽然没能像\",{\"1\":{\"96\":1}}],[\"虽然运行到特定得代码会报错\",{\"1\":{\"718\":1}}],[\"虽然减少了对系统西能的影响\",{\"1\":{\"650\":1}}],[\"虽然名字叫做change\",{\"1\":{\"574\":1}}],[\"虽然volatile变量在各个线程的工作内存中是不存在一致性问题的\",{\"1\":{\"296\":1}}],[\"虽然g1和cms都使用卡表来处理跨代指针\",{\"1\":{\"262\":1}}],[\"虽然\",{\"1\":{\"203\":1,\"261\":1,\"336\":1,\"392\":1,\"660\":1}}],[\"虽然它是一个局部变量\",{\"1\":{\"202\":1}}],[\"虽然会让提前编译面临困难以及加载类增加一些开销\",{\"1\":{\"165\":1}}],[\"虽然二者都能解决问题\",{\"1\":{\"40\":1}}],[\"事物是抽象化的最终结果\",{\"1\":{\"1093\":1}}],[\"事物\",{\"0\":{\"1093\":1}}],[\"事先准备多个散列函数\",{\"1\":{\"924\":1}}],[\"事先clone\",{\"1\":{\"212\":1}}],[\"事实上它并不负责\",{\"1\":{\"961\":1}}],[\"事实上\",{\"1\":{\"713\":1}}],[\"事实上很多时候\",{\"1\":{\"561\":1}}],[\"事发后\",{\"1\":{\"642\":1}}],[\"事发中\",{\"1\":{\"642\":1}}],[\"事发前\",{\"1\":{\"642\":1}}],[\"事务是在\",{\"1\":{\"1242\":1}}],[\"事务是最小的执行单位\",{\"1\":{\"519\":1}}],[\"事务控制\",{\"1\":{\"754\":1}}],[\"事务传播行为是为了解决业务层方法之间互相调用的事务问题\",{\"1\":{\"740\":1}}],[\"事务处理\",{\"1\":{\"719\":1}}],[\"事务管理\",{\"1\":{\"717\":1}}],[\"事务操作支持有限\",{\"1\":{\"678\":1}}],[\"事务中出现运行错误\",{\"1\":{\"665\":1}}],[\"事务中任意命令执行失败\",{\"1\":{\"665\":1}}],[\"事务开始\",{\"1\":{\"665\":1}}],[\"事务功能是通过multi\",{\"1\":{\"665\":1}}],[\"事务提供了一种将多个命令请求打包的功能\",{\"1\":{\"665\":1}}],[\"事务提交的时候\",{\"1\":{\"571\":2}}],[\"事务就是防止\",{\"1\":{\"665\":1}}],[\"事务等功能\",{\"1\":{\"610\":1}}],[\"事务执行\",{\"1\":{\"665\":1}}],[\"事务执行过程中\",{\"1\":{\"571\":1,\"665\":1}}],[\"事务执行中间过程的\",{\"1\":{\"568\":1}}],[\"事务日志包括\",{\"1\":{\"567\":1}}],[\"事务日志⭐\",{\"0\":{\"567\":1}}],[\"事务之所以会出现\",{\"1\":{\"523\":1}}],[\"事务发生错误并执行回滚操作\",{\"1\":{\"521\":1}}],[\"事务尚未提交的数据\",{\"1\":{\"521\":1}}],[\"事务读取到的数据就是脏数据\",{\"1\":{\"521\":1}}],[\"事务读取\",{\"1\":{\"521\":1}}],[\"事务进入部分提交状态\",{\"1\":{\"520\":1}}],[\"事务状态\",{\"0\":{\"520\":1}}],[\"事务的保证相比producer相对较弱\",{\"1\":{\"864\":1}}],[\"事务的隔离级别\",{\"0\":{\"741\":1}}],[\"事务的隔离级别都是如何实现的\",{\"0\":{\"524\":1}}],[\"事务的传播机制\",{\"0\":{\"740\":1}}],[\"事务的实现方式\",{\"0\":{\"739\":1}}],[\"事务的三个阶段\",{\"1\":{\"665\":1}}],[\"事务的启动方式\",{\"0\":{\"526\":1}}],[\"事务的四个隔离级别⭐\",{\"0\":{\"522\":1}}],[\"事务的第一个状态\",{\"1\":{\"520\":1}}],[\"事务的原子性确保动作要么全部完成\",{\"1\":{\"519\":1}}],[\"事务的\",{\"0\":{\"519\":1}}],[\"事务的能力\",{\"1\":{\"493\":1}}],[\"事务ｂ更新表时\",{\"1\":{\"514\":1}}],[\"事务ａ在加行锁之前\",{\"1\":{\"514\":1}}],[\"事务要获取某些行的\",{\"1\":{\"514\":2}}],[\"事务有意向对表中的某些行加\",{\"1\":{\"514\":2}}],[\"事务完成后就会解锁了\",{\"1\":{\"513\":1}}],[\"事务t可以读a也可以修改a\",{\"1\":{\"509\":1}}],[\"事务\",{\"0\":{\"665\":1,\"862\":1},\"1\":{\"491\":1,\"493\":1,\"514\":2,\"578\":3}}],[\"事件来构建系统\",{\"1\":{\"1236\":1,\"1243\":1}}],[\"事件等领域对象\",{\"1\":{\"1217\":1}}],[\"事件风暴主要完成以下两个目标\",{\"1\":{\"1216\":1}}],[\"事件风暴过程需要问题驱动\",{\"1\":{\"1216\":1}}],[\"事件风暴法\",{\"1\":{\"1216\":1}}],[\"事件处理器\",{\"1\":{\"611\":1}}],[\"事件分派器每次从事件队列中取出一个事件\",{\"1\":{\"611\":1}}],[\"事件\",{\"0\":{\"1229\":1},\"1\":{\"381\":1,\"759\":1,\"817\":1,\"1157\":1}}],[\"事件驱动模型就是观察者模式很经典的一个应用\",{\"1\":{\"742\":1}}],[\"事件驱动\",{\"1\":{\"381\":1}}],[\"事件通知我们\",{\"1\":{\"381\":1}}],[\"事件发生了\",{\"1\":{\"381\":1}}],[\"复杂业务需要多个域编排完成一个复杂业务流程\",{\"1\":{\"1221\":1}}],[\"复杂度的节点查找\",{\"1\":{\"630\":1}}],[\"复习四门科目\",{\"1\":{\"689\":1}}],[\"复用\",{\"0\":{\"611\":1},\"1\":{\"997\":1,\"999\":2}}],[\"复用模型\",{\"1\":{\"610\":1}}],[\"复用的网络模型\",{\"1\":{\"610\":1}}],[\"复用都是同步\",{\"1\":{\"380\":1}}],[\"复\",{\"1\":{\"550\":1}}],[\"复合索引未用左列字段\",{\"1\":{\"534\":1}}],[\"复合索引\",{\"1\":{\"533\":1}}],[\"复制和重新排序\",{\"1\":{\"873\":1}}],[\"复制与故障转移\",{\"0\":{\"683\":1}}],[\"复制中断后\",{\"1\":{\"675\":1}}],[\"复制期间网络断了咋办\",{\"0\":{\"663\":1}}],[\"复制过程\",{\"0\":{\"662\":1}}],[\"复制到其它的\",{\"1\":{\"661\":1}}],[\"复制到锁记录中\",{\"1\":{\"87\":1}}],[\"复制文件或目录\",{\"0\":{\"423\":1},\"1\":{\"418\":1}}],[\"复制算法实现的\",{\"1\":{\"261\":1}}],[\"复制算法在对象存活率较高时就要进行较多的复制操作\",{\"1\":{\"246\":1}}],[\"复制算法\",{\"0\":{\"245\":1}}],[\"流程图\",{\"1\":{\"1271\":1}}],[\"流氓软件\",{\"1\":{\"1054\":1}}],[\"流与流之间是互不影响的\",{\"1\":{\"1042\":1}}],[\"流水线上编译出\",{\"1\":{\"1206\":1}}],[\"流水线\",{\"1\":{\"1042\":1}}],[\"流水记录也变成了两条\",{\"1\":{\"807\":1}}],[\"流量控制往往是指点对点通信量的控制\",{\"1\":{\"1019\":1}}],[\"流量控制是为了控制发送方发送速率\",{\"1\":{\"1015\":1}}],[\"流量控制\",{\"1\":{\"961\":1,\"1009\":1}}],[\"流量削峰\",{\"1\":{\"840\":1}}],[\"流量削峰等问题\",{\"1\":{\"840\":1}}],[\"流向\",{\"1\":{\"878\":1}}],[\"流的效果\",{\"1\":{\"604\":1}}],[\"流\",{\"1\":{\"379\":1}}],[\"流是阻塞式的\",{\"1\":{\"377\":1}}],[\"库内分表只解决了单一表数据量过大的问题\",{\"1\":{\"585\":1}}],[\"库中的表会越来越多\",{\"1\":{\"583\":1}}],[\"库和表的管理\",{\"1\":{\"501\":1}}],[\"库名\",{\"1\":{\"452\":1,\"459\":1}}],[\"库\",{\"1\":{\"369\":1}}],[\"～\",{\"1\":{\"368\":1,\"680\":1}}],[\"基础语法\",{\"0\":{\"1250\":1}}],[\"基础设置\",{\"1\":{\"1177\":1}}],[\"基础\",{\"0\":{\"1154\":1}}],[\"基础理论\",{\"0\":{\"444\":1}}],[\"基本多对一映射\",{\"0\":{\"1255\":1}}],[\"基本上参照\",{\"1\":{\"1170\":1}}],[\"基本上就是map\",{\"1\":{\"891\":1}}],[\"基本语法\",{\"1\":{\"1133\":1}}],[\"基本方法\",{\"1\":{\"1087\":1}}],[\"基本概念\",{\"0\":{\"966\":1,\"1228\":1}}],[\"基本思想\",{\"1\":{\"930\":1,\"931\":1,\"932\":1,\"935\":1}}],[\"基本原理及要点\",{\"1\":{\"882\":1,\"883\":1,\"884\":1,\"885\":1,\"886\":1,\"887\":1,\"888\":1,\"889\":1,\"890\":1,\"891\":1}}],[\"基本原理是使用\",{\"1\":{\"753\":1}}],[\"基本可用\",{\"1\":{\"871\":1}}],[\"基本特性同临时节点\",{\"1\":{\"818\":1}}],[\"基本特性同持久节点\",{\"1\":{\"818\":1}}],[\"基本映射\",{\"1\":{\"751\":1}}],[\"基本的版本大约\",{\"1\":{\"717\":1}}],[\"基本编码方式是\",{\"1\":{\"617\":1}}],[\"基本数据类型是在栈上分配的\",{\"1\":{\"368\":1}}],[\"基数\",{\"1\":{\"536\":1}}],[\"基于当前的语言环境\",{\"1\":{\"1190\":1}}],[\"基于token的身份验证的过程如下\",{\"1\":{\"1053\":1}}],[\"基于tcp\",{\"1\":{\"964\":1}}],[\"基于文本格式传输数据\",{\"1\":{\"1042\":1}}],[\"基于文本的\",{\"1\":{\"1035\":1}}],[\"基于快速排序\",{\"0\":{\"936\":1}}],[\"基于软负载均衡算法\",{\"1\":{\"811\":1}}],[\"基于负载均衡算法\",{\"1\":{\"810\":1}}],[\"基于注解方式实现对象创建以及注入属性\",{\"1\":{\"743\":1}}],[\"基于注解的注入\",{\"1\":{\"730\":1}}],[\"基于字节码操作\",{\"1\":{\"720\":1}}],[\"基于代理的aop\",{\"1\":{\"728\":1}}],[\"基于代理\",{\"1\":{\"720\":1}}],[\"基于事件驱动的网络应用框架\",{\"1\":{\"685\":1}}],[\"基于关系型数据库实现分布式锁\",{\"1\":{\"668\":1}}],[\"基于关系型数据库\",{\"1\":{\"668\":1}}],[\"基于主从复制\",{\"1\":{\"655\":1,\"661\":1}}],[\"基于整数数组来实现\",{\"1\":{\"625\":1}}],[\"基于整数数组实现\",{\"0\":{\"625\":1}}],[\"基于数组实现\",{\"1\":{\"619\":1}}],[\"基于哈希表实现\",{\"1\":{\"537\":1}}],[\"基于通道的\",{\"1\":{\"377\":1}}],[\"基于eclipse的内存分析工具\",{\"1\":{\"313\":1}}],[\"基于标记\",{\"1\":{\"258\":1,\"259\":1}}],[\"基于三个假说\",{\"1\":{\"239\":1}}],[\"基于栈的执行引擎\",{\"1\":{\"193\":1}}],[\"基于冲突检测的乐观并发策略\",{\"1\":{\"142\":1}}],[\"基于\",{\"1\":{\"81\":1,\"377\":1,\"380\":1,\"494\":1,\"668\":3,\"739\":1,\"746\":1,\"805\":1,\"809\":1,\"1004\":1,\"1042\":3,\"1167\":1}}],[\"型要快\",{\"1\":{\"494\":1}}],[\"型散列值\",{\"1\":{\"405\":1}}],[\"型变量的默认值是\",{\"1\":{\"368\":1}}],[\"型任务主要时间消耗在\",{\"1\":{\"64\":1}}],[\"阻止执行\",{\"1\":{\"463\":1}}],[\"阻止实例中那些用此关键字修饰的的变量序列化\",{\"1\":{\"364\":1}}],[\"阻塞模型\",{\"1\":{\"829\":1}}],[\"阻塞问题做的优化\",{\"1\":{\"647\":1}}],[\"阻塞只发生在\",{\"1\":{\"647\":1}}],[\"阻塞当前\",{\"1\":{\"647\":1}}],[\"阻塞的结果就是会带来大量的线程上下文切换\",{\"1\":{\"377\":1}}],[\"阻塞状态\",{\"1\":{\"148\":1}}],[\"阻塞队列就是生产者用来存放元素\",{\"1\":{\"62\":1}}],[\"阻塞队列就相当于一个缓冲区\",{\"1\":{\"50\":1}}],[\"阻塞队列常用于生产者和消费者的场景\",{\"1\":{\"62\":1}}],[\"阻塞队列相比普通队列\",{\"1\":{\"62\":1}}],[\"阻塞队列\",{\"0\":{\"62\":1}}],[\"阻塞是被动的\",{\"1\":{\"38\":1}}],[\"阻塞和等待的区别在于\",{\"1\":{\"38\":1}}],[\"阻塞\",{\"1\":{\"38\":1,\"137\":1,\"148\":2,\"380\":1}}],[\"普通二分\",{\"0\":{\"911\":1}}],[\"普通创建\",{\"1\":{\"823\":1}}],[\"普通的jar包\",{\"1\":{\"790\":1}}],[\"普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果\",{\"1\":{\"296\":1}}],[\"普通组件\",{\"1\":{\"743\":1}}],[\"普通情况下的系统调用\",{\"1\":{\"604\":1}}],[\"普通日志\",{\"0\":{\"566\":1}}],[\"普通索引等都是二级索引\",{\"1\":{\"549\":1}}],[\"普通索引无法直接定位行记录\",{\"1\":{\"549\":1}}],[\"普通索引的叶子节点存储主键值\",{\"1\":{\"545\":1}}],[\"普通索引\",{\"1\":{\"545\":1,\"548\":1}}],[\"普通语句块\",{\"1\":{\"363\":2}}],[\"普通内部类可以\",{\"1\":{\"361\":1}}],[\"普通内部类不行\",{\"1\":{\"361\":1}}],[\"普通内部类需要\",{\"1\":{\"361\":1}}],[\"普通内部类持有\",{\"1\":{\"361\":1}}],[\"普通类是不允许声明为静态的\",{\"1\":{\"360\":1}}],[\"覆盖被代理类的方法来进行代理\",{\"1\":{\"727\":1}}],[\"覆盖索引必须要存储索引列的值\",{\"1\":{\"550\":1}}],[\"覆盖索引\",{\"0\":{\"550\":1}}],[\"覆盖\",{\"0\":{\"358\":1},\"1\":{\"986\":1}}],[\"×\",{\"1\":{\"357\":6,\"407\":1,\"462\":2,\"522\":6,\"539\":2}}],[\"√\",{\"1\":{\"357\":10,\"462\":4,\"522\":6}}],[\"封装成一个\",{\"1\":{\"1161\":1}}],[\"封装成帧就是在一段数据的前后分别添加首部和尾部\",{\"1\":{\"972\":1}}],[\"封装成帧\",{\"0\":{\"972\":1},\"1\":{\"975\":1}}],[\"封装性好\",{\"1\":{\"1086\":1}}],[\"封装起来\",{\"1\":{\"715\":1}}],[\"封装在jar包中\",{\"1\":{\"586\":1}}],[\"封装出一个\",{\"1\":{\"409\":1}}],[\"封装\",{\"1\":{\"355\":1}}],[\"易于维护\",{\"1\":{\"718\":1}}],[\"易于水平扩展\",{\"1\":{\"588\":1}}],[\"易扩展\",{\"1\":{\"354\":1}}],[\"易复用\",{\"1\":{\"354\":1}}],[\"易维护\",{\"1\":{\"354\":1}}],[\"90\",{\"1\":{\"1148\":1}}],[\"900\",{\"1\":{\"708\":1}}],[\"9版本之后\",{\"1\":{\"860\":1}}],[\"9版本之前\",{\"1\":{\"860\":1}}],[\"9a\",{\"1\":{\"559\":1}}],[\"9f\",{\"1\":{\"559\":3}}],[\"9e\",{\"1\":{\"559\":2}}],[\"999\",{\"1\":{\"883\":2}}],[\"9999\",{\"1\":{\"475\":1}}],[\"99\",{\"1\":{\"559\":2,\"651\":1,\"882\":1,\"1167\":1}}],[\"96\",{\"1\":{\"559\":1}}],[\"95\",{\"1\":{\"559\":1}}],[\"9d\",{\"1\":{\"559\":1}}],[\"98\",{\"1\":{\"559\":1}}],[\"9b\",{\"1\":{\"559\":1}}],[\"91\",{\"1\":{\"559\":2}}],[\"920ms\",{\"1\":{\"840\":1}}],[\"92\",{\"1\":{\"439\":1}}],[\"97\",{\"1\":{\"367\":1}}],[\"9\",{\"0\":{\"413\":1},\"1\":{\"350\":1,\"426\":2,\"436\":2,\"443\":1,\"473\":3,\"935\":1,\"951\":3,\"953\":1,\"1094\":2,\"1162\":1}}],[\"9的一个重量级功能是java的模块化功能\",{\"1\":{\"292\":1}}],[\"获得正文的摘要数据\",{\"1\":{\"1057\":1}}],[\"获得大多数选票\",{\"1\":{\"877\":1}}],[\"获得同意后才会被\",{\"1\":{\"875\":1}}],[\"获得节点的值\",{\"1\":{\"823\":1}}],[\"获得该\",{\"1\":{\"755\":1}}],[\"获得依赖对象\",{\"1\":{\"718\":1}}],[\"获得了超过半数的\",{\"1\":{\"683\":1}}],[\"获得运行时类型\",{\"1\":{\"350\":1}}],[\"获取源码\",{\"1\":{\"1170\":1}}],[\"获取代理对象\",{\"1\":{\"1083\":1}}],[\"获取域名对应的\",{\"1\":{\"959\":1,\"1029\":1}}],[\"获取新日志和当前的\",{\"1\":{\"875\":1}}],[\"获取查询结果集\",{\"1\":{\"744\":1}}],[\"获取数据库连接对象\",{\"1\":{\"744\":1}}],[\"获取webapplicationcontext\",{\"1\":{\"736\":1}}],[\"获取bean的方式\",{\"0\":{\"736\":1}}],[\"获取所有锁用了\",{\"1\":{\"672\":1}}],[\"获取所有\",{\"1\":{\"672\":1}}],[\"获取锁\",{\"1\":{\"668\":1,\"672\":1}}],[\"获取锁时加上一个超时时间\",{\"1\":{\"98\":1}}],[\"获取这两个节点时间复杂度都为\",{\"1\":{\"626\":1}}],[\"获取字符串长度的时间复杂度为\",{\"1\":{\"624\":1}}],[\"获取长度的时间复杂度为\",{\"1\":{\"624\":2}}],[\"获取低效率\",{\"1\":{\"559\":1}}],[\"获取参数的值\",{\"1\":{\"461\":2,\"596\":2,\"750\":2}}],[\"获取的缓冲区为直接缓冲区\",{\"1\":{\"378\":1}}],[\"获取的是类的所有共有方法\",{\"1\":{\"356\":1}}],[\"获取的是类自身声明的所有方法\",{\"1\":{\"356\":1}}],[\"获取调用者的classloader\",{\"1\":{\"182\":1}}],[\"获取系统的classloader\",{\"1\":{\"182\":1}}],[\"获取classloader的途径\",{\"1\":{\"182\":1}}],[\"获取同步状态时\",{\"1\":{\"123\":1}}],[\"获取占有线程\",{\"1\":{\"96\":1}}],[\"获取当前时间戳\",{\"1\":{\"672\":1}}],[\"获取当前类的classloader\",{\"1\":{\"182\":1}}],[\"获取当前状态\",{\"1\":{\"96\":1}}],[\"获取当前线程上下文的classloader\",{\"1\":{\"182\":1}}],[\"获取当前线程\",{\"1\":{\"39\":1}}],[\"获取\",{\"1\":{\"85\":1,\"339\":1}}],[\"获取后将锁计数器设为\",{\"1\":{\"82\":1}}],[\"获取元素的线程会被阻塞\",{\"1\":{\"62\":1}}],[\"获取值\",{\"1\":{\"39\":1}}],[\"获取和设置线程的变量值\",{\"1\":{\"39\":1,\"41\":1}}],[\"习惯性将其称为代理类\",{\"1\":{\"349\":1}}],[\"故意篡改网络上发送的报文\",{\"1\":{\"1054\":1}}],[\"故需要四步握手\",{\"1\":{\"1024\":1}}],[\"故障自动转移\",{\"1\":{\"676\":1}}],[\"故障转移\",{\"1\":{\"657\":1}}],[\"故障恢复\",{\"1\":{\"655\":1,\"661\":1}}],[\"故名思议就是创建一个新的类\",{\"1\":{\"349\":1}}],[\"故又称为电梯调度算法\",{\"1\":{\"163\":1}}],[\"想监听对象内部的变化\",{\"1\":{\"1157\":1}}],[\"想用\",{\"1\":{\"1134\":1}}],[\"想用套接字在网络上传递对象的时候\",{\"1\":{\"344\":1}}],[\"想个办法高效统计出这批数据的top10\",{\"1\":{\"891\":1}}],[\"想要构建聚合\",{\"1\":{\"1219\":1}}],[\"想要调用服务的时候\",{\"1\":{\"801\":1}}],[\"想要调用\",{\"1\":{\"801\":1}}],[\"想要可靠性要\",{\"1\":{\"650\":1}}],[\"想要高性能选择\",{\"1\":{\"650\":1}}],[\"想要将数据写入到物理磁盘中\",{\"1\":{\"378\":1}}],[\"想把gc日志保存到文件的话\",{\"1\":{\"332\":1}}],[\"浅拷贝\",{\"1\":{\"343\":2}}],[\"深入组件\",{\"0\":{\"1158\":1}}],[\"深入理解\",{\"1\":{\"362\":1}}],[\"深入理解jvm\",{\"1\":{\"278\":1}}],[\"深度学习环境配置超详细教程\",{\"1\":{\"1145\":1}}],[\"深耕java后端与金融科技领域\",{\"1\":{\"697\":1}}],[\"深耕java后端与aigc技术融合\",{\"1\":{\"697\":1}}],[\"深拷贝\",{\"1\":{\"343\":2}}],[\"深拷贝和浅拷贝\",{\"0\":{\"343\":1}}],[\"跟前序遍历的两个方法类似\",{\"1\":{\"908\":1}}],[\"跟\",{\"1\":{\"342\":1}}],[\"跟踪指定的方法调用\",{\"1\":{\"313\":1}}],[\"冲突少的散列函数极为重要\",{\"1\":{\"922\":1}}],[\"冲突较少的环境中\",{\"1\":{\"513\":1}}],[\"冲突\",{\"0\":{\"615\":1},\"1\":{\"398\":1,\"405\":1,\"541\":1}}],[\"冲突时\",{\"1\":{\"342\":1}}],[\"冲突的解决\",{\"0\":{\"47\":1}}],[\"散列函数是否均匀\",{\"1\":{\"925\":1}}],[\"散列函数的构造方法\",{\"0\":{\"923\":1}}],[\"散列表的装填因子\",{\"1\":{\"925\":1}}],[\"散列表的长度\",{\"1\":{\"399\":1,\"925\":1}}],[\"散列表查找的性能分析\",{\"0\":{\"925\":1}}],[\"散列技术最适合的求解问题是查找与给定值相等的记录\",{\"1\":{\"922\":1}}],[\"散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系\",{\"1\":{\"922\":1}}],[\"散列\",{\"1\":{\"341\":1}}],[\"吗\",{\"0\":{\"341\":1,\"371\":1}}],[\"什么情况下需要保证接口的幂等性\",{\"1\":{\"807\":1}}],[\"什么情况下需要序列化\",{\"1\":{\"344\":1}}],[\"什么情况下才会用到红黑树\",{\"0\":{\"401\":1}}],[\"什么时候会引发数据库刷页\",{\"0\":{\"594\":1}}],[\"什么时候会使用静态内部类\",{\"0\":{\"361\":1}}],[\"什么时候触发major\",{\"0\":{\"243\":1}}],[\"什么时候触发minor\",{\"0\":{\"242\":1}}],[\"什么是安全的计算机网络\",{\"0\":{\"1055\":1}}],[\"什么是粘包\",{\"1\":{\"1006\":1}}],[\"什么是网络分区\",{\"1\":{\"870\":1}}],[\"什么是maven仓库\",{\"0\":{\"794\":1}}],[\"什么是mybatis\",{\"0\":{\"746\":1}}],[\"什么是springboot\",{\"0\":{\"767\":1}}],[\"什么是ssm框架\",{\"0\":{\"761\":1}}],[\"什么是\",{\"0\":{\"747\":1,\"795\":1,\"809\":1,\"824\":1,\"840\":1}}],[\"什么是分布式锁\",{\"0\":{\"667\":1}}],[\"什么是元注解\",{\"0\":{\"338\":1}}],[\"什么是注解\",{\"0\":{\"338\":1}}],[\"屏蔽掉了很多servlet的细节\",{\"1\":{\"755\":1}}],[\"屏蔽掉了硬件和操作系统的差异\",{\"1\":{\"337\":1}}],[\"屏障才会开门\",{\"1\":{\"120\":1}}],[\"屏障指令\",{\"1\":{\"72\":1}}],[\"阿里的tddl是两种比较常用的实现\",{\"1\":{\"586\":1}}],[\"阿里开源的java诊断工具\",{\"1\":{\"313\":1}}],[\"阿里巴巴\",{\"1\":{\"59\":1}}],[\"监视着集群中各个节点的状态\",{\"1\":{\"816\":1}}],[\"监听不到\",{\"1\":{\"1157\":1}}],[\"监听对象的属性的时候\",{\"1\":{\"1157\":1}}],[\"监听\",{\"0\":{\"1157\":1}}],[\"监听到有数据或路径变化\",{\"1\":{\"822\":1}}],[\"监听通知机制\",{\"0\":{\"817\":1}}],[\"监听接口\",{\"1\":{\"759\":2}}],[\"监听器不需要访问\",{\"1\":{\"759\":1}}],[\"监听器\",{\"0\":{\"759\":1},\"1\":{\"759\":2}}],[\"监听器与回调\",{\"1\":{\"304\":1}}],[\"监控中心\",{\"1\":{\"810\":1}}],[\"监控服务健康状况\",{\"1\":{\"801\":1}}],[\"监控一组\",{\"1\":{\"676\":1}}],[\"监控\",{\"1\":{\"585\":1,\"677\":1}}],[\"监控系统性能\",{\"0\":{\"440\":1}}],[\"监控堆信息\",{\"1\":{\"313\":1}}],[\"远远大于内存限制的4g\",{\"1\":{\"896\":1}}],[\"远远好于\",{\"1\":{\"108\":1}}],[\"远程登陆等\",{\"1\":{\"1001\":1}}],[\"远程过程调用\",{\"1\":{\"801\":1}}],[\"远程同步\",{\"0\":{\"452\":1}}],[\"远程主机信息收集\",{\"1\":{\"312\":1}}],[\"导入声明\",{\"1\":{\"1162\":1}}],[\"导入spring\",{\"1\":{\"778\":1}}],[\"导入第三方提供的bean配置类\",{\"1\":{\"771\":1}}],[\"导出内存映像文件\",{\"1\":{\"312\":1}}],[\"导致一直下载不动\",{\"1\":{\"1184\":1}}],[\"导致程序内存泄露的问题\",{\"1\":{\"1072\":1}}],[\"导致程序运行速度减慢甚至系统崩溃等严重后果\",{\"1\":{\"45\":1}}],[\"导致了这个数据包超时事件的发生\",{\"1\":{\"1020\":1}}],[\"导致没有\",{\"1\":{\"877\":1}}],[\"导致没有足够数量的副本参与新leader选举\",{\"1\":{\"866\":1}}],[\"导致producer重试\",{\"1\":{\"866\":1}}],[\"导致再次连接时\",{\"1\":{\"866\":1}}],[\"导致各个consumer的压力不均衡\",{\"1\":{\"859\":1}}],[\"导致不能发送ack怎么办\",{\"1\":{\"853\":1}}],[\"导致数据库移植性差\",{\"1\":{\"746\":1}}],[\"导致数据不一致\",{\"1\":{\"410\":1}}],[\"导致的\",{\"1\":{\"645\":1}}],[\"导致后面的请求都会落到数据库上\",{\"1\":{\"642\":1}}],[\"导致每次查询都是相同的结果\",{\"1\":{\"641\":1}}],[\"导致哈希表的\",{\"1\":{\"623\":1}}],[\"导致其他线程\",{\"1\":{\"668\":1}}],[\"导致其性能瓶颈\",{\"1\":{\"587\":1}}],[\"导致其它人拿到的对象就可能是个不完整的对象\",{\"1\":{\"101\":1,\"1068\":1}}],[\"导致索引失效\",{\"1\":{\"560\":1}}],[\"导致引擎走全表扫描\",{\"1\":{\"560\":1}}],[\"导致事务\",{\"1\":{\"521\":1}}],[\"导致大量的内存碎片\",{\"1\":{\"466\":1}}],[\"导致效率随对象数量增长而降低\",{\"1\":{\"244\":1}}],[\"导致永久代内存不足\",{\"1\":{\"207\":1}}],[\"导致抛出oom异常\",{\"1\":{\"205\":1}}],[\"导致寻道时间过长\",{\"1\":{\"163\":1}}],[\"导致\",{\"1\":{\"88\":1,\"405\":1}}],[\"导致内存泄漏\",{\"1\":{\"45\":1}}],[\"列入黑名单即可\",{\"1\":{\"1060\":1}}],[\"列表真正调用服务\",{\"1\":{\"801\":1}}],[\"列表的节点之间不是通过指针连接\",{\"1\":{\"627\":1}}],[\"列表尾的偏移量和列表中的\",{\"1\":{\"627\":1}}],[\"列表\",{\"1\":{\"626\":1,\"801\":1}}],[\"列表中的子查询\",{\"1\":{\"556\":1}}],[\"列表中包含了子查询\",{\"1\":{\"556\":1}}],[\"列值唯一\",{\"1\":{\"548\":2}}],[\"列的值\",{\"1\":{\"475\":1}}],[\"列出需要查询的字段\",{\"1\":{\"560\":1}}],[\"列出所有远程分支\",{\"1\":{\"451\":1}}],[\"列出所有本地分支和远程分支\",{\"1\":{\"451\":1}}],[\"列出所有本地分支\",{\"1\":{\"451\":1}}],[\"列出所有tag\",{\"1\":{\"450\":1}}],[\"列出所有的文件与目录容量\",{\"1\":{\"441\":1}}],[\"列出文件系统的整体磁盘使用量\",{\"1\":{\"441\":1}}],[\"列出解压文件内容\",{\"1\":{\"437\":1}}],[\"列出程序时\",{\"1\":{\"426\":3}}],[\"列出目录\",{\"0\":{\"419\":1}}],[\"列出目录及文件名\",{\"1\":{\"418\":1}}],[\"列出虚拟机进程启动时的jvm参数\",{\"1\":{\"312\":1}}],[\"列举出方法中可能抛出的受查异常\",{\"1\":{\"292\":1}}],[\"命中率统计这三点\",{\"1\":{\"607\":1}}],[\"命中率如何\",{\"1\":{\"606\":1}}],[\"命令启动\",{\"1\":{\"1177\":1}}],[\"命令提示符输入以下命令ipconfig\",{\"1\":{\"1124\":1}}],[\"命令就可以完成\",{\"1\":{\"873\":1}}],[\"命令就结束了\",{\"1\":{\"647\":1}}],[\"命令向\",{\"1\":{\"673\":2}}],[\"命令总是返回\",{\"1\":{\"668\":1}}],[\"命令入队\",{\"1\":{\"665\":1}}],[\"命令将执行所有命令\",{\"1\":{\"665\":1}}],[\"命令将计算指定文件的行数\",{\"1\":{\"439\":1}}],[\"命令后可以输入多个命令\",{\"1\":{\"665\":1}}],[\"命令执行\",{\"1\":{\"662\":1}}],[\"命令的频率会从\",{\"1\":{\"657\":1,\"677\":1}}],[\"命令的时间超过\",{\"1\":{\"657\":1,\"677\":1}}],[\"命令生成\",{\"1\":{\"655\":1}}],[\"命令之后\",{\"1\":{\"655\":1}}],[\"命令时\",{\"1\":{\"647\":1}}],[\"命令重新加载\",{\"1\":{\"647\":1}}],[\"命令返回有效回复\",{\"1\":{\"657\":1,\"677\":1}}],[\"命令返回\",{\"1\":{\"647\":1}}],[\"命令直接返回\",{\"1\":{\"647\":1}}],[\"命令回复处理器\",{\"1\":{\"611\":1}}],[\"命令请求处理器\",{\"1\":{\"611\":1}}],[\"命令来查看语句的执行计划\",{\"1\":{\"556\":1}}],[\"命令是对文件和目录磁盘使用的空间的查看\",{\"1\":{\"441\":1}}],[\"命令不同的是\",{\"1\":{\"441\":1}}],[\"命令查找程序\",{\"1\":{\"436\":1}}],[\"命令查找与进程相关的\",{\"1\":{\"426\":1}}],[\"命令产生硬链接\",{\"1\":{\"427\":1}}],[\"命令结束进程\",{\"1\":{\"426\":1}}],[\"命令创建\",{\"1\":{\"420\":1}}],[\"命令行参数\",{\"1\":{\"784\":1}}],[\"命令行中的\",{\"0\":{\"417\":1}}],[\"命令行篇\",{\"0\":{\"312\":1}}],[\"命令\",{\"1\":{\"416\":1,\"426\":3,\"603\":1,\"647\":2,\"655\":1,\"657\":2,\"662\":1,\"673\":1,\"677\":1,\"1217\":1}}],[\"命令等\",{\"1\":{\"335\":1}}],[\"命名服务\",{\"1\":{\"816\":1}}],[\"命名管道\",{\"1\":{\"149\":2}}],[\"命名规范\",{\"0\":{\"25\":1}}],[\"吞吐量\",{\"1\":{\"310\":1,\"584\":1}}],[\"吞吐量高\",{\"1\":{\"62\":1}}],[\"增强的组播支持以及对流的支持\",{\"1\":{\"996\":1}}],[\"增强\",{\"1\":{\"721\":1}}],[\"增量复制\",{\"1\":{\"655\":1}}],[\"增量的数据以\",{\"1\":{\"653\":1}}],[\"增量更新\",{\"0\":{\"251\":1},\"1\":{\"251\":2}}],[\"增删查的时间复杂度为\",{\"1\":{\"612\":1}}],[\"增删改查效率与红黑树基本一致\",{\"1\":{\"630\":1}}],[\"增删改查的开销\",{\"1\":{\"583\":1}}],[\"增删改以及加了\",{\"1\":{\"523\":1}}],[\"增删改都是走当前读\",{\"1\":{\"499\":1}}],[\"增大数据库工作量\",{\"1\":{\"532\":1}}],[\"增长方式是\",{\"1\":{\"407\":2}}],[\"增加维护难度\",{\"1\":{\"1088\":1}}],[\"增加代码维护复杂度\",{\"1\":{\"1082\":1}}],[\"增加复杂度\",{\"1\":{\"1078\":1}}],[\"增加新的具体产品需要修改工厂类的判断逻辑代码\",{\"1\":{\"1077\":1}}],[\"增加程序的可复用性\",{\"1\":{\"1064\":1}}],[\"增加此时间值可减少网络开销\",{\"1\":{\"1032\":1}}],[\"增加在重复提交的场景下会出现幂等性问题\",{\"1\":{\"807\":1}}],[\"增加开发成本\",{\"1\":{\"805\":1}}],[\"增加了系统的抽象性和理解难度\",{\"1\":{\"1079\":1}}],[\"增加了顺序属性\",{\"1\":{\"818\":1}}],[\"增加了\",{\"1\":{\"664\":1,\"1094\":1}}],[\"增加了随机性\",{\"1\":{\"405\":1}}],[\"增加cpu运算的操作\",{\"1\":{\"584\":1}}],[\"增加从服务器\",{\"1\":{\"582\":1}}],[\"增加一个指向相邻叶子节点的链表指针\",{\"1\":{\"538\":1}}],[\"增加一个新的远程仓库\",{\"1\":{\"452\":1}}],[\"增加检索速度\",{\"1\":{\"464\":1}}],[\"增加\",{\"0\":{\"447\":1},\"1\":{\"754\":1}}],[\"增加权限\",{\"1\":{\"433\":1}}],[\"增加机器\",{\"1\":{\"309\":1}}],[\"灵活度差\",{\"1\":{\"749\":1}}],[\"灵活度高\",{\"1\":{\"746\":1,\"749\":1}}],[\"灵活\",{\"1\":{\"349\":1}}],[\"灵活运用命令行工具\",{\"1\":{\"308\":1}}],[\"灵活性增强\",{\"1\":{\"1078\":1}}],[\"灵活性\",{\"1\":{\"94\":1}}],[\"六\",{\"0\":{\"305\":1,\"387\":1}}],[\"却是业务模块所共同调用的逻辑封装起来\",{\"1\":{\"719\":1}}],[\"却为业务模块所共同调用的逻辑或责任\",{\"1\":{\"715\":1}}],[\"却对内存非常不友好\",{\"1\":{\"632\":1}}],[\"却不是\",{\"1\":{\"624\":1,\"1041\":1}}],[\"却并不知道是哪几个流\",{\"1\":{\"381\":1}}],[\"却没有显式取消\",{\"1\":{\"304\":1}}],[\"却会影响到多线程并发执行的正确性\",{\"1\":{\"295\":1}}],[\"造成程序间耦合严重\",{\"1\":{\"1076\":1}}],[\"造成数据接收不完整\",{\"1\":{\"973\":1}}],[\"造成数据库短时间内承受大量请求而崩掉\",{\"1\":{\"642\":1}}],[\"造成效率问题\",{\"1\":{\"838\":1}}],[\"造成不必要的切换\",{\"1\":{\"660\":1}}],[\"造成\",{\"1\":{\"645\":1}}],[\"造成过大压力\",{\"1\":{\"643\":1}}],[\"造成额外的性能开销\",{\"1\":{\"585\":1}}],[\"造成并发死链的问题\",{\"1\":{\"409\":1}}],[\"造成oom\",{\"1\":{\"304\":1}}],[\"造成系统内存的浪费\",{\"1\":{\"45\":1}}],[\"泄漏的8种情况\",{\"0\":{\"304\":1}}],[\"泄漏的分类\",{\"0\":{\"303\":1}}],[\"泄漏一块内存\",{\"1\":{\"303\":1}}],[\"叫做最长前缀匹配\",{\"1\":{\"991\":1}}],[\"叫做内存泄漏\",{\"1\":{\"302\":1}}],[\"叫做同步省略\",{\"1\":{\"202\":1}}],[\"做了空值保护\",{\"1\":{\"1260\":1}}],[\"做了三点改造\",{\"1\":{\"130\":1}}],[\"做出行为会触发事件\",{\"1\":{\"1234\":1}}],[\"做到头之后\",{\"1\":{\"908\":1}}],[\"做到即使有读写冲突时\",{\"1\":{\"499\":1}}],[\"做数据库的\",{\"1\":{\"807\":1}}],[\"做一个定时任务\",{\"1\":{\"668\":1}}],[\"做的修改\",{\"1\":{\"649\":1}}],[\"做防止击穿的手段\",{\"1\":{\"641\":1}}],[\"做全库逻辑备份\",{\"1\":{\"508\":1}}],[\"做完这些操作后\",{\"1\":{\"490\":1}}],[\"做快速排序\",{\"1\":{\"484\":1}}],[\"做\",{\"1\":{\"301\":1,\"397\":1,\"398\":1,\"660\":1,\"678\":1}}],[\"盒子中可以存储每个线程的私有数据\",{\"1\":{\"299\":1}}],[\"掌握了泄漏对象的类信息和gc\",{\"1\":{\"298\":1}}],[\"排队对每个客户是一样的\",{\"1\":{\"1087\":1}}],[\"排队\",{\"1\":{\"1087\":2}}],[\"排在对头的先处理\",{\"1\":{\"942\":1}}],[\"排列\",{\"1\":{\"884\":1}}],[\"排除依赖\",{\"0\":{\"796\":1},\"1\":{\"796\":1}}],[\"排行榜\",{\"1\":{\"603\":1}}],[\"排它锁\",{\"1\":{\"509\":1,\"510\":1}}],[\"排他锁与排他锁之间互相排斥\",{\"1\":{\"500\":1}}],[\"排他锁\",{\"1\":{\"500\":1}}],[\"排查oom\",{\"0\":{\"298\":1}}],[\"排序缓冲区\",{\"1\":{\"1177\":1}}],[\"排序的过程\",{\"1\":{\"934\":1}}],[\"排序过程中每次从无序表中取出第一个元素\",{\"1\":{\"932\":1}}],[\"排序已经完成\",{\"1\":{\"930\":1}}],[\"排序字段若通过索引去访问将大大提高排序的速度\",{\"1\":{\"531\":1}}],[\"排序会要求回表多造成磁盘读\",{\"1\":{\"484\":1}}],[\"排序算法\",{\"1\":{\"484\":1}}],[\"排序\",{\"0\":{\"929\":1},\"1\":{\"62\":1,\"484\":1,\"674\":1}}],[\"抛出第一个\",{\"0\":{\"957\":1}}],[\"抛出的\",{\"1\":{\"717\":1}}],[\"抛出\",{\"1\":{\"297\":1}}],[\"场景\",{\"0\":{\"297\":1}}],[\"逃逸\",{\"1\":{\"295\":1}}],[\"逃逸分析的基本行为就是分析对象动态作用域\",{\"1\":{\"202\":1}}],[\"逃逸分析\",{\"0\":{\"202\":1},\"1\":{\"202\":1}}],[\"载入收到的快照\",{\"1\":{\"655\":1}}],[\"载入\",{\"1\":{\"294\":1}}],[\"长链接\",{\"1\":{\"1042\":1}}],[\"长连接\",{\"1\":{\"1039\":1}}],[\"长连接什么的\",{\"1\":{\"685\":1}}],[\"长事务还占用锁资源\",{\"1\":{\"525\":1}}],[\"长事务意味着系统里面会存在很老的事务视图\",{\"1\":{\"525\":1}}],[\"长时间持有锁的\",{\"1\":{\"516\":1}}],[\"长数据串列出\",{\"1\":{\"419\":1}}],[\"长度更短\",{\"1\":{\"1035\":1}}],[\"长度的数组\",{\"1\":{\"903\":1}}],[\"长度\",{\"1\":{\"637\":2,\"755\":1,\"1002\":1}}],[\"长度小于\",{\"1\":{\"617\":1}}],[\"长度较长\",{\"1\":{\"585\":1}}],[\"长度为\",{\"1\":{\"468\":1,\"539\":1}}],[\"长度已经到达上限\",{\"1\":{\"406\":1}}],[\"长度可变\",{\"1\":{\"372\":1}}],[\"长度和内容不同\",{\"1\":{\"291\":1}}],[\"长生命周期的对象持有短生命周期对象的引用\",{\"1\":{\"304\":1}}],[\"长期存活的对象分配到old\",{\"1\":{\"220\":1}}],[\"几百w的数据\",{\"1\":{\"541\":1}}],[\"几乎所有的应用程序都需要用到这些共享库\",{\"1\":{\"416\":1}}],[\"几乎所有的对象实例以及数组都应当在堆上分配\",{\"1\":{\"199\":1}}],[\"几项\",{\"1\":{\"289\":1,\"290\":1}}],[\"描述\",{\"1\":{\"1188\":1}}],[\"描述了产品的主要特性和功能\",{\"1\":{\"1079\":1}}],[\"描述符上有可读事件发⽣时\",{\"1\":{\"613\":1}}],[\"描述符索引\",{\"1\":{\"289\":1,\"290\":1}}],[\"描述java源码行号与字节码行号\",{\"1\":{\"292\":1}}],[\"描述结构\",{\"1\":{\"289\":1}}],[\"名称\",{\"1\":{\"1035\":2}}],[\"名称索引\",{\"1\":{\"289\":1,\"290\":1}}],[\"名字的由来\",{\"1\":{\"260\":1}}],[\"识别一些类或者接口层次的访问信息\",{\"1\":{\"287\":1}}],[\"书p304\",{\"1\":{\"286\":1}}],[\"唯一不足的地方就是声明式事务管理的粒度是方法级别\",{\"1\":{\"739\":1}}],[\"唯一值\",{\"1\":{\"702\":1}}],[\"唯一索引连接\",{\"1\":{\"702\":1}}],[\"唯一索引和普通索引对数据的更新过程\",{\"1\":{\"574\":1}}],[\"唯一索引的更新就不能使用\",{\"1\":{\"574\":1}}],[\"唯一索引与普通索引的速度比较\",{\"0\":{\"555\":1}}],[\"唯一索引\",{\"1\":{\"548\":2,\"807\":1}}],[\"唯一索引上的范围查询会访问到不满足条件的第一个值为止\",{\"1\":{\"515\":1}}],[\"唯一\",{\"1\":{\"462\":1,\"734\":1}}],[\"唯一约束\",{\"1\":{\"460\":1}}],[\"唯一作用\",{\"1\":{\"285\":1}}],[\"唯一目的\",{\"1\":{\"199\":1}}],[\"魔数与class文件的版本\",{\"0\":{\"285\":1}}],[\"各站直接连接在总线上\",{\"1\":{\"977\":1}}],[\"各层中间设备的名称\",{\"0\":{\"965\":1}}],[\"各层之间的联系\",{\"0\":{\"766\":1}}],[\"各存放50亿个url\",{\"0\":{\"896\":1}}],[\"各个具体的建造者相互独立\",{\"1\":{\"1086\":1}}],[\"各个机子只需拿出各自的出现次数最多的前n个数据\",{\"1\":{\"891\":1}}],[\"各个子项目继承该pom即可\",{\"1\":{\"800\":1}}],[\"各个哨兵之间还会进行监控\",{\"1\":{\"657\":1}}],[\"各个节点保存的成员对象必须是唯一的\",{\"1\":{\"630\":1}}],[\"各个服务之间的缓存是无法共享的\",{\"1\":{\"609\":1}}],[\"各个引擎都能用\",{\"1\":{\"571\":1}}],[\"各个数据项目严格按照顺序紧凑地排列在文件之中\",{\"1\":{\"284\":1}}],[\"各并发事务之间数据库是独立的\",{\"1\":{\"519\":1}}],[\"各事务都在等待对方释放已经持有的锁或因为加锁顺序不一致造成循环等待锁资源\",{\"1\":{\"516\":1}}],[\"各种不同的算法以不同的方式实现这个接口\",{\"1\":{\"1088\":1}}],[\"各种aware接口\",{\"1\":{\"737\":1}}],[\"各种连接\",{\"1\":{\"304\":1}}],[\"各种类加载器之间的层次关系被称为类加载器的\",{\"1\":{\"184\":1}}],[\"逐个写入到一个大文件中\",{\"1\":{\"892\":1}}],[\"逐个调用\",{\"1\":{\"813\":1}}],[\"逐步确定范围\",{\"1\":{\"886\":1}}],[\"逐步完成任务\",{\"1\":{\"691\":1}}],[\"逐步采用本地内存的计划\",{\"1\":{\"203\":1}}],[\"逐行将字节码翻译成机器码并执行\",{\"1\":{\"283\":1}}],[\"源端口\",{\"1\":{\"1002\":1}}],[\"源地址散列\",{\"1\":{\"869\":1}}],[\"源与目标打开的连接\",{\"1\":{\"379\":1}}],[\"源代码\",{\"1\":{\"309\":1}}],[\"源代码经过编译器编译之后便会生成一个字节码文件\",{\"1\":{\"280\":1}}],[\"源码解析\",{\"1\":{\"1087\":1,\"1090\":1}}],[\"源码中设置为\",{\"1\":{\"539\":1}}],[\"源码分析\",{\"0\":{\"111\":1,\"414\":1}}],[\"源码进行了一些修改\",{\"1\":{\"18\":1}}],[\"尚未提交commit的事务版本号集合\",{\"1\":{\"499\":1}}],[\"尚未到就绪状态\",{\"1\":{\"148\":1}}],[\"尚硅谷jvm视频\",{\"1\":{\"278\":1}}],[\"准生产环境的运行应用监控\",{\"1\":{\"768\":1}}],[\"准确的来说\",{\"1\":{\"414\":1}}],[\"准确来说是编译器\",{\"1\":{\"277\":1}}],[\"准备发送的数据\",{\"1\":{\"1015\":1}}],[\"准备好业务和架构师可能要看的日志和报文\",{\"1\":{\"693\":1}}],[\"准备处理节点\",{\"1\":{\"406\":1}}],[\"准备阶段会显式初始化\",{\"1\":{\"171\":1}}],[\"准备阶段是正式为类中定义的变量\",{\"1\":{\"171\":1}}],[\"准备\",{\"0\":{\"171\":1}}],[\"尽最大努力交付的数据报服务\",{\"1\":{\"982\":1}}],[\"尽最大努力的数据传输服务\",{\"1\":{\"961\":1}}],[\"尽量通过扩展软件实体来解决需求变化\",{\"1\":{\"1064\":1}}],[\"尽量不要重写父类的方法\",{\"1\":{\"1064\":1}}],[\"尽量不要在同一时间段进行重启\",{\"1\":{\"656\":1}}],[\"尽量不要使用\",{\"1\":{\"641\":1}}],[\"尽量不去扩容\",{\"1\":{\"623\":1}}],[\"尽量顺序插入\",{\"1\":{\"564\":1}}],[\"尽量避免我们的数据库被干掉\",{\"1\":{\"642\":1}}],[\"尽量避免在字段开头模糊查询\",{\"1\":{\"560\":1}}],[\"尽量避免使用\",{\"1\":{\"560\":2,\"729\":1}}],[\"尽量避免\",{\"1\":{\"535\":1,\"642\":1}}],[\"尽量的扩展索引\",{\"1\":{\"533\":1}}],[\"尽量选择区分度高的列作为索引\",{\"1\":{\"533\":1}}],[\"尽量约定以相同的顺序访问表\",{\"1\":{\"516\":1}}],[\"尽量将大事务拆成多个小事务来处理\",{\"1\":{\"516\":1}}],[\"尽量减少磁盘访问\",{\"1\":{\"484\":1}}],[\"尽量减少碰撞\",{\"1\":{\"404\":1}}],[\"尽可能地屏蔽掉这些传输媒体和通信手段的差异\",{\"1\":{\"966\":1}}],[\"尽可能避免全表扫描\",{\"1\":{\"560\":1}}],[\"尽可能做到一次锁定所需要的所有资源\",{\"1\":{\"516\":1}}],[\"尽可能通过索引定位更少的行\",{\"1\":{\"516\":1}}],[\"尽可能缩减加锁的范围\",{\"1\":{\"98\":1}}],[\"尽管服务器\",{\"1\":{\"820\":1}}],[\"尽管短生命周期的对象不再使用\",{\"1\":{\"304\":1}}],[\"尽管虚拟机未把lock和unlock操作直接开放给用户使用\",{\"1\":{\"295\":1}}],[\"尽管它使用invokevirtual指令调用\",{\"1\":{\"275\":1}}],[\"未按序到达的数据\",{\"1\":{\"1015\":1}}],[\"未使用索引\",{\"1\":{\"556\":1}}],[\"未匹配的行作为外部行添加到虚拟表vt2中\",{\"1\":{\"487\":1}}],[\"未来将在服务端\",{\"1\":{\"268\":1}}],[\"未被使用的页面很少\",{\"1\":{\"594\":1}}],[\"未被同步到\",{\"1\":{\"582\":1}}],[\"未被\",{\"1\":{\"174\":1}}],[\"染色指针和内存多重映射等技术来实现可并发的标记\",{\"1\":{\"268\":1}}],[\"暂时将未提交的变化移除\",{\"1\":{\"453\":1}}],[\"暂时不设分代\",{\"1\":{\"268\":1}}],[\"暂存区\",{\"1\":{\"444\":1,\"1121\":1}}],[\"暂停屏幕输出\",{\"1\":{\"417\":1}}],[\"暂停主线程\",{\"1\":{\"35\":1}}],[\"收敛出的业务聚合内的类都继承这个聚合根实体\",{\"1\":{\"1219\":1}}],[\"收敛阶段\",{\"0\":{\"1219\":1}}],[\"收缩大小为第一个大于\",{\"1\":{\"623\":1}}],[\"收益就越大\",{\"1\":{\"574\":1}}],[\"收到的都是完全正确的包\",{\"1\":{\"1006\":1}}],[\"收到的帧的mac地址与本站的硬件地址相同\",{\"1\":{\"979\":1}}],[\"收到此报文的主机必须给源主机发送icmp回送回答报文\",{\"1\":{\"993\":1}}],[\"收到此命令\",{\"1\":{\"651\":1}}],[\"收到数据后将目标\",{\"1\":{\"986\":1}}],[\"收到了多数的成功响应\",{\"1\":{\"878\":1}}],[\"收到了官方的排挤\",{\"1\":{\"267\":1}}],[\"收到客户端请求后\",{\"1\":{\"878\":1}}],[\"收到消息后\",{\"1\":{\"804\":1}}],[\"收到\",{\"1\":{\"662\":1}}],[\"收到写命令\",{\"1\":{\"650\":1}}],[\"收到请求后\",{\"1\":{\"489\":1}}],[\"收费\",{\"1\":{\"313\":1}}],[\"收集结束时会有大量空间碎片产生\",{\"1\":{\"259\":1}}],[\"收集算法\",{\"1\":{\"255\":1}}],[\"收集器是一种以获取最短回收停顿时间为目标的收集器\",{\"1\":{\"259\":1}}],[\"收集器\",{\"0\":{\"257\":1}}],[\"收集器配合工作\",{\"1\":{\"255\":1}}],[\"收集器外\",{\"1\":{\"255\":1}}],[\"收集器对于运行在\",{\"1\":{\"254\":1}}],[\"收集器由于没有线程交互的开销\",{\"1\":{\"254\":1}}],[\"收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了\",{\"1\":{\"249\":1}}],[\"筛选回收\",{\"1\":{\"264\":1}}],[\"筛选的条件是此对象是否有必要执行finalize\",{\"1\":{\"236\":1}}],[\"找单向链表的倒数第\",{\"0\":{\"927\":1}}],[\"找一台内存在\",{\"1\":{\"895\":1}}],[\"找一台电脑充当服务器的角色\",{\"1\":{\"452\":1}}],[\"找出父节点和孩子之间的最大值\",{\"1\":{\"937\":1}}],[\"找出左右子节点中最大的值\",{\"1\":{\"937\":1}}],[\"找出出现最频繁的前10个词\",{\"1\":{\"899\":1}}],[\"找出top\",{\"1\":{\"893\":3}}],[\"找出那个频率最大的ip\",{\"1\":{\"892\":1}}],[\"找出相应的\",{\"1\":{\"804\":1}}],[\"找出慢sql\",{\"1\":{\"701\":1}}],[\"找出消耗高的sql\",{\"1\":{\"562\":1}}],[\"找出\",{\"1\":{\"538\":1,\"558\":1}}],[\"找出能读出数据\",{\"1\":{\"381\":1}}],[\"找出要回收的对象\",{\"1\":{\"264\":1}}],[\"找到对应的硬件地址\",{\"1\":{\"986\":1}}],[\"找到该记录\",{\"1\":{\"922\":1}}],[\"找到他对应的整数中的位\",{\"1\":{\"903\":1}}],[\"找到每台出现次数最多的前\",{\"1\":{\"891\":1}}],[\"找到处理器映射\",{\"1\":{\"755\":1}}],[\"找到最近的一次全量备份\",{\"1\":{\"576\":1}}],[\"找到最耗cpu的线程\",{\"1\":{\"201\":1}}],[\"找到最耗cpu的进程\",{\"1\":{\"201\":1}}],[\"找到位置之后\",{\"1\":{\"574\":2}}],[\"找到索引也就找到了数据\",{\"1\":{\"547\":1}}],[\"找到一个\",{\"1\":{\"538\":1}}],[\"找到相应记录\",{\"1\":{\"506\":1}}],[\"找到第一个满足\",{\"1\":{\"484\":2}}],[\"找到操作数栈顶的第一个元素所指向的对象的实际类型\",{\"1\":{\"278\":1}}],[\"找到后加⼊⾄gc\",{\"1\":{\"247\":1}}],[\"找到\",{\"1\":{\"247\":1}}],[\"找到线程在干嘛\",{\"1\":{\"201\":1}}],[\"乃至更多的内存空间\",{\"1\":{\"262\":1}}],[\"毫秒的时间片段内\",{\"1\":{\"261\":1}}],[\"超文本传输协议概述\",{\"1\":{\"1037\":1}}],[\"超类的\",{\"1\":{\"340\":1}}],[\"超过则采用\",{\"1\":{\"618\":1}}],[\"超过栈的大小\",{\"1\":{\"297\":1}}],[\"超过98\",{\"1\":{\"297\":1}}],[\"超过大小\",{\"1\":{\"297\":1}}],[\"超过此值\",{\"1\":{\"262\":1}}],[\"超过50\",{\"1\":{\"261\":1}}],[\"超时事件就一定是网络拥塞么\",{\"0\":{\"1020\":1}}],[\"超时计时器设置的超时重传时间rto\",{\"1\":{\"1012\":1}}],[\"超时重传时间的选择\",{\"0\":{\"1012\":1}}],[\"超时重传\",{\"1\":{\"1009\":1,\"1010\":1}}],[\"超时\",{\"1\":{\"94\":1,\"1201\":1}}],[\"面向接口编程\",{\"1\":{\"1064\":1}}],[\"面向接口的远程方法调用\",{\"1\":{\"809\":1}}],[\"面向切面编程\",{\"1\":{\"715\":1,\"718\":1}}],[\"面向过程性能比面向对象高\",{\"1\":{\"354\":1}}],[\"面向过程\",{\"0\":{\"354\":1},\"1\":{\"354\":1}}],[\"面向对象的三大特性\",{\"0\":{\"355\":1}}],[\"面向对象的程序与以前结构化的程序在执行上没有任何区别\",{\"1\":{\"198\":1}}],[\"面向对象\",{\"0\":{\"353\":1},\"1\":{\"354\":2}}],[\"面向服务端应用\",{\"1\":{\"261\":1}}],[\"专注\",{\"1\":{\"961\":1}}],[\"专业术语叫做类型擦除\",{\"1\":{\"345\":1}}],[\"专业说\",{\"1\":{\"36\":1}}],[\"专门用来存储大对象\",{\"1\":{\"260\":1}}],[\"官网有数据表明\",{\"1\":{\"850\":1}}],[\"官网的教程很简短易读\",{\"1\":{\"23\":1}}],[\"官方推荐\",{\"1\":{\"1150\":1}}],[\"官方\",{\"1\":{\"1139\":1}}],[\"官方文档的\",{\"1\":{\"1138\":1}}],[\"官方文档\",{\"1\":{\"1138\":1}}],[\"官方教程\",{\"1\":{\"1133\":1}}],[\"官方提供了一个动态代理类\",{\"1\":{\"1083\":1}}],[\"官方站提出了一种权威的基于\",{\"1\":{\"672\":1}}],[\"官方称这种存放记录的页为\",{\"1\":{\"591\":1}}],[\"官方也是认为该功能在实际的应用场景比较少\",{\"1\":{\"490\":1}}],[\"官方建议重写\",{\"1\":{\"342\":1}}],[\"官方给g1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量\",{\"1\":{\"260\":1}}],[\"负担太大\",{\"1\":{\"1052\":1}}],[\"负载\",{\"1\":{\"655\":1,\"661\":1}}],[\"负载均衡算法\",{\"0\":{\"832\":1,\"869\":1},\"1\":{\"832\":1}}],[\"负载均衡等功能\",{\"1\":{\"825\":1}}],[\"负载均衡策略\",{\"0\":{\"812\":1},\"1\":{\"812\":1}}],[\"负载均衡\",{\"0\":{\"849\":1},\"1\":{\"655\":1,\"661\":1,\"816\":1,\"827\":1,\"861\":1}}],[\"负载因子是\",{\"1\":{\"399\":1}}],[\"负载因子为\",{\"1\":{\"399\":1}}],[\"负载因子的大小决定着哈希表的扩容和哈希冲突\",{\"1\":{\"399\":1}}],[\"负载因子的大小为\",{\"1\":{\"399\":1}}],[\"负载因子\",{\"1\":{\"397\":1}}],[\"负载较大\",{\"1\":{\"259\":1}}],[\"负责给出一个算法的轮廓和骨架\",{\"1\":{\"1087\":1}}],[\"负责网络通信的二进制比特流传输\",{\"1\":{\"961\":1}}],[\"负责选择最佳路径\",{\"1\":{\"961\":1}}],[\"负责数据格式转换\",{\"1\":{\"961\":1}}],[\"负责不同主机间的通信服务\",{\"1\":{\"961\":1}}],[\"负责发起心跳\",{\"1\":{\"874\":1}}],[\"负责具体的业务模块流程的控制\",{\"1\":{\"764\":1}}],[\"负责与数据库进行联络的一些任务都封装在此\",{\"1\":{\"762\":1}}],[\"负责页面的显示\",{\"1\":{\"754\":1}}],[\"负责业务逻辑处理\",{\"1\":{\"754\":1}}],[\"负责接收客户端请求\",{\"1\":{\"754\":1}}],[\"负责读取中继日志\",{\"1\":{\"470\":1,\"581\":1}}],[\"负责从主服务器上读取二进制日志\",{\"1\":{\"470\":1,\"581\":1}}],[\"负责将主服务器上的数据更改写入二进制日志\",{\"1\":{\"470\":1,\"581\":1}}],[\"负责更新region的统计数据\",{\"1\":{\"264\":1}}],[\"负责加载环境变量classpath或系统属性java\",{\"1\":{\"178\":1}}],[\"负责加载存放在<java\",{\"1\":{\"176\":1}}],[\"负责内存的分配与回收\",{\"1\":{\"153\":1}}],[\"负责向\",{\"1\":{\"39\":1,\"41\":1}}],[\"清屏\",{\"1\":{\"417\":1}}],[\"清理无效的\",{\"1\":{\"301\":1}}],[\"清理删除掉标记阶段判断的已经死亡的对象\",{\"1\":{\"259\":1}}],[\"清除已安装文件\",{\"1\":{\"1168\":1}}],[\"清除过期session\",{\"1\":{\"759\":1}}],[\"清除之后会产生大量不连续的内存碎片\",{\"1\":{\"244\":1}}],[\"清除\",{\"1\":{\"244\":1,\"259\":1,\"261\":1}}],[\"清除算法的\",{\"1\":{\"246\":1}}],[\"清除算法与标记\",{\"1\":{\"246\":1}}],[\"清除算法面对大量可回收对象时执行效率低的问题\",{\"1\":{\"245\":1}}],[\"清除算法\",{\"0\":{\"244\":1}}],[\"速度要求高\",{\"1\":{\"1001\":1}}],[\"速度是非常快的\",{\"1\":{\"838\":1}}],[\"速度是会比\",{\"1\":{\"393\":1}}],[\"速度最快\",{\"1\":{\"391\":1}}],[\"速度很快\",{\"1\":{\"259\":1}}],[\"速度大幅度提升\",{\"1\":{\"138\":1}}],[\"绿线被deprecated了\",{\"1\":{\"252\":1}}],[\"经历了战略设计之后\",{\"1\":{\"1224\":1}}],[\"经典问题分析\",{\"1\":{\"891\":1}}],[\"经典垃圾收集器\",{\"0\":{\"252\":1}}],[\"经过客户端反序列化\",{\"1\":{\"804\":1}}],[\"经过\",{\"1\":{\"651\":1}}],[\"经过修改以后写回数据库\",{\"1\":{\"513\":1}}],[\"经过了优化器之后\",{\"1\":{\"490\":1}}],[\"经过javac编译器编译成字节码指令之后\",{\"1\":{\"290\":1}}],[\"经常同时存储多列\",{\"1\":{\"535\":1}}],[\"经常发生\",{\"1\":{\"303\":1}}],[\"经常会遇到\",{\"1\":{\"295\":1}}],[\"经常会使用一个前置的容量计数器加若干个连续的数据项的形式\",{\"1\":{\"284\":1}}],[\"经常用于限制获取某种资源的线程数量\",{\"1\":{\"117\":1}}],[\"zxid\",{\"1\":{\"820\":1}}],[\"znode\",{\"0\":{\"818\":1},\"1\":{\"817\":3,\"818\":1}}],[\"zk\",{\"1\":{\"803\":4,\"817\":1,\"819\":1,\"820\":6}}],[\"zookeeper通过心跳机制检查每个节点的连接\",{\"1\":{\"868\":1}}],[\"zookeeper维护一个类似文件系统的多层级节点命名空间\",{\"1\":{\"818\":1}}],[\"zookeeper会通知客户端\",{\"1\":{\"817\":1}}],[\"zookeeper是什么\",{\"0\":{\"816\":1}}],[\"zookeeper\",{\"0\":{\"819\":1,\"820\":1,\"822\":1,\"823\":1},\"1\":{\"668\":5,\"803\":2,\"815\":1,\"816\":3,\"818\":3,\"820\":2,\"821\":2,\"822\":4,\"860\":2,\"861\":4,\"870\":4}}],[\"zet\",{\"1\":{\"637\":1}}],[\"zerofill\",{\"1\":{\"476\":1}}],[\"zskiplistnode\",{\"1\":{\"630\":1}}],[\"zskiplist结构构成\",{\"1\":{\"630\":1}}],[\"zset\",{\"0\":{\"620\":1},\"1\":{\"603\":1,\"610\":1,\"616\":1,\"620\":2,\"630\":1,\"637\":1}}],[\"zlend\",{\"1\":{\"627\":1}}],[\"zllen\",{\"1\":{\"627\":1}}],[\"zltail\",{\"1\":{\"627\":1}}],[\"zlbytes\",{\"1\":{\"627\":1}}],[\"zipmap\",{\"1\":{\"622\":6}}],[\"ziplist\",{\"0\":{\"627\":2},\"1\":{\"618\":2,\"629\":3}}],[\"zgc也采用基于region的堆内存布局\",{\"1\":{\"268\":1}}],[\"zgc几乎在所有地方并发执行\",{\"1\":{\"268\":1}}],[\"zgc和shenandoah的目标是高度相似的\",{\"1\":{\"268\":1}}],[\"zgc\",{\"0\":{\"268\":1},\"1\":{\"249\":1}}],[\"zh\",{\"1\":{\"26\":1,\"1038\":1,\"1179\":1}}],[\"⽽传输层的设计理念是简单\",{\"1\":{\"961\":1}}],[\"⽽针对于不同的隔离级别\",{\"1\":{\"499\":1}}],[\"⽽版本的数据存在于undo\",{\"1\":{\"499\":1}}],[\"⽽不⽤去遍历整个\",{\"1\":{\"247\":1}}],[\"⽽⾮阻塞\",{\"1\":{\"137\":1}}],[\"卡页大小都是以2的n次幂的字节数\",{\"1\":{\"249\":1}}],[\"卡页\",{\"1\":{\"249\":1}}],[\"卡精度\",{\"1\":{\"249\":2}}],[\"卡⻚\",{\"1\":{\"247\":1}}],[\"卡表维护操作外\",{\"1\":{\"262\":1}}],[\"卡表最简单的形式可以只是一个字节数组\",{\"1\":{\"249\":1}}],[\"卡表就是记忆集的一种具体实现\",{\"1\":{\"249\":1}}],[\"卡表实际上就是卡⻚的集合\",{\"1\":{\"247\":1}}],[\"卡表\",{\"1\":{\"247\":3,\"249\":2}}],[\"⽼年代\",{\"1\":{\"247\":2}}],[\"压缩实现\",{\"1\":{\"890\":1}}],[\"压缩等\",{\"1\":{\"804\":1}}],[\"压缩响应信息\",{\"1\":{\"759\":1}}],[\"压缩列表在表尾还有\",{\"1\":{\"627\":1}}],[\"压缩列表在表头有三个字段\",{\"1\":{\"627\":1}}],[\"压缩列表实际上类似于一个数组\",{\"1\":{\"627\":1}}],[\"压缩列表\",{\"0\":{\"627\":1}}],[\"压缩文件\",{\"1\":{\"437\":1}}],[\"压缩解压命令\",{\"0\":{\"437\":1}}],[\"压缩类指针\",{\"1\":{\"323\":1}}],[\"压缩对象指针\",{\"1\":{\"323\":1}}],[\"压缩算法\",{\"1\":{\"268\":1}}],[\"压缩\",{\"0\":{\"246\":1},\"1\":{\"804\":1}}],[\"压力并不大\",{\"1\":{\"64\":1}}],[\"整条左边界依次入栈\",{\"1\":{\"908\":1}}],[\"整数个数为2^32\",{\"1\":{\"886\":1}}],[\"整数\",{\"1\":{\"884\":1,\"900\":1}}],[\"整数槽内\",{\"1\":{\"679\":1}}],[\"整形\",{\"1\":{\"867\":1}}],[\"整形数据比起字符\",{\"1\":{\"535\":1}}],[\"整体对象可以控制部分对象的生命周期\",{\"1\":{\"1099\":1}}],[\"整体上来说\",{\"1\":{\"843\":1}}],[\"整体呈现层层封装\",{\"1\":{\"622\":1}}],[\"整合\",{\"1\":{\"585\":1}}],[\"整型\",{\"0\":{\"472\":1}}],[\"整个目录复制即可\",{\"1\":{\"1186\":1}}],[\"整个网络就分成了几块区域\",{\"1\":{\"870\":1}}],[\"整个调用请求就结束了\",{\"1\":{\"804\":1}}],[\"整个过程的复杂度为o\",{\"1\":{\"893\":1}}],[\"整个过程需要人为干预\",{\"1\":{\"675\":1}}],[\"整个过程分为\",{\"1\":{\"259\":1}}],[\"整个系统就不可用了\",{\"1\":{\"674\":1}}],[\"整个系统就不能再接受更新了\",{\"1\":{\"594\":1}}],[\"整个集群就会进入\",{\"1\":{\"659\":1}}],[\"整个email字符串作为索引\",{\"1\":{\"554\":1}}],[\"整个表就变成了一个索引\",{\"1\":{\"548\":1}}],[\"整个事务存在期间都用这个视图\",{\"1\":{\"524\":1}}],[\"整个\",{\"1\":{\"335\":1}}],[\"整个class文件本质上也可以视作是一张表\",{\"1\":{\"284\":1}}],[\"整理算法实现\",{\"1\":{\"258\":1}}],[\"整理算法\",{\"1\":{\"256\":1}}],[\"整理算法的\",{\"1\":{\"246\":1}}],[\"整理算法的本质差异在于前者是一种非移动式的回收算法\",{\"1\":{\"246\":1}}],[\"整理\",{\"0\":{\"246\":1},\"1\":{\"246\":1,\"261\":1}}],[\"整堆收集\",{\"1\":{\"240\":1}}],[\"年才诞生了一个比\",{\"1\":{\"872\":1}}],[\"年\",{\"1\":{\"475\":2,\"687\":1,\"872\":1}}],[\"年的日期和时间\",{\"1\":{\"475\":1}}],[\"年到\",{\"1\":{\"475\":2}}],[\"年轻代gc不关心老年代对象\",{\"1\":{\"242\":1}}],[\"年龄大于等于该年龄的对象可以直接进入老年代\",{\"1\":{\"220\":1}}],[\"达到了第一维数组长度的\",{\"1\":{\"623\":1}}],[\"达到分布式的效果\",{\"1\":{\"585\":1}}],[\"达到默认值15则晋升老年代\",{\"1\":{\"241\":1}}],[\"达到写操作可见性的效果\",{\"1\":{\"72\":1}}],[\"新学的英语\",{\"1\":{\"1206\":1}}],[\"新浪\",{\"1\":{\"824\":1}}],[\"新的二进制格式\",{\"1\":{\"1042\":1}}],[\"新的连接就建立了\",{\"1\":{\"1022\":1}}],[\"新的\",{\"1\":{\"651\":1,\"1012\":2}}],[\"新写入操作会报错\",{\"1\":{\"636\":1}}],[\"新写入的行就会覆盖原有的行\",{\"1\":{\"468\":1}}],[\"新增\",{\"1\":{\"1177\":1}}],[\"新增了回调函数\",{\"1\":{\"829\":1}}],[\"新增操作\",{\"1\":{\"623\":1,\"807\":1}}],[\"新增的注解\",{\"1\":{\"338\":1}}],[\"新版本的mysql中对row\",{\"1\":{\"572\":1}}],[\"新值不是主表的主键值便阻止修改\",{\"1\":{\"463\":1}}],[\"新\",{\"1\":{\"406\":1,\"677\":1}}],[\"新生代什么时候会变成老年代\",{\"0\":{\"241\":1}}],[\"新生代收集\",{\"1\":{\"240\":1}}],[\"新建spring\",{\"1\":{\"773\":1}}],[\"新建自动装配类\",{\"1\":{\"773\":1}}],[\"新建配置类\",{\"1\":{\"773\":1}}],[\"新建maven项目\",{\"1\":{\"773\":1}}],[\"新建仓库\",{\"0\":{\"445\":1}}],[\"新建一个commit\",{\"1\":{\"453\":1}}],[\"新建一个分支\",{\"1\":{\"450\":1,\"451\":4}}],[\"新建一个tag在指定commit\",{\"1\":{\"450\":1}}],[\"新建一个tag在当前commit\",{\"1\":{\"450\":1}}],[\"新建一个目录\",{\"1\":{\"445\":1}}],[\"新建一个\",{\"1\":{\"396\":1,\"622\":1}}],[\"新建\",{\"1\":{\"38\":1}}],[\"跨会话间的幂等性\",{\"1\":{\"863\":1}}],[\"跨会话的事务\",{\"1\":{\"863\":1}}],[\"跨度\",{\"1\":{\"630\":1}}],[\"跨度越大\",{\"1\":{\"630\":1}}],[\"跨节点的count\",{\"1\":{\"589\":1}}],[\"跨库跨表的join\",{\"1\":{\"589\":1}}],[\"跨库的join关联查询性能较差\",{\"1\":{\"585\":1}}],[\"跨分片事务也是分布式事务\",{\"1\":{\"589\":1}}],[\"跨分片的事务一致性难以保证\",{\"1\":{\"585\":1}}],[\"跨代引用相对于同代引用来说仅占极少数\",{\"1\":{\"239\":1}}],[\"跨代引用假说\",{\"1\":{\"239\":1}}],[\"跨region\",{\"1\":{\"234\":1}}],[\"熬过越多次垃圾收集过程的对象就越难以消亡\",{\"1\":{\"239\":1}}],[\"强制扩容\",{\"1\":{\"623\":1}}],[\"强制的意思\",{\"1\":{\"425\":1}}],[\"强行推送当前分支到远程仓库\",{\"1\":{\"452\":1}}],[\"强化类型安全\",{\"1\":{\"345\":1}}],[\"强分代假说\",{\"1\":{\"239\":1}}],[\"强引用\",{\"1\":{\"45\":1,\"235\":1}}],[\"绝大部分\",{\"1\":{\"735\":1}}],[\"绝大多数的请求都是纯内存操作\",{\"1\":{\"604\":1}}],[\"绝大多数对象都是朝生夕灭的\",{\"1\":{\"239\":1}}],[\"绝对路径\",{\"1\":{\"418\":1}}],[\"绝对路径与相对路径\",{\"1\":{\"418\":1}}],[\"绝对\",{\"1\":{\"199\":1}}],[\"弱分代假说\",{\"1\":{\"239\":1}}],[\"弱引用可以和一个引用队列\",{\"1\":{\"235\":1}}],[\"弱引用与软引用的区别在于\",{\"1\":{\"235\":1}}],[\"弱引用的\",{\"1\":{\"46\":1}}],[\"弱引用比强引用可以多一层保障\",{\"1\":{\"46\":1}}],[\"弱引用\",{\"1\":{\"45\":1,\"235\":1}}],[\"弱引用相关概念\",{\"1\":{\"45\":1}}],[\"至少一个rtt\",{\"1\":{\"1042\":1}}],[\"至少要经历两次标记过程\",{\"1\":{\"236\":1}}],[\"至于这个connection怎么构造\",{\"1\":{\"718\":1}}],[\"至于update或者delete等修改数据的语句\",{\"1\":{\"572\":1}}],[\"至于具体线程等待队列的维护\",{\"1\":{\"115\":1}}],[\"至20\",{\"1\":{\"265\":1}}],[\"顾名思义就是保证一个类只有一个实例\",{\"1\":{\"1065\":1}}],[\"顾名思义\",{\"1\":{\"235\":1,\"456\":1,\"508\":1,\"667\":1}}],[\"虚方法\",{\"0\":{\"275\":1},\"1\":{\"275\":1}}],[\"虚引用必须和引用队列\",{\"1\":{\"235\":1}}],[\"虚引用与软引用和弱引用的一个区别在于\",{\"1\":{\"235\":1}}],[\"虚引用并不会决定对象的生命周期\",{\"1\":{\"235\":1}}],[\"虚引用\",{\"1\":{\"235\":2}}],[\"虚拟节点越多\",{\"1\":{\"681\":1}}],[\"虚拟节点机制\",{\"1\":{\"681\":1}}],[\"虚拟节点\",{\"1\":{\"681\":1}}],[\"虚拟内存\",{\"0\":{\"157\":1}}],[\"虚拟地址空间所能够访问的地址有\",{\"1\":{\"156\":1}}],[\"虚拟地址和物理地址之间的映射是以页\",{\"1\":{\"156\":1}}],[\"虚拟地址和物理地址之间的映射\",{\"0\":{\"156\":1}}],[\"虚拟的双向队列即不存在队列实例\",{\"1\":{\"110\":1}}],[\"虚拟机\",{\"1\":{\"687\":1}}],[\"虚拟机利用运行时类型信息选择要执行的正确方法\",{\"1\":{\"339\":1}}],[\"虚拟机就会为所有赋值操作生成相应的指令\",{\"1\":{\"250\":1}}],[\"虚拟机就必须维护一个列表\",{\"1\":{\"217\":1}}],[\"虚拟机宁愿抛出\",{\"1\":{\"235\":1}}],[\"虚拟机的设计者们当然知道\",{\"1\":{\"254\":1}}],[\"虚拟机的自动内存管理系统要求对象起始地址必须是\",{\"1\":{\"227\":1}}],[\"虚拟机的类加载机制\",{\"1\":{\"165\":1}}],[\"虚拟机通过这个指针来确定这个对象是哪个类的实例\",{\"1\":{\"225\":1}}],[\"虚拟机中\",{\"1\":{\"224\":1}}],[\"虚拟机中运行\",{\"1\":{\"38\":1}}],[\"虚拟机要对对象进行必要的设置\",{\"1\":{\"222\":1}}],[\"虚拟机必须将分配到的内存空间\",{\"1\":{\"221\":1}}],[\"虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间\",{\"1\":{\"220\":1}}],[\"虚拟机是否使用tlab\",{\"1\":{\"219\":1}}],[\"虚拟机采用\",{\"1\":{\"219\":1}}],[\"虚拟机栈\",{\"1\":{\"188\":1,\"234\":1}}],[\"虚拟机会先初始化这个类\",{\"1\":{\"174\":1}}],[\"虚拟机会实现这种规范\",{\"1\":{\"65\":1}}],[\"虚拟机为每个类都准备了一张方法表来存放类中所有的方法\",{\"1\":{\"172\":1}}],[\"虚拟机直接创建\",{\"1\":{\"168\":1}}],[\"虚拟机直接调用的\",{\"1\":{\"34\":1}}],[\"软状态\",{\"1\":{\"871\":1}}],[\"软件包版本\",{\"0\":{\"1140\":1}}],[\"软件设计也是这样\",{\"1\":{\"1090\":1}}],[\"软件\",{\"1\":{\"457\":1}}],[\"软链接文件有类似于\",{\"1\":{\"427\":1}}],[\"软连接\",{\"1\":{\"427\":1}}],[\"软引用可以和一个引用队列\",{\"1\":{\"235\":1}}],[\"软引用可用来实现内存敏感的高速缓存\",{\"1\":{\"235\":1}}],[\"软引用\",{\"1\":{\"235\":1}}],[\"软中断指令\",{\"1\":{\"134\":1}}],[\"错误的时钟和极端的消息延迟\",{\"1\":{\"873\":1}}],[\"错误日志\",{\"1\":{\"566\":1}}],[\"错误\",{\"1\":{\"235\":1,\"384\":1,\"644\":1}}],[\"错误写法\",{\"1\":{\"26\":1}}],[\"共\",{\"1\":{\"930\":1}}],[\"共需内存2^32\",{\"1\":{\"900\":1}}],[\"共识是可容错系统中的一个基本问题\",{\"1\":{\"873\":1}}],[\"共识算法允许一组节点像一个整体一样一起工作\",{\"1\":{\"873\":1}}],[\"共识算法\",{\"1\":{\"873\":1}}],[\"共同点\",{\"1\":{\"610\":1}}],[\"共同推荐好友\",{\"1\":{\"603\":1}}],[\"共同的关注点\",{\"1\":{\"261\":1}}],[\"共同构成完整gc\",{\"1\":{\"234\":1}}],[\"共享锁是读锁共享\",{\"1\":{\"821\":1}}],[\"共享锁\",{\"1\":{\"509\":1,\"510\":1,\"821\":1}}],[\"共享锁与共享锁之间不排斥\",{\"1\":{\"500\":1}}],[\"共享锁与排他锁之间互相排斥\",{\"1\":{\"500\":1}}],[\"共享锁的概念是一个锁可以有多个线程共享\",{\"1\":{\"81\":1}}],[\"共享\",{\"1\":{\"296\":1}}],[\"共享内存用来实现进程间共享的\",{\"1\":{\"149\":1}}],[\"共享内存是最快的一种\",{\"1\":{\"149\":1}}],[\"共享内存\",{\"1\":{\"149\":1}}],[\"共享式获取\",{\"0\":{\"123\":1}}],[\"共享模式\",{\"1\":{\"115\":1}}],[\"共享变量\",{\"1\":{\"110\":1,\"111\":1}}],[\"地面\",{\"1\":{\"1086\":1}}],[\"地图包括天空\",{\"1\":{\"1086\":1}}],[\"地位\",{\"1\":{\"877\":1}}],[\"地加入\",{\"1\":{\"234\":1}}],[\"地址绑定\",{\"1\":{\"1039\":1}}],[\"地址或报错\",{\"1\":{\"1031\":1}}],[\"地址或主机名作为关键字进行哈希\",{\"1\":{\"681\":1}}],[\"地址告诉本地域名服务器\",{\"1\":{\"1031\":1}}],[\"地址长度为\",{\"1\":{\"996\":1}}],[\"地址改为\",{\"1\":{\"986\":1}}],[\"地址实现\",{\"1\":{\"986\":1}}],[\"地址和\",{\"1\":{\"986\":1}}],[\"地址和端口等信息记录到该节点中去\",{\"1\":{\"861\":1}}],[\"地址和端口号\",{\"1\":{\"612\":1}}],[\"地址应用在\",{\"1\":{\"981\":1}}],[\"地址应用于\",{\"1\":{\"981\":1}}],[\"地址为\",{\"1\":{\"981\":2,\"1210\":1}}],[\"地址虽然也可以更改\",{\"1\":{\"981\":1}}],[\"地址是\",{\"1\":{\"986\":1}}],[\"地址是多少\",{\"1\":{\"986\":1}}],[\"地址是可以更改的\",{\"1\":{\"981\":1}}],[\"地址是哪个设备的了\",{\"1\":{\"961\":1}}],[\"地址是哪个设备的呢\",{\"1\":{\"961\":1}}],[\"地址能否更改不同\",{\"1\":{\"981\":1}}],[\"地址相互识别\",{\"1\":{\"981\":1}}],[\"地址解析协议arp\",{\"0\":{\"986\":1},\"1\":{\"962\":1,\"983\":1}}],[\"地址以后\",{\"1\":{\"959\":1,\"1029\":1}}],[\"地址到显示主页的过程\",{\"0\":{\"959\":1,\"1029\":1}}],[\"地址的需求量越来越大\",{\"1\":{\"996\":1}}],[\"地址的长度为\",{\"1\":{\"996\":1}}],[\"地址的分配是由网卡生产厂家烧入网卡的\",{\"1\":{\"981\":1}}],[\"地址的分配是基于网络拓扑\",{\"1\":{\"981\":1}}],[\"地址的\",{\"1\":{\"892\":1}}],[\"地址进行哈希\",{\"1\":{\"880\":1}}],[\"地址\",{\"1\":{\"426\":1,\"801\":1,\"892\":1,\"959\":2,\"961\":3,\"981\":2,\"986\":1,\"1029\":2,\"1031\":1,\"1179\":1}}],[\"地址转换\",{\"1\":{\"153\":1}}],[\"地址空间不同\",{\"1\":{\"996\":1}}],[\"地址空间\",{\"1\":{\"28\":1,\"139\":1}}],[\"临时使用以下指令从镜像源下载依赖库\",{\"1\":{\"1184\":1}}],[\"临时指定镜像源下载依赖库\",{\"0\":{\"1184\":1}}],[\"临时重定向\",{\"1\":{\"1040\":1}}],[\"临时变量\",{\"1\":{\"930\":1}}],[\"临时变量等\",{\"1\":{\"234\":1}}],[\"临时\",{\"1\":{\"823\":1}}],[\"临时顺序节点create\",{\"1\":{\"818\":1}}],[\"临时节点的生命周期与客户端会话绑定\",{\"1\":{\"818\":1}}],[\"临时目录节点create\",{\"1\":{\"818\":1}}],[\"临时打开\",{\"1\":{\"701\":1}}],[\"临时有序节点可以实现的分布式锁\",{\"1\":{\"668\":1}}],[\"临时性\",{\"1\":{\"234\":1}}],[\"临界区\",{\"1\":{\"142\":1}}],[\"譬如接口或者抽象类中的方法就不存在code属性\",{\"1\":{\"292\":1}}],[\"譬如在内部类中为了保持对外部类的访问性\",{\"1\":{\"289\":1}}],[\"譬如类或接口也可以动态生成\",{\"1\":{\"284\":1}}],[\"譬如把自己\",{\"1\":{\"236\":1}}],[\"譬如字符串常量池\",{\"1\":{\"234\":1}}],[\"譬如java类的引用类型静态变量\",{\"1\":{\"234\":1}}],[\"譬如各个线程被调用的方法堆栈中使用到的参数\",{\"1\":{\"234\":1}}],[\"譬如赋值给类变量或可以在其他线程中访问的实例变量\",{\"1\":{\"202\":1}}],[\"垃圾\",{\"1\":{\"231\":1}}],[\"垃圾收集算法\",{\"0\":{\"238\":1}}],[\"垃圾收集器是不会回收单例对象的\",{\"1\":{\"1075\":1}}],[\"垃圾收集器收集吗\",{\"1\":{\"1075\":1}}],[\"垃圾收集器在新生代中建立了记忆集数据结构\",{\"1\":{\"249\":1}}],[\"垃圾收集器就永远不会回收掉被引用的对象\",{\"1\":{\"235\":1}}],[\"垃圾收集器找到这些需要回收的对象\",{\"1\":{\"231\":1}}],[\"垃圾收集\",{\"0\":{\"231\":1}}],[\"垃圾收集时移动对象是非常普遍的行为\",{\"1\":{\"230\":1}}],[\"垃圾回收\",{\"1\":{\"144\":1}}],[\"垃圾回收线程就是守护线程\",{\"1\":{\"143\":1}}],[\"垃圾回收器一旦发现弱引用的对象\",{\"1\":{\"45\":1}}],[\"垃圾回收器就不会回收这种对象\",{\"1\":{\"45\":1}}],[\"匿名客户\",{\"1\":{\"227\":1}}],[\"匿名管道\",{\"1\":{\"149\":1}}],[\"换句话说\",{\"1\":{\"548\":1}}],[\"换句话说就是对象的大小必须是\",{\"1\":{\"227\":1}}],[\"换言之\",{\"1\":{\"191\":1}}],[\"偏向时间戳\",{\"1\":{\"225\":1}}],[\"偏向锁默认是延迟的\",{\"1\":{\"86\":1}}],[\"偏向锁\",{\"0\":{\"88\":1},\"1\":{\"82\":1,\"84\":1,\"86\":2,\"131\":1}}],[\"空调等\",{\"1\":{\"1079\":1}}],[\"空行和响应体\",{\"1\":{\"1038\":1}}],[\"空行和请求体\",{\"1\":{\"1038\":1}}],[\"空出内存给别的数据页使用\",{\"1\":{\"594\":1}}],[\"空格\",{\"1\":{\"429\":2}}],[\"空指针异常\",{\"1\":{\"385\":1}}],[\"空间复杂度750\",{\"1\":{\"902\":1}}],[\"空间预分配\",{\"1\":{\"624\":1}}],[\"空间\",{\"1\":{\"615\":1}}],[\"空间固定会用完\",{\"1\":{\"573\":1}}],[\"空间索引和全文索引不存储索引列的值\",{\"1\":{\"550\":1}}],[\"空间数据索引等\",{\"1\":{\"492\":1}}],[\"空间效率更高\",{\"1\":{\"475\":1}}],[\"空间整合\",{\"1\":{\"261\":1}}],[\"空间占用和维护成本都很高\",{\"1\":{\"249\":1}}],[\"空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作\",{\"1\":{\"244\":1}}],[\"空间分配担保\",{\"1\":{\"220\":1}}],[\"空闲\",{\"1\":{\"594\":1}}],[\"空闲的内存被放在另一边\",{\"1\":{\"216\":1}}],[\"空闲列表\",{\"0\":{\"217\":1},\"1\":{\"215\":1}}],[\"应答包\",{\"1\":{\"1026\":1}}],[\"应对网络中的不稳定性以及硬件的不稳定性\",{\"1\":{\"873\":1}}],[\"应该使用32位的无符号整数\",{\"1\":{\"997\":1}}],[\"应该叫做\",{\"1\":{\"825\":1}}],[\"应该算的上是\",{\"1\":{\"720\":1}}],[\"应该选择更高效的序列化工具来降低字节数组大小\",{\"1\":{\"637\":1}}],[\"应该指定一个前缀长度\",{\"1\":{\"535\":1}}],[\"应该尽量使用\",{\"1\":{\"475\":1}}],[\"应该尽量使上面两个条件接近等价\",{\"1\":{\"350\":1}}],[\"应该根据具体的情况来决定\",{\"1\":{\"455\":1}}],[\"应该怎么选择呢\",{\"1\":{\"390\":1}}],[\"应避免程序中出现过多的大对象\",{\"1\":{\"220\":1}}],[\"应用数据协议负责将tls承载的应用数据传达给通信对象的协议\",{\"1\":{\"1062\":1}}],[\"应用数据被分割成\",{\"1\":{\"1009\":1}}],[\"应用之间的数据共享和通信\",{\"1\":{\"1035\":1}}],[\"应用层拿数据速度\",{\"1\":{\"1006\":1}}],[\"应用层\",{\"1\":{\"961\":2,\"962\":1}}],[\"应用到自己的状态机中\",{\"1\":{\"875\":1,\"878\":1}}],[\"应用解耦\",{\"1\":{\"840\":1}}],[\"应用服务器往往也会集成\",{\"1\":{\"825\":1}}],[\"应用服务器\",{\"1\":{\"825\":1}}],[\"应用的容器\",{\"1\":{\"825\":1}}],[\"应用的现状\",{\"1\":{\"606\":1}}],[\"应用将会变的非常简单\",{\"1\":{\"770\":1}}],[\"应用\",{\"0\":{\"994\":1,\"1272\":1},\"1\":{\"770\":1,\"1062\":1,\"1077\":1,\"1086\":1}}],[\"应用无需打包成war包\",{\"1\":{\"768\":1}}],[\"应用对数据库的访问中\",{\"1\":{\"606\":1}}],[\"应用端改造较小\",{\"1\":{\"585\":1}}],[\"应用场合\",{\"1\":{\"362\":1}}],[\"应用场景与具体应用\",{\"1\":{\"1079\":1}}],[\"应用场景包括遗传算法\",{\"1\":{\"127\":1}}],[\"应用场景\",{\"0\":{\"261\":1,\"603\":1},\"1\":{\"56\":1,\"435\":1,\"603\":1,\"729\":1,\"759\":1,\"1001\":1,\"1091\":1,\"1092\":1}}],[\"应用举例\",{\"1\":{\"348\":1}}],[\"应用写屏障后\",{\"1\":{\"250\":1}}],[\"应用类是app\",{\"1\":{\"181\":1}}],[\"应用程序的生命周期\",{\"1\":{\"774\":1}}],[\"应用程序\",{\"1\":{\"774\":1}}],[\"应用程序则无需去关心类是如何完成代理的\",{\"1\":{\"718\":1}}],[\"应用程序等\",{\"1\":{\"440\":1}}],[\"应用程序存放目录\",{\"1\":{\"416\":1}}],[\"应用程序进行读写操作调用函数时\",{\"1\":{\"379\":1}}],[\"应用程序类加载器都继承自jdk\",{\"1\":{\"181\":1}}],[\"应用程序类加载器\",{\"0\":{\"178\":1},\"1\":{\"175\":1}}],[\"应用程序只能在用户态运行\",{\"1\":{\"134\":1}}],[\"应用进程利用线程库提供创建\",{\"1\":{\"143\":1}}],[\"预测图片\",{\"1\":{\"1145\":1}}],[\"预测较慢\",{\"1\":{\"1145\":1}}],[\"预计扫描行数\",{\"1\":{\"702\":1}}],[\"预编译后产生的\",{\"1\":{\"597\":1}}],[\"预编译语句对象可以重复利用\",{\"1\":{\"597\":1}}],[\"预编译阶段可以合并多次操作作为一个操作\",{\"1\":{\"597\":1}}],[\"预编译阶段可以优化sql的执行\",{\"1\":{\"597\":1}}],[\"预编译之后的sql多数情况下可以直接执行\",{\"1\":{\"597\":1}}],[\"预编译到\",{\"1\":{\"461\":1,\"596\":1,\"750\":1}}],[\"预处理器\",{\"1\":{\"1210\":1}}],[\"预处理\",{\"1\":{\"489\":1}}],[\"预处理阶段\",{\"1\":{\"162\":1}}],[\"预先在\",{\"1\":{\"219\":1}}],[\"配套的提交语句是\",{\"1\":{\"526\":1}}],[\"配置文档地址\",{\"1\":{\"1208\":1}}],[\"配置文件没指定字符集\",{\"1\":{\"1178\":1}}],[\"配置文件目录\",{\"1\":{\"1177\":1}}],[\"配置文件由父\",{\"1\":{\"783\":1}}],[\"配置文件这个容易理解\",{\"1\":{\"783\":1}}],[\"配置文件的方式\",{\"1\":{\"739\":1}}],[\"配置文件的权限\",{\"1\":{\"422\":1}}],[\"配置文件\",{\"1\":{\"729\":2,\"783\":1,\"1266\":2}}],[\"配置本地\",{\"0\":{\"1202\":1}}],[\"配置全局镜像源\",{\"0\":{\"1185\":1}}],[\"配置镜像源\",{\"1\":{\"1143\":1}}],[\"配置拒绝帧\",{\"1\":{\"975\":1}}],[\"配置否认帧\",{\"1\":{\"975\":1}}],[\"配置确认帧\",{\"1\":{\"975\":1}}],[\"配置和测试数据链路连接的链路控制协议lcp\",{\"1\":{\"975\":1}}],[\"配置类将必须扩展websecurityconfigureradapter并覆盖其方法\",{\"1\":{\"789\":1}}],[\"配置有序很关键\",{\"1\":{\"785\":1}}],[\"配置有序\",{\"1\":{\"785\":1}}],[\"配置在应用程序上下文的引导阶段生效\",{\"1\":{\"783\":1}}],[\"配置在path环境中的\",{\"1\":{\"282\":1}}],[\"配置也同样在spring的配置文件中进行\",{\"1\":{\"764\":1}}],[\"配置的所有相关的对象\",{\"1\":{\"755\":1}}],[\"配置要创建的对象类\",{\"1\":{\"729\":1}}],[\"配置autoproxycreator\",{\"1\":{\"728\":1}}],[\"配置proxyfactorybean\",{\"1\":{\"728\":1}}],[\"配置可以通过xml文件来进行\",{\"1\":{\"728\":1}}],[\"配置这些对象\",{\"1\":{\"718\":1}}],[\"配置中心和客户端通知\",{\"1\":{\"676\":1}}],[\"配置中的\",{\"1\":{\"565\":1}}],[\"配置value最大为512字节\",{\"1\":{\"622\":1}}],[\"配置字段最多64个\",{\"1\":{\"622\":1}}],[\"配置\",{\"0\":{\"446\":1,\"1196\":1,\"1200\":1,\"1270\":1},\"1\":{\"1202\":1,\"1208\":1}}],[\"配上失败重试的方式保证更新操作的原子性\",{\"1\":{\"219\":1}}],[\"配合db权限表对给定主机上数据库级操作权限做更细致的控制\",{\"1\":{\"458\":1}}],[\"配合可以实现等待\",{\"1\":{\"126\":1}}],[\"配合可以用来获取异步执行的结果\",{\"1\":{\"33\":1}}],[\"配合\",{\"1\":{\"32\":1}}],[\"既不合并也不拆分\",{\"1\":{\"1002\":1}}],[\"既然无法伪造\",{\"1\":{\"1061\":1}}],[\"既然\",{\"1\":{\"671\":1}}],[\"既然只依靠\",{\"1\":{\"577\":1}}],[\"既然是基于多版本\",{\"1\":{\"499\":1}}],[\"既是链表的开始也是链表的结尾\",{\"1\":{\"392\":1}}],[\"既简单又高效\",{\"1\":{\"218\":1}}],[\"既支持非公平锁又支持公平锁\",{\"1\":{\"81\":1}}],[\"记为b0\",{\"1\":{\"896\":1}}],[\"记为a0\",{\"1\":{\"896\":1}}],[\"记为\",{\"1\":{\"895\":2}}],[\"记为x0\",{\"1\":{\"894\":1}}],[\"记住一个原则\",{\"1\":{\"383\":1}}],[\"记作c\",{\"1\":{\"278\":1}}],[\"记录下来\",{\"1\":{\"1003\":1}}],[\"记录下的在并发时有引用变动的对象\",{\"1\":{\"264\":1}}],[\"记录每个分数的的个数就可以了\",{\"1\":{\"902\":1}}],[\"记录每次对数据的操作到硬盘上\",{\"1\":{\"646\":1}}],[\"记录失败请求\",{\"1\":{\"813\":1}}],[\"记录当前获得锁的机器的主机信息和线程信息\",{\"1\":{\"668\":1}}],[\"记录的都是数据库中数据的最新状态\",{\"1\":{\"651\":1}}],[\"记录的是这个语句的原始逻辑\",{\"1\":{\"573\":1}}],[\"记录的是在具体某个数据页上做了什么修改\",{\"1\":{\"573\":1}}],[\"记录的是每一行的数据变更\",{\"1\":{\"566\":1}}],[\"记录没有写回磁盘\",{\"1\":{\"650\":1}}],[\"记录跳跃表的长度\",{\"1\":{\"630\":1}}],[\"记录目前跳跃表内\",{\"1\":{\"630\":1}}],[\"记录buf数组中未使用字节的数量\",{\"1\":{\"624\":1}}],[\"记录duf数组中已使用字节的数量\",{\"1\":{\"624\":1}}],[\"记录就很适合使用\",{\"1\":{\"603\":1}}],[\"记录就会顺序添加到当前索引节点的后续位置\",{\"1\":{\"466\":1}}],[\"记录对数据的更改内容\",{\"1\":{\"568\":1}}],[\"记录了客户端所有的查询语句\",{\"1\":{\"566\":1}}],[\"记录了所有执行时间超过参数\",{\"1\":{\"566\":1}}],[\"记录了所有\",{\"1\":{\"566\":1}}],[\"记录\",{\"1\":{\"566\":1,\"624\":1}}],[\"记录锁永远锁的是索引\",{\"1\":{\"503\":1}}],[\"记录锁\",{\"0\":{\"503\":1}}],[\"记录数据列级的操作权限\",{\"1\":{\"458\":1}}],[\"记录数据表级的操作权限\",{\"1\":{\"458\":1}}],[\"记录各个账号在各个数据库上的操作权限\",{\"1\":{\"458\":1}}],[\"记录允许连接到服务器的用户账号信息\",{\"1\":{\"458\":1}}],[\"记录方法的各个形参名称和信息\",{\"1\":{\"292\":1}}],[\"记录上哪些内存块是可用的\",{\"1\":{\"217\":1}}],[\"记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构\",{\"1\":{\"249\":1}}],[\"记忆集\",{\"1\":{\"249\":1}}],[\"记忆集与卡表\",{\"0\":{\"249\":1}}],[\"记得要修改状态\",{\"1\":{\"72\":1}}],[\"两位\",{\"1\":{\"900\":1}}],[\"两层\",{\"1\":{\"880\":1}}],[\"两条指令\",{\"1\":{\"665\":1}}],[\"两端的\",{\"1\":{\"660\":1}}],[\"两者的性能都非常高\",{\"1\":{\"610\":1}}],[\"两者都应该依赖其抽象\",{\"1\":{\"1064\":1}}],[\"两者都是存放\",{\"1\":{\"607\":1}}],[\"两者都是通过读写分离的思想实现\",{\"1\":{\"411\":1}}],[\"两者都不是线程安全的\",{\"1\":{\"408\":1}}],[\"两者都基于键存储值\",{\"1\":{\"408\":1}}],[\"两点来看这个事情\",{\"1\":{\"606\":1}}],[\"两次写\",{\"0\":{\"593\":1}}],[\"两次读到的数据是不一样的\",{\"1\":{\"521\":1}}],[\"两阶段提交\",{\"1\":{\"589\":1}}],[\"两阶段提交的方式就不一样了\",{\"1\":{\"578\":1}}],[\"两台salve只负责读操作\",{\"1\":{\"579\":1}}],[\"两二阶段提交\",{\"0\":{\"578\":1}}],[\"两部分\",{\"1\":{\"292\":1}}],[\"两个不兼容的接口之间的桥梁\",{\"1\":{\"1092\":1}}],[\"两个原因\",{\"1\":{\"1027\":1}}],[\"两个原则\",{\"1\":{\"515\":1}}],[\"两个函数\",{\"1\":{\"647\":1}}],[\"两个缓冲区\",{\"1\":{\"612\":1}}],[\"两个优化\",{\"1\":{\"515\":1}}],[\"两个重要参数\",{\"1\":{\"486\":1}}],[\"两个文件名指向同一个文件\",{\"1\":{\"427\":1}}],[\"两个\",{\"1\":{\"368\":1}}],[\"两个对象的\",{\"0\":{\"341\":1},\"1\":{\"341\":1}}],[\"两个字段的数据类型\",{\"1\":{\"289\":1}}],[\"两个线程通过\",{\"1\":{\"127\":1}}],[\"两根红线的搭配remove了\",{\"1\":{\"252\":1}}],[\"两种代理的区别\",{\"0\":{\"727\":1}}],[\"两种格式\",{\"1\":{\"566\":1}}],[\"两种触发模式\",{\"1\":{\"381\":1}}],[\"两种方式的优劣\",{\"1\":{\"230\":1}}],[\"两种\",{\"1\":{\"215\":1}}],[\"反向代理对于客户端而言隐藏了目标服务器ip地址\",{\"1\":{\"826\":1}}],[\"反向代理\",{\"0\":{\"826\":1},\"1\":{\"826\":1,\"827\":1}}],[\"反向的重复前一个搜寻\",{\"1\":{\"429\":1}}],[\"反应数据的新旧程度\",{\"1\":{\"820\":1}}],[\"反而增加了change\",{\"1\":{\"574\":1}}],[\"反编译成字节码之后\",{\"1\":{\"391\":1}}],[\"反序列化\",{\"1\":{\"356\":1}}],[\"反射比正常生成对象在效率上慢一点\",{\"1\":{\"731\":1}}],[\"反射\",{\"1\":{\"356\":1}}],[\"反射代码破坏了抽象性\",{\"1\":{\"348\":1}}],[\"反射操作的效率要比那些非反射操作低得多\",{\"1\":{\"348\":1}}],[\"反射涉及了动态类型的解析\",{\"1\":{\"348\":1}}],[\"反射可以提供运行时的类信息\",{\"1\":{\"348\":1}}],[\"反射及其应用场景\",{\"0\":{\"348\":1}}],[\"反射的方式\",{\"1\":{\"212\":2}}],[\"反映java虚拟机内部情况的jmxbean\",{\"1\":{\"234\":1}}],[\"反之不行\",{\"1\":{\"285\":1}}],[\"反之\",{\"1\":{\"91\":1,\"574\":1,\"1019\":1}}],[\"回送请求和回答\",{\"1\":{\"993\":1}}],[\"回来执行过滤器放行下边的代码\",{\"1\":{\"759\":1}}],[\"回表查询\",{\"0\":{\"549\":1},\"1\":{\"549\":1}}],[\"回滚语句是\",{\"1\":{\"526\":1}}],[\"回滚段被清理\",{\"1\":{\"525\":1}}],[\"回滚段等\",{\"1\":{\"498\":1}}],[\"回滚日志是跟数据字典一起放在\",{\"1\":{\"525\":1}}],[\"回滚日志\",{\"1\":{\"519\":1}}],[\"回滚\",{\"1\":{\"483\":1}}],[\"回调函数\",{\"1\":{\"414\":1}}],[\"回收对象前会先调用这个对象的\",{\"1\":{\"346\":1}}],[\"回收\",{\"1\":{\"300\":1,\"392\":1}}],[\"回收阶段可以与用户线程并发\",{\"1\":{\"267\":1}}],[\"回收所获得的空间大小以及回收所需时间的经验值\",{\"1\":{\"260\":1}}],[\"回收策略等都与serial收集器完全一致\",{\"1\":{\"255\":1}}],[\"回收效率低\",{\"1\":{\"207\":1}}],[\"回溯\",{\"0\":{\"10\":1}}],[\"永久重定向\",{\"1\":{\"1040\":1}}],[\"永久打开\",{\"1\":{\"701\":1}}],[\"永久代不足的时候才会触发\",{\"1\":{\"207\":1}}],[\"永久代为何被元空间替代\",{\"0\":{\"206\":1}}],[\"永不过期\",{\"1\":{\"643\":1}}],[\"永远不会覆盖已经存在的日志条目\",{\"1\":{\"878\":1}}],[\"永远无法被gc\",{\"1\":{\"300\":1}}],[\"永远执行不完\",{\"1\":{\"99\":1}}],[\"完整版\",{\"1\":{\"1070\":1}}],[\"完善的\",{\"1\":{\"804\":1}}],[\"完全二叉树\",{\"1\":{\"937\":1}}],[\"完全由c语言写成\",{\"1\":{\"824\":1}}],[\"完全由操作系统来完成请求的处理\",{\"1\":{\"380\":1}}],[\"完全可以独立进行\",{\"1\":{\"766\":1}}],[\"完全可以将\",{\"1\":{\"582\":1}}],[\"完全注解开发\",{\"1\":{\"743\":1}}],[\"完全不用考虑对象是如何创建出来的\",{\"1\":{\"718\":1}}],[\"完全依赖\",{\"1\":{\"650\":1}}],[\"完全基于内存\",{\"1\":{\"604\":1}}],[\"完全服从\",{\"1\":{\"522\":1,\"741\":1}}],[\"完全相等的行\",{\"1\":{\"485\":1}}],[\"完全废弃了永久代\",{\"1\":{\"203\":1}}],[\"完成领域对象分析之后\",{\"1\":{\"1219\":1}}],[\"完成复杂产品的各个部件的具体创建方法\",{\"1\":{\"1086\":1}}],[\"完成具体产品的创建\",{\"1\":{\"1079\":1}}],[\"完成之后才可以真正传输业务数据\",{\"1\":{\"1042\":1}}],[\"完成一些特殊的功能\",{\"1\":{\"759\":1}}],[\"完成一些特定功能\",{\"1\":{\"338\":1}}],[\"完成的\",{\"1\":{\"712\":1}}],[\"完成的通知\",{\"1\":{\"380\":1}}],[\"完成公共组件的封装\",{\"1\":{\"695\":1}}],[\"完成任务的过程中\",{\"1\":{\"691\":1}}],[\"完成业务\",{\"1\":{\"691\":1}}],[\"完成业务流程后\",{\"1\":{\"668\":1}}],[\"完成项目\",{\"1\":{\"690\":1}}],[\"完成对快照文件的加载\",{\"1\":{\"655\":1}}],[\"完成后代开\",{\"1\":{\"1202\":1}}],[\"完成后自动结束\",{\"1\":{\"647\":1}}],[\"完成后对原有文件进行替换\",{\"1\":{\"647\":1}}],[\"完成后\",{\"1\":{\"647\":1,\"1042\":1}}],[\"完成后也会把结果缓存起来\",{\"1\":{\"490\":1}}],[\"完成元素判重的过程\",{\"1\":{\"645\":1}}],[\"完成这\",{\"1\":{\"490\":1}}],[\"完成\",{\"1\":{\"101\":1,\"623\":1}}],[\"符号引⽤\",{\"1\":{\"203\":1}}],[\"符号引用则属于编译原理方面的概念\",{\"1\":{\"286\":1}}],[\"符号引用以一组符号来描述所引用的目标\",{\"1\":{\"172\":1}}],[\"符号引用\",{\"1\":{\"172\":1}}],[\"符号引用验证的目的是确保解析动作能正常执行\",{\"1\":{\"170\":1}}],[\"符号引用验证\",{\"1\":{\"170\":1}}],[\"运输层的端口号分为\",{\"1\":{\"1000\":1}}],[\"运输层提供应用进程间的逻辑通信\",{\"1\":{\"997\":1,\"999\":1}}],[\"运输层向上面的应用层提供通信服务\",{\"1\":{\"997\":1}}],[\"运输层\",{\"1\":{\"961\":1}}],[\"运维的各种复杂度\",{\"1\":{\"561\":1}}],[\"运算符\",{\"1\":{\"943\":1}}],[\"运算\",{\"1\":{\"397\":1,\"398\":1}}],[\"运⾏时常量池\",{\"1\":{\"203\":4}}],[\"运行的安全性\",{\"1\":{\"1055\":1}}],[\"运行域名服务器程序的机器称为域名服务器\",{\"1\":{\"1030\":1}}],[\"运行在不同网络下的机器中的进程如何共享资源\",{\"1\":{\"873\":1}}],[\"运行在不同网络下的机器中的进程如何判断一些事件的发生顺序\",{\"1\":{\"873\":1}}],[\"运行在虚拟机之上\",{\"1\":{\"337\":1}}],[\"运行需要的标准类库\",{\"1\":{\"825\":1}}],[\"运行服务提供者\",{\"1\":{\"811\":1}}],[\"运行你的\",{\"1\":{\"774\":1}}],[\"运行机制\",{\"1\":{\"659\":1}}],[\"运行效率比\",{\"1\":{\"652\":1}}],[\"运行期类型的判断\",{\"1\":{\"348\":1}}],[\"运行期不可变\",{\"1\":{\"274\":1}}],[\"运行jar包\",{\"1\":{\"317\":1}}],[\"运行时动态生成\",{\"1\":{\"1081\":1}}],[\"运行时动态生成的一个对象\",{\"1\":{\"349\":1}}],[\"运行时可以输入的命令有\",{\"1\":{\"429\":1}}],[\"运行时异常\",{\"1\":{\"385\":1}}],[\"运行时异常与受检异常\",{\"0\":{\"385\":1}}],[\"运行时异常和编译时异常\",{\"1\":{\"384\":1}}],[\"运行时被读取\",{\"1\":{\"338\":1}}],[\"运行时环境\",{\"1\":{\"335\":1}}],[\"运行时类型\",{\"1\":{\"277\":1}}],[\"运行时常量池除了包含编译期已经明确的量\",{\"1\":{\"208\":1}}],[\"运行时常量池是方法区的一部分\",{\"1\":{\"208\":2}}],[\"运行时常量池\",{\"0\":{\"208\":1}}],[\"运行时栈帧结构\",{\"0\":{\"191\":1}}],[\"运行时数据区\",{\"0\":{\"188\":1}}],[\"运行时计算生成\",{\"1\":{\"168\":1}}],[\"运行时间\",{\"1\":{\"150\":1}}],[\"运行时元数据\",{\"1\":{\"85\":1,\"86\":1}}],[\"运行时元数据和类型指针\",{\"1\":{\"84\":1}}],[\"运行\",{\"1\":{\"148\":3,\"336\":1}}],[\"运行状态\",{\"1\":{\"148\":1}}],[\"运行新任务\",{\"1\":{\"144\":1}}],[\"运行过程产生的各种数据\",{\"1\":{\"136\":1}}],[\"⽅法\",{\"1\":{\"203\":1}}],[\"⽅法区主要是⽤来存放已被虚拟机加载的\",{\"1\":{\"203\":1}}],[\"甚至在\",{\"1\":{\"1134\":1}}],[\"甚至在编译时期该类的\",{\"1\":{\"348\":1}}],[\"甚至是机房宕掉\",{\"1\":{\"642\":1}}],[\"甚至是参数顺序\",{\"1\":{\"359\":1}}],[\"甚至全部\",{\"1\":{\"381\":1}}],[\"甚至还有可能被外部线程访问到\",{\"1\":{\"202\":1}}],[\"甚至jvm的某些部分就是用c写的\",{\"1\":{\"197\":1}}],[\"称之为表空间\",{\"1\":{\"498\":1}}],[\"称其逃逸到了方法外部\",{\"1\":{\"202\":1}}],[\"称为分布式拒绝服务dos\",{\"1\":{\"1054\":1}}],[\"称为即插即用联网\",{\"1\":{\"1049\":1}}],[\"称为quic\",{\"1\":{\"1042\":1}}],[\"称为慢开始\",{\"1\":{\"1019\":1}}],[\"称为拥塞避免\",{\"1\":{\"1019\":1}}],[\"称为拥塞\",{\"1\":{\"1019\":1}}],[\"称为比特差错\",{\"1\":{\"974\":1}}],[\"称为密集波分复用\",{\"1\":{\"967\":1}}],[\"称为大顶堆\",{\"1\":{\"937\":1}}],[\"称为散列函数\",{\"1\":{\"922\":1}}],[\"称为虚拟节点\",{\"1\":{\"681\":1}}],[\"称为\",{\"1\":{\"681\":1,\"820\":2}}],[\"称为覆盖索引\",{\"1\":{\"550\":1}}],[\"称为自适应哈希索引\",{\"1\":{\"496\":1}}],[\"称为索引节点号\",{\"1\":{\"427\":1}}],[\"称为变量的\",{\"1\":{\"277\":1}}],[\"称为这个元素变脏\",{\"1\":{\"249\":1}}],[\"称为线程逃逸\",{\"1\":{\"202\":1}}],[\"称为方法逃逸\",{\"1\":{\"202\":1}}],[\"称为栈帧信息\",{\"1\":{\"196\":1}}],[\"称为当前栈帧\",{\"1\":{\"191\":1}}],[\"目标\",{\"1\":{\"1092\":1,\"1127\":1}}],[\"目标类和代理类都实现了同样的接口\",{\"1\":{\"1084\":1}}],[\"目标类和代理都要实现该方法\",{\"1\":{\"1082\":1}}],[\"目标系统运行缓慢\",{\"1\":{\"1060\":1}}],[\"目标服务器宕机后\",{\"1\":{\"869\":1}}],[\"目标方法抛出异常后调用\",{\"1\":{\"722\":1}}],[\"目标方法被调用之后调用\",{\"1\":{\"722\":1}}],[\"目标方法被调用之前调用\",{\"1\":{\"722\":1}}],[\"目标对象\",{\"1\":{\"715\":1}}],[\"目标页可能不在内存中\",{\"1\":{\"466\":1}}],[\"目标档\",{\"1\":{\"423\":1}}],[\"目录中\",{\"1\":{\"1161\":1}}],[\"目录下才是我们的代码\",{\"1\":{\"790\":1}}],[\"目录下\",{\"1\":{\"647\":1}}],[\"目录或文件名\",{\"1\":{\"441\":1}}],[\"目录名\",{\"1\":{\"422\":1}}],[\"目录名称\",{\"1\":{\"418\":1,\"422\":1}}],[\"目录\",{\"1\":{\"416\":1,\"420\":3,\"428\":1,\"430\":1,\"1134\":1,\"1136\":1,\"1200\":1,\"1212\":1}}],[\"目前也有一些开源程序利用\",{\"1\":{\"1004\":1}}],[\"目前广泛使用了循环冗余检验crc的检错技术\",{\"1\":{\"974\":1}}],[\"目前用的比较少\",{\"1\":{\"965\":1}}],[\"目前处理请求最少的服务器\",{\"1\":{\"869\":1}}],[\"目前处理死锁的方法是将持有最少行级\",{\"1\":{\"516\":1}}],[\"目前有\",{\"1\":{\"820\":1}}],[\"目前只支持具有相同\",{\"1\":{\"678\":1}}],[\"目前只有g1收集器会有这种行为\",{\"1\":{\"240\":1}}],[\"目前只有cms收集器会有单独收集老年代的行为\",{\"1\":{\"240\":1}}],[\"目前分布式锁有三种流行方案\",{\"1\":{\"668\":1}}],[\"目前是原生支持\",{\"1\":{\"610\":1}}],[\"目前已出现事务id的最大值+1\",{\"1\":{\"499\":1}}],[\"目前已经弃用\",{\"1\":{\"489\":1}}],[\"目前已不推荐使用\",{\"1\":{\"259\":1}}],[\"目前很大一部分的java应用集中在互联网网站或者基于浏览器的b\",{\"1\":{\"259\":1}}],[\"目前所有的对象实例还是在堆上分配的\",{\"1\":{\"202\":1}}],[\"目的端口\",{\"1\":{\"1002\":1}}],[\"目的网络地址\",{\"1\":{\"990\":1}}],[\"目的减少网络传输的数据量\",{\"1\":{\"804\":1}}],[\"目的很简单\",{\"1\":{\"579\":1}}],[\"目的是检测数据在传输过程中的任何变化\",{\"1\":{\"1009\":1}}],[\"目的是与java堆区分开来\",{\"1\":{\"203\":1}}],[\"目的是保证不存在不符合\",{\"1\":{\"170\":1}}],[\"目的是为了保证系统程序不被应用程序有意或无意的破坏\",{\"1\":{\"134\":1}}],[\"目的\",{\"1\":{\"86\":1,\"170\":1,\"245\":1,\"309\":1,\"1019\":1,\"1035\":2}}],[\"|\",{\"0\":{\"438\":1},\"1\":{\"201\":1,\"424\":1,\"436\":1,\"438\":1,\"443\":2,\"551\":1,\"702\":5,\"707\":2,\"943\":1,\"1168\":1,\"1190\":1}}],[\"||\",{\"1\":{\"58\":5,\"908\":1,\"912\":1,\"913\":1,\"930\":1,\"932\":1,\"934\":1,\"937\":1,\"1140\":1}}],[\"工程结构\",{\"0\":{\"1237\":1}}],[\"工程启动的时候进行加载缓存动作\",{\"1\":{\"640\":1}}],[\"工厂方法模式退化成简单工厂模式\",{\"1\":{\"1080\":1}}],[\"工厂方法模式只生产一个等级的产品\",{\"1\":{\"1079\":1}}],[\"工厂方法模式只考虑生产同等级的产品\",{\"1\":{\"1079\":1}}],[\"工厂方法模式将生成具体产品的任务分发给具体的产品工厂\",{\"1\":{\"1078\":1}}],[\"工厂方法模式\",{\"0\":{\"1078\":1}}],[\"工厂方法代码将会非常复杂\",{\"1\":{\"1077\":1}}],[\"工厂方法实例化\",{\"1\":{\"730\":1}}],[\"工厂类不够灵活\",{\"1\":{\"1077\":1}}],[\"工厂设计模式\",{\"1\":{\"742\":1}}],[\"工厂模式的退化\",{\"0\":{\"1080\":1}}],[\"工厂模式的优点\",{\"1\":{\"712\":1}}],[\"工厂模式最大优点是\",{\"1\":{\"1076\":1}}],[\"工厂模式是把创建对象的任务交给工厂\",{\"1\":{\"712\":1}}],[\"工厂模式\",{\"0\":{\"712\":1,\"1076\":1,\"1247\":1},\"1\":{\"348\":1}}],[\"工具查看\",{\"1\":{\"566\":1}}],[\"工具\",{\"0\":{\"311\":1,\"1198\":1},\"1\":{\"201\":2}}],[\"工作流的读写权限\",{\"1\":{\"1199\":1}}],[\"工作流程\",{\"0\":{\"755\":1}}],[\"工作目录\",{\"1\":{\"1121\":1}}],[\"工作原理\",{\"1\":{\"1013\":1}}],[\"工作者\",{\"1\":{\"833\":1}}],[\"工作量大\",{\"1\":{\"749\":1}}],[\"工作区有一个隐藏目录\",{\"1\":{\"444\":1}}],[\"工作区\",{\"1\":{\"444\":2}}],[\"工作过程中\",{\"1\":{\"689\":1}}],[\"工作过程可分为4个阶段\",{\"1\":{\"268\":1}}],[\"工作过程\",{\"1\":{\"184\":1}}],[\"工作内存与主内存同步延迟\",{\"1\":{\"295\":1}}],[\"工作内存中保存被该线程使用的变量的主内存副本\",{\"1\":{\"74\":1}}],[\"工作内存\",{\"1\":{\"66\":1,\"74\":4,\"79\":1}}],[\"工作队列\",{\"1\":{\"58\":1}}],[\"显式地设置advisors\",{\"1\":{\"728\":1}}],[\"显式启动事务语句\",{\"1\":{\"526\":1}}],[\"显卡等设备驱动程序的对象\",{\"1\":{\"713\":1}}],[\"显然\",{\"1\":{\"1075\":1}}],[\"显然声明式事务管理要优于编程式事务管理\",{\"1\":{\"739\":1}}],[\"显然成本太大\",{\"1\":{\"533\":1}}],[\"显然是为了让子类覆盖而设计的\",{\"1\":{\"39\":1}}],[\"显示索引的哪一列被使用了\",{\"1\":{\"556\":1}}],[\"显示查询使用了何种类型\",{\"1\":{\"556\":1}}],[\"显示访问类型\",{\"1\":{\"556\":1}}],[\"显示为\",{\"1\":{\"476\":1}}],[\"显示某次提交时\",{\"1\":{\"449\":1}}],[\"显示某次提交发生变化的文件\",{\"1\":{\"449\":1}}],[\"显示某次提交的元数据和内容变化\",{\"1\":{\"449\":1}}],[\"显示某个远程仓库的信息\",{\"1\":{\"452\":1}}],[\"显示某个文件的版本历史\",{\"1\":{\"449\":1}}],[\"显示某个commit之后的所有变动\",{\"1\":{\"449\":2}}],[\"显示今天你写了多少行代码\",{\"1\":{\"449\":1}}],[\"显示两次提交之间的差异\",{\"1\":{\"449\":1}}],[\"显示工作区与当前分支最新commit之间的差异\",{\"1\":{\"449\":1}}],[\"显示暂存区和上一个commit的差异\",{\"1\":{\"449\":1}}],[\"显示暂存区和工作区的差异\",{\"1\":{\"449\":1}}],[\"显示指定文件是什么人在什么时间修改过\",{\"1\":{\"449\":1}}],[\"显示指定文件相关的每一次diff\",{\"1\":{\"449\":1}}],[\"显示过去5次提交\",{\"1\":{\"449\":1}}],[\"显示commit历史\",{\"1\":{\"449\":1}}],[\"显示有变更的文件\",{\"1\":{\"449\":1}}],[\"显示文件当前的状态\",{\"1\":{\"449\":1}}],[\"显示当前分支的最近几次提交\",{\"1\":{\"449\":1}}],[\"显示当前分支的版本历史\",{\"1\":{\"449\":1}}],[\"显示当前的git配置\",{\"1\":{\"446\":1}}],[\"显示当前运行的进程\",{\"1\":{\"436\":1}}],[\"显示进程的pid和名字\",{\"1\":{\"435\":1}}],[\"显示进程运行信息列表\",{\"1\":{\"201\":1}}],[\"显示各种网络相关信息\",{\"1\":{\"435\":1}}],[\"显示行号\",{\"1\":{\"434\":1}}],[\"显示的时候\",{\"1\":{\"428\":1}}],[\"显示所有操作命令\",{\"1\":{\"823\":1}}],[\"显示所有远程仓库\",{\"1\":{\"452\":1}}],[\"显示所有提交过的用户\",{\"1\":{\"449\":1}}],[\"显示所有连接和监听端口\",{\"1\":{\"435\":1}}],[\"显示所有的程序\",{\"1\":{\"426\":1}}],[\"显示所有程序\",{\"1\":{\"426\":2}}],[\"显示树状结构\",{\"1\":{\"426\":1}}],[\"显示每个程序所使用的环境变量\",{\"1\":{\"426\":1}}],[\"显示每个程序真正的指令名称\",{\"1\":{\"426\":1}}],[\"显示现行终端机下的所有程序\",{\"1\":{\"426\":1}}],[\"显示出确实的路径\",{\"1\":{\"421\":1}}],[\"显示目前所在的目录\",{\"0\":{\"421\":1}}],[\"显示目前的目录\",{\"1\":{\"418\":1}}],[\"显示一个进程的线程运行信息列表\",{\"1\":{\"201\":1}}],[\"假定路由器对于某些分组的处理时间特别长\",{\"1\":{\"1021\":1}}],[\"假若\",{\"1\":{\"369\":1}}],[\"假如客户端主机突然坏了\",{\"1\":{\"1028\":1}}],[\"假如说要找到\",{\"1\":{\"919\":1}}],[\"假如10000个连接变动了1个\",{\"1\":{\"829\":1}}],[\"假如用户第一次访问数据库中的某些数据\",{\"1\":{\"606\":1}}],[\"假如使用的是单表设计\",{\"1\":{\"601\":1}}],[\"假如一个服务器开放\",{\"1\":{\"582\":1}}],[\"假如\",{\"1\":{\"559\":1}}],[\"假如在1\",{\"1\":{\"1049\":1}}],[\"假如在\",{\"1\":{\"553\":1}}],[\"假如在5\",{\"1\":{\"553\":1}}],[\"假如在创建新的对象时\",{\"1\":{\"200\":1}}],[\"假如你对一个表更新的话\",{\"1\":{\"490\":1}}],[\"假如和通过key\",{\"1\":{\"405\":1}}],[\"假如输入的数组长度是\",{\"1\":{\"404\":1}}],[\"假如此字符串值已经存在于常量池中\",{\"1\":{\"369\":1}}],[\"假如大于\",{\"1\":{\"331\":1}}],[\"假如我们不做任何措施的话\",{\"1\":{\"300\":1}}],[\"假如对象没有覆盖finalize\",{\"1\":{\"236\":1}}],[\"假设发送方为\",{\"1\":{\"1057\":1}}],[\"假设不采用\",{\"1\":{\"1022\":1}}],[\"假设a给b发送了1\",{\"1\":{\"1019\":1}}],[\"假设a向b发送数据\",{\"1\":{\"1013\":1}}],[\"假设mtu=1500\",{\"1\":{\"982\":1}}],[\"假设要处理的数据很大\",{\"1\":{\"919\":1}}],[\"假设这40亿个数开始放在一个文件中\",{\"1\":{\"901\":1}}],[\"假设这些机子排名在1000个之前的那些都是单独分布在一台机子上的\",{\"1\":{\"891\":1}}],[\"假设哈希函数足够优秀\",{\"1\":{\"897\":1}}],[\"假设hash函数是随机的\",{\"1\":{\"895\":1}}],[\"假设目前有一千万个记录\",{\"1\":{\"893\":1}}],[\"假设总数据条数为\",{\"1\":{\"880\":1}}],[\"假设nginx有一个master\",{\"1\":{\"836\":1}}],[\"假设有\",{\"1\":{\"672\":1}}],[\"假设有冲突则判断当前数据结构是链表还是红黑树\",{\"1\":{\"398\":1}}],[\"假设是单机\",{\"1\":{\"579\":1}}],[\"假设事务\",{\"1\":{\"578\":1}}],[\"假设写完了\",{\"1\":{\"578\":1}}],[\"假设写完\",{\"1\":{\"578\":1}}],[\"假设一个业务的更新模式是写入之后马上会做查询\",{\"1\":{\"574\":1}}],[\"假设一张表几十w\",{\"1\":{\"541\":1}}],[\"假设一行数据的大小是\",{\"1\":{\"539\":1}}],[\"假设聚簇索引为name\",{\"1\":{\"501\":2}}],[\"假设没有冲突直接返回\",{\"1\":{\"398\":1}}],[\"假设\",{\"1\":{\"397\":1,\"555\":1,\"657\":1,\"820\":1}}],[\"假设java堆中内存是绝对规整的\",{\"1\":{\"216\":1}}],[\"假设使用\",{\"1\":{\"131\":1}}],[\"出于效率的考虑\",{\"1\":{\"993\":1}}],[\"出队列\",{\"1\":{\"941\":1}}],[\"出现差错情况\",{\"1\":{\"1010\":1}}],[\"出现在分支结点中的元素会被当做它们在该分支节点位置的中序后继者\",{\"1\":{\"920\":1}}],[\"出现的一个不安全分子\",{\"1\":{\"1057\":1}}],[\"出现的次数\",{\"1\":{\"895\":1}}],[\"出现的错误\",{\"1\":{\"200\":1}}],[\"出现一次\",{\"1\":{\"895\":1}}],[\"出现次数的\",{\"1\":{\"893\":1}}],[\"出现次数为\",{\"1\":{\"892\":1}}],[\"出现异常时\",{\"1\":{\"813\":1}}],[\"出现故障时\",{\"1\":{\"676\":1}}],[\"出现断开重连后\",{\"1\":{\"655\":1}}],[\"出现问题时\",{\"1\":{\"655\":1,\"661\":1}}],[\"出现问题\",{\"1\":{\"644\":1}}],[\"出现这种情况\",{\"1\":{\"594\":1}}],[\"出现数据不一致的情况\",{\"1\":{\"578\":1}}],[\"出来的\",{\"1\":{\"368\":1}}],[\"出栈\",{\"1\":{\"190\":1}}],[\"模板方法\",{\"1\":{\"1087\":1}}],[\"模板方法模式\",{\"0\":{\"1087\":1},\"1\":{\"742\":1}}],[\"模板模式的第三者是模板类\",{\"1\":{\"50\":1}}],[\"模块间也有联系\",{\"1\":{\"809\":1}}],[\"模块\",{\"0\":{\"1238\":1,\"1239\":1},\"1\":{\"488\":1,\"769\":1,\"882\":1}}],[\"模块化相关属性\",{\"1\":{\"292\":1}}],[\"模块化的思想在软件设计的方方面面都有体现\",{\"1\":{\"198\":1}}],[\"模式和工厂模式的关注点不同\",{\"1\":{\"1086\":1}}],[\"模式代码\",{\"0\":{\"950\":1}}],[\"模式实现了架构上将表现层\",{\"1\":{\"748\":1}}],[\"模式时\",{\"1\":{\"613\":1}}],[\"模式的结构\",{\"1\":{\"1079\":1}}],[\"模式的\",{\"1\":{\"610\":1}}],[\"模式的话\",{\"1\":{\"381\":1}}],[\"模式中\",{\"1\":{\"381\":1}}],[\"模式下\",{\"1\":{\"381\":2}}],[\"模式下的虚拟机的首要选择\",{\"1\":{\"255\":1}}],[\"模式下的虚拟机来说是个不错的选择\",{\"1\":{\"254\":1}}],[\"模式\",{\"1\":{\"381\":1,\"801\":1,\"1229\":1,\"1238\":1,\"1247\":1}}],[\"模型与数据分离\",{\"1\":{\"1242\":1}}],[\"模型用javabean\",{\"1\":{\"754\":1}}],[\"模型负责各个功能的实现\",{\"1\":{\"754\":1}}],[\"模型\",{\"1\":{\"380\":1,\"748\":1,\"754\":2}}],[\"区分redo\",{\"0\":{\"575\":1}}],[\"区分度就越好\",{\"1\":{\"536\":1}}],[\"区分度\",{\"1\":{\"536\":1}}],[\"区分度高的列放到组合索引前面\",{\"1\":{\"516\":1}}],[\"区分不同类的方式不仅仅根据类名\",{\"1\":{\"184\":1}}],[\"区是由连续页组成的空间\",{\"1\":{\"498\":1}}],[\"区\",{\"1\":{\"498\":2}}],[\"区为每一个线程分配一小块私有缓存区域\",{\"1\":{\"219\":1}}],[\"区别与应用场景\",{\"0\":{\"1001\":1}}],[\"区别是jdk代理只可以代理接口\",{\"1\":{\"727\":1}}],[\"区别是静态类型的变化仅仅在使用时发生\",{\"1\":{\"277\":1}}],[\"区别在于前者实现的是编译时的多态性\",{\"1\":{\"359\":1}}],[\"区别\",{\"0\":{\"336\":1,\"377\":1,\"380\":1,\"442\":1,\"461\":1,\"596\":1,\"745\":1,\"750\":1,\"806\":1},\"1\":{\"198\":1,\"610\":1,\"739\":1,\"981\":1,\"1001\":1,\"1041\":1}}],[\"索引下推\",{\"0\":{\"553\":1}}],[\"索引下标遍历时就需要计算对应的元素在哪\",{\"1\":{\"391\":1}}],[\"索引表的叶子节点保存了行的物理地址\",{\"1\":{\"546\":1}}],[\"索引表的叶子节点保存了行数据\",{\"1\":{\"546\":1}}],[\"索引树的叶子节点\",{\"1\":{\"546\":1}}],[\"索引字段和表中全量字段分两个文件进行保存\",{\"1\":{\"546\":1}}],[\"索引字段+全部其他表字段保存在一个文件中\",{\"1\":{\"546\":1}}],[\"索引项的顺序与表中记录的物理顺序一致\",{\"1\":{\"546\":1}}],[\"索引分类\",{\"0\":{\"544\":1}}],[\"索引具有哈希索引的一些优点\",{\"1\":{\"537\":1}}],[\"索引维护代价很高\",{\"1\":{\"537\":1,\"541\":1}}],[\"索引选择异常的处理\",{\"1\":{\"536\":1}}],[\"索引的数据结构对经典的\",{\"1\":{\"538\":1}}],[\"索引的区分度越好\",{\"1\":{\"536\":1}}],[\"索引的作用就相当于目录的作用\",{\"1\":{\"528\":1}}],[\"索引优化\",{\"0\":{\"535\":1}}],[\"索引失效\",{\"0\":{\"534\":1}}],[\"索引列不能参与计算\",{\"1\":{\"533\":1}}],[\"索引可以任意顺序\",{\"1\":{\"533\":1}}],[\"索引应该何时使用\",{\"0\":{\"530\":1}}],[\"索引需要使用物理文件存储\",{\"1\":{\"528\":1}}],[\"索引是一种用于快速查询和检索数据的数据结构\",{\"1\":{\"528\":1}}],[\"索引是否是唯一索引等等\",{\"1\":{\"501\":1}}],[\"索引名\",{\"1\":{\"527\":1}}],[\"索引类型\",{\"0\":{\"547\":1,\"548\":1},\"1\":{\"527\":1,\"548\":2}}],[\"索引相关语法\",{\"0\":{\"527\":1}}],[\"索引上的等值查询\",{\"1\":{\"515\":2}}],[\"索引上次已经说过了\",{\"1\":{\"508\":1}}],[\"索引段即b+树的非叶子节点\",{\"1\":{\"498\":1}}],[\"索引段\",{\"1\":{\"498\":1}}],[\"索引\",{\"1\":{\"494\":1,\"541\":1,\"548\":1,\"591\":1,\"919\":2}}],[\"索引文件具有\",{\"1\":{\"534\":1}}],[\"索引文件\",{\"1\":{\"493\":1}}],[\"索引和数据\",{\"1\":{\"493\":1}}],[\"索引取出整行\",{\"1\":{\"484\":2}}],[\"索引引用\",{\"1\":{\"284\":1}}],[\"索引n就代表了使用第n个变量槽\",{\"1\":{\"192\":1}}],[\"索引值的范围是从0开始至局部变量表最大的变量槽数量\",{\"1\":{\"192\":1}}],[\"xlrd==1\",{\"1\":{\"1184\":1}}],[\"xloggc\",{\"1\":{\"270\":1,\"325\":1,\"332\":1}}],[\"x4\",{\"1\":{\"1144\":1}}],[\"x4999\",{\"1\":{\"894\":1}}],[\"x509\",{\"1\":{\"1144\":1}}],[\"x1\",{\"1\":{\"894\":1}}],[\"x1>x2\",{\"1\":{\"893\":1}}],[\"x11\",{\"1\":{\"416\":1}}],[\"xiaoming\",{\"1\":{\"745\":2}}],[\"xinetd\",{\"1\":{\"416\":1}}],[\"xa\",{\"1\":{\"589\":1}}],[\"xa协议\",{\"1\":{\"589\":1}}],[\"xargs\",{\"1\":{\"424\":1}}],[\"x锁\",{\"1\":{\"509\":2}}],[\"xzvf\",{\"1\":{\"437\":1,\"1170\":1}}],[\"x\",{\"0\":{\"315\":1},\"1\":{\"426\":1,\"430\":2,\"433\":2,\"500\":1,\"501\":2,\"503\":1,\"509\":1,\"513\":1,\"514\":3,\"516\":1,\"840\":1,\"894\":1,\"903\":1,\"949\":4,\"1004\":2,\"1190\":1}}],[\"xxx\",{\"1\":{\"212\":1,\"426\":1,\"790\":1,\"807\":1,\"1038\":1,\"1186\":1,\"1202\":1}}],[\"xx\",{\"0\":{\"316\":1},\"1\":{\"203\":2,\"219\":1,\"220\":1,\"253\":2,\"257\":2,\"262\":6,\"270\":5,\"310\":1,\"315\":3,\"316\":6,\"317\":1,\"319\":4,\"321\":1,\"322\":10,\"323\":6,\"324\":4,\"325\":5,\"326\":5}}],[\"xn\",{\"1\":{\"201\":1}}],[\"xmin\",{\"1\":{\"893\":1}}],[\"xml<\",{\"1\":{\"1266\":3}}],[\"xml的设计宗旨的传输和储存数据\",{\"1\":{\"1035\":1}}],[\"xml可拓展标记语言\",{\"1\":{\"1035\":1}}],[\"xml中谁先被声明\",{\"1\":{\"798\":1}}],[\"xml中做如下配置\",{\"1\":{\"796\":1}}],[\"xml文件中增加配置\",{\"1\":{\"790\":1}}],[\"xmlwebapplicationcontext\",{\"1\":{\"712\":1}}],[\"xml\",{\"0\":{\"1035\":1},\"1\":{\"712\":1,\"713\":1,\"729\":2,\"734\":1,\"736\":1,\"739\":1,\"746\":2,\"755\":1,\"1266\":2}}],[\"xmn2g\",{\"1\":{\"322\":1}}],[\"xmx1024m\",{\"1\":{\"317\":2}}],[\"xmx50m\",{\"1\":{\"317\":1}}],[\"xmx<size>=\",{\"1\":{\"315\":1,\"322\":1}}],[\"xmx和\",{\"1\":{\"298\":1}}],[\"xmx指定的最大堆大小\",{\"1\":{\"209\":1}}],[\"xmx\",{\"1\":{\"199\":1}}],[\"xms512m\",{\"1\":{\"317\":2}}],[\"xms50m\",{\"1\":{\"317\":1}}],[\"xms<size>=\",{\"1\":{\"315\":1}}],[\"xms\",{\"1\":{\"199\":1,\"298\":1}}],[\"xss128k\",{\"1\":{\"321\":1}}],[\"xss<size>=\",{\"1\":{\"315\":1}}],[\"xss\",{\"1\":{\"190\":1,\"1061\":1}}],[\"xbootclasspath参数所指定的路径中存放的\",{\"1\":{\"176\":1}}],[\"栈和队列的应用场景\",{\"0\":{\"942\":1}}],[\"栈中的数据元素遵守后进先出\",{\"1\":{\"940\":1}}],[\"栈溢出错误\",{\"1\":{\"384\":1}}],[\"栈上分配\",{\"1\":{\"199\":1,\"202\":1}}],[\"栈主要用来执行程序\",{\"1\":{\"198\":1}}],[\"栈因为运行时的需要\",{\"1\":{\"198\":1}}],[\"栈代表了处理逻辑\",{\"1\":{\"198\":1}}],[\"栈内存存放的变量生命周期一旦结束就会被释放\",{\"1\":{\"198\":1}}],[\"栈内存存储的是局部变量而堆内存存储的是实体\",{\"1\":{\"198\":1}}],[\"栈内存的更新速度要快于堆内存\",{\"1\":{\"198\":1}}],[\"栈顶缓存\",{\"1\":{\"193\":1}}],[\"栈\",{\"0\":{\"320\":1,\"321\":1,\"939\":1,\"940\":1},\"1\":{\"193\":1,\"394\":1,\"940\":1,\"942\":1}}],[\"栈帧中的本地变量表\",{\"1\":{\"234\":1}}],[\"栈帧中就一般不会保存这部分信息\",{\"1\":{\"195\":1}}],[\"栈帧中很可能会保存这个计数器值\",{\"1\":{\"195\":1}}],[\"栈帧中需要多大的局部变量表\",{\"1\":{\"191\":1}}],[\"栈帧则是用于支持jvm进行方法调用和方法执行背后的数据结构\",{\"1\":{\"191\":1}}],[\"栈可能会出现的异常\",{\"1\":{\"190\":1}}],[\"栈是一种快速有效的分配存储的方式\",{\"1\":{\"190\":1}}],[\"栈是运行时的单位\",{\"1\":{\"190\":1}}],[\"栈与队列\",{\"0\":{\"8\":1}}],[\"生态系统\",{\"1\":{\"1208\":1}}],[\"生态系统中最完整的\",{\"1\":{\"720\":1}}],[\"生产端\",{\"1\":{\"866\":1}}],[\"生产者拦截器可以用在消息发送前做一些准备工作\",{\"1\":{\"867\":1}}],[\"生产者端\",{\"1\":{\"865\":1}}],[\"生产者消息可靠性保证\",{\"0\":{\"854\":1}}],[\"生产者消费者模式\",{\"0\":{\"50\":1}}],[\"生产者分区分配策略\",{\"0\":{\"852\":1}}],[\"生产者\",{\"0\":{\"851\":1}}],[\"生产者发布的消息会被不同的消费者多次消费\",{\"1\":{\"850\":1}}],[\"生产者发送数据的对象\",{\"1\":{\"845\":1}}],[\"生产者不断向log文件追加消息文件\",{\"1\":{\"846\":1}}],[\"生产者往满的队列里添加元素时会阻塞\",{\"1\":{\"62\":1}}],[\"生产者和消费者都是面向一个topic\",{\"1\":{\"845\":1}}],[\"生产者和消费者彼此之间不直接通信\",{\"1\":{\"50\":1}}],[\"生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题\",{\"1\":{\"50\":1}}],[\"生存时间为\",{\"1\":{\"669\":1}}],[\"生命周期随着\",{\"1\":{\"609\":1}}],[\"生命周期与线程相同\",{\"1\":{\"190\":1}}],[\"生成时序图\",{\"0\":{\"1274\":1}}],[\"生成器代替\",{\"1\":{\"1117\":1}}],[\"生成一个随机的\",{\"1\":{\"1004\":1}}],[\"生成一个唯一的瞬时有序节点\",{\"1\":{\"668\":1}}],[\"生成全局唯一\",{\"1\":{\"807\":1}}],[\"生成执行器可以使用的构造信息\",{\"1\":{\"774\":1}}],[\"生成执行计划\",{\"1\":{\"489\":1}}],[\"生成对象的方式不直观\",{\"1\":{\"731\":1}}],[\"生成代理对象的函数proxy\",{\"1\":{\"725\":1}}],[\"生成\",{\"1\":{\"647\":2}}],[\"生成的100000个\",{\"1\":{\"559\":1}}],[\"生成的\",{\"1\":{\"368\":1}}],[\"生成heap转储文件\",{\"1\":{\"324\":1}}],[\"跳过行数和列数后的换行符\",{\"1\":{\"954\":1}}],[\"跳过换行\",{\"1\":{\"954\":1}}],[\"跳跃表实现起来更简单\",{\"1\":{\"630\":1}}],[\"跳跃表节点\",{\"1\":{\"630\":1}}],[\"跳跃表支持平均\",{\"1\":{\"630\":1}}],[\"跳跃表是有序集合的底层实现\",{\"1\":{\"630\":1}}],[\"跳表是一个双向链表\",{\"1\":{\"630\":1}}],[\"跳表在范围查询的时候的效率是高于红黑树的\",{\"1\":{\"630\":1}}],[\"跳表在\",{\"1\":{\"630\":1}}],[\"跳表\",{\"0\":{\"630\":1}}],[\"跳表的实现\",{\"1\":{\"108\":1}}],[\"跳转\",{\"1\":{\"189\":1}}],[\"占物理内存的30\",{\"1\":{\"1177\":1}}],[\"占位符\",{\"1\":{\"745\":1}}],[\"占坑一般使用\",{\"1\":{\"669\":1}}],[\"占用了\",{\"0\":{\"836\":1}}],[\"占用成功了就可以继续执行\",{\"1\":{\"669\":1}}],[\"占用大量内存\",{\"1\":{\"632\":1}}],[\"占用的空间即将达到\",{\"1\":{\"568\":1}}],[\"占用的空间更小\",{\"1\":{\"554\":1}}],[\"占用的空间更少\",{\"1\":{\"549\":1}}],[\"占用导致的\",{\"1\":{\"562\":1}}],[\"占用空间\",{\"1\":{\"477\":1}}],[\"占用内存极小\",{\"1\":{\"189\":1}}],[\"占内存大小\",{\"1\":{\"367\":1}}],[\"占有内存小\",{\"1\":{\"824\":1}}],[\"占有\",{\"1\":{\"98\":4}}],[\"占有并等待\",{\"1\":{\"98\":1}}],[\"堆结构\",{\"1\":{\"937\":1}}],[\"堆排序\",{\"0\":{\"937\":1}}],[\"堆顶\",{\"1\":{\"893\":1}}],[\"堆顶存放的是整个堆中最小的数\",{\"1\":{\"893\":1}}],[\"堆可以放入内存\",{\"1\":{\"885\":1}}],[\"堆中不存在该类的任何实例\",{\"1\":{\"1075\":1}}],[\"堆中几乎放着所有的对象实例\",{\"1\":{\"232\":1}}],[\"堆中将会划分出一块内存来作为句柄池\",{\"1\":{\"229\":1}}],[\"堆对象的布局中就必须考虑如何放置访问类型数据的相关信息\",{\"1\":{\"230\":1}}],[\"堆区是线程共享区域\",{\"1\":{\"219\":1}}],[\"堆这里最容易出现的就是\",{\"1\":{\"200\":1}}],[\"堆内存之中\",{\"1\":{\"378\":1}}],[\"堆内存中一个特殊的存储区域\",{\"1\":{\"369\":1}}],[\"堆内存中的空间不足以存放新创建的对象\",{\"1\":{\"200\":1}}],[\"堆内存溢出\",{\"1\":{\"297\":1}}],[\"堆内存\",{\"1\":{\"200\":1,\"247\":1}}],[\"堆主要用来存放对象\",{\"1\":{\"198\":1}}],[\"堆和栈的完美结合就是面向对象的一个实例\",{\"1\":{\"198\":1}}],[\"堆的大小可以根据需要动态增长\",{\"1\":{\"198\":1}}],[\"堆与栈的分离\",{\"1\":{\"198\":2}}],[\"堆栈分离\",{\"1\":{\"198\":1}}],[\"堆是存储的单位\",{\"1\":{\"190\":1}}],[\"堆外内存\",{\"1\":{\"188\":1}}],[\"堆\",{\"0\":{\"320\":1,\"322\":1,\"885\":1},\"1\":{\"188\":1,\"203\":1,\"261\":1,\"881\":1,\"892\":1,\"894\":1,\"895\":3,\"897\":1}}],[\"热点数据成为性能瓶颈\",{\"1\":{\"587\":1}}],[\"热点数据太多\",{\"1\":{\"584\":1}}],[\"热点代码\",{\"1\":{\"283\":1}}],[\"热替换的实现\",{\"0\":{\"187\":1}}],[\"热部署\",{\"1\":{\"185\":1,\"834\":1}}],[\"全称是\",{\"1\":{\"1035\":1}}],[\"全称为\",{\"1\":{\"185\":1}}],[\"全新集群选举是新搭建起来的\",{\"1\":{\"820\":1}}],[\"全索引扫描\",{\"1\":{\"702\":1}}],[\"全同步结束后\",{\"1\":{\"655\":1}}],[\"全量复制\",{\"1\":{\"648\":1}}],[\"全局配置镜像源时\",{\"1\":{\"1184\":1}}],[\"全局唯一\",{\"1\":{\"807\":1}}],[\"全局的web域\",{\"1\":{\"734\":1}}],[\"全局的键空间选择性移除\",{\"1\":{\"636\":1}}],[\"全局哈希表\",{\"0\":{\"614\":1},\"1\":{\"614\":1}}],[\"全局锁的典型使用场景是\",{\"1\":{\"508\":1}}],[\"全局锁就是对整个数据库实例加锁\",{\"1\":{\"508\":1}}],[\"全局锁\",{\"0\":{\"508\":1}}],[\"全表扫描\",{\"1\":{\"556\":1,\"702\":1}}],[\"全文索引\",{\"1\":{\"548\":1}}],[\"全连接\",{\"1\":{\"485\":1}}],[\"全字段排序\",{\"1\":{\"484\":2}}],[\"全部落盘\",{\"1\":{\"854\":1}}],[\"全部的文件\",{\"1\":{\"419\":1}}],[\"全部缓存\",{\"1\":{\"368\":2}}],[\"全为\",{\"1\":{\"399\":1}}],[\"全能屏障\",{\"1\":{\"72\":1}}],[\"破坏的诉求\",{\"1\":{\"185\":1}}],[\"破坏双亲委派模型\",{\"0\":{\"185\":1}}],[\"子域为例\",{\"1\":{\"1240\":1}}],[\"子域包含聚合\",{\"1\":{\"1233\":1}}],[\"子域\",{\"1\":{\"1221\":1}}],[\"子组件中需要与其他组件共享的数据最好用\",{\"1\":{\"1163\":1}}],[\"子系统\",{\"1\":{\"1090\":1}}],[\"子系统会越来越多\",{\"1\":{\"1090\":1}}],[\"子网掩码\",{\"1\":{\"989\":1,\"990\":1,\"1049\":2}}],[\"子网的划分\",{\"1\":{\"983\":1}}],[\"子目录节点增加删除\",{\"1\":{\"817\":1}}],[\"子pom配置\",{\"1\":{\"800\":1}}],[\"子进程开始将新\",{\"1\":{\"651\":1}}],[\"子进程完成的不会阻塞主进程\",{\"1\":{\"651\":1}}],[\"子进程负责将内存内容写入到临时文件\",{\"1\":{\"647\":1}}],[\"子进程发送信号给父进程表示完成\",{\"1\":{\"647\":1}}],[\"子进程创建\",{\"1\":{\"647\":1}}],[\"子进程\",{\"1\":{\"647\":1}}],[\"子查询等的复杂查询\",{\"1\":{\"556\":1}}],[\"子查询表大\",{\"1\":{\"482\":1}}],[\"子查询表小\",{\"1\":{\"482\":1}}],[\"子句就可以实现\",{\"1\":{\"486\":1}}],[\"子句\",{\"1\":{\"485\":1}}],[\"子加载器才会尝试自己去完成加载\",{\"1\":{\"184\":1}}],[\"子类继承父类时\",{\"1\":{\"1064\":1}}],[\"子类继承父类后\",{\"1\":{\"275\":1}}],[\"子类\",{\"1\":{\"363\":3}}],[\"子类初始化的顺序\",{\"0\":{\"363\":1}}],[\"子类是否可以重写\",{\"0\":{\"358\":1}}],[\"子类覆盖父类的方法或属性后\",{\"1\":{\"355\":1}}],[\"子类拥有父类对象所有的属性和方法\",{\"1\":{\"355\":1}}],[\"子类一般都要重写这个方法\",{\"1\":{\"350\":1}}],[\"子类实现的虚函数就会在父类调用的时候自动响应\",{\"1\":{\"275\":1}}],[\"子类主要实现这样一些方法\",{\"1\":{\"109\":1}}],[\"子类需要定义如何维护这个状态\",{\"1\":{\"109\":1}}],[\"否则监听不到内部变化\",{\"1\":{\"1157\":1}}],[\"否则将会实例化一个新对象\",{\"1\":{\"1074\":1}}],[\"否则丢弃\",{\"1\":{\"979\":1}}],[\"否则计算机会误认为该数据就是帧结束符\",{\"1\":{\"973\":1}}],[\"否则重新发送数据\",{\"1\":{\"854\":1}}],[\"否则节点一直存在于\",{\"1\":{\"818\":1}}],[\"否则说明已经支付过了\",{\"1\":{\"807\":1}}],[\"否则响应服务并将\",{\"1\":{\"807\":1}}],[\"否则影响其他\",{\"1\":{\"672\":1}}],[\"否则的话\",{\"1\":{\"638\":1}}],[\"否则不要一开始就考虑分库分表\",{\"1\":{\"561\":1}}],[\"否则会出现查询不到数据的问题\",{\"1\":{\"880\":1}}],[\"否则会导致历史数据失效\",{\"1\":{\"587\":1}}],[\"否则会使索引失效\",{\"1\":{\"535\":1}}],[\"否则会抛出java\",{\"1\":{\"85\":1}}],[\"否则返回\",{\"1\":{\"517\":1,\"1188\":1}}],[\"否则判断桶的第一个位置\",{\"1\":{\"398\":1}}],[\"否则编译无法通过\",{\"1\":{\"385\":1}}],[\"否则为\",{\"1\":{\"368\":1}}],[\"否则抛出\",{\"1\":{\"350\":1}}],[\"否则\",{\"1\":{\"278\":1,\"304\":1,\"406\":1,\"489\":1,\"990\":3,\"1075\":1}}],[\"否则才会尝试加载\",{\"1\":{\"184\":1}}],[\"像以下这样在\",{\"1\":{\"1159\":1}}],[\"像遇到表结构变更的时候就会以statement模式来记录\",{\"1\":{\"572\":1}}],[\"像复合索引\",{\"1\":{\"548\":1}}],[\"像不加锁的\",{\"1\":{\"499\":1}}],[\"像现在主流的容器类的框架一样\",{\"1\":{\"180\":1}}],[\"像数据库提供的类似于\",{\"1\":{\"103\":1}}],[\"初始状态数据为空\",{\"1\":{\"640\":1}}],[\"初始空间大小\",{\"1\":{\"323\":1}}],[\"初始标记\",{\"1\":{\"259\":1,\"264\":1}}],[\"初始化链表\",{\"1\":{\"955\":1}}],[\"初始化一个整数数组\",{\"1\":{\"955\":1}}],[\"初始化一个类\",{\"1\":{\"174\":1}}],[\"初始化对象\",{\"1\":{\"714\":1}}],[\"初始化为空哈希表释放原来的\",{\"1\":{\"623\":1}}],[\"初始化大小为大于\",{\"1\":{\"399\":1}}],[\"初始化过程\",{\"0\":{\"399\":1}}],[\"初始化顺序为\",{\"1\":{\"363\":1}}],[\"初始化零值完成之后\",{\"1\":{\"222\":1}}],[\"初始化零值\",{\"0\":{\"221\":1}}],[\"初始化阶段就是执行类构造器<clinit>\",{\"1\":{\"173\":1}}],[\"初始化\",{\"0\":{\"173\":1,\"214\":1},\"1\":{\"484\":2}}],[\"初次读取时是\",{\"1\":{\"106\":1}}],[\"字典中一定数量的\",{\"1\":{\"632\":1}}],[\"字典排序\",{\"1\":{\"630\":1}}],[\"字典还是哈希键的底层实现\",{\"1\":{\"623\":1}}],[\"字典是用于保存键值对的抽象数据结构\",{\"1\":{\"623\":1}}],[\"字典\",{\"0\":{\"623\":1},\"1\":{\"623\":1}}],[\"字数\",{\"1\":{\"439\":1}}],[\"字母法\",{\"1\":{\"433\":1}}],[\"字母法与数字法\",{\"1\":{\"433\":1}}],[\"字串\",{\"1\":{\"429\":6,\"893\":1}}],[\"字符类别\",{\"1\":{\"1190\":2}}],[\"字符集设置\",{\"1\":{\"1177\":1}}],[\"字符型\",{\"0\":{\"474\":1}}],[\"字符显示树状结构\",{\"1\":{\"426\":1}}],[\"字符串在内存中的共享\",{\"1\":{\"1091\":1}}],[\"字符串序列化器\",{\"1\":{\"867\":1}}],[\"字符串无法正确存取\",{\"1\":{\"624\":1}}],[\"字符串为主的表在五百万以下是没有太大问题的\",{\"1\":{\"561\":1}}],[\"字符串转换为数字异常\",{\"1\":{\"385\":1}}],[\"字符串不变性保证了\",{\"1\":{\"369\":1}}],[\"字符串常量占若干字节\",{\"1\":{\"367\":1}}],[\"字符串常量池是\",{\"1\":{\"369\":1}}],[\"字符串常量池的需要\",{\"1\":{\"369\":1}}],[\"字符串常量池\",{\"1\":{\"203\":1,\"204\":1}}],[\"字符常量占用\",{\"1\":{\"367\":1}}],[\"字面量与java语言层面的常量含义类似\",{\"1\":{\"286\":1}}],[\"字面量和符号引用\",{\"1\":{\"286\":1}}],[\"字长精度\",{\"1\":{\"249\":1}}],[\"字⾯量\",{\"1\":{\"203\":1}}],[\"字段无法映射到\",{\"1\":{\"1117\":1}}],[\"字段出现的次数\",{\"1\":{\"893\":1}}],[\"字段值增加\",{\"1\":{\"807\":1}}],[\"字段关系映射\",{\"1\":{\"746\":1}}],[\"字段切分到4个库中\",{\"1\":{\"587\":1}}],[\"字段加\",{\"1\":{\"573\":1}}],[\"字段不在where语句出现时不要添加索引\",{\"1\":{\"532\":1}}],[\"字段名称可以不一致\",{\"1\":{\"751\":1}}],[\"字段名\",{\"1\":{\"527\":2}}],[\"字段存的值是\",{\"1\":{\"476\":1}}],[\"字段的值\",{\"1\":{\"295\":1}}],[\"字段的名称和描述符\",{\"1\":{\"286\":1}}],[\"字段表\",{\"1\":{\"291\":1}}],[\"字段表集合中不会列出从父类或者父接口中继承而来的字段\",{\"1\":{\"289\":1}}],[\"字段表集合\",{\"0\":{\"289\":1}}],[\"字段\",{\"1\":{\"172\":1,\"203\":1,\"204\":1,\"208\":1,\"292\":1,\"553\":1,\"556\":1,\"1026\":4,\"1117\":1}}],[\"字节时\",{\"1\":{\"1016\":1}}],[\"字节时采用\",{\"1\":{\"618\":1}}],[\"字节填充法\",{\"1\":{\"973\":1}}],[\"字节之间的\",{\"1\":{\"628\":1}}],[\"字节\",{\"1\":{\"442\":1,\"539\":4,\"547\":1,\"617\":2,\"627\":2,\"628\":1,\"631\":1,\"982\":2,\"1033\":1}}],[\"字节数组\",{\"1\":{\"624\":1,\"867\":1}}],[\"字节数组card\",{\"1\":{\"249\":1}}],[\"字节数598\",{\"1\":{\"439\":1}}],[\"字节的\",{\"1\":{\"628\":1}}],[\"字节的存储空间\",{\"1\":{\"475\":1}}],[\"字节的倍数\",{\"1\":{\"227\":1}}],[\"字节的整数倍\",{\"1\":{\"227\":2}}],[\"字节码的偏移量\",{\"1\":{\"292\":1}}],[\"字节码指令\",{\"0\":{\"280\":1},\"1\":{\"280\":1}}],[\"字节码指令集设计了不同的指令\",{\"1\":{\"274\":1}}],[\"字节码文件解释成二进制\",{\"1\":{\"335\":1}}],[\"字节码文件\",{\"0\":{\"280\":1}}],[\"字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数\",{\"1\":{\"194\":1}}],[\"字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令\",{\"1\":{\"189\":1}}],[\"字节码\",{\"1\":{\"173\":1}}],[\"字节码验证\",{\"1\":{\"170\":1}}],[\"字节码验证和符号引用验证\",{\"1\":{\"170\":1}}],[\"字节流才会进入内存的方法区进行存储\",{\"1\":{\"170\":1}}],[\"零比特填充法\",{\"1\":{\"973\":1}}],[\"零复制技术\",{\"1\":{\"850\":1}}],[\"零值\",{\"1\":{\"171\":1}}],[\"零拷贝技术\",{\"1\":{\"850\":3}}],[\"零拷贝\",{\"0\":{\"138\":1}}],[\"语句块内有加锁操作\",{\"1\":{\"1067\":1}}],[\"语句块内\",{\"1\":{\"1067\":1}}],[\"语句依赖于数据库\",{\"1\":{\"746\":1}}],[\"语句编程\",{\"1\":{\"746\":1}}],[\"语句本身\",{\"1\":{\"746\":1}}],[\"语句是静态的\",{\"1\":{\"745\":1}}],[\"语句是来干嘛的\",{\"1\":{\"490\":1}}],[\"语句去数据库进行读写操作时\",{\"1\":{\"606\":1}}],[\"语句执行就结束了\",{\"1\":{\"574\":1}}],[\"语句执行结束\",{\"1\":{\"574\":3}}],[\"语句为\",{\"1\":{\"565\":1}}],[\"语句解析次数\",{\"1\":{\"560\":1}}],[\"语句插入多条数据\",{\"1\":{\"560\":1}}],[\"语句就会被堵住\",{\"1\":{\"559\":1}}],[\"语句耗时情况\",{\"1\":{\"557\":1}}],[\"语句写到慢查询日志中\",{\"1\":{\"557\":1}}],[\"语句开始执行的时候创建的\",{\"1\":{\"524\":1}}],[\"语句\",{\"1\":{\"501\":3,\"518\":1,\"566\":4,\"744\":1,\"745\":3,\"746\":1,\"749\":1,\"1067\":1,\"1088\":2}}],[\"语句会加不同的锁\",{\"1\":{\"501\":1}}],[\"语句和当前数据库数据会共同影响该条\",{\"1\":{\"499\":1}}],[\"语句有多个字符串组成\",{\"1\":{\"490\":1}}],[\"语句以及该语句的结果集\",{\"1\":{\"490\":1}}],[\"语句中可以使用\",{\"1\":{\"745\":1}}],[\"语句中\",{\"1\":{\"481\":1}}],[\"语句的功底有一定要求\",{\"1\":{\"746\":1}}],[\"语句的编写工作量较大\",{\"1\":{\"746\":1}}],[\"语句的\",{\"1\":{\"501\":1,\"558\":1}}],[\"语句的执行流程\",{\"0\":{\"489\":1}}],[\"语句的结果组合到一个结果集合中\",{\"1\":{\"480\":1}}],[\"语句的存在\",{\"1\":{\"364\":1}}],[\"语言\",{\"1\":{\"1035\":1}}],[\"语言用\",{\"1\":{\"1006\":1}}],[\"语言字符串以空字符\",{\"1\":{\"624\":1}}],[\"语言字符串\",{\"1\":{\"624\":1}}],[\"语言字符串的差别\",{\"1\":{\"624\":1}}],[\"语言写的\",{\"1\":{\"624\":1}}],[\"语言编写\",{\"1\":{\"603\":1}}],[\"语言中使用\",{\"1\":{\"624\":1}}],[\"语言中的字符串\",{\"1\":{\"624\":1}}],[\"语言中\",{\"1\":{\"347\":1}}],[\"语言中没有结束符这一概念\",{\"1\":{\"336\":1}}],[\"语言中字符串或字符数组最后都会有一个额外的字符\",{\"1\":{\"336\":1}}],[\"语言特性\",{\"0\":{\"334\":1}}],[\"语言规范的元数据信息\",{\"1\":{\"170\":1}}],[\"语言规范的要求\",{\"1\":{\"170\":1}}],[\"语法扩展\",{\"1\":{\"1134\":1}}],[\"语法格式\",{\"1\":{\"1035\":1}}],[\"语法分析\",{\"1\":{\"490\":1}}],[\"语法\",{\"0\":{\"1119\":1},\"1\":{\"312\":2}}],[\"语义版本控制\",{\"1\":{\"1140\":1}}],[\"语义\",{\"1\":{\"76\":1}}],[\"元数据的更新比较分散\",{\"1\":{\"684\":1}}],[\"元数据锁\",{\"0\":{\"511\":1}}],[\"元数据验证\",{\"1\":{\"170\":2}}],[\"元注解是自定义注解的注解\",{\"1\":{\"338\":1}}],[\"元空间使用情况\",{\"1\":{\"313\":1}}],[\"元空间存储不在虚拟机中\",{\"1\":{\"205\":1}}],[\"元空间\",{\"1\":{\"188\":1}}],[\"元素的\",{\"0\":{\"1155\":1}}],[\"元素的个数等于第一维数组的长度时\",{\"1\":{\"623\":1}}],[\"元素个数低于数组长度的\",{\"1\":{\"623\":1}}],[\"元素分布相对来说比较均匀\",{\"1\":{\"404\":1}}],[\"元素内容\",{\"1\":{\"392\":1}}],[\"元素\",{\"1\":{\"26\":3,\"614\":1,\"1155\":1}}],[\"确认报文后\",{\"1\":{\"1027\":1}}],[\"确认了双方的收发能力均正常\",{\"1\":{\"1022\":1}}],[\"确认丢失和确认迟到\",{\"1\":{\"1010\":1}}],[\"确认ack\",{\"1\":{\"1007\":1}}],[\"确认号ack=u+1\",{\"1\":{\"1026\":1}}],[\"确认号ack=x+1\",{\"1\":{\"1022\":1}}],[\"确认号\",{\"1\":{\"1007\":1}}],[\"确认\",{\"1\":{\"558\":1}}],[\"确保最后的\",{\"1\":{\"1027\":1}}],[\"确保数据发送到对端\",{\"1\":{\"1004\":1}}],[\"确保在非拜占庭条件\",{\"1\":{\"873\":1}}],[\"确保开启g1\",{\"1\":{\"263\":1}}],[\"确保不会威胁虚拟机的安全\",{\"1\":{\"170\":1}}],[\"确保class文件的字节流包含的信息符合\",{\"1\":{\"170\":1}}],[\"确定该元素不存在于过滤器中\",{\"1\":{\"882\":1}}],[\"确定该元素在过滤器中\",{\"1\":{\"882\":1}}],[\"确定放入两个字段\",{\"1\":{\"484\":1}}],[\"确定放入\",{\"1\":{\"484\":1}}],[\"确定这个文件是否为一个能被虚拟机接受的class文件\",{\"1\":{\"285\":1}}],[\"确定\",{\"1\":{\"129\":1}}],[\"验证结果存储到\",{\"1\":{\"755\":1}}],[\"验证数据的有效性\",{\"1\":{\"755\":1}}],[\"验证字节流是否符合\",{\"1\":{\"170\":1}}],[\"验证阶段会完成四个阶段的检验动作\",{\"1\":{\"170\":1}}],[\"验证\",{\"0\":{\"170\":1}}],[\"典型的表现就是拒绝服务以及网络拥塞\",{\"1\":{\"858\":1}}],[\"典型的例子就是\",{\"1\":{\"737\":1}}],[\"典型的包括方法调用\",{\"1\":{\"721\":1}}],[\"典型应用\",{\"1\":{\"277\":1}}],[\"典型应用是web\",{\"1\":{\"168\":1}}],[\"典型场景jsp\",{\"1\":{\"168\":1}}],[\"本节采用\",{\"1\":{\"1259\":1}}],[\"本文以\",{\"1\":{\"1249\":1}}],[\"本局域网上的所有主机arp进程都收到了这个请求分组\",{\"1\":{\"986\":1}}],[\"本项目\",{\"1\":{\"798\":2}}],[\"本命令用于检查maven是否安装成功\",{\"1\":{\"793\":1}}],[\"本来使我们手动new出来的对象\",{\"1\":{\"718\":1}}],[\"本身有自己的分区策略\",{\"1\":{\"867\":1}}],[\"本身就是一个集群的\",{\"1\":{\"803\":1}}],[\"本身需要的一些元数据存储开销\",{\"1\":{\"622\":1}}],[\"本身不能直接访问数据\",{\"1\":{\"379\":1}}],[\"本机是无法恢复这一条记录的\",{\"1\":{\"578\":1}}],[\"本类内部创建对象实例\",{\"1\":{\"1066\":1}}],[\"本类\",{\"1\":{\"357\":1}}],[\"本地调试时运行\",{\"1\":{\"1212\":1}}],[\"本地调用过程中\",{\"1\":{\"804\":1}}],[\"本地不修改文件名也可正常编译出\",{\"1\":{\"1206\":1}}],[\"本地网络的主机都能收到该广播报文\",{\"1\":{\"1049\":1}}],[\"本地域名服务器得到了所要解析的\",{\"1\":{\"1031\":1}}],[\"本地仓库\",{\"1\":{\"794\":2}}],[\"本地缓存\",{\"1\":{\"642\":1}}],[\"本地缓存对分布式架构支持不友好\",{\"1\":{\"609\":1}}],[\"本地缓存直接获取则是浅拷贝\",{\"1\":{\"608\":1}}],[\"本地缓存固然好\",{\"1\":{\"607\":1}}],[\"本地有三个工作区域\",{\"1\":{\"444\":1}}],[\"本地代码缓存等\",{\"1\":{\"234\":1}}],[\"本地线程分配缓冲\",{\"1\":{\"219\":1}}],[\"本地方法栈\",{\"0\":{\"197\":1},\"1\":{\"188\":1,\"197\":1,\"234\":1}}],[\"本地物理磁盘\",{\"1\":{\"180\":1}}],[\"本地系统直接加载\",{\"1\":{\"168\":1}}],[\"本质是一个数据结构服务器\",{\"1\":{\"637\":1}}],[\"本质是在告诉\",{\"1\":{\"79\":1}}],[\"本质上还是一个ip数据报\",{\"1\":{\"992\":1}}],[\"本质上是\",{\"1\":{\"1042\":1}}],[\"本质上是遍历每个topic\",{\"1\":{\"859\":1}}],[\"本质上是插入一条\",{\"1\":{\"72\":1}}],[\"本质上来说\",{\"1\":{\"771\":1}}],[\"本质上就是\",{\"1\":{\"412\":1}}],[\"本质上和\",{\"1\":{\"381\":1}}],[\"本质默认为application\",{\"1\":{\"179\":1}}],[\"注释生成代码\",{\"1\":{\"1152\":1}}],[\"注释事物\",{\"1\":{\"1093\":1}}],[\"注射到a当中\",{\"1\":{\"718\":1}}],[\"注解导入老\",{\"1\":{\"788\":1}}],[\"注解导入自定义的yml配置\",{\"1\":{\"785\":1}}],[\"注解可以引入一个xml配置\",{\"1\":{\"787\":1}}],[\"注解即可\",{\"1\":{\"718\":1}}],[\"注解\",{\"1\":{\"713\":1,\"734\":1,\"739\":1,\"777\":1}}],[\"注解是一种标记\",{\"1\":{\"338\":1}}],[\"注入普通类型属性\",{\"1\":{\"743\":1}}],[\"注入问题\",{\"1\":{\"461\":1,\"596\":1,\"750\":1}}],[\"注入\",{\"1\":{\"461\":1,\"596\":1,\"745\":1,\"750\":1,\"1162\":1}}],[\"注册中心将基于长连接推送给数据消费者\",{\"1\":{\"811\":1}}],[\"注册中心返回服务提供者列表给消费者\",{\"1\":{\"811\":1}}],[\"注册中心返回服务提供者地址列表给消费者\",{\"1\":{\"810\":1}}],[\"注册中心\",{\"1\":{\"810\":1}}],[\"注册中心增加一个心跳检测功能\",{\"1\":{\"802\":1}}],[\"注册中心如何知道服务不可用了呢\",{\"0\":{\"802\":1}}],[\"注册时的服务唯一\",{\"1\":{\"801\":1}}],[\"注册表\",{\"1\":{\"713\":1}}],[\"注册\",{\"1\":{\"381\":1,\"861\":2}}],[\"注意不但要关注正常的业务流程\",{\"1\":{\"1216\":1}}],[\"注意从\",{\"1\":{\"1163\":1}}],[\"注意从0开始\",{\"1\":{\"486\":1}}],[\"注意线程安全问题\",{\"1\":{\"1074\":1}}],[\"注意可以强制开启持续连接\",{\"1\":{\"1042\":1}}],[\"注意与二叉排序树不同\",{\"1\":{\"918\":1}}],[\"注意去除重复的元素\",{\"1\":{\"900\":1}}],[\"注意会有一定的错误率\",{\"1\":{\"896\":1}}],[\"注意到ip是32位的\",{\"1\":{\"892\":1}}],[\"注意发布到topic中的消息会被多个消费者消费\",{\"1\":{\"844\":1}}],[\"注意事项\",{\"1\":{\"665\":1}}],[\"注意点\",{\"1\":{\"355\":1,\"870\":1}}],[\"注意\",{\"1\":{\"284\":1,\"294\":1,\"398\":1,\"411\":1,\"568\":1,\"645\":1,\"676\":1,\"731\":1,\"937\":1,\"954\":1,\"1006\":1,\"1159\":1}}],[\"注\",{\"0\":{\"900\":1},\"1\":{\"168\":1,\"733\":1,\"895\":1,\"1190\":1,\"1219\":1}}],[\"转枚举和枚举转\",{\"1\":{\"1260\":1}}],[\"转化而来\",{\"1\":{\"874\":1}}],[\"转化为一致的\",{\"1\":{\"717\":1}}],[\"转换成\",{\"1\":{\"755\":1}}],[\"转换成一个对象\",{\"1\":{\"755\":1}}],[\"转换解析和初始化\",{\"1\":{\"165\":1}}],[\"转发到相同的服务器\",{\"1\":{\"869\":1}}],[\"转发\",{\"1\":{\"754\":1,\"758\":1}}],[\"转成顺序写\",{\"1\":{\"575\":1}}],[\"转账者和收款人的总额应该是不变的\",{\"1\":{\"519\":1}}],[\"转入后台运行\",{\"1\":{\"417\":1}}],[\"转移到了\",{\"1\":{\"203\":1}}],[\"转而执行另一个线程的代码\",{\"1\":{\"144\":1}}],[\"转而切换成内核态去执行中断信号对应的处理程序\",{\"1\":{\"134\":1}}],[\"概述\",{\"1\":{\"165\":1,\"173\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"184\":1,\"190\":1,\"191\":1,\"199\":1,\"202\":1,\"203\":1,\"299\":1,\"302\":1,\"655\":1,\"661\":1,\"673\":1,\"674\":1,\"675\":1,\"678\":1,\"919\":1,\"922\":1,\"997\":1,\"1035\":3}}],[\"概念与用法\",{\"0\":{\"26\":1}}],[\"磁道只响应一个方向上的请求\",{\"1\":{\"163\":1}}],[\"磁头在一个方向上移动\",{\"1\":{\"163\":1}}],[\"磁盘读io瓶颈\",{\"1\":{\"584\":1}}],[\"磁盘读取数据靠的是机械运动\",{\"1\":{\"543\":1}}],[\"磁盘io与预读\",{\"0\":{\"543\":1}}],[\"磁盘管理\",{\"0\":{\"441\":1}}],[\"磁盘调度算法\",{\"0\":{\"163\":1}}],[\"磁盘\",{\"1\":{\"157\":1,\"583\":1}}],[\"磁盘使用情况等\",{\"1\":{\"136\":1}}],[\"克服了先来先服务\",{\"1\":{\"163\":1}}],[\"平台\",{\"1\":{\"1127\":1}}],[\"平台类是platform\",{\"1\":{\"181\":1}}],[\"平台类加载器\",{\"1\":{\"181\":1}}],[\"平台类加载器和应用程序类加载器不在继承自java\",{\"1\":{\"181\":1}}],[\"平方之类的操作之后再取模\",{\"1\":{\"923\":1}}],[\"平方取中法\",{\"1\":{\"923\":1}}],[\"平时不知道你有没有注意到有一些正常的邮件也会被放进垃圾邮件目录中\",{\"1\":{\"645\":1}}],[\"平时执行很快的更新操作\",{\"1\":{\"592\":1}}],[\"平时\",{\"1\":{\"518\":1}}],[\"平时存放代码的地方\",{\"1\":{\"444\":1}}],[\"平时是空的\",{\"1\":{\"416\":1}}],[\"平衡树\",{\"1\":{\"630\":1}}],[\"平衡点大概在6\",{\"1\":{\"262\":1}}],[\"平衡了生产者和消费者的处理能力\",{\"1\":{\"50\":1}}],[\"平均寻道时间短\",{\"1\":{\"163\":2}}],[\"链路的另一端可以发送以下响应中的一种\",{\"1\":{\"975\":1}}],[\"链路建立之后\",{\"1\":{\"975\":1}}],[\"链地址法\",{\"1\":{\"924\":1}}],[\"链式级联等不同业务场景的复制\",{\"1\":{\"469\":1,\"580\":1}}],[\"链接文档\",{\"1\":{\"430\":1}}],[\"链接分两种\",{\"1\":{\"427\":1}}],[\"链接\",{\"0\":{\"427\":1}}],[\"链接阶段\",{\"1\":{\"162\":1}}],[\"链表输入\",{\"0\":{\"955\":1}}],[\"链表节点使用\",{\"1\":{\"626\":1}}],[\"链表具有前置节点和后置节点的引用\",{\"1\":{\"626\":1}}],[\"链表特性\",{\"1\":{\"626\":1}}],[\"链表实现是双端\",{\"1\":{\"626\":1}}],[\"链表是\",{\"1\":{\"626\":1}}],[\"链表是一块可不连续的动态空间\",{\"1\":{\"372\":1}}],[\"链表已经逆向排序\",{\"1\":{\"406\":1}}],[\"链表查询时间复杂度\",{\"1\":{\"401\":1}}],[\"链表内部有一个\",{\"1\":{\"392\":1}}],[\"链表由一系列表项连接而成\",{\"1\":{\"392\":1}}],[\"链表应用场景\",{\"1\":{\"373\":1}}],[\"链表不存在越界问题\",{\"1\":{\"372\":1}}],[\"链表可以快速插入删除节点\",{\"1\":{\"372\":1}}],[\"链表需要按顺序检索节点\",{\"1\":{\"372\":1}}],[\"链表组成的双向阻塞队列\",{\"1\":{\"62\":1}}],[\"链表组成的无界阻塞队列\",{\"1\":{\"62\":1}}],[\"链表\",{\"0\":{\"7\":1,\"626\":1,\"926\":1},\"1\":{\"395\":2}}],[\"汇编阶段\",{\"1\":{\"162\":1}}],[\"翻译成汇编文件\",{\"1\":{\"162\":1}}],[\"开闭原则\",{\"1\":{\"1090\":1}}],[\"开放封闭原则\",{\"1\":{\"1064\":1}}],[\"开放地址法\",{\"1\":{\"924\":1}}],[\"开销\",{\"1\":{\"1048\":1}}],[\"开销非常大\",{\"1\":{\"663\":1}}],[\"开启幂等性的\",{\"1\":{\"856\":1}}],[\"开启\",{\"0\":{\"778\":1},\"1\":{\"863\":1}}],[\"开启混合持久化\",{\"1\":{\"708\":1}}],[\"开启aof\",{\"1\":{\"708\":1}}],[\"开启数据持久化功能和配置合理的备份策略\",{\"1\":{\"675\":1}}],[\"开启慢查询日志\",{\"1\":{\"562\":1}}],[\"开启慢查询\",{\"1\":{\"557\":1}}],[\"开启逃逸分析\",{\"1\":{\"326\":1}}],[\"开头\",{\"1\":{\"534\":1}}],[\"开头为\",{\"1\":{\"419\":1}}],[\"开头的预处理命令\",{\"1\":{\"162\":1}}],[\"开始但低于\",{\"1\":{\"1140\":1}}],[\"开始时有序表中只包含一个元素\",{\"1\":{\"932\":1}}],[\"开始接受命令请求\",{\"1\":{\"655\":1}}],[\"开始向\",{\"1\":{\"655\":1}}],[\"开始执行拥塞避免\",{\"1\":{\"1019\":1}}],[\"开始执行handler\",{\"1\":{\"755\":1}}],[\"开始执行\",{\"1\":{\"655\":1}}],[\"开始\",{\"1\":{\"416\":1,\"559\":1,\"663\":1,\"933\":1}}],[\"开始遍历\",{\"1\":{\"301\":1}}],[\"开发框架知识库\",{\"1\":{\"1263\":1}}],[\"开发分支和主分支之间的合并\",{\"0\":{\"1125\":1}}],[\"开发简单\",{\"1\":{\"805\":1}}],[\"开发人员可以重新加载spring\",{\"1\":{\"769\":1}}],[\"开发可以节省很多代码\",{\"1\":{\"749\":1}}],[\"开发时只需要关注\",{\"1\":{\"746\":1}}],[\"开发aop三步走\",{\"1\":{\"719\":1}}],[\"开发相关知识\",{\"1\":{\"696\":1}}],[\"开发\",{\"0\":{\"1204\":1},\"1\":{\"685\":1,\"696\":1,\"770\":1}}],[\"开发中用到的\",{\"1\":{\"338\":1}}],[\"开发工具包\",{\"1\":{\"335\":1}}],[\"开发手册\",{\"1\":{\"59\":1}}],[\"开源类库\",{\"1\":{\"1090\":1}}],[\"开源\",{\"1\":{\"282\":1}}],[\"去银行办理业务一般要经过以下\",{\"1\":{\"1087\":1}}],[\"去掉最后一位\",{\"1\":{\"949\":1}}],[\"去掉末尾的那个\",{\"1\":{\"948\":1}}],[\"去掉不必要的属性避免存储无效数据\",{\"1\":{\"637\":1}}],[\"去重\",{\"1\":{\"882\":2,\"889\":1}}],[\"去注册中心查找在线可供调用的服务\",{\"1\":{\"801\":1}}],[\"去繁从简\",{\"1\":{\"767\":1}}],[\"去找到对应的插槽所对应的节点\",{\"1\":{\"659\":1}}],[\"去磁盘把对应的数据索引取回来\",{\"1\":{\"606\":1}}],[\"去执行\",{\"1\":{\"623\":1}}],[\"去执行其他命令\",{\"1\":{\"379\":1}}],[\"去执行这个脚本\",{\"1\":{\"324\":1}}],[\"去处理这些\",{\"1\":{\"379\":1}}],[\"去永久代\",{\"1\":{\"204\":1}}],[\"去完成\",{\"1\":{\"184\":1}}],[\"去共享执行内存中已经加载的动态库可执行代码\",{\"1\":{\"161\":1}}],[\"去创建\",{\"1\":{\"59\":1}}],[\"静态函数没有办法生成子类的实例\",{\"1\":{\"1072\":1}}],[\"静态内部类单例模式是一种优秀的单例模式\",{\"1\":{\"1069\":1}}],[\"静态内部类\",{\"0\":{\"1069\":1},\"1\":{\"1065\":1}}],[\"静态内部类的主要特点\",{\"1\":{\"361\":1}}],[\"静态代理和动态代理中\",{\"1\":{\"1084\":1}}],[\"静态代理需要在运行之前就写好代理类\",{\"1\":{\"1082\":1}}],[\"静态代理\",{\"0\":{\"1082\":1}}],[\"静态代理类在运行前就写好\",{\"1\":{\"1081\":1}}],[\"静态代理的的代理类是我们自己定义好的\",{\"1\":{\"723\":1}}],[\"静态代码块\",{\"1\":{\"1065\":2}}],[\"静态常量\",{\"1\":{\"1065\":1}}],[\"静态常量池也包括了我们说的\",{\"1\":{\"203\":1}}],[\"静态常量池主要存储的是\",{\"1\":{\"203\":1}}],[\"静态常量池\",{\"1\":{\"203\":3}}],[\"静态语句块\",{\"1\":{\"363\":2}}],[\"静态集合类\",{\"1\":{\"304\":2}}],[\"静态类型和实际类型在程序中都可能会发生变化\",{\"1\":{\"277\":1}}],[\"静态类型\",{\"1\":{\"277\":1}}],[\"静态类型语言\",{\"1\":{\"194\":1}}],[\"静态分派\",{\"0\":{\"277\":1}}],[\"静态变量仍在堆中\",{\"1\":{\"204\":1}}],[\"静态变量移除\",{\"1\":{\"204\":1}}],[\"静态变量存放在永久代上\",{\"1\":{\"204\":1}}],[\"静态变量等移出\",{\"1\":{\"203\":1}}],[\"静态变量\",{\"1\":{\"203\":1,\"363\":2}}],[\"静态\",{\"1\":{\"194\":1}}],[\"静态方法和具体方法\",{\"1\":{\"362\":1}}],[\"静态方法可以被继承\",{\"1\":{\"358\":1}}],[\"静态方法\",{\"1\":{\"194\":1}}],[\"静态链接就是在编译链接时直接将需要的执行代码拷贝到调用处\",{\"1\":{\"161\":1}}],[\"静态字段\",{\"1\":{\"74\":1}}],[\"改写所有\",{\"1\":{\"565\":1}}],[\"改成提交\",{\"1\":{\"489\":1}}],[\"改成了下面这个\",{\"1\":{\"212\":1}}],[\"改名文件\",{\"1\":{\"447\":1}}],[\"改变数据\",{\"1\":{\"1242\":1}}],[\"改变模型\",{\"1\":{\"1242\":1}}],[\"改变路由\",{\"1\":{\"993\":1}}],[\"改变对象属性\",{\"1\":{\"718\":1}}],[\"改变副本不影响原变量的值\",{\"1\":{\"351\":1}}],[\"改变哈希值\",{\"1\":{\"304\":1}}],[\"改为1以确保数据安全\",{\"1\":{\"1177\":1}}],[\"改为\",{\"1\":{\"1004\":1}}],[\"改为使用连接矩阵来记录跨region的引用关系\",{\"1\":{\"267\":1}}],[\"改为了\",{\"1\":{\"130\":1}}],[\"改进型\",{\"1\":{\"160\":2}}],[\"置于双引号中\",{\"1\":{\"1035\":1}}],[\"置换选择败者树原理\",{\"1\":{\"889\":1}}],[\"置换算法\",{\"1\":{\"160\":1}}],[\"置为\",{\"1\":{\"46\":1,\"85\":1,\"301\":1}}],[\"选出16个小文件各自的第一名中谁出现的次数最多即可\",{\"1\":{\"897\":1}}],[\"选出所有的数据中出现次数最多的前n个数据\",{\"1\":{\"891\":1}}],[\"选出新的\",{\"1\":{\"657\":1}}],[\"选不出leader怎么办\",{\"1\":{\"877\":1}}],[\"选主期间整个集群对外是不可用的\",{\"1\":{\"877\":1}}],[\"选自己发现当不了\",{\"1\":{\"820\":1}}],[\"选举超时时间\",{\"1\":{\"879\":1}}],[\"选举开始的条件\",{\"1\":{\"877\":1}}],[\"选举的过程中就需要引入服务器\",{\"1\":{\"820\":1}}],[\"选举过程中的临时角色\",{\"1\":{\"874\":1}}],[\"选举过程中或者半数以上的机器不可用的时候服务就是不可用的\",{\"1\":{\"870\":1}}],[\"选举过程中\",{\"1\":{\"820\":1}}],[\"选举状态\",{\"1\":{\"820\":1}}],[\"选举机制有两种类型\",{\"1\":{\"820\":1}}],[\"选举机制相关概念\",{\"1\":{\"820\":1}}],[\"选举机制\",{\"0\":{\"820\":1},\"1\":{\"820\":1}}],[\"选举\",{\"1\":{\"816\":1,\"820\":1}}],[\"选一台提供者进行调用\",{\"1\":{\"810\":1,\"811\":1}}],[\"选错索引\",{\"0\":{\"536\":1},\"1\":{\"559\":1}}],[\"选项有的无法识别或不能接受\",{\"1\":{\"975\":1}}],[\"选项所指定的值\",{\"1\":{\"657\":1,\"677\":1}}],[\"选项\",{\"0\":{\"1197\":1},\"1\":{\"492\":1,\"1007\":1}}],[\"选项与参数\",{\"1\":{\"419\":1}}],[\"选未来最远将使用的页淘汰\",{\"1\":{\"160\":1}}],[\"选择你想要使用的\",{\"0\":{\"1198\":1}}],[\"选择确认\",{\"1\":{\"1013\":1}}],[\"选择确认sack\",{\"0\":{\"1013\":1}}],[\"选择路径\",{\"1\":{\"961\":1}}],[\"选择排序\",{\"0\":{\"931\":1}}],[\"选择不同的配置\",{\"1\":{\"854\":1}}],[\"选择一个适合的\",{\"1\":{\"755\":1}}],[\"选择一个合适的handleradapter\",{\"1\":{\"755\":1}}],[\"选择一个commit\",{\"1\":{\"451\":1}}],[\"选择优先级\",{\"1\":{\"677\":1}}],[\"选择指定的列\",{\"1\":{\"487\":1}}],[\"选择exists\",{\"1\":{\"482\":1}}],[\"选择in\",{\"1\":{\"482\":1}}],[\"选择区\",{\"1\":{\"377\":1}}],[\"选择链表\",{\"1\":{\"373\":1}}],[\"选择数组\",{\"1\":{\"373\":1}}],[\"选择哪种分配方式由java堆是否规整决定\",{\"1\":{\"218\":1}}],[\"选择另一个进程执行\",{\"1\":{\"147\":1}}],[\"选择器\",{\"1\":{\"24\":1}}],[\"常常存在办事较复杂的例子\",{\"1\":{\"1090\":1}}],[\"常常会遇到这种情况\",{\"1\":{\"1087\":1}}],[\"常被用于伪造证书进行中间人攻击\",{\"1\":{\"1045\":1}}],[\"常被用作网址劫持\",{\"1\":{\"1040\":1}}],[\"常接\",{\"1\":{\"436\":1}}],[\"常用指令\",{\"0\":{\"1111\":1,\"1167\":1}}],[\"常用在列名和java对象属性不一样的情况\",{\"1\":{\"751\":1}}],[\"常用注入bean的方式\",{\"0\":{\"730\":1}}],[\"常用和主要的数据\",{\"1\":{\"606\":1}}],[\"常用于\",{\"1\":{\"482\":1}}],[\"常用命令\",{\"0\":{\"459\":1,\"705\":1,\"823\":1}}],[\"常用命令一般都在这里\",{\"1\":{\"416\":1}}],[\"常用\",{\"1\":{\"423\":1,\"426\":1,\"516\":1}}],[\"常用来进行一些资源释放工作\",{\"1\":{\"346\":1}}],[\"常用参数\",{\"0\":{\"318\":1}}],[\"常用的mq\",{\"0\":{\"842\":1}}],[\"常用的监听接口\",{\"1\":{\"759\":1}}],[\"常用的日志分析工具有\",{\"1\":{\"271\":1}}],[\"常用的磁盘调度算法有以下\",{\"1\":{\"163\":1}}],[\"常见问题\",{\"0\":{\"1117\":1,\"1164\":1,\"1178\":1,\"1266\":1}}],[\"常见数据结构的时间复杂度\",{\"0\":{\"928\":1}}],[\"常见需求是把业务对象序列化成二进制数组放入\",{\"1\":{\"637\":1}}],[\"常见取值\",{\"1\":{\"556\":1}}],[\"常见的分布式锁有哪些解决方案\",{\"0\":{\"668\":1}}],[\"常见的分库分表的策略\",{\"0\":{\"587\":1}}],[\"常见的方法是使用\",{\"1\":{\"1060\":1}}],[\"常见的方法是\",{\"1\":{\"550\":1}}],[\"常见的索引结构有\",{\"1\":{\"528\":1}}],[\"常见的\",{\"1\":{\"501\":2}}],[\"常见的段有数据段\",{\"1\":{\"498\":1}}],[\"常见的有mysql\",{\"1\":{\"457\":1}}],[\"常见的比如在\",{\"1\":{\"297\":1}}],[\"常见前\",{\"1\":{\"160\":1}}],[\"常量能否被回收的判定\",{\"1\":{\"237\":1}}],[\"常量保存在本地内存的元空间\",{\"1\":{\"204\":1}}],[\"常量\",{\"1\":{\"203\":1}}],[\"常量池中每一项常量都是一个表\",{\"1\":{\"286\":1}}],[\"常量池中主要存放两大类常量\",{\"1\":{\"286\":1}}],[\"常量池中废弃的常量\",{\"1\":{\"237\":1}}],[\"常量池可以比喻为class文件里的资源仓库\",{\"1\":{\"286\":1}}],[\"常量池是class文件的一部分\",{\"1\":{\"208\":1}}],[\"常量池与运行时常量池\",{\"1\":{\"208\":1}}],[\"常量池⼜可以分\",{\"1\":{\"203\":1}}],[\"常量池\",{\"0\":{\"286\":1},\"1\":{\"203\":1,\"1091\":1}}],[\"常量会被加载到运行时常量池\",{\"1\":{\"174\":1}}],[\"常在初始化之后才发生\",{\"1\":{\"172\":1}}],[\"常驻核心线程数\",{\"1\":{\"58\":1}}],[\"访问其值需要\",{\"1\":{\"1156\":1}}],[\"访问子组件\",{\"1\":{\"1155\":1}}],[\"访问控制\",{\"1\":{\"1055\":1}}],[\"访问一次树的结点就是一次\",{\"1\":{\"916\":1}}],[\"访问右子树\",{\"1\":{\"908\":2}}],[\"访问左子树\",{\"1\":{\"908\":2}}],[\"访问数据的时候\",{\"1\":{\"880\":1}}],[\"访问数据文件\",{\"1\":{\"543\":1}}],[\"访问任意节点都能请求到数据\",{\"1\":{\"880\":1}}],[\"访问动态资源\",{\"1\":{\"836\":1}}],[\"访问静态资源\",{\"1\":{\"836\":1}}],[\"访问服务器上存储的资源\",{\"1\":{\"825\":1}}],[\"访问类型\",{\"1\":{\"702\":1}}],[\"访问\",{\"1\":{\"623\":1}}],[\"访问的资源url\",{\"1\":{\"1038\":1}}],[\"访问的时候以视图的逻辑结果为准\",{\"1\":{\"524\":1}}],[\"访问的信息不在内存时\",{\"1\":{\"157\":1}}],[\"访问和插入速度比\",{\"1\":{\"408\":1}}],[\"访问父类的成员\",{\"1\":{\"364\":1}}],[\"访问父类的构造函数\",{\"1\":{\"364\":1}}],[\"访问权限控制符\",{\"1\":{\"357\":1}}],[\"访问权限控制符有哪些\",{\"0\":{\"357\":1}}],[\"访问私有的属性和方法\",{\"1\":{\"348\":1}}],[\"访问标志\",{\"0\":{\"287\":1}}],[\"访问速度仅次于程序计数器\",{\"1\":{\"190\":1}}],[\"访问所有未完成的请求\",{\"1\":{\"163\":1}}],[\"访问位\",{\"1\":{\"160\":1}}],[\"访管指令\",{\"1\":{\"135\":1}}],[\"系统只有域\",{\"1\":{\"1236\":1,\"1243\":1}}],[\"系统立即分配\",{\"1\":{\"1060\":1}}],[\"系统端口号\",{\"1\":{\"1000\":1}}],[\"系统不能仅仅因为一些事件发生的比预想的快一些或者慢一些就产生错误\",{\"1\":{\"879\":1}}],[\"系统不会充斥大量你不关心的就绪文件描述符\",{\"1\":{\"381\":1}}],[\"系统复杂度提升\",{\"1\":{\"841\":1}}],[\"系统可用性降低\",{\"1\":{\"841\":1}}],[\"系统可以根据一些关键数据进行自动降级\",{\"1\":{\"644\":1}}],[\"系统容错性低\",{\"1\":{\"840\":1}}],[\"系统也慢慢扩大\",{\"1\":{\"805\":1}}],[\"系统与系统交互较少的情况下\",{\"1\":{\"805\":1}}],[\"系统环境变量\",{\"1\":{\"784\":1}}],[\"系统级\",{\"1\":{\"759\":2}}],[\"系统级别参数\",{\"1\":{\"759\":1}}],[\"系统级错误\",{\"1\":{\"384\":1}}],[\"系统\",{\"1\":{\"736\":1,\"840\":1}}],[\"系统更健壮\",{\"1\":{\"658\":1}}],[\"系统并不会马上进行\",{\"1\":{\"657\":1}}],[\"系统上线初期\",{\"1\":{\"640\":1}}],[\"系统内存不足\",{\"1\":{\"594\":1}}],[\"系统有后台线程会定期merge\",{\"1\":{\"574\":1}}],[\"系统给\",{\"1\":{\"571\":1}}],[\"系统崩溃后可以把事务所做的任何操作都恢复出来\",{\"1\":{\"568\":1}}],[\"系统自增\",{\"1\":{\"468\":1}}],[\"系统管理员安装临时文件系统的安装点\",{\"1\":{\"416\":1}}],[\"系统引导管理器\",{\"1\":{\"416\":1}}],[\"系统启动时用到的一些文件\",{\"1\":{\"416\":1}}],[\"系统目录结构\",{\"0\":{\"416\":1}}],[\"系统中有多个产品族\",{\"1\":{\"1079\":1}}],[\"系统中一部分数据不可用或者不一致时\",{\"1\":{\"871\":1}}],[\"系统中一旦有大量你不需要读写的就绪文件描述符\",{\"1\":{\"381\":1}}],[\"系统中的数据对象是\",{\"1\":{\"608\":1}}],[\"系统中使用以下命令来查看文件的内容\",{\"1\":{\"428\":1}}],[\"系统中\",{\"1\":{\"380\":1,\"381\":1}}],[\"系统为所有对象维护一个运行时类型标识\",{\"1\":{\"339\":1}}],[\"系统会调用应用程序帮助加速垃圾回收过程\",{\"1\":{\"260\":1}}],[\"系统会首先判断当前类是否被加载过\",{\"1\":{\"184\":1}}],[\"系统采用的分配算法是指针碰撞\",{\"1\":{\"218\":1}}],[\"系统就会出现多个不同的\",{\"1\":{\"184\":1}}],[\"系统类加载器\",{\"0\":{\"178\":1},\"1\":{\"178\":1}}],[\"系统需要明确知道这个方法所在的位置\",{\"1\":{\"172\":1}}],[\"系统的时候太常见了\",{\"1\":{\"157\":1}}],[\"系统调用是有一定开销的\",{\"1\":{\"613\":1}}],[\"系统调用过程\",{\"1\":{\"135\":1}}],[\"系统调用指令\",{\"1\":{\"135\":1}}],[\"系统调用\",{\"0\":{\"135\":1},\"1\":{\"134\":1}}],[\"个人快速建站离不开\",{\"1\":{\"1208\":1}}],[\"个流程\",{\"1\":{\"1087\":1}}],[\"个探测报文段后仍然无客户端的响应\",{\"1\":{\"1028\":1}}],[\"个待排序的元素看成为一个有序表和一个无序表\",{\"1\":{\"932\":1}}],[\"个结点\",{\"0\":{\"927\":1}}],[\"个关键字\",{\"1\":{\"919\":1}}],[\"个孩子\",{\"1\":{\"918\":2,\"919\":1}}],[\"个孩子或\",{\"1\":{\"918\":1}}],[\"个文件\",{\"1\":{\"895\":1}}],[\"个ip地址\",{\"1\":{\"892\":1}}],[\"个小文件中的出现次数最多的\",{\"1\":{\"892\":1}}],[\"个小文件中\",{\"1\":{\"892\":1}}],[\"个整数的布隆过滤器\",{\"1\":{\"882\":1}}],[\"个用户谁快谁先进消息队列\",{\"1\":{\"840\":1}}],[\"个并发连接数\",{\"1\":{\"824\":1}}],[\"个节点\",{\"1\":{\"927\":1}}],[\"个节点找的话\",{\"1\":{\"927\":1}}],[\"个节点的\",{\"1\":{\"819\":2}}],[\"个节点以上\",{\"1\":{\"678\":1}}],[\"个注解\",{\"1\":{\"777\":1}}],[\"个方法\",{\"1\":{\"759\":2}}],[\"个锁\",{\"1\":{\"672\":1}}],[\"个完全独立的\",{\"1\":{\"672\":1}}],[\"个实例\",{\"1\":{\"671\":1}}],[\"个阶段\",{\"1\":{\"662\":1}}],[\"个相互独立的哈希函数\",{\"1\":{\"645\":1}}],[\"个别机器\",{\"1\":{\"642\":1}}],[\"个连续\",{\"1\":{\"973\":3}}],[\"个连续的长度为\",{\"1\":{\"628\":1}}],[\"个连接给客户端\",{\"1\":{\"582\":1}}],[\"个数字\",{\"1\":{\"1140\":1}}],[\"个数并对它们操作\",{\"1\":{\"891\":1}}],[\"个数据\",{\"1\":{\"840\":1}}],[\"个数据页\",{\"1\":{\"536\":1}}],[\"个数\",{\"1\":{\"627\":1}}],[\"个事务的\",{\"1\":{\"571\":1}}],[\"个点组成的圆环\",{\"1\":{\"880\":1}}],[\"个点\",{\"1\":{\"560\":1}}],[\"个字符\",{\"1\":{\"478\":1}}],[\"个字节数据\",{\"1\":{\"1087\":1}}],[\"个字节来保存这个长度值\",{\"1\":{\"627\":1}}],[\"个字节保存这个长度值\",{\"1\":{\"627\":1}}],[\"个字节的\",{\"1\":{\"468\":2}}],[\"个字节\",{\"1\":{\"367\":1,\"475\":1,\"477\":1,\"628\":4}}],[\"个是空字节\",{\"1\":{\"477\":1}}],[\"个主键就可以完成数据检索工作\",{\"1\":{\"464\":1}}],[\"个元素和\",{\"1\":{\"919\":1}}],[\"个元素\",{\"1\":{\"399\":2,\"932\":1}}],[\"个部分\",{\"1\":{\"392\":1,\"611\":1}}],[\"个时\",{\"1\":{\"390\":1}}],[\"个操作来完成主内存和工作内存的交互操作\",{\"1\":{\"294\":1}}],[\"个\",{\"1\":{\"160\":1,\"476\":1,\"632\":2,\"659\":1,\"672\":1,\"836\":3}}],[\"个地址\",{\"1\":{\"156\":2}}],[\"个线程\",{\"1\":{\"822\":1}}],[\"个线程在完成\",{\"1\":{\"121\":1}}],[\"个线程阻塞在一个地方\",{\"1\":{\"118\":1}}],[\"个线程为止\",{\"1\":{\"58\":1}}],[\"很大概率都会使用外观模式\",{\"1\":{\"1090\":1}}],[\"很可能并不会立即关闭socket\",{\"1\":{\"1024\":1}}],[\"很容易看到这个反向的关系\",{\"1\":{\"888\":1}}],[\"很容易就发现\",{\"1\":{\"499\":1}}],[\"很方便实现\",{\"1\":{\"676\":1}}],[\"很方便按照逻辑模块实现信息的共享和保护\",{\"1\":{\"155\":1}}],[\"很浪费内存\",{\"1\":{\"659\":1,\"678\":1}}],[\"很好的与各种数据库兼容\",{\"1\":{\"746\":1}}],[\"很好的利用了高低位\",{\"1\":{\"125\":1}}],[\"很好解决了\",{\"1\":{\"612\":1}}],[\"很多数据都查不到从而查数据库\",{\"1\":{\"643\":1}}],[\"很多地方都和concurrenthashmap的思想有异曲同工之妙\",{\"1\":{\"607\":1}}],[\"很多时候我们使用点开了很多占内存的软件\",{\"1\":{\"157\":1}}],[\"很慢的原因与解决办法\",{\"1\":{\"559\":1}}],[\"很危险\",{\"1\":{\"424\":1}}],[\"很少使用\",{\"1\":{\"350\":1,\"393\":1}}],[\"很强大\",{\"1\":{\"313\":1}}],[\"页中存储的数据就越多\",{\"1\":{\"585\":1}}],[\"页溢出\",{\"1\":{\"585\":1}}],[\"页面\",{\"0\":{\"590\":1}}],[\"页面在写完以后马上被访问到的概率比较小\",{\"1\":{\"574\":1}}],[\"页面置换算法\",{\"0\":{\"160\":1}}],[\"页面置换\",{\"0\":{\"157\":1}}],[\"页级锁的锁定粒度介于行级锁和表级锁中间\",{\"1\":{\"512\":1}}],[\"页是innodb管理存储空间的基本单位\",{\"1\":{\"591\":1}}],[\"页是innodb磁盘管理的最小单位\",{\"1\":{\"498\":1}}],[\"页是信息的物理单位\",{\"1\":{\"155\":1}}],[\"页\",{\"0\":{\"591\":1},\"1\":{\"498\":1,\"591\":1}}],[\"页组成\",{\"1\":{\"498\":1}}],[\"页在老年代中的停留时间超过配置阈值的\",{\"1\":{\"495\":1}}],[\"页被访问\",{\"1\":{\"495\":1}}],[\"页目录\",{\"1\":{\"156\":1}}],[\"页向用户提供的是一维地址空间\",{\"1\":{\"155\":1}}],[\"页大小固定\",{\"1\":{\"155\":1,\"585\":1}}],[\"段\",{\"1\":{\"498\":1}}],[\"段名+段内地址\",{\"1\":{\"155\":1}}],[\"段向用户提供二维地址空间\",{\"1\":{\"155\":1}}],[\"段的大小不固定\",{\"1\":{\"155\":1}}],[\"段是信息的逻辑单位\",{\"1\":{\"155\":1}}],[\"段页式\",{\"1\":{\"153\":2}}],[\"函数参数说明\",{\"1\":{\"1188\":1}}],[\"函数语法\",{\"1\":{\"1188\":1}}],[\"函数内提供变量是无效的\",{\"1\":{\"1159\":1}}],[\"函数指针是不行的\",{\"1\":{\"804\":1}}],[\"函数体是直接通过函数指针来指定\",{\"1\":{\"804\":1}}],[\"函数呢\",{\"1\":{\"804\":1}}],[\"函数回调\",{\"1\":{\"759\":1}}],[\"函数进行哈希\",{\"1\":{\"681\":1}}],[\"函数强制\",{\"1\":{\"649\":1}}],[\"函数都会算得一个不同的位置\",{\"1\":{\"645\":1}}],[\"函数对\",{\"1\":{\"645\":1}}],[\"函数来进行两个字符串的拼接\",{\"1\":{\"624\":1}}],[\"函数读完才结束\",{\"1\":{\"613\":1}}],[\"函数从内核读取数据\",{\"1\":{\"613\":1}}],[\"函数时\",{\"1\":{\"612\":1}}],[\"函数加入内核中的红黑树里\",{\"1\":{\"612\":1}}],[\"函数等\",{\"1\":{\"488\":1}}],[\"函数把日期转换为\",{\"1\":{\"475\":1}}],[\"函数把\",{\"1\":{\"475\":1}}],[\"函数调用的是\",{\"1\":{\"405\":1}}],[\"函数访问父类的构造函数\",{\"1\":{\"364\":1}}],[\"函数直接分配堆外内存就容易导致\",{\"1\":{\"297\":1}}],[\"函数\",{\"0\":{\"1188\":1,\"1189\":1},\"1\":{\"153\":2,\"804\":1}}],[\"函数或者代码块\",{\"1\":{\"38\":1}}],[\"孤儿进程将被\",{\"1\":{\"151\":1}}],[\"孤儿进程\",{\"0\":{\"151\":1},\"1\":{\"151\":1}}],[\"僵尸进程是当子进程比父进程先结束\",{\"1\":{\"151\":1}}],[\"僵尸进程\",{\"0\":{\"151\":1},\"1\":{\"151\":1}}],[\"迅速完成\",{\"1\":{\"150\":1}}],[\"优化处理\",{\"1\":{\"562\":1}}],[\"优化顺序\",{\"1\":{\"561\":1}}],[\"优化我们抓住\",{\"1\":{\"560\":1}}],[\"优化二\",{\"1\":{\"515\":1}}],[\"优化一\",{\"1\":{\"515\":1}}],[\"优化也违背了2pl的约束\",{\"1\":{\"501\":1}}],[\"优化\",{\"0\":{\"560\":1},\"1\":{\"489\":1,\"516\":1,\"560\":1,\"561\":1,\"930\":1}}],[\"优化器还会结合是否使用临时表\",{\"1\":{\"536\":1}}],[\"优化器选择索引的目的\",{\"1\":{\"536\":1}}],[\"优化器选择索引的逻辑\",{\"1\":{\"536\":1}}],[\"优化器的作用就是按照mysql认为的最优的执行方案去执行\",{\"1\":{\"490\":1}}],[\"优化器\",{\"1\":{\"488\":1,\"489\":2,\"490\":1}}],[\"优化代码\",{\"1\":{\"309\":1}}],[\"优势\",{\"1\":{\"261\":1,\"653\":1}}],[\"优缺点\",{\"0\":{\"746\":1},\"1\":{\"259\":1,\"348\":1,\"513\":2}}],[\"优先使用\",{\"1\":{\"652\":1}}],[\"优先保证热点数据可以提前加载到缓存\",{\"1\":{\"640\":1}}],[\"优先移除\",{\"1\":{\"636\":1}}],[\"优先级越高\",{\"1\":{\"556\":1}}],[\"优先级调度算法\",{\"1\":{\"150\":1}}],[\"优先进入老年代\",{\"1\":{\"495\":1}}],[\"优先选择\",{\"1\":{\"484\":1}}],[\"优先队列\",{\"1\":{\"394\":1}}],[\"优先处理回收价值收益最大的那些region\",{\"1\":{\"260\":1}}],[\"优先回收价值最大的region\",{\"1\":{\"260\":1}}],[\"优先分配到eden\",{\"1\":{\"220\":1}}],[\"优先委派给负责那个模块的加载器完成加载\",{\"1\":{\"181\":1}}],[\"优点是跨平台\",{\"1\":{\"190\":1}}],[\"优点是多个程序可以共享同一段代码\",{\"1\":{\"161\":1}}],[\"优点就是在程序发布的时候就不需要的依赖库\",{\"1\":{\"161\":1}}],[\"优点\",{\"1\":{\"86\":1,\"155\":1,\"254\":1,\"259\":1,\"348\":1,\"467\":1,\"477\":1,\"528\":1,\"554\":1,\"572\":2,\"585\":2,\"587\":2,\"588\":2,\"648\":1,\"656\":1,\"658\":1,\"660\":1,\"674\":1,\"675\":1,\"676\":1,\"678\":1,\"746\":1,\"843\":2,\"869\":5,\"1064\":6,\"1078\":1,\"1079\":1,\"1086\":1,\"1088\":1,\"1090\":1}}],[\"响应式变量定义在\",{\"1\":{\"1155\":1}}],[\"响应式变量const\",{\"1\":{\"1155\":1}}],[\"响应消息\",{\"1\":{\"1042\":1}}],[\"响应体\",{\"1\":{\"1038\":2}}],[\"响应头字段主要有connection\",{\"1\":{\"1038\":1}}],[\"响应头\",{\"1\":{\"1038\":3}}],[\"响应客户端\",{\"1\":{\"874\":1}}],[\"响应快的\",{\"1\":{\"677\":1}}],[\"响应时间短的优先分配\",{\"1\":{\"832\":1}}],[\"响应时间\",{\"1\":{\"310\":1}}],[\"响应时间缓慢\",{\"1\":{\"86\":1}}],[\"响应比计算增加开销\",{\"1\":{\"150\":1}}],[\"响应比=\",{\"1\":{\"150\":1}}],[\"节省内存空间\",{\"1\":{\"1071\":1}}],[\"节省空间\",{\"1\":{\"997\":1}}],[\"节省了内存空间\",{\"1\":{\"198\":1}}],[\"节约了io\",{\"1\":{\"572\":1}}],[\"节点颜色有红色和黑色\",{\"1\":{\"921\":1}}],[\"节点孩子的表示方式\",{\"1\":{\"890\":1}}],[\"节点数越多\",{\"1\":{\"880\":1}}],[\"节点数据分配问题\",{\"0\":{\"679\":1}}],[\"节点类型\",{\"0\":{\"874\":1}}],[\"节点必须可以维护和zookeeper\",{\"1\":{\"868\":1}}],[\"节点上的partition数据不丢失\",{\"1\":{\"845\":1}}],[\"节点上存储不同的内容\",{\"1\":{\"659\":1}}],[\"节点名后边会追加一个由父节点维护的自增整型数字\",{\"1\":{\"818\":2}}],[\"节点称为\",{\"1\":{\"818\":1}}],[\"节点间的网络连接通信正常的话\",{\"1\":{\"870\":1}}],[\"节点间通信\",{\"0\":{\"684\":1}}],[\"节点间数据共享\",{\"1\":{\"660\":1,\"678\":1}}],[\"节点投票\",{\"1\":{\"683\":1}}],[\"节点中选举出一个\",{\"1\":{\"683\":1}}],[\"节点的增加和移除\",{\"1\":{\"684\":1}}],[\"节点的\",{\"1\":{\"683\":1}}],[\"节点会进行投票选举\",{\"1\":{\"683\":1}}],[\"节点正常状态下接收到\",{\"1\":{\"683\":1}}],[\"节点提拔为\",{\"1\":{\"683\":1}}],[\"节点只是充当了一个数据备份的角色\",{\"1\":{\"683\":1}}],[\"节点存储不同的内容\",{\"1\":{\"678\":1}}],[\"节点存活就可以正常提供服务\",{\"1\":{\"672\":1}}],[\"节点作为备份节点不提供写服务\",{\"1\":{\"676\":1}}],[\"节点组成的分布式集群\",{\"1\":{\"676\":1}}],[\"节点之间需要不断进行\",{\"1\":{\"660\":1}}],[\"节点之间通过\",{\"1\":{\"660\":1,\"678\":1}}],[\"节点可动态添加或删除\",{\"1\":{\"660\":1,\"678\":1}}],[\"节点直连\",{\"1\":{\"659\":1}}],[\"节点后\",{\"1\":{\"659\":1}}],[\"节点需要动态变化的情况\",{\"1\":{\"638\":1}}],[\"节点保存的分值\",{\"1\":{\"630\":1}}],[\"节点按照\",{\"1\":{\"630\":1}}],[\"节点对应两个不同的文件名\",{\"1\":{\"427\":1}}],[\"节点号不相同\",{\"1\":{\"427\":1}}],[\"节点号相同\",{\"1\":{\"427\":1}}],[\"节点号与\",{\"1\":{\"427\":2}}],[\"节点\",{\"1\":{\"412\":1,\"659\":1,\"679\":1,\"683\":1,\"820\":1,\"921\":4}}],[\"节点所走过的路径称为引用链\",{\"1\":{\"234\":1}}],[\"节点和节点在循环检查的过程中基本不通信\",{\"1\":{\"122\":1}}],[\"节流以及缓冲区大小受限等缺点\",{\"1\":{\"149\":1}}],[\"消费时按发送分区的顺序消费\",{\"1\":{\"865\":1}}],[\"消费端\",{\"1\":{\"866\":2}}],[\"消费端开启多线程消费\",{\"1\":{\"865\":1}}],[\"消费端采用轮询的方式\",{\"1\":{\"843\":1}}],[\"消费的时候\",{\"1\":{\"861\":1}}],[\"消费速度较慢时\",{\"1\":{\"843\":1}}],[\"消费方需要实现消息拉取的代码\",{\"1\":{\"843\":1}}],[\"消费完成通知mq删除已消费成功的消息\",{\"1\":{\"843\":1}}],[\"消费者端\",{\"1\":{\"865\":1}}],[\"消费者分区分配策略\",{\"0\":{\"859\":1}}],[\"消费者可能会陷入循环之中\",{\"1\":{\"858\":1}}],[\"消费者可以从中消费消息\",{\"1\":{\"844\":1}}],[\"消费者可以根据自己的性能主动控制消息拉去的速度\",{\"1\":{\"843\":1}}],[\"消费者\",{\"0\":{\"857\":1}}],[\"消费者消费方式\",{\"0\":{\"858\":1}}],[\"消费者消费broker中当前topic的不同分区中的消息\",{\"1\":{\"845\":1}}],[\"消费者消费数据之后\",{\"1\":{\"844\":1}}],[\"消费者组中的每个消费者\",{\"1\":{\"846\":1}}],[\"消费者组之间互不影响\",{\"1\":{\"845\":1}}],[\"消费者组则是一组中存在多个消费者\",{\"1\":{\"845\":1}}],[\"消费者组\",{\"1\":{\"845\":1}}],[\"消费者根据消息队列的订阅拉取消息消费\",{\"1\":{\"844\":1}}],[\"消费者性能有限\",{\"1\":{\"843\":1}}],[\"消费者性能较好\",{\"1\":{\"843\":1}}],[\"消费者属于主动方\",{\"1\":{\"843\":1}}],[\"消费者属于被动方\",{\"1\":{\"843\":1}}],[\"消费者属于一种被动消费\",{\"1\":{\"843\":1}}],[\"消费者代码较少\",{\"1\":{\"843\":1}}],[\"消费者需提供一个消费接口\",{\"1\":{\"843\":1}}],[\"消费者用来获取元素的容器\",{\"1\":{\"62\":1}}],[\"消费者不找生产者要数据\",{\"1\":{\"50\":1}}],[\"消除了\",{\"1\":{\"746\":1}}],[\"消除了对两端磁道请求的不公平\",{\"1\":{\"163\":1}}],[\"消耗服务器资源主要是由于当\",{\"1\":{\"1060\":1}}],[\"消耗服务器系统的资源\",{\"1\":{\"1054\":1}}],[\"消耗资源并不多\",{\"1\":{\"562\":1}}],[\"消耗在垃圾收集上的时间不得超过n毫秒\",{\"1\":{\"261\":1}}],[\"消息认证码\",{\"1\":{\"1062\":1}}],[\"消息重复消费和消息漏掉的场景\",{\"0\":{\"866\":1}}],[\"消息顺序性的体现\",{\"0\":{\"865\":1}}],[\"消息生产者\",{\"1\":{\"845\":1}}],[\"消息生产者将消息发布到topic中\",{\"1\":{\"844\":1}}],[\"消息生产者发布消息到queue队列中\",{\"1\":{\"844\":1}}],[\"消息被消费之后则删除\",{\"1\":{\"844\":1}}],[\"消息消费者\",{\"1\":{\"845\":1}}],[\"消息消费延迟等\",{\"1\":{\"843\":1}}],[\"消息消费的过程\",{\"1\":{\"843\":2}}],[\"消息量比较大时\",{\"1\":{\"843\":1}}],[\"消息一旦到达mq\",{\"1\":{\"843\":1}}],[\"消息一致性问题\",{\"1\":{\"841\":1}}],[\"消息实时性比较高\",{\"1\":{\"843\":1}}],[\"消息保序性\",{\"1\":{\"841\":1}}],[\"消息会返回一个\",{\"1\":{\"683\":1}}],[\"消息\",{\"1\":{\"683\":2,\"859\":1,\"992\":1}}],[\"消息不一定要以先进先出的次序读取\",{\"1\":{\"149\":1}}],[\"消息队列设置定长\",{\"1\":{\"840\":1}}],[\"消息队列可以用数组实现吗\",{\"0\":{\"374\":1}}],[\"消息队列可以实现消息的随机查询\",{\"1\":{\"149\":1}}],[\"消息队列等\",{\"1\":{\"309\":1}}],[\"消息队列克服了信号承载信息量少\",{\"1\":{\"149\":1}}],[\"消息队列存放在内核中\",{\"1\":{\"149\":1}}],[\"消息队列是消息的链表\",{\"1\":{\"149\":1}}],[\"消息队列\",{\"1\":{\"149\":1,\"603\":1,\"840\":1}}],[\"具备非阻塞锁特性\",{\"1\":{\"667\":1}}],[\"具备锁失效机制\",{\"1\":{\"667\":1}}],[\"具备可重入特性\",{\"1\":{\"667\":1}}],[\"具体策略\",{\"1\":{\"1088\":1}}],[\"具体如何读取一个字节数据呢\",{\"1\":{\"1087\":1}}],[\"具体如下\",{\"1\":{\"755\":1}}],[\"具体实现\",{\"1\":{\"1087\":1}}],[\"具体实现应该依赖于抽象\",{\"1\":{\"1064\":1}}],[\"具体子类\",{\"1\":{\"1087\":1}}],[\"具体方法\",{\"1\":{\"1087\":1}}],[\"具体建造者\",{\"1\":{\"1086\":1}}],[\"具体装饰\",{\"1\":{\"1085\":1}}],[\"具体构件\",{\"1\":{\"1085\":1}}],[\"具体产品\",{\"1\":{\"1079\":1}}],[\"具体工厂\",{\"1\":{\"1079\":1}}],[\"具体的交互过程如下\",{\"1\":{\"1044\":1}}],[\"具体的可以看下图\",{\"1\":{\"622\":1}}],[\"具体思路\",{\"1\":{\"989\":1}}],[\"具体是服务器接收到这个请求\",{\"1\":{\"959\":1,\"1029\":1}}],[\"具体是指\",{\"1\":{\"158\":1}}],[\"具体过程是\",{\"1\":{\"893\":1}}],[\"具体相应的hash方法\",{\"1\":{\"884\":1}}],[\"具体配置在\",{\"1\":{\"824\":1}}],[\"具体可以选择服务器的\",{\"1\":{\"681\":1}}],[\"具体步骤如下\",{\"1\":{\"681\":1}}],[\"具体需要根据业务选\",{\"1\":{\"587\":1}}],[\"具体地说\",{\"1\":{\"583\":1}}],[\"具体执行步骤\",{\"1\":{\"557\":1}}],[\"具体一页有多大数据跟操作系统有关\",{\"1\":{\"543\":1}}],[\"具体来说\",{\"1\":{\"489\":1,\"569\":1}}],[\"具体做法是\",{\"1\":{\"880\":1}}],[\"具体做法可以在服务器\",{\"1\":{\"681\":1}}],[\"具体做法\",{\"1\":{\"197\":1}}],[\"具体有没有运行要看底层操作系统的资源调度\",{\"1\":{\"38\":1}}],[\"具有卖票功能\",{\"1\":{\"1082\":1}}],[\"具有全球唯一性\",{\"1\":{\"981\":1}}],[\"具有同1个key的所有消息\",{\"1\":{\"865\":1}}],[\"具有天然的幂等性\",{\"1\":{\"807\":1}}],[\"具有主从模式的缺点\",{\"1\":{\"658\":1}}],[\"具有较好的容错性和可扩展性\",{\"1\":{\"587\":1,\"681\":1}}],[\"具有提交\",{\"1\":{\"493\":1}}],[\"具有执行文件的权限\",{\"1\":{\"430\":1}}],[\"具有删除\",{\"1\":{\"430\":1}}],[\"具有修改文件内容的权限\",{\"1\":{\"430\":1}}],[\"具有浏览目录的权限\",{\"1\":{\"430\":1}}],[\"具有读取文件内容的权限\",{\"1\":{\"430\":1}}],[\"具有解耦意义\",{\"1\":{\"349\":1}}],[\"具有特定的格式\",{\"1\":{\"149\":1}}],[\"具有固定的读端和写端\",{\"1\":{\"149\":1}}],[\"管理者\",{\"1\":{\"833\":1}}],[\"管理\",{\"1\":{\"774\":1}}],[\"管理内存\",{\"1\":{\"594\":1}}],[\"管道机制\",{\"1\":{\"1042\":1}}],[\"管道有两个文件描述符\",{\"1\":{\"612\":1}}],[\"管道主要应用于本地进程间通信\",{\"1\":{\"612\":1}}],[\"管道命令\",{\"0\":{\"438\":1}}],[\"管道用来实现进程间相互发送非常短小的\",{\"1\":{\"149\":1}}],[\"管道只能承载无格式字\",{\"1\":{\"149\":1}}],[\"管道和消息队列的通信数据都是先进先出的原则\",{\"1\":{\"149\":1}}],[\"管道\",{\"1\":{\"149\":1}}],[\"管程锁定规则\",{\"1\":{\"75\":1,\"102\":1}}],[\"得出两个地址h1\",{\"1\":{\"884\":1}}],[\"得不到满足时变成等待资源状态\",{\"1\":{\"148\":1}}],[\"得到整个业务流程中的所有聚合之后\",{\"1\":{\"1220\":1}}],[\"得到一个按排序码从小到大排列的有序序列\",{\"1\":{\"931\":1}}],[\"得到一个平均值\",{\"1\":{\"536\":1}}],[\"得到结果后\",{\"1\":{\"891\":1}}],[\"得到值之后判断位数组中的每个元素是否都为\",{\"1\":{\"882\":1}}],[\"得到哈希值\",{\"1\":{\"882\":1}}],[\"得到应用服务器\",{\"1\":{\"869\":1}}],[\"得到请求资源标识符\",{\"1\":{\"755\":1}}],[\"得到\",{\"1\":{\"680\":1}}],[\"得到最终的网页内容\",{\"1\":{\"1044\":1}}],[\"得到最终的可执行目标文件\",{\"1\":{\"162\":1}}],[\"得到最新结果的过程称为merge\",{\"1\":{\"574\":1}}],[\"得到新的一行数据\",{\"1\":{\"489\":1}}],[\"得到的值保持不变\",{\"1\":{\"468\":1}}],[\"得到的值放入工作内存的变量副本\",{\"1\":{\"74\":1}}],[\"得到的余数才能用来访问数组下标\",{\"1\":{\"405\":1}}],[\"得到其他\",{\"1\":{\"72\":1}}],[\"恢复数据\",{\"1\":{\"578\":1}}],[\"恢复暂存区的所有文件到工作区\",{\"1\":{\"453\":1}}],[\"恢复暂存区的指定文件到工作区\",{\"1\":{\"453\":1}}],[\"恢复某个commit的指定文件到暂存区和工作区\",{\"1\":{\"453\":1}}],[\"恢复屏幕输出\",{\"1\":{\"417\":1}}],[\"恢复进程上下文\",{\"1\":{\"147\":1}}],[\"恢复到中断前的状态继续执行\",{\"1\":{\"139\":1}}],[\"移动目录内文件的权限\",{\"1\":{\"430\":1}}],[\"移动或修改名称\",{\"0\":{\"425\":1}}],[\"移动文件与目录\",{\"1\":{\"418\":1}}],[\"移动则内存回收时会更复杂\",{\"1\":{\"246\":1}}],[\"移动\",{\"1\":{\"200\":1}}],[\"移入相应的队列\",{\"1\":{\"147\":1}}],[\"移除最近最少使用的\",{\"1\":{\"636\":2}}],[\"移除文件或目录\",{\"0\":{\"424\":1}}],[\"移除所有数值等于\",{\"1\":{\"6\":1}}],[\"移除元素\",{\"0\":{\"6\":1}}],[\"寄存器和程序计数器\",{\"1\":{\"144\":1}}],[\"守护线程\",{\"0\":{\"143\":1},\"1\":{\"143\":1}}],[\"维护性\",{\"1\":{\"1064\":1}}],[\"维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息\",{\"1\":{\"1032\":1}}],[\"维护存放自己最近使用的域名的高速缓存\",{\"1\":{\"1032\":1}}],[\"维护一个key\",{\"1\":{\"893\":1}}],[\"维护\",{\"1\":{\"585\":1}}],[\"维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开销\",{\"1\":{\"142\":1}}],[\"维护的\",{\"1\":{\"39\":1,\"41\":1}}],[\"协作图\",{\"1\":{\"1094\":1}}],[\"协商缓存命中\",{\"1\":{\"1040\":1}}],[\"协同自动化修复集群的状态\",{\"1\":{\"660\":1}}],[\"协程机制\",{\"0\":{\"831\":1}}],[\"协程恢复执行时\",{\"1\":{\"139\":1}}],[\"协程主动让出执行权时\",{\"1\":{\"139\":1}}],[\"协程调度由用户自己执行\",{\"1\":{\"139\":1}}],[\"协程\",{\"0\":{\"139\":1},\"1\":{\"139\":1,\"144\":1,\"831\":1}}],[\"协议代替普通的\",{\"1\":{\"1061\":1}}],[\"协议替代普通\",{\"1\":{\"1061\":1}}],[\"协议三次握手的原理\",{\"1\":{\"1060\":1}}],[\"协议需要到\",{\"1\":{\"1048\":1}}],[\"协议之下\",{\"1\":{\"1042\":1}}],[\"协议基于\",{\"1\":{\"1042\":1}}],[\"协议使用五元组来表示一条唯一的连接\",{\"1\":{\"1042\":1}}],[\"协议和\",{\"1\":{\"1042\":1}}],[\"协议在收到数据包之后\",{\"1\":{\"1042\":1}}],[\"协议版本\",{\"1\":{\"1038\":1}}],[\"协议处理是将其放置接收缓冲区\",{\"1\":{\"1006\":1}}],[\"协议接收数据时的过程是这样的\",{\"1\":{\"1006\":1}}],[\"协议接口\",{\"0\":{\"805\":1}}],[\"协议默认的会启用\",{\"1\":{\"1006\":1}}],[\"协议传输数据的客户端与服务器经常是保持一个长连接的状态\",{\"1\":{\"1006\":1}}],[\"协议并不能保证\",{\"1\":{\"1001\":1}}],[\"协议是基于\",{\"1\":{\"1042\":1}}],[\"协议是无连接的\",{\"1\":{\"992\":1}}],[\"协议是发送广播包来询问目标\",{\"1\":{\"986\":1}}],[\"协议询问\",{\"1\":{\"986\":1}}],[\"协议数据单元pdu\",{\"1\":{\"963\":1}}],[\"协议栈\",{\"1\":{\"963\":1}}],[\"协议找到该⽬的地的\",{\"1\":{\"961\":1}}],[\"协议的\",{\"1\":{\"1042\":1}}],[\"协议的多路复用机制解决了\",{\"1\":{\"1042\":1}}],[\"协议的寻址作⽤是告诉我们去往下⼀个⽬的地该朝哪个⽅向⾛\",{\"1\":{\"961\":1}}],[\"协议的主要用途就是信息传播和扩散\",{\"1\":{\"684\":1}}],[\"协议层面的传输和访问控制\",{\"1\":{\"825\":1}}],[\"协议那么臃肿\",{\"1\":{\"806\":1}}],[\"协议实现的\",{\"1\":{\"805\":1,\"1042\":1}}],[\"协议进行系统间通讯\",{\"1\":{\"805\":1}}],[\"协议进行通信\",{\"1\":{\"612\":1}}],[\"协议优点显而易见\",{\"1\":{\"805\":1}}],[\"协议交换状态信息\",{\"1\":{\"660\":1,\"678\":1}}],[\"协议\",{\"1\":{\"72\":1,\"660\":1,\"684\":1,\"685\":1,\"804\":1,\"1004\":1,\"1009\":1,\"1011\":2,\"1042\":1,\"1061\":2}}],[\"过来的请求由master管理\",{\"1\":{\"833\":1}}],[\"过滤敏感词汇\",{\"1\":{\"759\":1}}],[\"过滤器执行流程\",{\"1\":{\"759\":1}}],[\"过滤器的配置比较简单\",{\"1\":{\"759\":1}}],[\"过滤器\",{\"0\":{\"759\":1},\"1\":{\"759\":3}}],[\"过滤故障的节点\",{\"1\":{\"677\":1}}],[\"过多的键同样会消耗大量内存\",{\"1\":{\"637\":1}}],[\"过期了\",{\"1\":{\"876\":1}}],[\"过期时\",{\"1\":{\"669\":1}}],[\"过期时间\",{\"1\":{\"607\":1,\"705\":1}}],[\"过期策略用于处理过期的缓存数据\",{\"1\":{\"636\":1}}],[\"过期策略通常有以下两种\",{\"1\":{\"632\":1}}],[\"过期扫描不会遍历过期字典中所有的\",{\"1\":{\"632\":1}}],[\"过期则清除\",{\"1\":{\"632\":1}}],[\"过期键的删除策略\",{\"0\":{\"632\":1}}],[\"过程完成为止\",{\"1\":{\"647\":1}}],[\"过程中\",{\"1\":{\"623\":1}}],[\"过程\",{\"0\":{\"213\":1,\"397\":1,\"398\":1},\"1\":{\"137\":4,\"622\":1,\"655\":1,\"986\":1,\"1049\":1}}],[\"过早通知指前驱节点不是头节点的线程由于中断被唤醒\",{\"1\":{\"122\":1}}],[\"保密性\",{\"1\":{\"1055\":1}}],[\"保活计时器的作用\",{\"0\":{\"1028\":1}}],[\"保留这些报文的边界\",{\"1\":{\"1002\":1}}],[\"保留两位小数\",{\"1\":{\"953\":2}}],[\"保留没有重复的字符串\",{\"1\":{\"890\":1}}],[\"保持和leader数据的同步\",{\"1\":{\"845\":1}}],[\"保持列\",{\"1\":{\"533\":1}}],[\"保护方法\",{\"1\":{\"350\":1}}],[\"保存数据提交之前的版本\",{\"1\":{\"570\":1}}],[\"保存从\",{\"1\":{\"475\":1}}],[\"保存在服务端\",{\"0\":{\"1052\":1}}],[\"保存在客户端\",{\"0\":{\"1051\":1}}],[\"保存在它的一个concurrenthashmap中\",{\"1\":{\"737\":1}}],[\"保存在磁盘分区中的文件不管是什么类型都给它分配一个编号\",{\"1\":{\"427\":1}}],[\"保存在堆中\",{\"1\":{\"204\":1}}],[\"保存这些信息的类就是\",{\"1\":{\"339\":1}}],[\"保存进程上下文\",{\"1\":{\"147\":1}}],[\"保存起来\",{\"1\":{\"144\":1}}],[\"保存的线程状态比\",{\"1\":{\"136\":1}}],[\"保证内部实体的一致性\",{\"1\":{\"1232\":1}}],[\"保证内存不泄露\",{\"1\":{\"46\":1}}],[\"保证这个业务流程所涉及的领域都在一个限界上下文中\",{\"1\":{\"1221\":1}}],[\"保证接收方来得及接收\",{\"1\":{\"1015\":1}}],[\"保证的是\",{\"1\":{\"870\":1}}],[\"保证producer到server之间不会丢失数据\",{\"1\":{\"856\":1}}],[\"保证应用能够在应用服务器上正常运行\",{\"1\":{\"825\":1}}],[\"保证系统有条不紊的进行\",{\"1\":{\"809\":1}}],[\"保证服务平稳运行\",{\"1\":{\"675\":1}}],[\"保证数据一致性\",{\"1\":{\"647\":1}}],[\"保证事务的持久性\",{\"1\":{\"519\":1}}],[\"保证生成的id不仅是表独立的\",{\"1\":{\"467\":1}}],[\"保证实体完整性\",{\"1\":{\"464\":1}}],[\"保证唯一性\",{\"1\":{\"462\":1}}],[\"保证在给定的空间\",{\"1\":{\"645\":1}}],[\"保证在操作不同段\",{\"1\":{\"410\":1}}],[\"保证在该屏障之后对共享变量的读取\",{\"1\":{\"78\":1}}],[\"保证在该屏障之前对共享变量的改动\",{\"1\":{\"78\":1}}],[\"保证有序性\",{\"1\":{\"337\":1}}],[\"保证此变量对所有线程时可见的\",{\"1\":{\"296\":1}}],[\"保证被校验类的方法在运行时不会做出危害虚拟机安全的行为\",{\"1\":{\"170\":1}}],[\"保证被加载类的正确性\",{\"1\":{\"170\":1}}],[\"保证共享数据在同一个时刻只被一条\",{\"1\":{\"142\":1}}],[\"保证读读共享\",{\"1\":{\"125\":1}}],[\"保证\",{\"1\":{\"123\":1,\"674\":1,\"820\":1}}],[\"保证正确同步的多线程程序的执行结果不变\",{\"1\":{\"77\":1,\"102\":1}}],[\"保证单线程程序的执行结果不变\",{\"1\":{\"77\":1}}],[\"保证并发编程的正确性\",{\"1\":{\"75\":1}}],[\"保证程序最终执行结果和代码顺序执行的结果一致\",{\"1\":{\"70\":1}}],[\"保证了数据的快速访问\",{\"1\":{\"615\":1}}],[\"保证了事务的持久性\",{\"1\":{\"519\":1}}],[\"保证了\",{\"1\":{\"65\":1}}],[\"保证了同一个线程获取一个\",{\"1\":{\"43\":1}}],[\"缺陷\",{\"1\":{\"669\":1}}],[\"缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的\",{\"1\":{\"159\":1}}],[\"缺页中断\",{\"0\":{\"159\":1}}],[\"缺页异常\",{\"0\":{\"159\":1},\"1\":{\"134\":1}}],[\"缺点则是元数据更新有延时\",{\"1\":{\"684\":1}}],[\"缺点是性能下降\",{\"1\":{\"190\":1}}],[\"缺点是由于是运行时加载\",{\"1\":{\"161\":1}}],[\"缺点\",{\"1\":{\"86\":1,\"155\":1,\"259\":1,\"348\":1,\"411\":1,\"467\":1,\"477\":1,\"528\":1,\"549\":1,\"554\":1,\"572\":2,\"585\":2,\"587\":2,\"588\":2,\"648\":1,\"656\":1,\"658\":1,\"660\":1,\"668\":1,\"674\":1,\"675\":1,\"676\":1,\"678\":1,\"746\":1,\"843\":2,\"869\":5,\"997\":1,\"1042\":1,\"1078\":1,\"1079\":1,\"1088\":1}}],[\"异构网络\",{\"1\":{\"961\":1}}],[\"异常通知\",{\"1\":{\"722\":1}}],[\"异常调用完成\",{\"1\":{\"195\":1}}],[\"异常处理等\",{\"1\":{\"719\":1}}],[\"异常处理\",{\"1\":{\"189\":1,\"717\":1}}],[\"异常\",{\"0\":{\"382\":1},\"1\":{\"134\":1,\"297\":1,\"350\":2,\"384\":1,\"717\":1}}],[\"异步处理\",{\"1\":{\"840\":2}}],[\"异步通讯框架\",{\"1\":{\"804\":1}}],[\"异步删除\",{\"1\":{\"604\":1}}],[\"异步io\",{\"1\":{\"496\":1}}],[\"异步非阻塞\",{\"1\":{\"380\":1}}],[\"异步\",{\"1\":{\"72\":1,\"137\":1,\"380\":3,\"381\":1}}],[\"异步原理\",{\"1\":{\"72\":1}}],[\"引发宕机的情况\",{\"1\":{\"843\":1}}],[\"引发一个内中断\",{\"1\":{\"134\":1}}],[\"引起数据库压力瞬间增大\",{\"1\":{\"643\":1}}],[\"引起\",{\"1\":{\"559\":1}}],[\"引导mysql使用我们期望的索引\",{\"1\":{\"536\":1}}],[\"引导类加载器\",{\"0\":{\"176\":1},\"1\":{\"175\":1}}],[\"引擎\",{\"1\":{\"528\":1,\"577\":1}}],[\"引擎和\",{\"1\":{\"528\":1}}],[\"引擎通过\",{\"1\":{\"519\":1}}],[\"引擎使用\",{\"1\":{\"519\":1}}],[\"引擎把刚刚写入的\",{\"1\":{\"489\":1}}],[\"引擎将这行新数据更新到内存中\",{\"1\":{\"489\":1}}],[\"引擎直接用树搜索找到这一行\",{\"1\":{\"489\":1}}],[\"引擎会在适当的时候\",{\"1\":{\"489\":1,\"569\":1}}],[\"引擎就会先把记录写到\",{\"1\":{\"489\":1,\"569\":1}}],[\"引擎有自有的日志模块\",{\"1\":{\"488\":1}}],[\"引用错了\",{\"1\":{\"1165\":1}}],[\"引用路径长度相同时\",{\"1\":{\"798\":1}}],[\"引用\",{\"0\":{\"1155\":1},\"1\":{\"714\":1}}],[\"引用另外一个表中的一列或多列数据\",{\"1\":{\"462\":1}}],[\"引用主表的主键列\",{\"1\":{\"455\":1}}],[\"引用地址不能变\",{\"1\":{\"346\":1}}],[\"引用传递\",{\"1\":{\"343\":1}}],[\"引用访问到初始化了一半的对象\",{\"1\":{\"295\":1}}],[\"引用类型字段赋值\",{\"1\":{\"250\":1}}],[\"引用强度分类\",{\"0\":{\"235\":1}}],[\"引用计数法\",{\"0\":{\"233\":1},\"1\":{\"232\":1}}],[\"引入外观模式可将它们分离\",{\"1\":{\"1090\":1}}],[\"引入虚拟节点后\",{\"1\":{\"880\":1}}],[\"引入额外的单点\",{\"1\":{\"588\":1}}],[\"引入的索引下推优化\",{\"1\":{\"553\":1}}],[\"引入了多路查找树的概念\",{\"1\":{\"916\":1}}],[\"引入了多线程\",{\"1\":{\"610\":1}}],[\"引入了一项重大特性\",{\"1\":{\"856\":1}}],[\"引入了一种基于通道\",{\"1\":{\"209\":1}}],[\"引入了域的概念\",{\"1\":{\"186\":1}}],[\"引入thread\",{\"1\":{\"185\":1}}],[\"引入偏向锁\",{\"1\":{\"88\":1}}],[\"方案1\",{\"1\":{\"900\":1}}],[\"方案三\",{\"1\":{\"895\":1}}],[\"方案二\",{\"1\":{\"895\":1,\"896\":1,\"900\":1,\"901\":1}}],[\"方案一\",{\"1\":{\"895\":1,\"896\":1,\"901\":1}}],[\"方式有两种\",{\"1\":{\"1042\":1}}],[\"方式保存了\",{\"1\":{\"653\":1}}],[\"方式会让持久化文件越来越大\",{\"1\":{\"651\":1}}],[\"方便快捷的开发方式\",{\"1\":{\"1208\":1}}],[\"方便资源之间的互相通信\",{\"1\":{\"1073\":1}}],[\"方便在集群中扩展\",{\"1\":{\"852\":1}}],[\"方便组内开发人员之间的配合\",{\"1\":{\"754\":1}}],[\"方便指向下一个节点\",{\"1\":{\"622\":1}}],[\"方便下一次调用\",{\"1\":{\"490\":1}}],[\"方便维护\",{\"1\":{\"133\":1}}],[\"方法吗\",{\"1\":{\"1247\":1}}],[\"方法上\",{\"1\":{\"1242\":1}}],[\"方法增强\",{\"1\":{\"1082\":1}}],[\"方法增加一个许可证\",{\"1\":{\"117\":1}}],[\"方法只能得到同一个单例\",{\"1\":{\"1075\":1}}],[\"方法只能使同优先级或更高优先级的线程有执行的机会\",{\"1\":{\"35\":1}}],[\"方法本身是可缓存的\",{\"1\":{\"1041\":1}}],[\"方法不是\",{\"1\":{\"1041\":1}}],[\"方法不会改变服务器状态\",{\"1\":{\"1041\":1}}],[\"方法不能被重写\",{\"1\":{\"358\":1}}],[\"方法输出response\",{\"1\":{\"959\":1,\"1029\":1}}],[\"方法编写\",{\"1\":{\"804\":2}}],[\"方法运行\",{\"1\":{\"781\":1}}],[\"方法可能继续在现有事务中运行\",{\"1\":{\"740\":1}}],[\"方法可以将参数为\",{\"1\":{\"344\":1}}],[\"方法可以在任何地方使用\",{\"1\":{\"37\":1}}],[\"方法将applicationcontext\",{\"1\":{\"736\":1}}],[\"方法将高位和低位都利用起来了\",{\"1\":{\"405\":1}}],[\"方法设置id\",{\"1\":{\"733\":1}}],[\"方法实现可选依赖\",{\"1\":{\"730\":1}}],[\"方法注入是容器通过调用无参构造器或无参\",{\"1\":{\"730\":1}}],[\"方法注入\",{\"1\":{\"730\":1}}],[\"方法指的是执行真实对象的方法\",{\"1\":{\"725\":1}}],[\"方法指定排序规则\",{\"1\":{\"62\":1}}],[\"方法反射来调用目标类中的代码\",{\"1\":{\"715\":1,\"725\":1}}],[\"方法内通过对象锁实现\",{\"1\":{\"409\":1}}],[\"方法内实现了要执行的任务\",{\"1\":{\"31\":1}}],[\"方法以\",{\"1\":{\"408\":1}}],[\"方法对数组进行初始化\",{\"1\":{\"402\":1}}],[\"方法对于类或接口来说并不是必需的\",{\"1\":{\"173\":1}}],[\"方法从该位置上的链表中取出\",{\"1\":{\"396\":1}}],[\"方法从调用到执行完毕\",{\"1\":{\"190\":1}}],[\"方法确定其在数组位置上链表的位置\",{\"1\":{\"396\":1}}],[\"方法转换成\",{\"1\":{\"391\":1}}],[\"方法进行比较和排序的\",{\"1\":{\"408\":1}}],[\"方法进行重复键比较\",{\"1\":{\"408\":1}}],[\"方法进行了重写\",{\"1\":{\"389\":1}}],[\"方法进行设置\",{\"1\":{\"179\":1}}],[\"方法传递参数异常\",{\"1\":{\"385\":1}}],[\"方法默认\",{\"1\":{\"362\":1}}],[\"方法跟类的任何实例都不相关\",{\"1\":{\"358\":1}}],[\"方法获取的缓冲区都是非直接缓冲区\",{\"1\":{\"378\":1}}],[\"方法获取指定构造器\",{\"1\":{\"356\":1}}],[\"方法获取锁而不被阻塞\",{\"1\":{\"96\":1}}],[\"方法创建\",{\"1\":{\"356\":2}}],[\"方法具有\",{\"1\":{\"355\":1}}],[\"方法访问到\",{\"1\":{\"355\":1}}],[\"方法就是使当前线程等待该对象的锁\",{\"1\":{\"350\":1}}],[\"方法就会一直阻塞\",{\"1\":{\"118\":1}}],[\"方法读取和修改\",{\"1\":{\"348\":1}}],[\"方法配合\",{\"1\":{\"342\":1}}],[\"方法也可以\",{\"1\":{\"342\":1}}],[\"方法来判断该元素是否相同\",{\"1\":{\"400\":1}}],[\"方法来实现动态扩容\",{\"1\":{\"392\":1}}],[\"方法来进行调用\",{\"1\":{\"349\":1}}],[\"方法来比较两个对象的内容是否相等\",{\"1\":{\"340\":1}}],[\"方法来获取默认值或将其值更改为当前线程所存的副本的值\",{\"1\":{\"299\":1}}],[\"方法来获取返回值\",{\"1\":{\"61\":1}}],[\"方法作用是清除对象的引用\",{\"1\":{\"301\":1}}],[\"方法定义及其他信息\",{\"1\":{\"292\":1}}],[\"方法体里面的java代码\",{\"1\":{\"292\":1}}],[\"方法和类\",{\"1\":{\"370\":1}}],[\"方法和类级别\",{\"1\":{\"79\":1}}],[\"方法和实例构造器<init>\",{\"1\":{\"290\":1}}],[\"方法里的java代码\",{\"1\":{\"290\":1}}],[\"方法里的两条invokevirtual指令的参数中\",{\"1\":{\"277\":1}}],[\"方法里面的代码哪里去了\",{\"1\":{\"290\":1}}],[\"方法表都可以携带自己的属性表集合\",{\"1\":{\"291\":1}}],[\"方法表的结构如同字段表一样\",{\"1\":{\"290\":1}}],[\"方法表集合中就不会出现来自父类的方法信息\",{\"1\":{\"290\":1}}],[\"方法表集合\",{\"0\":{\"290\":1}}],[\"方法句柄和方法类型\",{\"1\":{\"286\":1}}],[\"方法句柄和调用限定符7类符号引用进行\",{\"1\":{\"172\":1}}],[\"方法重写的本质\",{\"1\":{\"278\":1}}],[\"方法重载\",{\"1\":{\"277\":1}}],[\"方法调用与\",{\"1\":{\"348\":1}}],[\"方法调用阶段唯一的任务就是确定被调用方法的版本\",{\"1\":{\"273\":1}}],[\"方法调用并不等同于方法中的代码被执行\",{\"1\":{\"273\":1}}],[\"方法调用\",{\"0\":{\"273\":1},\"1\":{\"733\":1}}],[\"方法调用流程\",{\"1\":{\"124\":1}}],[\"方法去拯救对象\",{\"1\":{\"236\":1}}],[\"方法还没有执行\",{\"1\":{\"223\":1}}],[\"方法区等内存大小的设置\",{\"0\":{\"320\":1}}],[\"方法区中常量引用的对象\",{\"1\":{\"234\":1}}],[\"方法区中类静态属性引用的对象\",{\"1\":{\"234\":1}}],[\"方法区的gc主要涉及\",{\"1\":{\"237\":1}}],[\"方法区的gc\",{\"0\":{\"237\":1}}],[\"方法区的实现从永久代变成元空间有什么区别\",{\"0\":{\"205\":1}}],[\"方法区的演进细节\",{\"0\":{\"204\":1}}],[\"方法区\",{\"0\":{\"203\":1,\"323\":1}}],[\"方法服务\",{\"1\":{\"197\":1}}],[\"方法正常退出时\",{\"1\":{\"195\":1}}],[\"方法返回一个匹配的对象\",{\"1\":{\"1188\":1}}],[\"方法返回\",{\"1\":{\"882\":1}}],[\"方法返回值为\",{\"1\":{\"759\":2}}],[\"方法返回时可能需要在栈帧中保存一些信息\",{\"1\":{\"195\":1}}],[\"方法返回地址与其他附加信息全部归为一类\",{\"1\":{\"196\":1}}],[\"方法返回地址\",{\"0\":{\"195\":1}}],[\"方法返回地址和一些额外的附加信息\",{\"1\":{\"191\":1}}],[\"方法或者类在符号引用被替换为直接引用的过程\",{\"1\":{\"194\":1}}],[\"方法出口等信息\",{\"1\":{\"190\":1}}],[\"方法会返回该集合所实现的特定迭代器对象\",{\"1\":{\"389\":1}}],[\"方法会打破双亲委派机制\",{\"1\":{\"185\":1}}],[\"方法会阻塞当前线程直到任务完成\",{\"1\":{\"61\":1}}],[\"方法在多线程下被同步加锁\",{\"1\":{\"173\":1}}],[\"方法在内存中的指针或者偏移量\",{\"1\":{\"172\":1}}],[\"方法已经被虚拟机调用过\",{\"1\":{\"236\":1}}],[\"方法已经被调用过一次之后\",{\"1\":{\"88\":1}}],[\"方法已经执行完毕\",{\"1\":{\"173\":1}}],[\"方法执行前\",{\"1\":{\"173\":1}}],[\"方法与类的构造函数\",{\"1\":{\"173\":1}}],[\"方法类型\",{\"1\":{\"172\":1}}],[\"方法交换数据\",{\"1\":{\"127\":1}}],[\"方法必须确保同步状态安全释放\",{\"1\":{\"123\":1}}],[\"方法必须返回\",{\"1\":{\"96\":1}}],[\"方法尝试获取同步状态\",{\"1\":{\"123\":1}}],[\"方法之后的语句得到执行\",{\"1\":{\"118\":1}}],[\"方法之后的语句不会被执行\",{\"1\":{\"118\":1}}],[\"方法之后重量级锁才支持\",{\"1\":{\"88\":1}}],[\"方法阻塞\",{\"1\":{\"117\":1}}],[\"方法阻塞生产者\",{\"1\":{\"62\":1}}],[\"方法后会阻塞等待第二个线程执行该方法\",{\"1\":{\"127\":1}}],[\"方法后\",{\"1\":{\"111\":1}}],[\"方法得到的结果不一致\",{\"1\":{\"88\":1}}],[\"方法先行发生于此线程的每一个动作\",{\"1\":{\"75\":1,\"102\":1}}],[\"方法则会阻塞当前线程一段时间后立即返回\",{\"1\":{\"61\":1}}],[\"方法则只能在同步方法或同步块中使用\",{\"1\":{\"37\":1}}],[\"方法时\",{\"1\":{\"46\":1,\"96\":1,\"118\":1,\"402\":1}}],[\"方法中实现\",{\"1\":{\"804\":1}}],[\"方法中有三个参数\",{\"1\":{\"725\":1}}],[\"方法中将共享变量定义为\",{\"1\":{\"129\":1}}],[\"方法中\",{\"1\":{\"114\":1}}],[\"方法中断线程\",{\"1\":{\"59\":1}}],[\"方法中断\",{\"1\":{\"37\":1}}],[\"方法中的代码而已\",{\"1\":{\"33\":1}}],[\"方法同样必须在\",{\"1\":{\"35\":1}}],[\"方法了\",{\"1\":{\"35\":1}}],[\"方法的参数或者对静态方法的调用来访问另一个类\",{\"1\":{\"1096\":1}}],[\"方法的作用是把原\",{\"1\":{\"406\":1}}],[\"方法的重载和重写都是实现多态的方式\",{\"1\":{\"359\":1}}],[\"方法的名称和描述符\",{\"1\":{\"286\":1}}],[\"方法的绑定机制\",{\"1\":{\"194\":1}}],[\"方法的那个类\",{\"1\":{\"174\":1}}],[\"方法的类型肯定是java\",{\"1\":{\"173\":1}}],[\"方法的过程\",{\"1\":{\"173\":1}}],[\"方法的返回值\",{\"1\":{\"178\":1}}],[\"方法的返回值是\",{\"1\":{\"33\":1}}],[\"方法的返回结果\",{\"1\":{\"166\":1}}],[\"方法的时候\",{\"1\":{\"118\":1,\"300\":1}}],[\"方法的开始\",{\"1\":{\"75\":1,\"102\":1}}],[\"方法的调用先行发生于被中断线程的代码检测到中断事件的发生\",{\"1\":{\"75\":1,\"102\":1}}],[\"方法的调用在调用方所在的线程\",{\"1\":{\"34\":1}}],[\"方法其实运行在当前线程\",{\"1\":{\"34\":1}}],[\"方法是安全的\",{\"1\":{\"1041\":1}}],[\"方法是从网络的主机号借用若干位来作为子网号\",{\"1\":{\"989\":1}}],[\"方法是编译时静态绑定的\",{\"1\":{\"358\":1}}],[\"方法是对象逃脱死亡命运的最后一次机会\",{\"1\":{\"236\":1}}],[\"方法是带锁线程安全\",{\"1\":{\"173\":1}}],[\"方法是否结束\",{\"1\":{\"75\":1,\"102\":1}}],[\"方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块\",{\"1\":{\"173\":1}}],[\"方法是由\",{\"1\":{\"34\":1}}],[\"方法是有返回值的\",{\"1\":{\"33\":1}}],[\"方法四\",{\"1\":{\"31\":1}}],[\"方法三\",{\"1\":{\"31\":1}}],[\"方法二\",{\"1\":{\"31\":1,\"908\":1}}],[\"方法一直等待\",{\"1\":{\"350\":1}}],[\"方法一般都要重写\",{\"1\":{\"350\":1}}],[\"方法一\",{\"1\":{\"31\":1,\"908\":1}}],[\"方法\",{\"0\":{\"223\":1,\"301\":1,\"342\":1,\"358\":1},\"1\":{\"6\":1,\"31\":1,\"34\":2,\"38\":8,\"46\":1,\"85\":1,\"96\":1,\"114\":1,\"117\":1,\"123\":2,\"125\":1,\"126\":1,\"166\":2,\"168\":1,\"173\":2,\"182\":1,\"185\":1,\"204\":1,\"208\":1,\"223\":1,\"234\":1,\"236\":4,\"274\":1,\"290\":1,\"300\":1,\"301\":1,\"340\":2,\"342\":1,\"343\":2,\"346\":1,\"349\":1,\"350\":13,\"355\":1,\"356\":6,\"361\":2,\"389\":1,\"391\":2,\"393\":2,\"402\":1,\"406\":2,\"712\":1,\"725\":1,\"729\":1,\"730\":1,\"733\":2,\"736\":2,\"755\":1,\"759\":1,\"801\":1,\"804\":2,\"822\":1,\"885\":1,\"959\":1,\"1029\":1,\"1040\":1,\"1041\":1,\"1083\":2,\"1084\":2,\"1087\":2}}],[\"性能优化\",{\"1\":{\"1177\":1}}],[\"性能优化的步骤\",{\"0\":{\"306\":1}}],[\"性能消耗低\",{\"1\":{\"806\":1}}],[\"性能统计\",{\"1\":{\"719\":1}}],[\"性能好\",{\"1\":{\"652\":1}}],[\"性能最好\",{\"1\":{\"650\":1}}],[\"性能考虑\",{\"1\":{\"630\":1}}],[\"性能\",{\"1\":{\"583\":1,\"734\":1}}],[\"性能不就能大大提高了吗\",{\"1\":{\"579\":1}}],[\"性能肯定不高\",{\"1\":{\"579\":1}}],[\"性能的消耗\",{\"1\":{\"558\":1}}],[\"性能较扫一遍索引树更低\",{\"1\":{\"549\":1}}],[\"性能较好\",{\"1\":{\"163\":2}}],[\"性能略微下降了一些\",{\"1\":{\"391\":1}}],[\"性能开销\",{\"1\":{\"348\":1}}],[\"性能评测的指标\",{\"0\":{\"310\":1}}],[\"性能调优\",{\"0\":{\"309\":1}}],[\"性能分析\",{\"0\":{\"308\":1}}],[\"性能监控\",{\"0\":{\"307\":1}}],[\"性能监控与调优\",{\"0\":{\"305\":1}}],[\"性能收集相关的信息\",{\"1\":{\"196\":1}}],[\"性能低\",{\"1\":{\"133\":1}}],[\"性能高\",{\"1\":{\"133\":1}}],[\"难以维护\",{\"1\":{\"133\":1}}],[\"难点在于边界\",{\"1\":{\"5\":1}}],[\"利用系统漏洞入侵系统\",{\"1\":{\"1054\":1}}],[\"利用滑动窗口实现流量控制的机制\",{\"1\":{\"1015\":1}}],[\"利用滑动窗口实现流量控制\",{\"1\":{\"1009\":1}}],[\"利用公用的互联网作为本机构各专用网之间的通信载体\",{\"1\":{\"995\":1}}],[\"利用快速\",{\"1\":{\"895\":1}}],[\"利用数据的设计实现方法\",{\"1\":{\"887\":1}}],[\"利用现成的\",{\"1\":{\"805\":1}}],[\"利用长连接进行写命令的传播\",{\"1\":{\"662\":1}}],[\"利用文件描述符\",{\"1\":{\"612\":1}}],[\"利用这一特性可以运用在手机验证码\",{\"1\":{\"603\":1}}],[\"利用explain看看执行计划是否准确\",{\"1\":{\"562\":1}}],[\"利用二分查找二等原理\",{\"1\":{\"529\":1}}],[\"利用该\",{\"1\":{\"356\":1}}],[\"利用加载器加载\",{\"1\":{\"349\":1}}],[\"利用到\",{\"1\":{\"349\":1}}],[\"利用类型擦除的原理\",{\"1\":{\"345\":1}}],[\"利用率\",{\"1\":{\"150\":1}}],[\"利用率一直维持在较高水平\",{\"1\":{\"64\":1}}],[\"利用网络进行通信\",{\"1\":{\"149\":1}}],[\"利用\",{\"1\":{\"131\":1,\"612\":1,\"637\":1,\"642\":1,\"834\":1}}],[\"弃用分段锁的原因\",{\"0\":{\"131\":1}}],[\"查出所有记录再按偏移量和\",{\"1\":{\"753\":1}}],[\"查进程\",{\"1\":{\"426\":1}}],[\"查询报文数量\",{\"1\":{\"1032\":1}}],[\"查询效率\",{\"1\":{\"1032\":1}}],[\"查询效率要求极高\",{\"1\":{\"619\":1}}],[\"查询统计\",{\"1\":{\"893\":1}}],[\"查询串的重复度比较高\",{\"1\":{\"890\":1}}],[\"查询那些文件包含了某单词\",{\"1\":{\"888\":1}}],[\"查询结果是一样的\",{\"1\":{\"807\":1}}],[\"查询结果只有一条\",{\"1\":{\"556\":1}}],[\"查询一次或多次\",{\"1\":{\"807\":1}}],[\"查询对于结果不会有任何改变\",{\"1\":{\"807\":1}}],[\"查询操作\",{\"1\":{\"807\":1}}],[\"查询maven版本\",{\"1\":{\"793\":1}}],[\"查询数据库\",{\"1\":{\"752\":1}}],[\"查询数据只使用前进指针就可以了\",{\"1\":{\"630\":1}}],[\"查询字段\",{\"1\":{\"751\":1}}],[\"查询\",{\"0\":{\"701\":1},\"1\":{\"623\":1,\"643\":1,\"678\":1}}],[\"查询分数\",{\"1\":{\"620\":1}}],[\"查询语句\",{\"0\":{\"598\":1},\"1\":{\"601\":1}}],[\"查询语句的执行流程如下\",{\"1\":{\"489\":1}}],[\"查询切分\",{\"1\":{\"588\":1}}],[\"查询老版本数据\",{\"1\":{\"570\":1}}],[\"查询日志\",{\"1\":{\"566\":1}}],[\"查询慢查询是否开启以及日志存储位置等\",{\"1\":{\"557\":1}}],[\"查询时扫描的行太多\",{\"1\":{\"584\":1}}],[\"查询时实际使用到的索引\",{\"1\":{\"556\":1}}],[\"查询时可能使用到的索引\",{\"1\":{\"556\":1}}],[\"查询时间复杂度\",{\"1\":{\"130\":1}}],[\"查询类型\",{\"1\":{\"556\":1}}],[\"查询仍然是从头到尾\",{\"1\":{\"541\":1}}],[\"查询流程如下\",{\"1\":{\"537\":1}}],[\"查询条件一定要符合最左前缀原则才能使用到索引\",{\"1\":{\"535\":1}}],[\"查询中若包含任何复杂的子查询\",{\"1\":{\"556\":1}}],[\"查询中统计或者分组字段\",{\"1\":{\"531\":1}}],[\"查询中排序的字段\",{\"1\":{\"531\":1}}],[\"查询中与其他表关联的字段存在外键关系\",{\"1\":{\"531\":1}}],[\"查询会变快\",{\"0\":{\"529\":1}}],[\"查询过程中访问到的对象才会加锁\",{\"1\":{\"515\":1}}],[\"查询不建议使用缓存\",{\"1\":{\"490\":1}}],[\"查询缓存主要用来缓存我们所执行的\",{\"1\":{\"490\":1}}],[\"查询缓存\",{\"1\":{\"488\":1,\"490\":1}}],[\"查询速度越慢\",{\"1\":{\"486\":1}}],[\"查询机器与哪些应用建立了\",{\"1\":{\"435\":1}}],[\"查询快\",{\"1\":{\"392\":1}}],[\"查找的时间复杂度是\",{\"1\":{\"916\":1}}],[\"查找树\",{\"0\":{\"914\":1}}],[\"查找或者更新操作时\",{\"1\":{\"623\":1}}],[\"查找都是\",{\"1\":{\"622\":1}}],[\"查找表和缓存类似\",{\"1\":{\"603\":1}}],[\"查找表\",{\"1\":{\"603\":1}}],[\"查找信息\",{\"1\":{\"601\":1}}],[\"查找使用了索引\",{\"1\":{\"556\":1}}],[\"查找到第一个满足条件的记录后\",{\"1\":{\"555\":1}}],[\"查找到满足条件的第一个记录\",{\"1\":{\"555\":1}}],[\"查找文件中符合条件的字符串\",{\"1\":{\"443\":1}}],[\"查找文件里符合条件的字符串\",{\"1\":{\"434\":1}}],[\"查找二进制文件和源代码文件\",{\"1\":{\"434\":1}}],[\"查找历史命令\",{\"1\":{\"417\":1}}],[\"查找\",{\"0\":{\"434\":1,\"909\":1},\"1\":{\"388\":1}}],[\"查找操作直接使用偏移地址\",{\"1\":{\"372\":1}}],[\"查找过程\",{\"1\":{\"288\":1}}],[\"查找过程结束\",{\"1\":{\"278\":1}}],[\"查找名称为name的类\",{\"1\":{\"182\":1}}],[\"查看冲突文件\",{\"1\":{\"1126\":1}}],[\"查看相应bit位是否为1\",{\"1\":{\"901\":1}}],[\"查看bitmap\",{\"1\":{\"900\":1}}],[\"查看bitmap中相对应位\",{\"1\":{\"900\":1}}],[\"查看节点状态\",{\"1\":{\"823\":1}}],[\"查看执行计划\",{\"0\":{\"702\":1}}],[\"查看执行计划⭐\",{\"0\":{\"556\":1}}],[\"查看当前节点数据并能看到更新次数等内容\",{\"1\":{\"823\":1}}],[\"查看当前正在执行的sql\",{\"1\":{\"701\":1}}],[\"查看当前所有连接信息\",{\"1\":{\"562\":1}}],[\"查看死锁信息\",{\"1\":{\"700\":1}}],[\"查看慢查询的\",{\"1\":{\"562\":1}}],[\"查看索引\",{\"1\":{\"527\":1}}],[\"查看表的结构\",{\"1\":{\"459\":1}}],[\"查看某个数据库下面有哪些表\",{\"1\":{\"459\":1}}],[\"查看有哪些数据库show\",{\"1\":{\"459\":1}}],[\"查看tag信息\",{\"1\":{\"450\":1}}],[\"查看信息\",{\"0\":{\"449\":1}}],[\"查看内存使用情况\",{\"1\":{\"436\":1}}],[\"查看该占用端口的进程\",{\"1\":{\"435\":1}}],[\"查看网络配置\",{\"1\":{\"435\":1}}],[\"查看路由表\",{\"1\":{\"426\":1}}],[\"查看自己的\",{\"1\":{\"426\":1}}],[\"查看进程杀死进程启动进程\",{\"0\":{\"426\":1}}],[\"查看java应用程序的运行状况\",{\"1\":{\"313\":1}}],[\"查看jvm统计信息\",{\"1\":{\"312\":1}}],[\"查看正在运行的java进程\",{\"1\":{\"312\":1}}],[\"查看命令行相关参数\",{\"1\":{\"253\":1}}],[\"查看默认的垃圾回收器\",{\"0\":{\"253\":1}}],[\"查看堆栈\",{\"1\":{\"201\":2}}],[\"查阅笔记\",{\"1\":{\"1\":1}}],[\"除添加新的方法完成新增功能外\",{\"1\":{\"1064\":1}}],[\"除此以外还包括delete\",{\"1\":{\"1038\":1}}],[\"除此之外\",{\"1\":{\"623\":1}}],[\"除丢弃该数据外\",{\"1\":{\"993\":1}}],[\"除留余数法\",{\"1\":{\"923\":1}}],[\"除非是使用反射方式\",{\"1\":{\"1075\":1}}],[\"除非人为地断开单例中静态引用到单例对象的连接\",{\"1\":{\"1075\":1}}],[\"除非要用来绕过一些验证软件\",{\"1\":{\"981\":1}}],[\"除非手动删除\",{\"1\":{\"818\":1}}],[\"除非执行\",{\"1\":{\"608\":1}}],[\"除非单表数据未来会一直不断上涨\",{\"1\":{\"561\":1}}],[\"除非数据是被本身事务自己所修改\",{\"1\":{\"522\":1,\"741\":1}}],[\"除非在\",{\"1\":{\"383\":1}}],[\"除非读到空值才会加锁重读\",{\"1\":{\"129\":1}}],[\"除过子类中方法的返回值是父类中方法返回值的子类时\",{\"1\":{\"359\":1}}],[\"除了时间等待计时器之外\",{\"1\":{\"1028\":1}}],[\"除了必须有一条物理线路外\",{\"1\":{\"971\":1}}],[\"除了singleton作用域\",{\"1\":{\"713\":1}}],[\"除了有beanfactory的功能还有额外更多功能\",{\"1\":{\"712\":1}}],[\"除了提供beanfactory所具有的功能外\",{\"1\":{\"712\":1}}],[\"除了扩容以外\",{\"1\":{\"623\":1}}],[\"除了访问这个数据页会触发merge外\",{\"1\":{\"574\":1}}],[\"除了后台线程每秒一次的轮询操作外\",{\"1\":{\"568\":1}}],[\"除了对回滚段的影响\",{\"1\":{\"525\":1}}],[\"除了主动释放锁\",{\"1\":{\"510\":1}}],[\"除了执行\",{\"1\":{\"426\":1}}],[\"除了要与原方法具有相同的简单名称之外\",{\"1\":{\"290\":1}}],[\"除了初始标记是stw\",{\"1\":{\"268\":1}}],[\"除了并发标记外\",{\"1\":{\"264\":1}}],[\"除了追求低停顿外\",{\"1\":{\"261\":1}}],[\"除了g1\",{\"1\":{\"260\":1}}],[\"除了同时使用多条线程进行垃圾收集之外\",{\"1\":{\"255\":1}}],[\"除了old和young之间\",{\"1\":{\"249\":1}}],[\"除了浪费空间\",{\"1\":{\"246\":1}}],[\"除了这些固定的gc\",{\"1\":{\"234\":1}}],[\"除了保存class文件中描述的符号引用外\",{\"1\":{\"208\":1}}],[\"除了\",{\"1\":{\"117\":1,\"255\":1}}],[\"里氏替换原则\",{\"1\":{\"1064\":1}}],[\"里氏代换原则\",{\"1\":{\"359\":1}}],[\"里\",{\"1\":{\"582\":1,\"746\":1}}],[\"里并没有\",{\"1\":{\"577\":1}}],[\"里缓存了该内存地址的数据无效\",{\"1\":{\"296\":1}}],[\"里的完整事务写入到\",{\"1\":{\"571\":1}}],[\"里的引用\",{\"1\":{\"234\":1}}],[\"里的\",{\"1\":{\"129\":1,\"416\":1}}],[\"里包含一个\",{\"1\":{\"129\":1}}],[\"里包含一个segment数组\",{\"1\":{\"129\":1}}],[\"里面有一些步骤比如设置python\",{\"1\":{\"1170\":1}}],[\"里面有个例子说是数据只有\",{\"1\":{\"525\":1}}],[\"里面每一行是一个词\",{\"0\":{\"894\":1},\"1\":{\"889\":1}}],[\"里面定义的程序点具体要做的操作\",{\"1\":{\"721\":1}}],[\"里面只规定了它是一个指向对象的引用\",{\"1\":{\"228\":1}}],[\"里面的元素\",{\"1\":{\"624\":1}}],[\"里面的权限是全局级的\",{\"1\":{\"458\":1}}],[\"里面的\",{\"1\":{\"193\":1}}],[\"里面包含了一些进程的信息\",{\"1\":{\"156\":1}}],[\"里面\",{\"1\":{\"142\":1,\"489\":1,\"568\":1,\"861\":1}}],[\"里面使用了\",{\"1\":{\"78\":1}}],[\"里面存储的元素是卡表的索引号\",{\"1\":{\"265\":1}}],[\"里面存储threadlocal\",{\"1\":{\"39\":1,\"41\":1}}],[\"里面存东西就是向他里面的\",{\"1\":{\"39\":1}}],[\"赋予了一个对象锁\",{\"1\":{\"128\":1}}],[\"赋值给\",{\"1\":{\"623\":1}}],[\"赋值给某个类变量或者对象的成员变量\",{\"1\":{\"236\":1}}],[\"赋值等\",{\"1\":{\"294\":1,\"337\":1}}],[\"赋值\",{\"1\":{\"66\":1,\"294\":1}}],[\"切回开发分支并合并主分支\",{\"1\":{\"1126\":1}}],[\"切面\",{\"1\":{\"721\":1}}],[\"切入点\",{\"1\":{\"721\":1}}],[\"切分的目的\",{\"1\":{\"585\":1}}],[\"切割成\",{\"1\":{\"128\":1}}],[\"切换虚拟环境\",{\"1\":{\"1144\":1}}],[\"切换时\",{\"1\":{\"1042\":1}}],[\"切换请求协议\",{\"1\":{\"1040\":1}}],[\"切换开销小\",{\"1\":{\"831\":1}}],[\"切换成功后\",{\"1\":{\"657\":1}}],[\"切换到主分支并拉取最新代码\",{\"1\":{\"1126\":1}}],[\"切换到\",{\"1\":{\"657\":1,\"1040\":1}}],[\"切换到上一个分支\",{\"1\":{\"451\":1}}],[\"切换到指定分支\",{\"1\":{\"451\":1}}],[\"切换目录\",{\"0\":{\"420\":1},\"1\":{\"418\":1}}],[\"切换内核栈和硬件上下文\",{\"1\":{\"145\":1}}],[\"切换页目录以使用新的地址空间\",{\"1\":{\"145\":1}}],[\"切换\",{\"1\":{\"64\":1,\"656\":1}}],[\"任意节点到叶子节点经过的黑色节点数目相同\",{\"1\":{\"921\":1}}],[\"任意一台报错则报错\",{\"1\":{\"813\":1}}],[\"任意一个\",{\"1\":{\"126\":1}}],[\"任期用单调递增的数字表示\",{\"1\":{\"876\":1}}],[\"任期\",{\"0\":{\"876\":1}}],[\"任何时刻对\",{\"1\":{\"870\":1}}],[\"任何时候计数器为\",{\"1\":{\"233\":1}}],[\"任何正在执行的事务都处于此状态\",{\"1\":{\"520\":1}}],[\"任何地方\",{\"1\":{\"357\":1}}],[\"任何一个class文件都对应着唯一的一个类或接口的定义信息\",{\"1\":{\"284\":1}}],[\"任何线程都可以访问到堆区中的共享数据\",{\"1\":{\"219\":1}}],[\"任务是负责向两台主机中进程之间的通信提供通用的数据传输服务\",{\"1\":{\"961\":1}}],[\"任务中\",{\"1\":{\"696\":1}}],[\"任务\",{\"1\":{\"688\":1}}],[\"任务很少\",{\"1\":{\"144\":1}}],[\"任务调度线程池\",{\"1\":{\"56\":1}}],[\"任务数比较密集\",{\"1\":{\"56\":1}}],[\"任务可以不需要的等到线程创建就能立即执行\",{\"1\":{\"53\":1}}],[\"低耦合\",{\"1\":{\"1064\":1}}],[\"低时延的金融平台\",{\"1\":{\"697\":1}}],[\"低位掩码\",{\"1\":{\"405\":1}}],[\"低数据位保存在内存的低地址位中\",{\"1\":{\"347\":1}}],[\"低数据位保存在内存的高地址位中\",{\"1\":{\"347\":1}}],[\"低延迟应用的首选垃圾收集器\",{\"1\":{\"268\":1}}],[\"低延迟垃圾收集器\",{\"0\":{\"266\":1}}],[\"低停顿\",{\"1\":{\"259\":1}}],[\"低调度优先级的finalizer线程去执行它们的finalize\",{\"1\":{\"236\":1}}],[\"低\",{\"1\":{\"125\":1}}],[\"位的随机数作为连接的\",{\"1\":{\"1042\":1}}],[\"位的话会很容易造成计算结果一样\",{\"1\":{\"405\":1}}],[\"位运算的常见使用\",{\"0\":{\"945\":1}}],[\"位运算符\",{\"0\":{\"943\":1}}],[\"位相当于除以\",{\"1\":{\"943\":1}}],[\"位相当于乘以\",{\"1\":{\"943\":1}}],[\"位值的列表\",{\"1\":{\"645\":1}}],[\"位存储整数部分\",{\"1\":{\"473\":1}}],[\"位存储小数部分\",{\"1\":{\"473\":1}}],[\"位存储空间\",{\"1\":{\"472\":1}}],[\"位\",{\"1\":{\"406\":1,\"473\":1,\"981\":2}}],[\"位做异或运算\",{\"1\":{\"405\":1}}],[\"位置的概念\",{\"1\":{\"1221\":1}}],[\"位置和t2中的h2\",{\"1\":{\"884\":1}}],[\"位置\",{\"1\":{\"313\":2,\"884\":1,\"937\":1}}],[\"位置到下一个为空的\",{\"1\":{\"301\":2}}],[\"位系统下\",{\"1\":{\"156\":1}}],[\"位系统的对象头\",{\"1\":{\"84\":1}}],[\"位表示写\",{\"1\":{\"125\":1}}],[\"位表示读\",{\"1\":{\"125\":1}}],[\"高内聚\",{\"1\":{\"1064\":1}}],[\"高层模块不应该依赖低层模块\",{\"1\":{\"1064\":1}}],[\"高层不应该依赖低层\",{\"1\":{\"1064\":1}}],[\"高位都是补\",{\"1\":{\"943\":1}}],[\"高度为\",{\"1\":{\"919\":1}}],[\"高考750分\",{\"1\":{\"902\":1}}],[\"高考\",{\"1\":{\"902\":1}}],[\"高水位\",{\"0\":{\"855\":1},\"1\":{\"855\":1}}],[\"高级映射\",{\"1\":{\"751\":2}}],[\"高可靠性\",{\"1\":{\"675\":1}}],[\"高可用的获取锁与释放锁\",{\"1\":{\"667\":1}}],[\"高可用性\",{\"1\":{\"660\":1,\"678\":1}}],[\"高可用\",{\"1\":{\"642\":1,\"655\":1,\"661\":2,\"840\":1,\"873\":1}}],[\"高性价比\",{\"1\":{\"674\":1}}],[\"高性能的网络服务器和客户端\",{\"1\":{\"685\":1}}],[\"高性能的获取锁与释放锁\",{\"1\":{\"667\":1}}],[\"高性能受限于单核\",{\"1\":{\"674\":1}}],[\"高性能\",{\"1\":{\"606\":2,\"674\":1}}],[\"高并发情景下吞吐量会大大降低\",{\"1\":{\"643\":1}}],[\"高并发情况下\",{\"1\":{\"585\":1}}],[\"高并发\",{\"1\":{\"606\":2}}],[\"高并发的性能瓶颈\",{\"1\":{\"585\":1}}],[\"高速缓存中的每一个映射地址都设置有生存时间\",{\"1\":{\"986\":1}}],[\"高速\",{\"1\":{\"381\":1}}],[\"高数据位保存在内存的高地址位中\",{\"1\":{\"347\":1}}],[\"高数据位保存在内存的低地址位中\",{\"1\":{\"347\":1}}],[\"高版本的jdk能兼容低版本\",{\"1\":{\"285\":1}}],[\"高响应比优先\",{\"1\":{\"150\":1}}],[\"高\",{\"1\":{\"125\":1}}],[\"高效的并发队列\",{\"1\":{\"108\":1}}],[\"阀门才能打开\",{\"1\":{\"121\":1}}],[\"某条线上电压的意义\",{\"1\":{\"966\":1}}],[\"某些节点之间不连通了\",{\"1\":{\"870\":1}}],[\"某些系统中使用的\",{\"1\":{\"587\":1}}],[\"某一个分区中的消息只能够一个消费者组中的一个消费者所消费\",{\"1\":{\"845\":1}}],[\"某一个节点认为\",{\"1\":{\"683\":1}}],[\"某种意义上\",{\"1\":{\"587\":1}}],[\"某件事情\",{\"1\":{\"121\":1}}],[\"某个类的方法通过局部变量\",{\"1\":{\"1096\":1}}],[\"某个follower会成为新的leader\",{\"1\":{\"845\":1}}],[\"某个文件的内容\",{\"1\":{\"449\":1}}],[\"某个\",{\"1\":{\"74\":1}}],[\"循环过后的\",{\"1\":{\"912\":1,\"913\":1}}],[\"循环写\",{\"1\":{\"568\":1}}],[\"循环遍历效率高了\",{\"1\":{\"391\":1}}],[\"循环遍历快\",{\"1\":{\"391\":1}}],[\"循环遍历比\",{\"1\":{\"391\":1}}],[\"循环\",{\"1\":{\"189\":1,\"391\":1,\"668\":1,\"927\":1}}],[\"循环扫描算法\",{\"1\":{\"163\":1}}],[\"循环扫描各页面\",{\"1\":{\"160\":1}}],[\"循环栅栏\",{\"0\":{\"120\":1}}],[\"循环等待\",{\"1\":{\"98\":1}}],[\"计数从1开始\",{\"1\":{\"286\":1}}],[\"计数器\",{\"1\":{\"603\":1}}],[\"计数器就减\",{\"1\":{\"233\":1}}],[\"计数器就加\",{\"1\":{\"233\":1}}],[\"计数器的值为空\",{\"1\":{\"189\":1}}],[\"计数器的值只能在构造方法中初始化一次\",{\"1\":{\"119\":1}}],[\"计数器记录正在执行字节码指令的地址\",{\"1\":{\"189\":1}}],[\"计算属性与父组件双向绑定\",{\"1\":{\"1163\":1}}],[\"计算属性\",{\"0\":{\"1156\":1}}],[\"计算完成之后将结果返回给客户端\",{\"1\":{\"801\":1}}],[\"计算公式\",{\"1\":{\"680\":1}}],[\"计算较少的场景\",{\"1\":{\"674\":1}}],[\"计算机软件学院只培养计算机软件专业的学生等\",{\"1\":{\"1079\":1}}],[\"计算机蠕虫\",{\"1\":{\"1054\":1}}],[\"计算机网络的通信面临两大类威胁\",{\"1\":{\"1054\":1}}],[\"计算机网络\",{\"0\":{\"958\":1}}],[\"计算机操作系统做了一些优化\",{\"1\":{\"543\":1}}],[\"计算机中磁盘最小存储单元是扇区\",{\"1\":{\"539\":1}}],[\"计算机上配置的底层软件\",{\"1\":{\"133\":1}}],[\"计算得到的\",{\"1\":{\"405\":1}}],[\"计算\",{\"0\":{\"405\":1}}],[\"计算元素存放位置时\",{\"1\":{\"404\":1}}],[\"计算出的值是一个\",{\"1\":{\"1156\":1}}],[\"计算出哈希值\",{\"1\":{\"681\":1}}],[\"计算出一个\",{\"1\":{\"680\":1}}],[\"计算出该\",{\"1\":{\"397\":1}}],[\"计算出\",{\"1\":{\"131\":1,\"342\":1,\"398\":1}}],[\"计算密集型的任务比较占\",{\"1\":{\"64\":1}}],[\"允许外部连接\",{\"1\":{\"1177\":1}}],[\"允许服务器向客户端推送资源\",{\"1\":{\"1042\":1}}],[\"允许的报文长度更长\",{\"1\":{\"1033\":1}}],[\"允许用户终止在远端机上的运行进程\",{\"1\":{\"1015\":1}}],[\"允许通过实现接口beanfactorypostprocessor在此处插入我们定义的代码\",{\"1\":{\"737\":1}}],[\"允许读取并发事务已经提交的数据\",{\"1\":{\"522\":1,\"741\":1}}],[\"允许读取尚未提交的数据变更\",{\"1\":{\"522\":1,\"741\":1}}],[\"允许一个空键和多个空值\",{\"1\":{\"408\":1}}],[\"允许编译器和处理器对指令进行重排序\",{\"1\":{\"295\":1}}],[\"允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中\",{\"1\":{\"196\":1}}],[\"允许java栈的大小是动态的或者是固定不变的\",{\"1\":{\"190\":1}}],[\"允许\",{\"1\":{\"118\":1,\"369\":1,\"407\":1}}],[\"遵循\",{\"1\":{\"117\":1,\"149\":1}}],[\"遵循一个基本原则\",{\"1\":{\"74\":1}}],[\"另有一种情况\",{\"1\":{\"1015\":1}}],[\"另一端称为栈底\",{\"1\":{\"940\":1}}],[\"另一个为空\",{\"1\":{\"935\":1}}],[\"另一个事务修改了该数据\",{\"1\":{\"521\":1}}],[\"另一个比较常用的与之对应的方法是tryacquire方法\",{\"1\":{\"117\":1}}],[\"另一部分是物理磁盘上共享表空间连续的128个页\",{\"1\":{\"496\":1}}],[\"另一种就是closed\",{\"1\":{\"884\":1}}],[\"另一种是\",{\"1\":{\"568\":1}}],[\"另一种情况就是\",{\"1\":{\"495\":1}}],[\"另一种被称为符号链接\",{\"1\":{\"427\":1}}],[\"另一种解决方法\",{\"1\":{\"304\":1}}],[\"另一类是类型指针\",{\"1\":{\"225\":1}}],[\"另一方面\",{\"1\":{\"198\":1,\"304\":1,\"675\":1}}],[\"另外对于\",{\"1\":{\"642\":1}}],[\"另外数据库以页为单位将数据加载到内存中\",{\"1\":{\"585\":1}}],[\"另外一种连接称之为符号连接\",{\"1\":{\"427\":1}}],[\"另外使用\",{\"1\":{\"409\":1}}],[\"另外\",{\"1\":{\"85\":1,\"222\":1,\"286\":1,\"301\":1,\"410\":1,\"464\":1,\"583\":1,\"648\":1}}],[\"信道复用技术\",{\"0\":{\"967\":1}}],[\"信创和\",{\"1\":{\"696\":1}}],[\"信创适配项目\",{\"1\":{\"689\":1}}],[\"信创适配\",{\"1\":{\"18\":1}}],[\"信号锁总线来达到独占共享内存的目的\",{\"1\":{\"296\":1}}],[\"信号会确保在声言该信号期间\",{\"1\":{\"296\":1}}],[\"信号是一种比较复杂的通信方式\",{\"1\":{\"149\":1}}],[\"信号\",{\"1\":{\"149\":1,\"296\":2}}],[\"信号量的意图在于进程间同步\",{\"1\":{\"149\":1}}],[\"信号量是一个计数器\",{\"1\":{\"149\":1}}],[\"信号量\",{\"0\":{\"117\":1},\"1\":{\"117\":1,\"142\":1,\"149\":1}}],[\"信息是明文传输\",{\"1\":{\"1048\":1}}],[\"信息性状态码\",{\"1\":{\"1040\":1}}],[\"信息等\",{\"1\":{\"684\":1}}],[\"信息的完整性\",{\"1\":{\"1055\":1}}],[\"信息的\",{\"1\":{\"641\":1}}],[\"信息\",{\"1\":{\"147\":1,\"1061\":1}}],[\"乖乖排到后面\",{\"1\":{\"114\":1}}],[\"上编写\",{\"1\":{\"1269\":1}}],[\"上编译出\",{\"0\":{\"1206\":1}}],[\"上现实的\",{\"1\":{\"1202\":1}}],[\"上层的是tls握手协议\",{\"1\":{\"1062\":1}}],[\"上层的区域范围更广\",{\"1\":{\"630\":1}}],[\"上传成功之后\",{\"1\":{\"1041\":1}}],[\"上传本地指定分支到远程仓库\",{\"1\":{\"452\":1}}],[\"上面可以承载http协议或者smtp\",{\"1\":{\"1062\":1}}],[\"上面提到我们对数字签名进行验证时\",{\"1\":{\"1057\":1}}],[\"上面那一条也说明\",{\"1\":{\"961\":1}}],[\"上面的计算主要遵循了一个计算公式\",{\"1\":{\"947\":1}}],[\"上面也说过了\",{\"1\":{\"861\":1}}],[\"上千万或上亿的数据\",{\"1\":{\"898\":1}}],[\"上千万或上亿数据\",{\"0\":{\"898\":1}}],[\"上千万or亿数据\",{\"1\":{\"891\":1}}],[\"上进行注册\",{\"1\":{\"861\":1}}],[\"上会有一个专门用来进行\",{\"1\":{\"861\":1}}],[\"上你可以看到代理\",{\"1\":{\"825\":1}}],[\"上自己封装的应用层协议\",{\"1\":{\"806\":1}}],[\"上完成的\",{\"1\":{\"683\":1}}],[\"上任\",{\"1\":{\"677\":1}}],[\"上的与该方法对应的指定节点的目录下\",{\"1\":{\"668\":1}}],[\"上的分布\",{\"1\":{\"659\":1}}],[\"上的事件来选择对应的事件处理器进行处理\",{\"1\":{\"611\":1}}],[\"上加入了\",{\"1\":{\"659\":1,\"678\":1}}],[\"上一秒内未落盘的命令操作仍然会丢失\",{\"1\":{\"650\":1}}],[\"上有可读事件发⽣时\",{\"1\":{\"613\":1}}],[\"上查到了两条结果\",{\"1\":{\"553\":1}}],[\"上锁\",{\"1\":{\"410\":1}}],[\"上述两种方法可配合使用\",{\"1\":{\"1018\":1}}],[\"上述场景对性能的影响\",{\"1\":{\"594\":1}}],[\"上述的每一个操作都是原子的\",{\"1\":{\"294\":1}}],[\"上述代码中直接将sb返回\",{\"1\":{\"202\":1}}],[\"上下文更像是一个环境\",{\"1\":{\"1221\":1}}],[\"上下文\",{\"1\":{\"144\":1}}],[\"上下文切换\",{\"1\":{\"81\":1}}],[\"上维护多个读线程和一个写线程\",{\"1\":{\"125\":1}}],[\"上\",{\"1\":{\"111\":1,\"126\":1,\"299\":1,\"623\":1,\"645\":1,\"818\":1,\"825\":1,\"861\":2,\"996\":1}}],[\"尝试从字符串的起始位置匹配一个模式\",{\"1\":{\"1188\":1}}],[\"尝试按照顺序使用相同的\",{\"1\":{\"672\":1}}],[\"尝试减少运行时内存的消耗\",{\"1\":{\"298\":1}}],[\"尝试写入\",{\"1\":{\"131\":1}}],[\"尝试释放共享锁\",{\"1\":{\"109\":1}}],[\"尝试释放独占锁\",{\"1\":{\"109\":1}}],[\"尝试获取共享锁\",{\"1\":{\"109\":1}}],[\"尝试获取独占锁\",{\"1\":{\"109\":1}}],[\"尝试获取锁\",{\"1\":{\"94\":1}}],[\"属主名\",{\"1\":{\"432\":2}}],[\"属组名\",{\"1\":{\"431\":1,\"432\":1}}],[\"属性的元素<element\",{\"1\":{\"1155\":1}}],[\"属性的存在\",{\"1\":{\"624\":1}}],[\"属性为true\",{\"1\":{\"1061\":1}}],[\"属性一致时\",{\"1\":{\"1039\":1}}],[\"属性值\",{\"1\":{\"1038\":1}}],[\"属性注入的注解\",{\"1\":{\"743\":1}}],[\"属性注入\",{\"1\":{\"733\":1}}],[\"属性是用一个字节\",{\"1\":{\"628\":1}}],[\"属性获取链表长度的时间复杂度为\",{\"1\":{\"626\":1}}],[\"属性将这些字节的数量记录下来\",{\"1\":{\"624\":1}}],[\"属性和\",{\"1\":{\"624\":1}}],[\"属性保存了字符串的长度\",{\"1\":{\"624\":1}}],[\"属性\",{\"1\":{\"412\":1,\"1061\":1,\"1245\":1}}],[\"属性则继续调用父类本身的旧属性\",{\"1\":{\"355\":1}}],[\"属性不具有多态性\",{\"1\":{\"355\":1}}],[\"属性配置等\",{\"1\":{\"309\":1}}],[\"属性表示的长度来判断字符串是否结束\",{\"1\":{\"624\":1}}],[\"属性表作为class文件格式中最具扩展性的一种数据项目\",{\"1\":{\"290\":1}}],[\"属性表集合的限制稍微宽松一些\",{\"1\":{\"291\":1}}],[\"属性表集合\",{\"0\":{\"291\":1},\"1\":{\"289\":1,\"290\":1}}],[\"属性来表示同步状态\",{\"1\":{\"109\":1}}],[\"属于运行时增强\",{\"1\":{\"720\":1}}],[\"属于重量级操作\",{\"1\":{\"648\":1}}],[\"属于实验性的\",{\"1\":{\"316\":1}}],[\"属于基本数据类型\",{\"1\":{\"284\":1}}],[\"属于线程私有的数据\",{\"1\":{\"192\":1}}],[\"属于object类\",{\"1\":{\"35\":1}}],[\"属于\",{\"0\":{\"36\":1},\"1\":{\"35\":1,\"36\":1}}],[\"属于thread类\",{\"1\":{\"35\":1}}],[\"属于thread\",{\"1\":{\"35\":1}}],[\"五层协议\",{\"1\":{\"961\":1}}],[\"五\",{\"0\":{\"107\":1,\"272\":1,\"382\":1,\"961\":1}}],[\"传入不同的拒绝策略\",{\"1\":{\"1089\":1}}],[\"传送的数据单位协议是\",{\"1\":{\"1006\":1}}],[\"传送到正确的网络\",{\"1\":{\"960\":1}}],[\"传统代理模式存在的问题\",{\"1\":{\"1083\":1}}],[\"传统方式下\",{\"1\":{\"850\":1}}],[\"传统拷贝\",{\"1\":{\"850\":1}}],[\"传统的\",{\"1\":{\"377\":1}}],[\"传统的io基于流\",{\"1\":{\"209\":1}}],[\"传统的互斥同步可能会比原子类更高效\",{\"1\":{\"106\":1}}],[\"传输可靠性等功能\",{\"1\":{\"1042\":1}}],[\"传输时\",{\"1\":{\"1033\":1}}],[\"传输时间指的是从磁盘读出或将数据写入磁盘的时间\",{\"1\":{\"543\":1}}],[\"传输时间三个部分\",{\"1\":{\"543\":1}}],[\"传输数据稳定可靠\",{\"1\":{\"1001\":1}}],[\"传输数据有序\",{\"1\":{\"1001\":1}}],[\"传输数据报的过程中\",{\"1\":{\"992\":1}}],[\"传输错误的比特占所有传输比特总数的比例称为误码率ber\",{\"1\":{\"974\":1}}],[\"传输层安全是ietf在ssl3\",{\"1\":{\"1062\":1}}],[\"传输层的\",{\"1\":{\"1006\":1}}],[\"传输层的复用和分用\",{\"1\":{\"999\":1}}],[\"传输层之间的数据交互是大小不等的数据块\",{\"1\":{\"1006\":1}}],[\"传输层来使网络包网络包找到自己属于的进程\",{\"1\":{\"999\":1}}],[\"传输层提供了应用进程之间的端\",{\"1\":{\"999\":1}}],[\"传输层与网络层的区别\",{\"0\":{\"999\":1}}],[\"传输层还有寻址的功能\",{\"1\":{\"998\":1}}],[\"传输层作用\",{\"0\":{\"998\":1}}],[\"传输层和应用层\",{\"1\":{\"964\":1}}],[\"传输层\",{\"1\":{\"961\":1,\"962\":1}}],[\"传输层可能⼤家刚接触的时候\",{\"1\":{\"961\":1}}],[\"传输控制协议tcp\",{\"1\":{\"961\":1}}],[\"传输效率高\",{\"1\":{\"806\":1}}],[\"传给服务端\",{\"1\":{\"804\":1}}],[\"传给\",{\"1\":{\"412\":1}}],[\"传递依赖\",{\"0\":{\"796\":1},\"1\":{\"796\":1}}],[\"传递的是对象地址的一个副本\",{\"1\":{\"351\":1}}],[\"传递的是该变量的一个副本\",{\"1\":{\"351\":1}}],[\"传递了变量值\",{\"1\":{\"299\":1}}],[\"传递系统调用参数\",{\"1\":{\"135\":1}}],[\"传递规则\",{\"1\":{\"75\":1,\"102\":1}}],[\"又使用\",{\"1\":{\"1033\":1}}],[\"又叫作门面模式\",{\"1\":{\"1090\":1}}],[\"又叫做短暂端口号\",{\"1\":{\"1000\":1}}],[\"又叫等值连接\",{\"1\":{\"485\":1}}],[\"又希望性能别受太大影响的话\",{\"1\":{\"650\":1}}],[\"又同时去数据库去取数据\",{\"1\":{\"643\":1}}],[\"又称子网寻址或子网路由选择\",{\"1\":{\"989\":1}}],[\"又称哈希函数\",{\"1\":{\"922\":1}}],[\"又称二叉查找树\",{\"1\":{\"915\":1}}],[\"又称\",{\"1\":{\"622\":1,\"1054\":1}}],[\"又称为平滑的往返时间\",{\"1\":{\"1012\":1}}],[\"又称为最长匹配或最佳匹配\",{\"1\":{\"991\":1}}],[\"又称为物理地址\",{\"1\":{\"981\":1}}],[\"又称为全双工通信\",{\"1\":{\"966\":1}}],[\"又称为半双工通信\",{\"1\":{\"966\":1}}],[\"又称为单工通信\",{\"1\":{\"966\":1}}],[\"又称为数据库软件或者数据库产品\",{\"1\":{\"457\":1}}],[\"又称为等待状态\",{\"1\":{\"148\":1}}],[\"又有记录\",{\"1\":{\"578\":1}}],[\"又允许你的类完全可以自己实现所有的方法\",{\"1\":{\"362\":1}}],[\"又可分为公平锁和非公平锁\",{\"1\":{\"113\":1}}],[\"又改回\",{\"1\":{\"106\":1}}],[\"又会存在可见性和有序性的问题\",{\"1\":{\"72\":1}}],[\"始终在高速运行\",{\"1\":{\"105\":1}}],[\"始终有\",{\"1\":{\"45\":1}}],[\"体现的是无锁并发\",{\"1\":{\"105\":1}}],[\"才不为\",{\"1\":{\"1068\":1}}],[\"才不为空\",{\"1\":{\"714\":1}}],[\"才去创建实例对象\",{\"1\":{\"1067\":1}}],[\"才放行\",{\"1\":{\"807\":1}}],[\"才对该bean进行加载实例化\",{\"1\":{\"712\":1}}],[\"才算真正的获取锁成功\",{\"1\":{\"672\":1}}],[\"才叫做单线程的模型\",{\"1\":{\"611\":1}}],[\"才进入新生代\",{\"1\":{\"495\":1}}],[\"才考虑使用其它存储引擎\",{\"1\":{\"491\":1}}],[\"才需要调用\",{\"1\":{\"342\":1}}],[\"才可以改变其他节点的\",{\"1\":{\"875\":1}}],[\"才可以发送ack\",{\"1\":{\"853\":1}}],[\"才可以使用这项属性\",{\"1\":{\"292\":1}}],[\"才可以只装入部分程序到内存就开始运行\",{\"1\":{\"158\":1}}],[\"才能得到下单响应\",{\"1\":{\"840\":1}}],[\"才能恢复\",{\"1\":{\"656\":1}}],[\"才能操作这行数据\",{\"1\":{\"513\":1}}],[\"才能被其他class引用\",{\"1\":{\"182\":1}}],[\"才能读取到共享变量的最新值来实现比较并交换的效果\",{\"1\":{\"105\":1}}],[\"才处理磁道访问请求\",{\"1\":{\"163\":1}}],[\"才调换方向\",{\"1\":{\"163\":1}}],[\"才会在垃圾收集的时候卸载类\",{\"1\":{\"1075\":1}}],[\"才会发送\",{\"1\":{\"829\":1}}],[\"才会判断该\",{\"1\":{\"632\":1}}],[\"才会同时写change\",{\"1\":{\"575\":1}}],[\"才会正式对数据的冲突与否进行检测\",{\"1\":{\"513\":1}}],[\"才会采用\",{\"1\":{\"484\":1}}],[\"才会升级\",{\"1\":{\"425\":1}}],[\"才会使用偏向锁\",{\"1\":{\"86\":1}}],[\"才会进入内部的synchronized代码块\",{\"1\":{\"101\":1}}],[\"才会进入\",{\"1\":{\"37\":1}}],[\"打包\",{\"1\":{\"793\":1}}],[\"打包用命令或者放到容器中运行\",{\"1\":{\"781\":1}}],[\"打开redis客户端\",{\"1\":{\"1192\":1}}],[\"打开自动配置的功能\",{\"1\":{\"777\":1}}],[\"打开aof\",{\"1\":{\"707\":1}}],[\"打开慢sql日志\",{\"1\":{\"701\":1}}],[\"打到所有节点上去更新\",{\"1\":{\"684\":1}}],[\"打印答案\",{\"1\":{\"955\":1}}],[\"打印根节点\",{\"1\":{\"908\":2}}],[\"打印tlab的使用情况\",{\"1\":{\"326\":1}}],[\"打印jvm参数\",{\"1\":{\"319\":1}}],[\"打印jvm中线程快照\",{\"1\":{\"312\":1}}],[\"打印出所有xx选项运行时的值\",{\"1\":{\"319\":1}}],[\"打印设置的xx选项及值\",{\"0\":{\"319\":1}}],[\"打印gc日志\",{\"1\":{\"308\":1}}],[\"打断线程\",{\"1\":{\"102\":1}}],[\"打破有序性的三种重排序\",{\"0\":{\"71\":1}}],[\"特洛伊木马\",{\"1\":{\"1054\":1}}],[\"特殊字符控制\",{\"1\":{\"1006\":1}}],[\"特有\",{\"1\":{\"613\":1}}],[\"特性有哪几种方式\",{\"0\":{\"778\":1}}],[\"特性的\",{\"1\":{\"519\":1}}],[\"特性\",{\"0\":{\"519\":1}}],[\"特别是运用多态比较频繁时\",{\"1\":{\"1064\":1}}],[\"特别是当执行alter\",{\"1\":{\"572\":1}}],[\"特别是随着数据量的增加特别明显\",{\"1\":{\"486\":1}}],[\"特别地\",{\"1\":{\"315\":1,\"316\":1}}],[\"特别注意\",{\"1\":{\"235\":1}}],[\"特征签名的范围明显要更大一些\",{\"1\":{\"290\":1}}],[\"特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合\",{\"1\":{\"290\":1}}],[\"特是可见性与有序性的一套规则总结\",{\"1\":{\"102\":1}}],[\"特点\",{\"1\":{\"56\":1,\"109\":1,\"125\":1,\"257\":1,\"824\":1,\"916\":1,\"918\":1,\"920\":1,\"922\":1,\"977\":1}}],[\"他们是双向关联\",{\"1\":{\"1097\":1}}],[\"他们可以使用\",{\"1\":{\"299\":1}}],[\"他会立即退回成\",{\"1\":{\"876\":1}}],[\"他会申请两次内存空间\",{\"1\":{\"617\":1}}],[\"他必须能及时的同步leader的写操作\",{\"1\":{\"868\":1}}],[\"他是基于\",{\"1\":{\"685\":1}}],[\"他现在只是一个指向还没有初始化对象的一个地址\",{\"1\":{\"101\":1,\"714\":1}}],[\"他只需要等待重新获取\",{\"1\":{\"35\":1}}],[\"分层结构来进行\",{\"1\":{\"1226\":1}}],[\"分隔\",{\"1\":{\"1035\":1}}],[\"分用和差错检测的功能\",{\"1\":{\"1002\":1}}],[\"分用服务\",{\"1\":{\"998\":1}}],[\"分用\",{\"1\":{\"997\":1,\"999\":2}}],[\"分片举例\",{\"1\":{\"987\":1}}],[\"分片\",{\"1\":{\"982\":3}}],[\"分片逻辑统一维护在中间件服务中\",{\"1\":{\"586\":1}}],[\"分片逻辑在应用端\",{\"1\":{\"586\":1}}],[\"分割与重组数据\",{\"1\":{\"961\":1}}],[\"分割成若干个子序列\",{\"1\":{\"933\":1}}],[\"分组事物\",{\"1\":{\"1093\":1}}],[\"分组事物和注释事物\",{\"1\":{\"1093\":1}}],[\"分组网间探测ping\",{\"1\":{\"994\":1}}],[\"分组也叫作ip数据报\",{\"1\":{\"961\":1}}],[\"分组又称为包\",{\"1\":{\"960\":1}}],[\"分组交换采用存储转发技术\",{\"1\":{\"960\":1}}],[\"分组交换\",{\"1\":{\"960\":1}}],[\"分治\",{\"0\":{\"934\":1}}],[\"分数大小是固定的\",{\"1\":{\"902\":1}}],[\"分成多个文件后\",{\"1\":{\"895\":1}}],[\"分\",{\"0\":{\"886\":1},\"1\":{\"934\":1}}],[\"分而治之+hash\",{\"1\":{\"892\":1}}],[\"分而治之\",{\"0\":{\"886\":1},\"1\":{\"881\":1,\"892\":2,\"894\":1,\"896\":1,\"897\":1}}],[\"分区容忍性\",{\"1\":{\"870\":1}}],[\"分区数量\",{\"1\":{\"867\":1}}],[\"分区器\",{\"0\":{\"867\":1},\"1\":{\"867\":2}}],[\"分区副本数小于2个\",{\"1\":{\"866\":1}}],[\"分区之间发送的顺序是无法保证的\",{\"1\":{\"865\":1}}],[\"分区的原则\",{\"1\":{\"852\":1}}],[\"分区的原因\",{\"1\":{\"852\":1}}],[\"分区有序\",{\"1\":{\"845\":1}}],[\"分区\",{\"1\":{\"845\":1,\"870\":1,\"873\":1}}],[\"分区表\",{\"1\":{\"561\":1}}],[\"分开\",{\"1\":{\"827\":1}}],[\"分发到客户端\",{\"1\":{\"825\":1}}],[\"分离\",{\"1\":{\"1238\":1}}],[\"分离的解耦合\",{\"1\":{\"748\":1}}],[\"分离对象或标量替换\",{\"1\":{\"202\":1}}],[\"分散放置到不同的\",{\"1\":{\"679\":1}}],[\"分散节点压力\",{\"1\":{\"309\":1}}],[\"分担\",{\"1\":{\"655\":1,\"661\":1}}],[\"分值相同的节点将按照成员对象在字典序中的大小来进行排序\",{\"1\":{\"630\":1}}],[\"分值相同的节点按照成员对象在字典序中的大小来进行排序\",{\"1\":{\"630\":1}}],[\"分值\",{\"1\":{\"630\":1}}],[\"分摊到了多次处理请求的过程中\",{\"1\":{\"615\":1}}],[\"分库反而成为拖累\",{\"1\":{\"587\":1}}],[\"分库\",{\"1\":{\"584\":1}}],[\"分库和垂直分表\",{\"1\":{\"584\":1}}],[\"分库与分表的选择\",{\"0\":{\"584\":1}}],[\"分库分表后带来的问题\",{\"0\":{\"589\":1}}],[\"分库分表\",{\"0\":{\"583\":1},\"1\":{\"560\":1,\"583\":1}}],[\"分布左右\",{\"1\":{\"921\":1}}],[\"分布到不同的\",{\"1\":{\"861\":1}}],[\"分布到不同的数据库上面\",{\"1\":{\"561\":1}}],[\"分布于不同的节点上时无法使用事务功能\",{\"1\":{\"678\":1}}],[\"分布式计算\",{\"1\":{\"891\":1}}],[\"分布式处理\",{\"0\":{\"891\":1}}],[\"分布式处理之hadoop\",{\"1\":{\"881\":1}}],[\"分布式算法的挑战\",{\"1\":{\"873\":1}}],[\"分布式系统中\",{\"1\":{\"870\":1}}],[\"分布式系统出现网络分区的时候\",{\"1\":{\"870\":1}}],[\"分布式协调\",{\"1\":{\"816\":1}}],[\"分布式应用程序可以基于\",{\"1\":{\"816\":1}}],[\"分布式服务框架\",{\"1\":{\"809\":1}}],[\"分布式\",{\"0\":{\"666\":1,\"671\":1},\"1\":{\"808\":1}}],[\"分布式互斥锁\",{\"1\":{\"643\":1}}],[\"分布式序列号的生成\",{\"1\":{\"603\":1}}],[\"分布式锁和分布式队列等功能\",{\"1\":{\"816\":1}}],[\"分布式锁有一个超时时间\",{\"1\":{\"670\":1}}],[\"分布式锁不能解决超时的问题\",{\"1\":{\"670\":1}}],[\"分布式锁其实就是在系统里面占一个\",{\"1\":{\"669\":1}}],[\"分布式锁应该具备的条件\",{\"1\":{\"667\":1}}],[\"分布式锁\",{\"0\":{\"517\":1,\"821\":1},\"1\":{\"603\":1,\"667\":1,\"807\":1}}],[\"分析业务中的事件\",{\"1\":{\"1216\":1}}],[\"分析语句的执行计划\",{\"1\":{\"559\":1}}],[\"分析出最近几次执行的\",{\"1\":{\"557\":1}}],[\"分析器也会分为几步\",{\"1\":{\"490\":1}}],[\"分析器主要是用来分析\",{\"1\":{\"490\":1}}],[\"分析器\",{\"1\":{\"488\":1,\"489\":2,\"490\":1}}],[\"分解为多个简单的\",{\"1\":{\"516\":1}}],[\"分别比较数组中的元素和父节点的大小\",{\"1\":{\"937\":1}}],[\"分别存储到1000小文件\",{\"1\":{\"896\":1}}],[\"分别叫做t1和t2\",{\"1\":{\"884\":1}}],[\"分别为\",{\"1\":{\"820\":2}}],[\"分别表示列表长度\",{\"1\":{\"627\":1}}],[\"分别是类图\",{\"1\":{\"1094\":1}}],[\"分别是链路层\",{\"1\":{\"964\":1}}],[\"分别是持久层dao层\",{\"1\":{\"761\":1}}],[\"分别是\",{\"1\":{\"622\":1,\"623\":1}}],[\"分别是无锁\",{\"1\":{\"86\":1}}],[\"分别指向了实际的键和值\",{\"1\":{\"614\":1}}],[\"分别对应一个缓冲区的读端和写端\",{\"1\":{\"612\":1}}],[\"分别查询\",{\"1\":{\"558\":1}}],[\"分别使用\",{\"1\":{\"472\":1}}],[\"分别从不同的数据结构中取出\",{\"1\":{\"398\":1}}],[\"分两种情况\",{\"1\":{\"343\":1,\"891\":1}}],[\"分派\",{\"0\":{\"276\":1}}],[\"分派逻辑都固化在java虚拟机内部\",{\"1\":{\"274\":1}}],[\"分代收集\",{\"1\":{\"261\":1}}],[\"分代收集理论也有其缺陷\",{\"1\":{\"240\":1}}],[\"分代收集理论\",{\"0\":{\"239\":1}}],[\"分代年龄\",{\"1\":{\"225\":1}}],[\"分代年龄等信息\",{\"1\":{\"222\":1}}],[\"分支结构中的case\",{\"0\":{\"600\":1}}],[\"分支的所有内容\",{\"1\":{\"452\":1}}],[\"分支\",{\"0\":{\"451\":1},\"1\":{\"189\":1}}],[\"分配方法\",{\"1\":{\"1060\":1}}],[\"分配方式有\",{\"1\":{\"215\":1}}],[\"分配依据不同\",{\"1\":{\"981\":1}}],[\"分配修改所必须的空间\",{\"1\":{\"624\":1}}],[\"分配更大的空间\",{\"1\":{\"615\":1}}],[\"分配新的缓存区时才需要同步锁定\",{\"1\":{\"219\":1}}],[\"分配\",{\"1\":{\"219\":1}}],[\"分配内存空间\",{\"1\":{\"714\":1}}],[\"分配内存\",{\"0\":{\"215\":1},\"1\":{\"1068\":1}}],[\"分配内存并设置该类变量的默认初始值\",{\"1\":{\"171\":1}}],[\"分配内存并设置类变量初始值的阶段\",{\"1\":{\"171\":1}}],[\"分配了一片内存\",{\"1\":{\"571\":1}}],[\"分配了多少内存\",{\"1\":{\"136\":1}}],[\"分配了内存空间\",{\"1\":{\"101\":1,\"714\":1}}],[\"分为一般关联关系\",{\"1\":{\"1097\":1}}],[\"分为结构事物\",{\"1\":{\"1093\":1}}],[\"分为封装业务逻辑的javabean和封装数据的javabean\",{\"1\":{\"754\":1}}],[\"分为两种\",{\"1\":{\"514\":1}}],[\"分为两个过程\",{\"1\":{\"137\":1}}],[\"分为\",{\"1\":{\"509\":1,\"794\":1}}],[\"分为标记和整理两个阶段\",{\"1\":{\"246\":1}}],[\"分为内部碎片和外部碎片\",{\"1\":{\"154\":1}}],[\"分页查询\",{\"0\":{\"486\":1}}],[\"分页会产生内碎片\",{\"1\":{\"155\":1}}],[\"分页与分段的区别\",{\"0\":{\"155\":1}}],[\"分页\",{\"0\":{\"753\":1},\"1\":{\"153\":2,\"155\":1}}],[\"分段大小100w至2000w之间\",{\"1\":{\"587\":1}}],[\"分段太大可能会导致单表依然存在性能问题\",{\"1\":{\"587\":1}}],[\"分段太小会导致切分后子表数量过多增加维护复杂度\",{\"1\":{\"587\":1}}],[\"分段会产生外碎片\",{\"1\":{\"155\":1}}],[\"分段\",{\"1\":{\"153\":2,\"155\":1}}],[\"分类的ip地址\",{\"0\":{\"984\":1},\"1\":{\"983\":1}}],[\"分类\",{\"0\":{\"376\":1},\"1\":{\"133\":1,\"240\":1,\"316\":1}}],[\"例\",{\"1\":{\"253\":1}}],[\"例子\",{\"1\":{\"101\":1,\"227\":1,\"714\":1,\"718\":1}}],[\"例如审批单编号\",{\"1\":{\"1230\":1}}],[\"例如表中\",{\"1\":{\"1117\":1}}],[\"例如增加子类\",{\"1\":{\"1077\":1}}],[\"例如排队问题\",{\"1\":{\"942\":1}}],[\"例如类库\",{\"1\":{\"825\":1}}],[\"例如事务处理\",{\"1\":{\"715\":1}}],[\"例如我们调用incr\",{\"1\":{\"651\":1}}],[\"例如产品详情\",{\"1\":{\"645\":1}}],[\"例如复杂的\",{\"1\":{\"643\":1}}],[\"例如无法保存数组的结束字符\",{\"1\":{\"624\":1}}],[\"例如是当前哈希表\",{\"1\":{\"615\":1}}],[\"例如按时间字段分片\",{\"1\":{\"587\":1}}],[\"例如商品一个库\",{\"1\":{\"585\":1}}],[\"例如查询到\",{\"1\":{\"558\":1}}],[\"例如转账业务中\",{\"1\":{\"519\":1}}],[\"例如两个事务都读取了数据库的某一行\",{\"1\":{\"513\":1}}],[\"例如要拿掉全部人的可执行权限\",{\"1\":{\"433\":1}}],[\"例如由\",{\"1\":{\"418\":1}}],[\"例如如果传\",{\"1\":{\"399\":1}}],[\"例如私有属性\",{\"1\":{\"355\":1}}],[\"例如将他们保存称为weakhashmap中的键\",{\"1\":{\"304\":1}}],[\"例如这个对象是哪个类的实例\",{\"1\":{\"222\":1}}],[\"例如网络并发场景\",{\"1\":{\"210\":1}}],[\"例如作为调用参数传递到其他地方中\",{\"1\":{\"202\":1}}],[\"例如与调试\",{\"1\":{\"196\":1}}],[\"例如jndi\",{\"1\":{\"185\":1}}],[\"例如编译器分析某个锁只会单线程访问就消除锁\",{\"1\":{\"74\":1}}],[\"例如当\",{\"1\":{\"72\":1}}],[\"例如存储用户的\",{\"1\":{\"39\":1,\"44\":1}}],[\"例如\",{\"1\":{\"35\":1,\"64\":1,\"71\":1,\"75\":1,\"102\":1,\"202\":1,\"283\":1,\"338\":2,\"369\":1,\"399\":1,\"418\":1,\"426\":1,\"473\":1,\"475\":1,\"558\":1,\"583\":1,\"587\":2,\"603\":1,\"647\":1,\"671\":1,\"724\":1,\"740\":1,\"772\":1,\"1015\":1,\"1032\":1,\"1049\":1,\"1087\":1,\"1098\":1,\"1099\":1,\"1100\":1,\"1101\":1,\"1134\":1,\"1140\":1,\"1231\":1}}],[\"第\",{\"1\":{\"931\":2}}],[\"第k大\",{\"1\":{\"886\":1}}],[\"第五步\",{\"1\":{\"562\":1}}],[\"第四次挥手\",{\"1\":{\"1026\":1}}],[\"第四次client发送\",{\"1\":{\"1026\":1}}],[\"第四层是数据链路层\",{\"1\":{\"964\":1}}],[\"第四种情况\",{\"1\":{\"594\":1}}],[\"第四步\",{\"1\":{\"562\":1}}],[\"第四轮淘汰\",{\"1\":{\"160\":1}}],[\"第1001条到第1010条数据\",{\"1\":{\"486\":1}}],[\"第7和第8个字节是主版本号\",{\"1\":{\"285\":1}}],[\"第5和第6个字节是次版本号\",{\"1\":{\"285\":1}}],[\"第三个是补丁版本\",{\"1\":{\"1140\":1}}],[\"第三个参数是实现方法逻辑的代理类\",{\"1\":{\"725\":1}}],[\"第三层\",{\"1\":{\"981\":1}}],[\"第三层是网络层\",{\"1\":{\"964\":1}}],[\"第三次挥手\",{\"1\":{\"1026\":1}}],[\"第三次service在发送完要发送的数据后\",{\"1\":{\"1026\":1}}],[\"第三次握手\",{\"1\":{\"1022\":1}}],[\"第三次client发送ack字段\",{\"1\":{\"1022\":1}}],[\"第三次从\",{\"1\":{\"931\":1}}],[\"第三次\",{\"1\":{\"930\":1}}],[\"第三种和第四种\",{\"1\":{\"594\":1}}],[\"第三种情况\",{\"1\":{\"594\":1}}],[\"第三种方式是\",{\"1\":{\"536\":1}}],[\"第三步\",{\"1\":{\"562\":1,\"801\":1}}],[\"第三范式\",{\"1\":{\"455\":1}}],[\"第三方接口调用等\",{\"1\":{\"806\":1}}],[\"第三方\",{\"1\":{\"313\":1,\"718\":1}}],[\"第三方库objenesis\",{\"1\":{\"212\":1}}],[\"第三轮淘汰\",{\"1\":{\"160\":1}}],[\"第二层\",{\"1\":{\"981\":1}}],[\"第二层是传输层有tcp和udp协议\",{\"1\":{\"964\":1}}],[\"第二列从大到小\",{\"1\":{\"938\":1}}],[\"第二次挥手\",{\"1\":{\"1026\":1}}],[\"第二次service发送\",{\"1\":{\"1026\":1}}],[\"第二次service发送ack+1字段和syn字段\",{\"1\":{\"1022\":1}}],[\"第二次握手\",{\"1\":{\"1022\":1}}],[\"第二次从\",{\"1\":{\"931\":1}}],[\"第二次\",{\"1\":{\"930\":1}}],[\"第二次是申请\",{\"1\":{\"617\":1}}],[\"第二种为一对多的消费\",{\"1\":{\"844\":1}}],[\"第二种用户下单只需要\",{\"1\":{\"840\":1}}],[\"第二种情况\",{\"1\":{\"594\":1}}],[\"第二种\",{\"1\":{\"584\":2,\"594\":1}}],[\"第二种方式是\",{\"1\":{\"536\":1}}],[\"第二种设计方案\",{\"1\":{\"455\":1}}],[\"第二步是收敛\",{\"1\":{\"1217\":1}}],[\"第二步\",{\"1\":{\"490\":1,\"562\":1,\"725\":1,\"880\":1,\"893\":1}}],[\"第二步定位添加元素的位置\",{\"1\":{\"129\":1}}],[\"第二个是次版本\",{\"1\":{\"1140\":1}}],[\"第二个到达了服务端\",{\"1\":{\"1023\":1}}],[\"第二个参数是我们把生成的代理对象挂在那个接口之下\",{\"1\":{\"725\":1}}],[\"第二个参数指定返回记录行的最大数目\",{\"1\":{\"486\":1}}],[\"第二个线程来发现已经不是\",{\"1\":{\"101\":1,\"1068\":1}}],[\"第二范式\",{\"1\":{\"455\":1}}],[\"第二轮淘汰\",{\"1\":{\"160\":1}}],[\"第二级页表以及该地址相对于该页首地址的偏移量三部分组成\",{\"1\":{\"156\":1}}],[\"第一台遇到的服务器就是其该定位到的服务器\",{\"1\":{\"681\":1}}],[\"第一种用户下单需要等待\",{\"1\":{\"840\":1}}],[\"第一种情况\",{\"1\":{\"594\":1}}],[\"第一种\",{\"1\":{\"584\":2,\"594\":1}}],[\"第一种方式是\",{\"1\":{\"536\":1}}],[\"第一种设计方案\",{\"1\":{\"455\":1}}],[\"第一步是发散\",{\"1\":{\"1217\":1}}],[\"第一步\",{\"1\":{\"490\":1,\"562\":1,\"725\":1,\"880\":1,\"893\":1}}],[\"第一步判断是否需要对\",{\"1\":{\"129\":1}}],[\"第一范式\",{\"1\":{\"455\":1}}],[\"第一次挥手\",{\"1\":{\"1026\":1}}],[\"第一次client发送\",{\"1\":{\"1026\":1}}],[\"第一次client发送syn字段\",{\"1\":{\"1022\":1}}],[\"第一次握手\",{\"1\":{\"1022\":1}}],[\"第一次从\",{\"1\":{\"931\":1}}],[\"第一次遍历\",{\"1\":{\"930\":1}}],[\"第一次是申请\",{\"1\":{\"617\":1}}],[\"第一次调用时随机生成一个整数\",{\"1\":{\"852\":1}}],[\"第一次调用\",{\"1\":{\"402\":1}}],[\"第一次使用时\",{\"1\":{\"88\":1}}],[\"第一个是主版本\",{\"1\":{\"1140\":1}}],[\"第一个参数proxy就是代理对象\",{\"1\":{\"725\":1}}],[\"第一个参数是类加载器\",{\"1\":{\"725\":1}}],[\"第一个参数指定第一个返回记录行的偏移量\",{\"1\":{\"486\":1}}],[\"第一个字节是\",{\"1\":{\"627\":1}}],[\"第一个事务\",{\"1\":{\"521\":1}}],[\"第一个就放args\",{\"1\":{\"227\":1}}],[\"第一个线程执行\",{\"1\":{\"127\":1}}],[\"第一个线程初始化对象到一半\",{\"1\":{\"101\":1,\"1068\":1}}],[\"第一类用于存储对象自身的运行时数据\",{\"1\":{\"225\":1}}],[\"第一条\",{\"1\":{\"168\":1}}],[\"第一轮淘汰访问位=0\",{\"1\":{\"160\":1}}],[\"3xx\",{\"1\":{\"1040\":1}}],[\"3位标志位\",{\"1\":{\"987\":1}}],[\"3变成\",{\"1\":{\"880\":1}}],[\"3个参数\",{\"1\":{\"865\":1}}],[\"3个隐式字段\",{\"1\":{\"499\":1}}],[\"3步骤乱序了\",{\"1\":{\"714\":1}}],[\"3年内成为具备分布式金融系统架构设计能力的高级java开发工程师\",{\"1\":{\"697\":1}}],[\"3年内成为具备ai工程化和分布式系统架构设计​​能力的高级java开发工程师\",{\"1\":{\"697\":1}}],[\"3s\",{\"1\":{\"672\":1}}],[\"304\",{\"1\":{\"1040\":1}}],[\"302\",{\"1\":{\"1040\":1}}],[\"301\",{\"1\":{\"1040\":1}}],[\"3000收到了\",{\"1\":{\"1013\":1}}],[\"300\",{\"1\":{\"708\":1}}],[\"300m\",{\"1\":{\"411\":1,\"896\":1}}],[\"30\",{\"1\":{\"668\":1,\"919\":1}}],[\"30s\",{\"1\":{\"641\":1,\"802\":1}}],[\"360的atlas\",{\"1\":{\"586\":1}}],[\"3306\",{\"1\":{\"1177\":3}}],[\"33\",{\"1\":{\"565\":2}}],[\"37\",{\"1\":{\"475\":1}}],[\"3时加入到rt\",{\"1\":{\"185\":1}}],[\"3\",{\"0\":{\"227\":1,\"309\":1,\"380\":1,\"385\":1,\"390\":1,\"831\":1,\"894\":1,\"918\":2,\"948\":1,\"1042\":1,\"1098\":1,\"1152\":1,\"1160\":1,\"1186\":1,\"1190\":1,\"1199\":1,\"1204\":1,\"1211\":1,\"1220\":1,\"1221\":1,\"1222\":1,\"1223\":2,\"1227\":1,\"1228\":1,\"1229\":1,\"1230\":2,\"1231\":1,\"1232\":1,\"1233\":1,\"1234\":1,\"1241\":1,\"1242\":1,\"1243\":1,\"1253\":1,\"1272\":1,\"1273\":1,\"1274\":1},\"1\":{\"101\":3,\"111\":1,\"153\":1,\"198\":1,\"224\":1,\"235\":1,\"237\":1,\"304\":1,\"350\":2,\"383\":1,\"392\":1,\"439\":1,\"442\":1,\"484\":2,\"485\":1,\"531\":1,\"532\":1,\"539\":1,\"541\":1,\"560\":1,\"607\":1,\"618\":2,\"632\":1,\"651\":1,\"653\":1,\"662\":1,\"665\":3,\"668\":1,\"672\":3,\"678\":2,\"716\":1,\"759\":3,\"770\":1,\"774\":1,\"776\":1,\"777\":1,\"781\":1,\"801\":1,\"805\":1,\"819\":2,\"820\":9,\"880\":1,\"918\":2,\"919\":3,\"921\":9,\"930\":1,\"935\":1,\"938\":1,\"947\":1,\"952\":1,\"953\":1,\"955\":2,\"956\":2,\"961\":1,\"968\":1,\"979\":1,\"986\":1,\"1019\":1,\"1042\":2,\"1066\":2,\"1087\":1,\"1140\":2,\"1148\":1,\"1162\":1,\"1167\":1}}],[\"32找到数组下标\",{\"1\":{\"903\":1}}],[\"32bit\",{\"1\":{\"903\":1}}],[\"324\",{\"1\":{\"426\":1}}],[\"32位数据类型所占的栈容量为1\",{\"1\":{\"193\":1}}],[\"32\",{\"1\":{\"84\":1,\"156\":1,\"399\":1,\"472\":1,\"630\":1,\"671\":1,\"903\":2,\"981\":1,\"996\":2}}],[\"外观\",{\"1\":{\"1090\":1}}],[\"外观模式可以为系统设计一个简单的接口供外界访问\",{\"1\":{\"1090\":1}}],[\"外观模式是\",{\"1\":{\"1090\":1}}],[\"外观模式\",{\"0\":{\"1090\":1}}],[\"外观类型\",{\"1\":{\"277\":1}}],[\"外排序的归并方法\",{\"1\":{\"889\":1}}],[\"外排序\",{\"0\":{\"889\":1},\"1\":{\"881\":1,\"891\":1}}],[\"外\",{\"1\":{\"661\":1}}],[\"外查询表小\",{\"1\":{\"482\":1}}],[\"外查询表大\",{\"1\":{\"482\":1}}],[\"外查询全表扫描\",{\"1\":{\"482\":1}}],[\"外表表名\",{\"1\":{\"462\":1}}],[\"外键的主要作用是保证数据的一致性和完整性\",{\"1\":{\"463\":1}}],[\"外键的作用\",{\"0\":{\"463\":1}}],[\"外键语法\",{\"1\":{\"462\":1}}],[\"外键字段名\",{\"1\":{\"462\":1}}],[\"外键用来建立和加强两个表数据之间的连接\",{\"1\":{\"462\":1}}],[\"外键\",{\"1\":{\"462\":2,\"491\":1,\"493\":1}}],[\"外键和唯一的区别\",{\"0\":{\"462\":1}}],[\"外键约束的场景会受到影响\",{\"1\":{\"585\":1}}],[\"外键约束\",{\"1\":{\"460\":1}}],[\"外键唯一\",{\"1\":{\"455\":1}}],[\"外部操作聚合内部的实体时\",{\"1\":{\"1232\":1}}],[\"外部应用程序不用关心内部子系统的具体的细节\",{\"1\":{\"1090\":1}}],[\"外部不能new\",{\"1\":{\"1066\":1}}],[\"外部类需要使用内部类\",{\"1\":{\"361\":1}}],[\"外部类与内部类有很强的联系\",{\"1\":{\"361\":1}}],[\"外部碎片往往比较多\",{\"1\":{\"154\":1}}],[\"外部碎片\",{\"1\":{\"154\":1}}],[\"外围设备的中断\",{\"1\":{\"134\":1}}],[\"外层判断提高效率\",{\"1\":{\"101\":1,\"714\":1,\"1068\":1}}],[\"外面包裹一层\",{\"1\":{\"24\":1}}],[\"若存在冲突\",{\"1\":{\"1126\":1}}],[\"若使用\",{\"1\":{\"1117\":1}}],[\"若一致\",{\"1\":{\"1057\":1}}],[\"若一个线程没有在给定的时限内成功获得锁\",{\"1\":{\"98\":1}}],[\"若从互联网上的成百上千个网络集中攻击一个网站\",{\"1\":{\"1054\":1}}],[\"若找到\",{\"1\":{\"1049\":1}}],[\"若每个网络上都设置有一个dhcp服务器\",{\"1\":{\"1049\":1}}],[\"若再省略<路径>项\",{\"1\":{\"1036\":1}}],[\"若连续发送\",{\"1\":{\"1028\":1}}],[\"若两个小时都没有收到客户端的数据\",{\"1\":{\"1028\":1}}],[\"若两表差不多大\",{\"1\":{\"482\":1}}],[\"若同意建立连接\",{\"1\":{\"1022\":1}}],[\"若对网络中某一资源的需求超过了该资源所能提供的可用部分\",{\"1\":{\"1019\":1}}],[\"若发送应用进程把要发送的数据逐个字节地送到tcp的发送缓存\",{\"1\":{\"1017\":1}}],[\"若发现逆序则交换\",{\"1\":{\"930\":1}}],[\"若计时器的时间到期\",{\"1\":{\"1015\":1}}],[\"若接收方收到重复分组\",{\"1\":{\"1010\":1}}],[\"若结果匹配\",{\"1\":{\"990\":1}}],[\"若路由器有目的地址为d的特定主机路由\",{\"1\":{\"990\":1}}],[\"若主机b接收到这个请求分组\",{\"1\":{\"986\":1}}],[\"若没有\",{\"1\":{\"986\":1,\"1049\":1}}],[\"若没有足够数量的\",{\"1\":{\"657\":1,\"677\":1}}],[\"若有默认路由\",{\"1\":{\"990\":1}}],[\"若有\",{\"1\":{\"986\":1}}],[\"若有一个follower坏了\",{\"1\":{\"853\":1}}],[\"若把实现这些协议的硬件和软件加到链路上\",{\"1\":{\"971\":1}}],[\"若遇到对\",{\"1\":{\"959\":1,\"1029\":1}}],[\"若小于孩子中较大的\",{\"1\":{\"937\":1}}],[\"若大于父节点的大小\",{\"1\":{\"937\":1}}],[\"若flag最后仍为false\",{\"1\":{\"930\":1}}],[\"若它的右子树不空\",{\"1\":{\"915\":1}}],[\"若它的左子树不空\",{\"1\":{\"915\":1}}],[\"若消费者机器资源有限\",{\"1\":{\"843\":1}}],[\"若本地域名服务器不能回答该请求\",{\"1\":{\"1031\":1}}],[\"若本地仓库没有\",{\"1\":{\"794\":1}}],[\"若本项目引用了a\",{\"1\":{\"798\":1}}],[\"若项目中多个jar同时引用了相同的jar时\",{\"1\":{\"798\":1}}],[\"若出现maven信息\",{\"1\":{\"793\":1}}],[\"若为\",{\"1\":{\"702\":1}}],[\"若\",{\"1\":{\"657\":1,\"677\":1}}],[\"若分库后将他们放到一个服务器上\",{\"1\":{\"585\":1}}],[\"若不拆分\",{\"1\":{\"585\":1}}],[\"若不进行分布式部署\",{\"1\":{\"583\":1}}],[\"若不在\",{\"1\":{\"496\":1,\"574\":1}}],[\"若事务t对数据对象a加上x锁\",{\"1\":{\"509\":1}}],[\"若事务\",{\"1\":{\"509\":1}}],[\"若在\",{\"1\":{\"496\":1,\"574\":1}}],[\"若表的主键不是顺序的\",{\"1\":{\"466\":1}}],[\"若目标文件已经存在\",{\"1\":{\"425\":1}}],[\"若目标文件\",{\"1\":{\"425\":1}}],[\"若目标档\",{\"1\":{\"423\":1}}],[\"若获取成功\",{\"1\":{\"410\":1}}],[\"若想使用指定的构造器来创建实例\",{\"1\":{\"356\":1}}],[\"若该类没有实现任何接口\",{\"1\":{\"288\":1}}],[\"若干次之后进行一次碎片整理\",{\"1\":{\"261\":1}}],[\"若用非收集区域所有含跨代引用的对象数组来实现rset的话\",{\"1\":{\"249\":1}}],[\"若用\",{\"1\":{\"160\":1}}],[\"若第一轮没选中\",{\"1\":{\"160\":1}}],[\"若内存空间不够\",{\"1\":{\"159\":1}}],[\"若整个空间都找不到空余地址\",{\"1\":{\"47\":1}}],[\"然而我只做了很少的代码量\",{\"1\":{\"724\":1}}],[\"然而一个哨兵进程对\",{\"1\":{\"657\":1}}],[\"然而哈希值相等\",{\"1\":{\"341\":1}}],[\"然而\",{\"1\":{\"117\":1}}],[\"然而总有些时候是无法预知的\",{\"1\":{\"98\":1}}],[\"然后就可以解决代码\",{\"1\":{\"1202\":1}}],[\"然后就是取出前n个出现次数最多的数据了\",{\"1\":{\"898\":1}}],[\"然后进入仓库用这个\",{\"1\":{\"1202\":1}}],[\"然后进行统计\",{\"1\":{\"884\":1}}],[\"然后进行插入操作\",{\"1\":{\"129\":1}}],[\"然后一步一步构建而成\",{\"1\":{\"1086\":1}}],[\"然后一台一台启动从节点\",{\"1\":{\"655\":1}}],[\"然后解密发送方发过来的数字签名\",{\"1\":{\"1057\":1}}],[\"然后解锁\",{\"1\":{\"643\":1}}],[\"然后使用相同的摘要算法计算发布内容的摘要\",{\"1\":{\"1057\":1}}],[\"然后使用一个输出流\",{\"1\":{\"344\":1}}],[\"然后服务端使用随机数构造对称加密算法\",{\"1\":{\"1044\":1}}],[\"然后服务端将字节流转换成自身能读取的格式\",{\"1\":{\"804\":1}}],[\"然后让本地服务器进行后续的查询\",{\"1\":{\"1031\":1}}],[\"然后向发送方发送确认\",{\"1\":{\"1018\":1}}],[\"然后由应用层来主动获取\",{\"1\":{\"1006\":1}}],[\"然后每一片按照数据大小分配\",{\"1\":{\"1004\":1}}],[\"然后从网卡发出去就行了\",{\"1\":{\"1001\":1}}],[\"然后从新的leader中同步数据\",{\"1\":{\"855\":1}}],[\"然后较小的元素作为左倾红节点存在于红黑树中\",{\"1\":{\"921\":1}}],[\"然后来到弹出节点的右树上继续执行\",{\"1\":{\"908\":1}}],[\"然后5000个小文件就行排序\",{\"1\":{\"904\":1}}],[\"然后利用\",{\"1\":{\"903\":1}}],[\"然后扫描这2\",{\"1\":{\"900\":1}}],[\"然后挨个读取另外一个文件的url\",{\"1\":{\"896\":1}}],[\"然后遍历另一个小文件的每个\",{\"1\":{\"896\":1}}],[\"然后遍历这些连接\",{\"1\":{\"829\":1}}],[\"然后我们为每个小文件构造一个数量为5的最大堆\",{\"1\":{\"904\":1}}],[\"然后我们只要求出1000对小文件中相同的\",{\"1\":{\"896\":1}}],[\"然后我们还需要在客户端和服务端分别维护一个\",{\"1\":{\"804\":1}}],[\"然后按出现次数做快速\",{\"1\":{\"895\":1}}],[\"然后按照该值存到5000个小文件\",{\"1\":{\"894\":1}}],[\"然后按照\",{\"1\":{\"753\":1}}],[\"然后汇总\",{\"1\":{\"891\":1}}],[\"然后子区域里的数的个数只有2^20\",{\"1\":{\"886\":1}}],[\"然后子进程退出\",{\"1\":{\"647\":1}}],[\"然后确定是子区域的第几大数\",{\"1\":{\"886\":1}}],[\"然后确定区域的第几大数\",{\"1\":{\"886\":1}}],[\"然后第二次扫描我们只统计落在这个区域中的那些数就可以了\",{\"1\":{\"886\":1}}],[\"然后读取数据统计落到各个区域里的数的个数\",{\"1\":{\"886\":1}}],[\"然后读取下一条\",{\"1\":{\"501\":1}}],[\"然后不同的区域在利用bitmap就可以直接解决了\",{\"1\":{\"886\":1}}],[\"然后最后在一个可以接受的范围内进行\",{\"1\":{\"886\":1}}],[\"然后他会向所有节点发起\",{\"1\":{\"877\":1}}],[\"然后它就会认为此时没有可用的\",{\"1\":{\"877\":1}}],[\"然后秒杀业务再从消息队列中取出数据进行业务计算\",{\"1\":{\"840\":1}}],[\"然后master进程重新去load配置文件\",{\"1\":{\"837\":1}}],[\"然后将修改的发布内容\",{\"1\":{\"1057\":1}}],[\"然后将这40亿个数分成两类\",{\"1\":{\"901\":1}}],[\"然后将这些topic按照其订阅的consumer数进行平均分配\",{\"1\":{\"859\":1}}],[\"然后将新key存储在负载少的位置\",{\"1\":{\"884\":1}}],[\"然后将数据分离到不同的区域\",{\"1\":{\"886\":1}}],[\"然后将数据从页面缓存直接发送到网络中\",{\"1\":{\"850\":1}}],[\"然后将数据写进\",{\"1\":{\"804\":1}}],[\"然后将对应的句柄交给新的worker进程管理\",{\"1\":{\"837\":1}}],[\"然后将其放入数组\",{\"1\":{\"129\":1}}],[\"然后函数自己去栈中读即可\",{\"1\":{\"804\":1}}],[\"然后执行相应函数代码\",{\"1\":{\"804\":1}}],[\"然后执行change\",{\"1\":{\"574\":1}}],[\"然后筛选出以\",{\"1\":{\"771\":1}}],[\"然后可以在模块中进行接口的调用来进行数据业务的处理\",{\"1\":{\"762\":1}}],[\"然后可以认为数据页内部通过二分法来定位记录\",{\"1\":{\"555\":1}}],[\"然后根据所取得的值将url分别存储到1000个小文件\",{\"1\":{\"896\":1}}],[\"然后根据统计结果\",{\"1\":{\"893\":1}}],[\"然后根据该\",{\"1\":{\"755\":1}}],[\"然后根据节点数\",{\"1\":{\"679\":1}}],[\"然后重写\",{\"1\":{\"753\":1}}],[\"然后在小文件中找出不重复的整数\",{\"1\":{\"900\":1}}],[\"然后在\",{\"1\":{\"804\":1}}],[\"然后在spring的配置文件中配置其实现的关联\",{\"1\":{\"763\":1}}],[\"然后在spring的配置文件中定义接口的实现类\",{\"1\":{\"762\":1}}],[\"然后在通过它获取需要的类实例\",{\"1\":{\"736\":1}}],[\"然后在叶子节点上进行二分查找\",{\"1\":{\"538\":1}}],[\"然后设置了超类的方法\",{\"1\":{\"726\":1}}],[\"然后像打针一样\",{\"1\":{\"718\":1}}],[\"然后spring会在系统运行到适当的时候\",{\"1\":{\"718\":1}}],[\"然后以指定的频率写入磁盘\",{\"1\":{\"707\":1}}],[\"然后发送给所有的\",{\"1\":{\"661\":1}}],[\"然后直接进行统计即可\",{\"1\":{\"891\":1}}],[\"然后直接自动跳转到这个对应的节点上进行存取操作\",{\"1\":{\"659\":1}}],[\"然后直接清理掉端边界以外的内存\",{\"1\":{\"246\":1}}],[\"然后对这些子序列内分别进行插入排序\",{\"1\":{\"933\":1}}],[\"然后对分区进行轮询\",{\"1\":{\"859\":1}}],[\"然后对每一个键值对用一条命令记录它的写入\",{\"1\":{\"651\":1}}],[\"然后对位数组长度进行取模运算得到一个位置\",{\"1\":{\"645\":1}}],[\"然后等解锁后返回数据或进入\",{\"1\":{\"643\":1}}],[\"然后查\",{\"1\":{\"643\":1}}],[\"然后写上网络前缀所占的位数\",{\"1\":{\"991\":1}}],[\"然后写\",{\"1\":{\"578\":2}}],[\"然后调用\",{\"1\":{\"568\":1,\"759\":1}}],[\"然后擦除该部分后继续使用\",{\"1\":{\"568\":1}}],[\"然后获得其使用索引的情况\",{\"1\":{\"559\":1}}],[\"然后获取迭代器对象进行遍历\",{\"1\":{\"391\":1}}],[\"然后分析慢查询日志\",{\"1\":{\"557\":1}}],[\"然后拿着这两个id一次次的回表查询\",{\"1\":{\"553\":1}}],[\"然后递归地在指针所指向的节点进行查找\",{\"1\":{\"538\":1}}],[\"然后乘以这个索引的页面数\",{\"1\":{\"536\":1}}],[\"然后返回给顾客\",{\"1\":{\"1086\":1}}],[\"然后返回\",{\"1\":{\"501\":1}}],[\"然后加主键聚簇索引上的记录x锁\",{\"1\":{\"501\":1}}],[\"然后加载新任务的上下文到这些寄存器和程序计数器\",{\"1\":{\"144\":1}}],[\"然后马上调用fsync函数\",{\"1\":{\"496\":1}}],[\"然后告知执行器执行完成了\",{\"1\":{\"489\":1}}],[\"然后往后查询\",{\"1\":{\"486\":1}}],[\"然后内核去查询每个\",{\"1\":{\"381\":1}}],[\"然后通过beandefinitionregistry将这些bean注册到beanfactory中\",{\"1\":{\"737\":1}}],[\"然后通过发布订阅模式通知其它\",{\"1\":{\"677\":1}}],[\"然后通过发布订阅模式通过其他的从服务器\",{\"1\":{\"657\":1}}],[\"然后通过从头遍历节点来实现删除操作\",{\"1\":{\"392\":1}}],[\"然后通过一个存储在java堆里面的directbytebuffer对象作为这块内存的引用进行操作\",{\"1\":{\"209\":1}}],[\"然后通知服务器端开启线程去处理\",{\"1\":{\"380\":1}}],[\"然后用函数把这些步骤实现\",{\"1\":{\"354\":1}}],[\"然后把加了密的数据送往传输层\",{\"1\":{\"1047\":1}}],[\"然后把这个结果返回给发起查询的主机\",{\"1\":{\"1031\":1}}],[\"然后把这一票投给\",{\"1\":{\"820\":1}}],[\"然后把对应的\",{\"1\":{\"875\":1}}],[\"然后把计算好的结果序列化传给客户端\",{\"1\":{\"804\":1}}],[\"然后把它传给服务端\",{\"1\":{\"804\":1}}],[\"然后把结果和\",{\"1\":{\"659\":1}}],[\"然后把结果集存在临时文件中\",{\"1\":{\"482\":1}}],[\"然后把决定回收的那一部分region的存活对象复制到空的region中\",{\"1\":{\"264\":1}}],[\"然后把数据\",{\"1\":{\"73\":1}}],[\"然后交换from和to指针\",{\"1\":{\"242\":1}}],[\"然后程序在运行到指定的代码时\",{\"1\":{\"161\":1}}],[\"然后再\",{\"1\":{\"1136\":1}}],[\"然后再给一个数\",{\"0\":{\"901\":1}}],[\"然后再进行归并\",{\"1\":{\"900\":1}}],[\"然后再在这1000个最大的ip中\",{\"1\":{\"892\":1}}],[\"然后再找出频率最大的几个\",{\"1\":{\"892\":1}}],[\"然后再发起共识请求\",{\"1\":{\"875\":1}}],[\"然后再删除\",{\"1\":{\"844\":1}}],[\"然后再生产代理对象返回\",{\"1\":{\"726\":1}}],[\"然后再请教他们\",{\"1\":{\"693\":1}}],[\"然后再将数据缓存\",{\"1\":{\"640\":1}}],[\"然后再拷贝至磁盘共享表空间\",{\"1\":{\"593\":1}}],[\"然后再提交\",{\"1\":{\"578\":1}}],[\"然后再以一定的频率和情况进行\",{\"1\":{\"574\":1}}],[\"然后再以一定的频率和情况进行insert\",{\"1\":{\"496\":1}}],[\"然后再返回\",{\"1\":{\"489\":1}}],[\"然后再与外层查询sql进行匹配\",{\"1\":{\"482\":1}}],[\"然后再执行该方法\",{\"1\":{\"274\":1}}],[\"然后再异步处理\",{\"1\":{\"262\":1}}],[\"然后再把使用的空间一次清理掉\",{\"1\":{\"245\":1}}],[\"然后再通过物理地址访问内存\",{\"1\":{\"153\":1}}],[\"然后再由系统进程调度程序在适当的时候将该进程转为执行状态\",{\"1\":{\"148\":1}}],[\"然后切换到其它协程\",{\"1\":{\"139\":1}}],[\"然后给每一个数据段配一把锁\",{\"1\":{\"129\":1}}],[\"然后继续执行程序\",{\"1\":{\"159\":1}}],[\"然后继续执行\",{\"1\":{\"121\":1}}],[\"然后当前线程被阻塞\",{\"1\":{\"120\":1}}],[\"然后自己进入\",{\"1\":{\"89\":1}}],[\"然后线程尝试使用\",{\"1\":{\"87\":1}}],[\"然后唤醒\",{\"1\":{\"85\":1}}],[\"然后中断没有正在执行任务的线程\",{\"1\":{\"59\":1}}],[\"然后尝试停止正在执行或暂停任务的线程\",{\"1\":{\"59\":1}}],[\"然后逐个调用线程的\",{\"1\":{\"59\":1}}],[\"然后\",{\"1\":{\"39\":1,\"118\":1,\"576\":1,\"623\":1,\"665\":1,\"817\":1,\"927\":1,\"1057\":2}}],[\"饥饿\",{\"0\":{\"97\":1,\"100\":1},\"1\":{\"163\":2}}],[\"活动图\",{\"1\":{\"1094\":1}}],[\"活跃状态\",{\"1\":{\"520\":1}}],[\"活锁\",{\"0\":{\"97\":1,\"99\":1}}],[\"活着\",{\"1\":{\"45\":1}}],[\"死锁检测\",{\"1\":{\"516\":1}}],[\"死锁现象\",{\"1\":{\"516\":1}}],[\"死锁⭐\",{\"0\":{\"516\":1}}],[\"死锁的\",{\"1\":{\"98\":1}}],[\"死锁就很容易发生\",{\"1\":{\"98\":1}}],[\"死锁\",{\"0\":{\"97\":1,\"98\":1},\"1\":{\"98\":2,\"307\":1,\"516\":1}}],[\"作为第三次报文的数据\",{\"1\":{\"1042\":1}}],[\"作为icmp差错报告报文的数据字段\",{\"1\":{\"993\":1}}],[\"作为网络传输框架\",{\"1\":{\"814\":1}}],[\"作为\",{\"1\":{\"807\":1,\"1090\":1,\"1210\":1}}],[\"作为持久化设计中的最重要也最复杂的技术\",{\"1\":{\"748\":1}}],[\"作为配置类\",{\"1\":{\"743\":1}}],[\"作为一个\",{\"1\":{\"673\":1}}],[\"作为一个相互依存的整体\",{\"1\":{\"354\":1}}],[\"作为进程\",{\"1\":{\"657\":1}}],[\"作为二级缓存\",{\"1\":{\"642\":1}}],[\"作为字符串结束的标识\",{\"1\":{\"624\":1}}],[\"作为多级缓存\",{\"1\":{\"607\":1}}],[\"作为聚集索引\",{\"1\":{\"547\":1}}],[\"作为主键\",{\"0\":{\"466\":1}}],[\"作为调用目标\",{\"1\":{\"277\":1}}],[\"作为cms收集器发生失败时的后备预案\",{\"1\":{\"256\":1}}],[\"作为程序访问方法区中类型数据的外部接口\",{\"1\":{\"168\":1}}],[\"作为方法区这个类的各种数据的访问入口\",{\"1\":{\"168\":1}}],[\"作为最终释放的条件\",{\"1\":{\"96\":1}}],[\"作用于持久层\",{\"1\":{\"743\":1}}],[\"作用于表现层\",{\"1\":{\"743\":1}}],[\"作用于业务逻辑层\",{\"1\":{\"743\":1}}],[\"作用于工作内存的变量\",{\"1\":{\"294\":4}}],[\"作用于主内存的变量\",{\"1\":{\"294\":4}}],[\"作用\",{\"0\":{\"840\":1},\"1\":{\"74\":1,\"78\":1,\"287\":1,\"292\":6,\"655\":1,\"677\":1,\"718\":1,\"762\":1,\"763\":1,\"764\":1,\"765\":1,\"840\":1,\"966\":1,\"986\":1,\"1030\":1,\"1232\":1}}],[\"作用变量范围\",{\"1\":{\"74\":1}}],[\"返回实例对象\",{\"1\":{\"1066\":2}}],[\"返回频数最高的100个词\",{\"0\":{\"894\":1},\"1\":{\"889\":1}}],[\"返回结果成功\",{\"1\":{\"807\":1}}],[\"返回结果为java\",{\"1\":{\"182\":2}}],[\"返回的可用\",{\"1\":{\"801\":1}}],[\"返回的数据为引用数据类型\",{\"1\":{\"383\":1}}],[\"返回的数据为基本数据类型\",{\"1\":{\"383\":1}}],[\"返回渲染视图之前被调用\",{\"1\":{\"759\":1}}],[\"返回给dispatcherservlet\",{\"1\":{\"755\":1}}],[\"返回给视图中的请求处\",{\"1\":{\"754\":1}}],[\"返回一个\",{\"1\":{\"755\":1,\"801\":1}}],[\"返回一个视图对象\",{\"1\":{\"755\":1}}],[\"返回接口执行的结果\",{\"1\":{\"490\":1}}],[\"返回右表中所有的记录以及左表中连接字段相等的记录\",{\"1\":{\"485\":1}}],[\"返回左表中所有的记录以及右表中连接字段相等的记录\",{\"1\":{\"485\":1}}],[\"返回类型\",{\"1\":{\"359\":1}}],[\"返回地址是要通过异常处理器表来确定的\",{\"1\":{\"195\":1}}],[\"返回该信息\",{\"1\":{\"1049\":1}}],[\"返回该类加载器的超类加载器\",{\"1\":{\"182\":1}}],[\"返回该线程局部变量的初始值\",{\"1\":{\"39\":1}}],[\"返回用户程序继续执行\",{\"1\":{\"135\":1}}],[\"返回\",{\"1\":{\"126\":1,\"405\":1,\"559\":1,\"668\":1}}],[\"返回值类型可以相同也可以不同\",{\"1\":{\"359\":1}}],[\"返回值不小于于\",{\"1\":{\"123\":1}}],[\"返回值为\",{\"1\":{\"123\":1,\"759\":1}}],[\"返回同步状态的当前值\",{\"1\":{\"110\":1}}],[\"返回true\",{\"1\":{\"96\":1}}],[\"此弊端可使用抽象工厂模式解决\",{\"1\":{\"1078\":1}}],[\"此tcp连接就处于空闲状态\",{\"1\":{\"1042\":1}}],[\"此过程统一了序列字段号\",{\"1\":{\"1022\":1}}],[\"此处提到的叶子其实是空链接\",{\"1\":{\"921\":1}}],[\"此处不需要\",{\"1\":{\"96\":1}}],[\"此问题的解决分为以下两个步骤\",{\"1\":{\"893\":1}}],[\"此种方式比原先的单节点的方法更安全\",{\"1\":{\"672\":1}}],[\"此日志对于非常重要\",{\"1\":{\"566\":1}}],[\"此后\",{\"1\":{\"452\":1}}],[\"此参数的效果和指定\",{\"1\":{\"426\":1}}],[\"此外\",{\"1\":{\"392\":2,\"752\":1,\"829\":1,\"830\":1,\"972\":1,\"975\":1,\"981\":1,\"1018\":1,\"1083\":1,\"1134\":1}}],[\"此key没有其他引用\",{\"1\":{\"304\":1}}],[\"此时该主机就成为了dhcp客户\",{\"1\":{\"1049\":1}}],[\"此时该线程就可以被调度了\",{\"1\":{\"350\":1}}],[\"此时tcp处于半关闭状态\",{\"1\":{\"1026\":1}}],[\"此时tcp连接已经建立\",{\"1\":{\"1022\":1}}],[\"此时ack=u+1\",{\"1\":{\"1026\":1}}],[\"此时a进入fin\",{\"1\":{\"1026\":2}}],[\"此时a一直在等待b的非零窗口通知\",{\"1\":{\"1015\":1}}],[\"此时客户端\",{\"1\":{\"1026\":1}}],[\"此时客户端忽略服务端发来的确认\",{\"1\":{\"1023\":1}}],[\"此时双方还没有完全建立其连接\",{\"1\":{\"1025\":1}}],[\"此时服务端误认为客户端又发出一次新的连接请求\",{\"1\":{\"1023\":1}}],[\"此时服务器进入syn\",{\"1\":{\"1022\":1}}],[\"此时服务器\",{\"1\":{\"820\":1}}],[\"此时进行快重传\",{\"1\":{\"1020\":1}}],[\"此时b就会重复确认编号2的号\",{\"1\":{\"1019\":1}}],[\"此时应当从匹配结果中选择具有最长网络前缀的路由\",{\"1\":{\"991\":1}}],[\"此时low=high\",{\"1\":{\"935\":1}}],[\"此时需要如何解决这个问题呢\",{\"1\":{\"853\":1}}],[\"此时将key的hash值与topic的partition总数进行取余得到partition值\",{\"1\":{\"852\":1}}],[\"此时将开始执行拦截器的\",{\"1\":{\"755\":1}}],[\"此时数据通过网络发送给消费者\",{\"1\":{\"850\":1}}],[\"此时会创建一个新的\",{\"1\":{\"846\":1}}],[\"此时会进行第二次扣款\",{\"1\":{\"807\":1}}],[\"此时会进入全表扫描\",{\"1\":{\"506\":1}}],[\"此时投票数正好大于半数\",{\"1\":{\"820\":1}}],[\"此时钱已经扣了\",{\"1\":{\"807\":1}}],[\"此时spring\",{\"1\":{\"715\":1}}],[\"此时singleton才不为null\",{\"1\":{\"101\":1}}],[\"此时instance\",{\"1\":{\"714\":1}}],[\"此时原队首的\",{\"1\":{\"628\":1}}],[\"此时对象头\",{\"1\":{\"617\":1}}],[\"此时哈希表\",{\"1\":{\"615\":1}}],[\"此时change\",{\"1\":{\"574\":1}}],[\"此时如果同步不成功\",{\"1\":{\"675\":1}}],[\"此时如果\",{\"1\":{\"521\":1}}],[\"此时更新会使用next\",{\"1\":{\"506\":1}}],[\"此时的时间复杂度就是\",{\"1\":{\"627\":1}}],[\"此时的写入是离散的\",{\"1\":{\"496\":1}}],[\"此时的对象是没有初始化的对象\",{\"1\":{\"101\":1,\"714\":1}}],[\"此时print的话\",{\"1\":{\"367\":1}}],[\"此时msg还不能被回收\",{\"1\":{\"304\":1}}],[\"此时用户线程stw\",{\"1\":{\"261\":1}}],[\"此时不再是常量池中的符号引用了\",{\"1\":{\"208\":1}}],[\"此时子进程将成为一个僵尸进程\",{\"1\":{\"151\":1}}],[\"此时就应该使用子网掩码\",{\"1\":{\"989\":1}}],[\"此时就得回滚事务而不是强行提交事务来导致数据不一致\",{\"1\":{\"519\":1}}],[\"此时就需要进行系统调用\",{\"1\":{\"134\":1}}],[\"此时就要进行锁膨胀\",{\"1\":{\"89\":1}}],[\"此时创建了\",{\"1\":{\"101\":1}}],[\"此时锁会膨胀为重量级\",{\"1\":{\"88\":1}}],[\"此时\",{\"1\":{\"46\":1,\"134\":1,\"393\":1,\"489\":1,\"501\":1,\"615\":1,\"927\":1,\"1022\":1,\"1068\":1}}],[\"代售点\",{\"1\":{\"1082\":1}}],[\"代理\",{\"0\":{\"1084\":1}}],[\"代理点收取一些额外费用\",{\"1\":{\"1082\":1}}],[\"代理角色\",{\"1\":{\"1082\":1}}],[\"代理对象可以扩展目标对象的功能\",{\"1\":{\"1081\":1}}],[\"代理对象主要起到一个中介的作用\",{\"1\":{\"715\":1}}],[\"代理软件可以对传输内容进行解密\",{\"1\":{\"1046\":1}}],[\"代理非抽象类用methodproxy\",{\"1\":{\"726\":1}}],[\"代理接口method\",{\"1\":{\"726\":1}}],[\"代理类属于目标类的子类\",{\"1\":{\"1084\":1}}],[\"代理类\",{\"1\":{\"725\":1,\"726\":1}}],[\"代理类在程序运行时创建的代理方式被成为动态代理\",{\"1\":{\"724\":1}}],[\"代理类可以对客户端隐藏真实对象的具体信息\",{\"1\":{\"716\":1}}],[\"代理模式\",{\"0\":{\"1081\":1}}],[\"代理模式的代理和真实对象之间的对象通常在编译时就已经确定了\",{\"1\":{\"716\":1}}],[\"代理模式的设计动机就是通过代理对象来访问真实对象\",{\"1\":{\"715\":1}}],[\"代理模式中\",{\"1\":{\"716\":1}}],[\"代理模式是代理原类进行操作\",{\"1\":{\"716\":1}}],[\"代理模式跟装饰器模式比较类似\",{\"1\":{\"716\":1}}],[\"代理模式与装饰器模式的区别\",{\"0\":{\"716\":1}}],[\"代理设计模式\",{\"0\":{\"715\":1},\"1\":{\"742\":1}}],[\"代替\",{\"1\":{\"560\":3}}],[\"代表两种不同的角色\",{\"1\":{\"1097\":1}}],[\"代表一个unsigned\",{\"1\":{\"901\":1}}],[\"代表一个地址值\",{\"1\":{\"367\":1}}],[\"代表可执行\",{\"1\":{\"430\":1}}],[\"代表可写\",{\"1\":{\"430\":1}}],[\"代表可读\",{\"1\":{\"430\":1}}],[\"代表往回翻页\",{\"1\":{\"429\":1}}],[\"代表立刻离开\",{\"1\":{\"429\":1}}],[\"代表在这个显示的内容当中\",{\"1\":{\"429\":1}}],[\"代表向下翻\",{\"1\":{\"429\":1}}],[\"代表向下翻一页\",{\"1\":{\"429\":1}}],[\"代表显示几行的意思\",{\"1\":{\"428\":1}}],[\"代表最终\",{\"1\":{\"346\":1}}],[\"代表着某种特定操作含义的操作码以及跟随其后的零至多个代表此操作所需参数的操作数所构成\",{\"1\":{\"280\":1}}],[\"代表资源可获取\",{\"1\":{\"96\":1}}],[\"代码规范\",{\"1\":{\"1264\":1}}],[\"代码示例\",{\"0\":{\"1241\":1}}],[\"代码实践\",{\"0\":{\"1235\":1}}],[\"代码层面可以通过事件总线或消息队列间接通信\",{\"1\":{\"1229\":1}}],[\"代码结构\",{\"0\":{\"1227\":1}}],[\"代码生成注释\",{\"1\":{\"1152\":1}}],[\"代码自动补全\",{\"1\":{\"1152\":1}}],[\"代码\",{\"1\":{\"1150\":1,\"1201\":1}}],[\"代码同步\",{\"1\":{\"831\":1}}],[\"代码判断不出来是真的不存在还是就是存了\",{\"1\":{\"641\":1}}],[\"代码会看着很干净和优雅\",{\"1\":{\"607\":1}}],[\"代码提交\",{\"0\":{\"448\":1}}],[\"代码的行为就有可能也随着变化\",{\"1\":{\"348\":1}}],[\"代码中可以不赋初始值就直接使用\",{\"1\":{\"221\":1}}],[\"代码缓存\",{\"1\":{\"188\":1}}],[\"代码就只能根据具体提供者的类型来硬编码判断\",{\"1\":{\"185\":1}}],[\"代码热替换\",{\"1\":{\"185\":1}}],[\"代码块只会被执行一次\",{\"1\":{\"352\":1}}],[\"代码块经常会被用来初始化静态变量\",{\"1\":{\"352\":1}}],[\"代码块\",{\"1\":{\"352\":1,\"1134\":1}}],[\"代码块的时候\",{\"1\":{\"87\":1}}],[\"代码块中的语句都会执行\",{\"1\":{\"383\":1}}],[\"代码块中显式释放锁\",{\"1\":{\"94\":1}}],[\"代码块中\",{\"1\":{\"71\":1,\"346\":2}}],[\"代码块中有\",{\"1\":{\"71\":1}}],[\"代码随想录\",{\"1\":{\"3\":1}}],[\"吃\",{\"1\":{\"94\":1}}],[\"比继承灵活\",{\"1\":{\"1085\":1}}],[\"比非持续连接的两倍rtt好一点\",{\"1\":{\"1042\":1}}],[\"比application优先加载\",{\"1\":{\"783\":1}}],[\"比率超过\",{\"1\":{\"632\":1}}],[\"比父类被重写方法更好访问\",{\"1\":{\"359\":1}}],[\"比的是内存中存放的内容是否相等\",{\"1\":{\"340\":1}}],[\"比\",{\"1\":{\"149\":1,\"411\":1,\"649\":1,\"652\":2}}],[\"比较有用\",{\"1\":{\"1138\":1}}],[\"比较规则使用匿名内部类或者\",{\"1\":{\"1089\":1}}],[\"比较器\",{\"1\":{\"1089\":1}}],[\"比较当前的数和它后面的数的大小\",{\"1\":{\"932\":1}}],[\"比较繁琐\",{\"1\":{\"675\":1}}],[\"比较鸡肋\",{\"1\":{\"607\":1}}],[\"比较常见的是将其设置为\",{\"1\":{\"571\":1}}],[\"比较常见是\",{\"1\":{\"563\":1}}],[\"比较合适\",{\"1\":{\"477\":2}}],[\"比较占地方\",{\"1\":{\"467\":1}}],[\"比较新\",{\"1\":{\"425\":1}}],[\"比较时\",{\"1\":{\"368\":1}}],[\"比较的是地址\",{\"1\":{\"368\":1}}],[\"比较内存地址\",{\"1\":{\"340\":1}}],[\"比较该类的两个对象时\",{\"1\":{\"340\":1}}],[\"比较老的处理器通过\",{\"1\":{\"296\":1}}],[\"比较\",{\"0\":{\"610\":1},\"1\":{\"105\":1,\"368\":1}}],[\"比较智能\",{\"1\":{\"91\":1}}],[\"比如电商系统可以包含商品子域\",{\"1\":{\"1221\":1}}],[\"比如取号\",{\"1\":{\"1087\":1}}],[\"比如办理具体业务\",{\"1\":{\"1087\":1}}],[\"比如请求a发送了所有的头信息字段\",{\"1\":{\"1042\":1}}],[\"比如手机号\",{\"1\":{\"923\":1}}],[\"比如一棵\",{\"1\":{\"919\":1}}],[\"比如一个涉及调用三方服务的后端接口开发\",{\"1\":{\"691\":1}}],[\"比如一个磁盘7200转\",{\"1\":{\"543\":1}}],[\"比如一个用户的信息\",{\"1\":{\"456\":1}}],[\"比如一个\",{\"1\":{\"96\":1}}],[\"比如mapreduce\",{\"1\":{\"895\":1}}],[\"比如模1000\",{\"1\":{\"892\":1}}],[\"比如有1001个\",{\"1\":{\"891\":1}}],[\"比如通过\",{\"1\":{\"891\":1}}],[\"比如常见的学术论文的关键字搜索\",{\"1\":{\"888\":1}}],[\"比如用单个文件代表一个区域\",{\"1\":{\"886\":1}}],[\"比如用户登录的信息等\",{\"1\":{\"606\":1}}],[\"比如用户表\",{\"1\":{\"456\":1}}],[\"比如求前n小\",{\"1\":{\"885\":1}}],[\"比如两个位置都为空或者都存储了一个key\",{\"1\":{\"884\":1}}],[\"比如8位电话号码\",{\"1\":{\"883\":1}}],[\"比如爬给定网址的时候对已经爬取过的\",{\"1\":{\"882\":1}}],[\"比如判断一个数字是否存在于包含大量数字的数字集中\",{\"1\":{\"882\":1}}],[\"比如根据节点的\",{\"1\":{\"880\":1}}],[\"比如节点的数量从\",{\"1\":{\"880\":1}}],[\"比如部分节点网络出了问题\",{\"1\":{\"870\":1}}],[\"比如order\",{\"1\":{\"865\":1}}],[\"比如科学上网\",{\"1\":{\"826\":1}}],[\"比如http的头信息等\",{\"1\":{\"805\":1}}],[\"比如你用的是\",{\"1\":{\"803\":1}}],[\"比如每隔\",{\"1\":{\"802\":1}}],[\"比如服务由于发版时\",{\"1\":{\"802\":1}}],[\"比如随机或者轮训从\",{\"1\":{\"801\":1}}],[\"比如beanfactoryaware\",{\"1\":{\"737\":1}}],[\"比如b=1\",{\"1\":{\"533\":1}}],[\"比如本来有我们自己new出来的对象\",{\"1\":{\"718\":1}}],[\"比如本地进程作为一级缓存\",{\"1\":{\"642\":1}}],[\"比如由\",{\"1\":{\"717\":1}}],[\"比如说\",{\"1\":{\"713\":1,\"751\":1,\"1042\":1}}],[\"比如说加日志\",{\"1\":{\"349\":1}}],[\"比如分布式\",{\"1\":{\"685\":1}}],[\"比如主键和唯一索引等\",{\"1\":{\"668\":1}}],[\"比如作为缓存\",{\"1\":{\"653\":1}}],[\"比如可以参考日志级别设置预案\",{\"1\":{\"644\":1}}],[\"比如对象a需要操作数据库\",{\"1\":{\"718\":1}}],[\"比如对象刚刚的一次自旋操作成功过\",{\"1\":{\"91\":1}}],[\"比如对某个\",{\"1\":{\"642\":1}}],[\"比如宕机等\",{\"1\":{\"642\":1}}],[\"比如设置为\",{\"1\":{\"641\":1}}],[\"比如秒杀活动开始前半小时\",{\"1\":{\"640\":1}}],[\"比如同一个相同的服务部署在多台机器上的时候\",{\"1\":{\"609\":1}}],[\"比如多个相同服务之间的本地缓存的数据无法共享\",{\"1\":{\"607\":1}}],[\"比如多个索引的时候该如何选择索引\",{\"1\":{\"490\":1}}],[\"比如按照时间区间或id区间来切分\",{\"1\":{\"588\":1}}],[\"比如上例中\",{\"1\":{\"587\":1}}],[\"比如text类型字段\",{\"1\":{\"585\":1}}],[\"比如sync\",{\"1\":{\"582\":1}}],[\"比如某天下午两点发现中午十二点有一次误删表\",{\"1\":{\"576\":1}}],[\"比如限制连接数等等\",{\"1\":{\"562\":1}}],[\"比如表中已经有a的索引\",{\"1\":{\"533\":1}}],[\"比如from\",{\"1\":{\"533\":1}}],[\"比如a=1\",{\"1\":{\"533\":1}}],[\"比如登录次数\",{\"1\":{\"532\":1}}],[\"比如性别\",{\"1\":{\"532\":1}}],[\"比如原来是\",{\"1\":{\"489\":1}}],[\"比如存储过程\",{\"1\":{\"488\":1}}],[\"比如个性签名等\",{\"1\":{\"477\":1}}],[\"比如返回\",{\"1\":{\"383\":1}}],[\"比如在支付场景\",{\"1\":{\"807\":1}}],[\"比如在事务发生过程中出现了异常\",{\"1\":{\"519\":1}}],[\"比如在\",{\"1\":{\"369\":1}}],[\"比如在某些场景下\",{\"1\":{\"206\":1}}],[\"比如调用\",{\"1\":{\"356\":1}}],[\"比如缓存是放\",{\"1\":{\"641\":1}}],[\"比如缓存\",{\"1\":{\"309\":1}}],[\"比如数据库\",{\"1\":{\"304\":1}}],[\"比如我们要找出现次数最多的前100个\",{\"1\":{\"891\":1}}],[\"比如我们想在每个代理方法之前都加一个处理方法\",{\"1\":{\"723\":1}}],[\"比如我们需要在方法上注入些重复性的非业务代码\",{\"1\":{\"718\":1}}],[\"比如我们需要在类的产生过程中做一些处理\",{\"1\":{\"718\":1}}],[\"比如我们在同一个线程中声明了两个\",{\"1\":{\"299\":1}}],[\"比如我们编写一个称为\",{\"1\":{\"184\":1}}],[\"比如软引用更弱\",{\"1\":{\"235\":1}}],[\"比如网卡\",{\"1\":{\"134\":1}}],[\"比如其他线程调用\",{\"1\":{\"102\":1}}],[\"比如\",{\"1\":{\"26\":4,\"174\":1,\"200\":1,\"348\":1,\"368\":1,\"377\":1,\"427\":2,\"477\":1,\"490\":1,\"537\":1,\"573\":1,\"672\":2,\"713\":1,\"719\":1,\"735\":1,\"736\":1,\"966\":1,\"1001\":1}}],[\"总不能把session在不同的机子上复制来复制去\",{\"1\":{\"1052\":1}}],[\"总\",{\"0\":{\"1019\":1}}],[\"总线网\",{\"1\":{\"977\":1}}],[\"总线锁\",{\"1\":{\"72\":1}}],[\"总共2个rtt的时间\",{\"1\":{\"1042\":1}}],[\"总共通过\",{\"1\":{\"931\":1}}],[\"总共有40多亿个bit\",{\"1\":{\"901\":1}}],[\"总能找到空的散列地址\",{\"1\":{\"924\":1}}],[\"总分多少\",{\"1\":{\"902\":1}}],[\"总是一边学一边用\",{\"1\":{\"1121\":1}}],[\"总是先被\",{\"1\":{\"875\":1}}],[\"总是由\",{\"1\":{\"801\":1}}],[\"总是将新节点添加到链表的表头位置\",{\"1\":{\"623\":1}}],[\"总是假设最好的情况\",{\"1\":{\"103\":1}}],[\"总的来说就是可以提高查询和插入的性能\",{\"1\":{\"466\":1}}],[\"总结起来主要分为五种情况\",{\"1\":{\"501\":1}}],[\"总结\",{\"1\":{\"114\":1,\"198\":1,\"820\":1,\"843\":1}}],[\"总之\",{\"1\":{\"91\":1}}],[\"单开一章是因为其有以下方向迥异的用途\",{\"1\":{\"1108\":1}}],[\"单向的关联用带一个箭头的实线来表示\",{\"1\":{\"1097\":1}}],[\"单向通信\",{\"1\":{\"966\":1}}],[\"单一职责原则\",{\"1\":{\"1064\":1}}],[\"单一的数字签名应用\",{\"1\":{\"1057\":1}}],[\"单一的http\",{\"1\":{\"1042\":1}}],[\"单播帧\",{\"1\":{\"979\":1}}],[\"单台机器的平均健康时间\",{\"1\":{\"879\":1}}],[\"单会话上的消息幂等性\",{\"1\":{\"863\":1}}],[\"单实例可用性可以用\",{\"1\":{\"674\":1}}],[\"单实例只使用\",{\"1\":{\"671\":1}}],[\"单副本\",{\"0\":{\"674\":1}}],[\"单条命令是原子性执行的\",{\"1\":{\"665\":1}}],[\"单条索引上加锁\",{\"1\":{\"503\":1}}],[\"单机的acid被打破\",{\"1\":{\"585\":1}}],[\"单机硬件资源的瓶颈\",{\"1\":{\"585\":1}}],[\"单表大小可控\",{\"1\":{\"587\":1,\"588\":1}}],[\"单表数据量太大\",{\"1\":{\"584\":1}}],[\"单表数据量过大\",{\"1\":{\"560\":1}}],[\"单表的性能依然有不少优化空间\",{\"1\":{\"561\":1}}],[\"单表查询\",{\"1\":{\"556\":1}}],[\"单个子句中不用写order\",{\"1\":{\"485\":1}}],[\"单个线程可以监听多个数据通道\",{\"1\":{\"377\":1}}],[\"单词数92\",{\"1\":{\"439\":1}}],[\"单片机\",{\"1\":{\"354\":1}}],[\"单位是字节\",{\"1\":{\"322\":1}}],[\"单例设计模式\",{\"1\":{\"742\":1}}],[\"单例的类不满足条件一\",{\"1\":{\"1075\":1}}],[\"单例的\",{\"1\":{\"713\":1}}],[\"单例模式常见问题\",{\"0\":{\"1075\":1}}],[\"单例模式注意事项\",{\"0\":{\"1074\":1}}],[\"单例模式的对象长时间不用会被\",{\"1\":{\"1075\":1}}],[\"单例模式的适用场景\",{\"0\":{\"1073\":1}}],[\"单例模式的缺点\",{\"0\":{\"1072\":1}}],[\"单例模式的优点\",{\"0\":{\"1071\":1},\"1\":{\"713\":1}}],[\"单例模式\",{\"0\":{\"713\":1,\"1065\":1},\"1\":{\"304\":1,\"1065\":1}}],[\"单例\",{\"0\":{\"101\":1,\"714\":1}}],[\"单核\",{\"1\":{\"91\":1,\"148\":1}}],[\"单线程反而更快\",{\"1\":{\"838\":1}}],[\"单线程\",{\"1\":{\"254\":1}}],[\"单线程工作的收集器\",{\"1\":{\"254\":1}}],[\"单线程程序是按程序的顺序执行的\",{\"1\":{\"76\":1}}],[\"单线程程序的执行结果不能改变\",{\"1\":{\"76\":1}}],[\"单线程执行内部无论指令是否重排序\",{\"1\":{\"71\":1}}],[\"单线程线程池\",{\"1\":{\"56\":1}}],[\"自签名证书是指不受信任的任意机构或个人\",{\"1\":{\"1045\":1}}],[\"自己测通之后建议同事试用\",{\"1\":{\"692\":1}}],[\"自己已将状态设置为\",{\"1\":{\"72\":1}}],[\"自测等任务设置各自的截止时间\",{\"1\":{\"691\":1}}],[\"自我介绍\",{\"0\":{\"687\":1}}],[\"自身单线程瓶颈\",{\"1\":{\"676\":1}}],[\"自带的\",{\"1\":{\"607\":1,\"609\":1}}],[\"自带的引擎是\",{\"1\":{\"577\":1}}],[\"自适应\",{\"1\":{\"537\":1}}],[\"自适应哈希索引\",{\"1\":{\"496\":1,\"537\":1}}],[\"自增id用完了怎么办\",{\"0\":{\"468\":1}}],[\"自增id与uuid的区别\",{\"0\":{\"467\":1}}],[\"自增id\",{\"0\":{\"465\":1},\"1\":{\"467\":1}}],[\"自增长列必须为一个\",{\"1\":{\"462\":1}}],[\"自然排序\",{\"1\":{\"390\":1}}],[\"自然可以获得很高的单线程收集效率\",{\"1\":{\"254\":1}}],[\"自然受到方法区内存的限制\",{\"1\":{\"208\":1}}],[\"自然也包括常量池\",{\"1\":{\"208\":1}}],[\"自动创建\",{\"1\":{\"1177\":1}}],[\"自动重传请求\",{\"0\":{\"1011\":1}}],[\"自动重传请求协议arq\",{\"1\":{\"962\":1}}],[\"自动化的配置过滤\",{\"1\":{\"779\":1}}],[\"自动配置\",{\"1\":{\"768\":1}}],[\"自动配置spring添加对应功能starter自动化配置\",{\"1\":{\"767\":1}}],[\"自动故障转移\",{\"1\":{\"677\":1}}],[\"自动更新的数据同步到其他数据库上\",{\"1\":{\"655\":1}}],[\"自动触发\",{\"1\":{\"647\":2}}],[\"自动事务提交关掉\",{\"1\":{\"565\":1}}],[\"自动建立唯一索引\",{\"1\":{\"531\":1}}],[\"自动拆箱\",{\"1\":{\"368\":1}}],[\"自动选择各区大小比例\",{\"1\":{\"322\":1}}],[\"自动加载文件里所定义的类\",{\"1\":{\"185\":1}}],[\"自动释放监视器\",{\"1\":{\"94\":1}}],[\"自定义\",{\"1\":{\"1204\":1}}],[\"自定义发送端的分区策略\",{\"1\":{\"865\":2}}],[\"自定义arrays\",{\"1\":{\"390\":1}}],[\"自定义加载器的话\",{\"1\":{\"185\":1}}],[\"自定义类加载器\",{\"0\":{\"180\":1}}],[\"自定义同步器在实现时只需要实现共享资源\",{\"1\":{\"115\":1}}],[\"自旋才能发挥优势\",{\"1\":{\"91\":1}}],[\"自旋就是浪费\",{\"1\":{\"91\":1}}],[\"自旋会占用\",{\"1\":{\"91\":1}}],[\"自旋优化\",{\"0\":{\"91\":1}}],[\"指南\",{\"1\":{\"1139\":1}}],[\"指挥者\",{\"1\":{\"1086\":1}}],[\"指将一个复杂对象的构造与它的表示分离\",{\"1\":{\"1086\":1}}],[\"指在不改变现有对象结构的情况下\",{\"1\":{\"1085\":1}}],[\"指在一个事务内多次读同一数据\",{\"1\":{\"521\":1}}],[\"指攻击者向互联网上的某个服务器不停发送大量分组\",{\"1\":{\"1054\":1}}],[\"指页面暂时性转移\",{\"1\":{\"1040\":1}}],[\"指页面永久性转移\",{\"1\":{\"1040\":1}}],[\"指出了现在允许对方发送的数据量\",{\"1\":{\"1007\":1}}],[\"指示helper中第一个为空的位置\",{\"1\":{\"934\":1}}],[\"指明了本报文段中的紧急数据的字节数\",{\"1\":{\"1007\":1}}],[\"指明partition\",{\"1\":{\"852\":1}}],[\"指明配置项前缀\",{\"1\":{\"773\":1}}],[\"指针来保存节点值\",{\"1\":{\"626\":1}}],[\"指针都指向\",{\"1\":{\"626\":1}}],[\"指针和表尾节点的\",{\"1\":{\"626\":1}}],[\"指针位置\",{\"1\":{\"617\":1}}],[\"指针被查找到\",{\"1\":{\"614\":1}}],[\"指针\",{\"1\":{\"614\":1,\"622\":1}}],[\"指针碰撞\",{\"0\":{\"216\":1},\"1\":{\"215\":1}}],[\"指\",{\"1\":{\"476\":1,\"1027\":1}}],[\"指什么\",{\"0\":{\"476\":1}}],[\"指索引\",{\"1\":{\"462\":1}}],[\"指向右半部分的第一个元素\",{\"1\":{\"934\":1}}],[\"指向左半部分的第一个元素\",{\"1\":{\"934\":1}}],[\"指向的子树所包含的索引值均小于\",{\"1\":{\"919\":1}}],[\"指向的是两个不同的\",{\"1\":{\"427\":1}}],[\"指向新的\",{\"1\":{\"657\":1,\"675\":1}}],[\"指向当前节点的前一个节点\",{\"1\":{\"630\":1}}],[\"指向表尾方向\",{\"1\":{\"630\":1}}],[\"指向跳跃表的表尾节点\",{\"1\":{\"630\":1}}],[\"指向跳跃表的头节点\",{\"1\":{\"630\":1}}],[\"指向news表\",{\"1\":{\"601\":1}}],[\"指向users表\",{\"1\":{\"601\":1}}],[\"指向父评论\",{\"1\":{\"601\":1}}],[\"指向指定commit\",{\"1\":{\"451\":1}}],[\"指向某个tag\",{\"1\":{\"450\":1}}],[\"指向重量级锁地址\",{\"1\":{\"89\":1}}],[\"指编译通过了\",{\"1\":{\"385\":1}}],[\"指编译期间\",{\"1\":{\"385\":1}}],[\"指的是在一个分布式系统中\",{\"1\":{\"870\":1}}],[\"指的是\",{\"1\":{\"380\":1}}],[\"指代消费者能见到的最大的offset\",{\"1\":{\"855\":1}}],[\"指代的是调用真实对象某个方法时接受的参数\",{\"1\":{\"349\":1}}],[\"指代的是我们所要调用真实对象的某个方法的\",{\"1\":{\"349\":1}}],[\"指代我们所代理的那个真实对象\",{\"1\":{\"349\":1}}],[\"指定\",{\"1\":{\"1190\":1}}],[\"指定与连接相关的属性\",{\"1\":{\"1039\":1}}],[\"指定浏览器可以支持的\",{\"1\":{\"1039\":1}}],[\"指定客户端能够接收的内容类型\",{\"1\":{\"1039\":1}}],[\"指定多个\",{\"1\":{\"861\":1}}],[\"指定starter的自动装配类\",{\"1\":{\"773\":1}}],[\"指定的内容\",{\"1\":{\"434\":1}}],[\"指定终端机编号\",{\"1\":{\"426\":1}}],[\"指定其所修饰的注解的保留策略\",{\"1\":{\"338\":1}}],[\"指定一个可行性程序或者脚本的路径\",{\"1\":{\"324\":1}}],[\"指定heap转存文件的存储路径\",{\"1\":{\"324\":1}}],[\"指定直接内存容量\",{\"1\":{\"323\":1}}],[\"指目标是收集整个新生代以及部分老年代的垃圾收集\",{\"1\":{\"240\":1}}],[\"指classloader实例对象\",{\"1\":{\"166\":1}}],[\"指内存分配过程中产生的不可被利用的\",{\"1\":{\"154\":1}}],[\"指已经被分配给某个进程\",{\"1\":{\"154\":1}}],[\"指令终端机下的程序之外\",{\"1\":{\"426\":1}}],[\"指令重排序\",{\"1\":{\"295\":1}}],[\"指令之后会接着执行\",{\"1\":{\"223\":1}}],[\"指令集小\",{\"1\":{\"190\":1}}],[\"指令的执行地址\",{\"1\":{\"144\":1}}],[\"指令的执行顺序并非代码执行顺序\",{\"1\":{\"72\":1}}],[\"指令加载到\",{\"1\":{\"139\":1}}],[\"指令序列\",{\"1\":{\"136\":1}}],[\"指令和\",{\"1\":{\"82\":1}}],[\"指令后\",{\"1\":{\"82\":1}}],[\"指令来释放锁\",{\"1\":{\"82\":1}}],[\"指令时\",{\"1\":{\"82\":1}}],[\"指令\",{\"0\":{\"1182\":1},\"1\":{\"82\":3,\"135\":1,\"142\":1,\"669\":1}}],[\"指令又接收指令需要修改\",{\"1\":{\"72\":1}}],[\"指令级并行的重排序\",{\"1\":{\"71\":1}}],[\"已传送数据的最后一个序号+1\",{\"1\":{\"1026\":1}}],[\"已建立连接\",{\"1\":{\"1022\":1}}],[\"已发送但尚未收到确认的数据\",{\"1\":{\"1015\":1}}],[\"已知某个文件内包含一些电话号码\",{\"1\":{\"883\":1}}],[\"已下线\",{\"1\":{\"683\":1}}],[\"已过期\",{\"1\":{\"664\":1}}],[\"已失效\",{\"1\":{\"220\":1}}],[\"已被使用的内存和空闲的内存相互交错在一起\",{\"1\":{\"217\":1}}],[\"已申请内存之外的内存空间\",{\"1\":{\"154\":1}}],[\"已经看到类似以下的版本号\",{\"1\":{\"1140\":1}}],[\"已经被回收\",{\"1\":{\"1075\":1}}],[\"已经被加载的类会直接返回\",{\"1\":{\"184\":1}}],[\"已经胜出\",{\"1\":{\"820\":1}}],[\"已经有\",{\"0\":{\"805\":1}}],[\"已经集成了\",{\"1\":{\"720\":1}}],[\"已经下线\",{\"1\":{\"677\":1}}],[\"已经废弃\",{\"1\":{\"647\":1}}],[\"已经存在时\",{\"1\":{\"423\":1,\"425\":1}}],[\"已经把原本放在永久代的字符串常量池\",{\"1\":{\"203\":1}}],[\"已经违背了双亲委派模型的一般性原则\",{\"1\":{\"185\":1}}],[\"已经在上层已经帮我们实现好了\",{\"1\":{\"115\":1}}],[\"已经获取到锁的线程\",{\"1\":{\"96\":1}}],[\"已经对该对象加了轻量级锁\",{\"1\":{\"89\":1}}],[\"已把修改后值写到了\",{\"1\":{\"72\":1}}],[\"批量操作限制\",{\"1\":{\"678\":1}}],[\"批量提交后再提交事务\",{\"1\":{\"565\":1}}],[\"批量导入1000万数据\",{\"0\":{\"564\":1}}],[\"批量撤销\",{\"1\":{\"88\":1}}],[\"批量重偏向\",{\"1\":{\"88\":1}}],[\"次握手\",{\"0\":{\"1023\":1}}],[\"次握⼿\",{\"1\":{\"805\":1}}],[\"次方台电脑可以连接到\",{\"1\":{\"996\":1}}],[\"次方\",{\"1\":{\"943\":2}}],[\"次从\",{\"1\":{\"931\":2}}],[\"次排序\",{\"1\":{\"930\":1}}],[\"次最高位为1\",{\"1\":{\"901\":1}}],[\"次最高位为0\",{\"1\":{\"901\":1}}],[\"次修改时\",{\"1\":{\"647\":1}}],[\"次内存分配\",{\"1\":{\"624\":2}}],[\"次必定执行\",{\"1\":{\"624\":1}}],[\"次数呢\",{\"1\":{\"919\":1}}],[\"次数\",{\"1\":{\"560\":1}}],[\"次数和内存读\",{\"1\":{\"193\":1}}],[\"次版本号之后的是常量池入口\",{\"1\":{\"286\":1}}],[\"次tryrelease\",{\"1\":{\"96\":1}}],[\"次\",{\"1\":{\"96\":1,\"539\":1,\"651\":1,\"931\":1}}],[\"次是轻量\",{\"1\":{\"88\":1}}],[\"次后面的是偏向\",{\"1\":{\"88\":1}}],[\"次后\",{\"1\":{\"88\":1}}],[\"于是服务器端认为数据包丢失\",{\"1\":{\"1060\":1}}],[\"于是就发送a请求已经处理好的部分\",{\"1\":{\"1042\":1}}],[\"于是就向客户端发出确认报文段\",{\"1\":{\"1023\":1}}],[\"于是先回应a请求\",{\"1\":{\"1042\":1}}],[\"于是客户端再重传一次连接请求\",{\"1\":{\"1023\":1}}],[\"于是在实际并没有拥塞的情况下采取了拥塞控制\",{\"1\":{\"1021\":1}}],[\"于是不启动慢开始\",{\"1\":{\"1019\":1}}],[\"于是b向a发送了rwnd=400的报文段\",{\"1\":{\"1015\":1}}],[\"于是\",{\"1\":{\"684\":1,\"961\":1,\"993\":1}}],[\"于是便有了\",{\"1\":{\"379\":1}}],[\"于是会在给这些对象加锁时重新偏向至\",{\"1\":{\"88\":1}}],[\"于是对项目\",{\"1\":{\"18\":1}}],[\"我理解为审批单不随属性的变化而变化\",{\"1\":{\"1230\":1}}],[\"我看中这个ip了\",{\"1\":{\"1049\":1}}],[\"我才能发送fin报文\",{\"1\":{\"1024\":1}}],[\"我要重启了\",{\"1\":{\"802\":1}}],[\"我认为比较通用的判断方式是\",{\"1\":{\"731\":1}}],[\"我主动跳出现有技术栈学习\",{\"1\":{\"696\":1}}],[\"我主动承担所有前端开发工作\",{\"1\":{\"690\":1}}],[\"我能够预判后端接口可能存在的问题\",{\"1\":{\"695\":1}}],[\"我提出了用\",{\"1\":{\"694\":1}}],[\"我会先将问题记录清楚\",{\"1\":{\"693\":1}}],[\"我会给阅读文档\",{\"1\":{\"691\":1}}],[\"我一般会将代码质量写好\",{\"1\":{\"692\":1}}],[\"我觉得用事实说话很重要\",{\"1\":{\"692\":1}}],[\"我觉得要分快照读和当前读两种情况来讨论\",{\"1\":{\"523\":1}}],[\"我的方法是一个界限上下文必须支持一个完整的业务流程\",{\"1\":{\"1221\":1}}],[\"我的理解是cglib也可以代理接口\",{\"1\":{\"726\":1}}],[\"我的自我介绍结束了\",{\"1\":{\"687\":1}}],[\"我的专业是新一代电子信息技术\",{\"1\":{\"687\":1}}],[\"我连续两年获得公司年度优秀员工奖\",{\"1\":{\"687\":1}}],[\"我获得了一等学业奖学金\",{\"1\":{\"687\":1}}],[\"我还参与了\",{\"1\":{\"687\":1}}],[\"我是来自北京交通大学电子与信息工程学院的王佳璇\",{\"1\":{\"687\":1}}],[\"我是不是偏向错了呢\",{\"1\":{\"88\":1}}],[\"我已经到达了屏障\",{\"1\":{\"120\":1}}],[\"我们会分析领域内的业务动作和行为\",{\"1\":{\"1234\":1}}],[\"我们构建了领域模型\",{\"1\":{\"1224\":1}}],[\"我们从不同的维度对之发散的产物进行聚类形成聚合\",{\"1\":{\"1217\":1}}],[\"我们每次创建字符串对象时\",{\"1\":{\"1091\":1}}],[\"我们在日常\",{\"1\":{\"1042\":1}}],[\"我们在谈论事务的时候\",{\"1\":{\"518\":1}}],[\"我们把这种队列称之为半连接队列\",{\"1\":{\"1025\":1}}],[\"我们要尽量避免出现\",{\"1\":{\"982\":1}}],[\"我们要尽量减少额外的排序\",{\"1\":{\"560\":1}}],[\"我们应该先读取二维数组的长度和宽度存在两个整数中\",{\"1\":{\"954\":1}}],[\"我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射\",{\"1\":{\"348\":1}}],[\"我们通过归并然后对这5千个数据进行归并拿前5\",{\"1\":{\"904\":1}}],[\"我们通常先在版本库中打一个标签\",{\"1\":{\"450\":1}}],[\"我们不能用一个int去装\",{\"1\":{\"903\":1}}],[\"我们不能太过浪费内存空间\",{\"1\":{\"478\":1}}],[\"我们最终的时间复杂度是\",{\"1\":{\"893\":1}}],[\"我们最熟悉的\",{\"1\":{\"81\":1}}],[\"我们将1000万的数据分布到10台机器上\",{\"1\":{\"891\":1}}],[\"我们比较当前元素与最大堆里的最大元素\",{\"1\":{\"885\":1}}],[\"我们先简化这个问题\",{\"1\":{\"884\":1}}],[\"我们用两个bit\",{\"1\":{\"883\":1}}],[\"我们希望这种情况仅占全部时间的很小一部分\",{\"1\":{\"879\":1}}],[\"我们就可以用\",{\"1\":{\"1061\":1}}],[\"我们就可以采用\",{\"1\":{\"895\":1}}],[\"我们就可以同时保证\",{\"1\":{\"870\":1}}],[\"我们就能得到下面的反向文件索引\",{\"1\":{\"888\":1}}],[\"我们就需要重写\",{\"1\":{\"651\":1}}],[\"我们调用\",{\"1\":{\"804\":1}}],[\"我们怎么告诉远程机器我们要调用\",{\"1\":{\"804\":1}}],[\"我们如何实现远程调用呢\",{\"1\":{\"804\":1}}],[\"我们一般在配置数据库的datasource时使用到的占位符的值\",{\"1\":{\"737\":1}}],[\"我们一般配置多个哨兵\",{\"1\":{\"676\":1}}],[\"我们来看下动态代理是怎么去实现的\",{\"1\":{\"723\":1}}],[\"我们来看看\",{\"1\":{\"349\":1}}],[\"我们上面的例子中只有一个代理方法\",{\"1\":{\"723\":1}}],[\"我们常常在代理类中创建真实对象的实例\",{\"1\":{\"716\":1}}],[\"我们常用泛型机制来统一集合中存储的元素\",{\"1\":{\"345\":1}}],[\"我们挑个响应快的\",{\"1\":{\"677\":1}}],[\"我们优先考虑使用哨兵模式\",{\"1\":{\"676\":1}}],[\"我们优先考虑哨兵模式\",{\"1\":{\"657\":1,\"675\":1}}],[\"我们想要通过\",{\"1\":{\"649\":1}}],[\"我们经常会把一些热点数据放在\",{\"1\":{\"645\":1}}],[\"我们还可以有如下的思路\",{\"1\":{\"642\":1}}],[\"我们仍然把这个空结果进行缓存\",{\"1\":{\"641\":1}}],[\"我们\",{\"1\":{\"632\":1}}],[\"我们也很容易就想到\",{\"1\":{\"630\":1}}],[\"我们称这个内存页为\",{\"1\":{\"592\":1}}],[\"我们现在谈的\",{\"1\":{\"586\":1}}],[\"我们知道tcp的发送方在规定时间内没有收到确认就要重传已经发送的报文段\",{\"1\":{\"1012\":1}}],[\"我们知道\",{\"1\":{\"1006\":1,\"1049\":1}}],[\"我们知道一个电脑可能有多个进程同时在使用网络连接\",{\"1\":{\"999\":1}}],[\"我们知道因为主服务器要负责更新操作\",{\"1\":{\"582\":1}}],[\"我们知道进程的虚拟地址称为线性地址\",{\"1\":{\"156\":1}}],[\"我们看看这两种方式会有什么问题\",{\"1\":{\"578\":1}}],[\"我们对自增长列建立索引\",{\"1\":{\"541\":1}}],[\"我们假设主键\",{\"1\":{\"539\":1}}],[\"我们给多个字段添加主键\",{\"1\":{\"464\":1}}],[\"我们的项目需要连接多个数据库\",{\"1\":{\"742\":1}}],[\"我们的\",{\"1\":{\"559\":1}}],[\"我们的数据都被存放在了各种表中\",{\"1\":{\"456\":1}}],[\"我们的程序在执行的时候往往呈现局部性规律\",{\"1\":{\"158\":1}}],[\"我们创建的变量是可以被任何一个线程访问并修改的\",{\"1\":{\"299\":1}}],[\"我们编写对象的时候\",{\"1\":{\"198\":1}}],[\"我们得以用java实现了jre与底层系统的交互\",{\"1\":{\"197\":1}}],[\"我们需要将聚合划分到更具业务语义的上下文中\",{\"1\":{\"1220\":1}}],[\"我们需要构建业务聚合\",{\"1\":{\"1219\":1}}],[\"我们需要一个治理系统来维护复杂的关系\",{\"1\":{\"809\":1}}],[\"我们需要执行的函数体是在远程的机器上的\",{\"1\":{\"804\":1}}],[\"我们需要从以下几个方面来考虑\",{\"1\":{\"606\":1}}],[\"我们需要保证查询至少达到\",{\"1\":{\"556\":1}}],[\"我们需要解密来还原成内存中的类\",{\"1\":{\"180\":1}}],[\"我们需要设计一些页面置换算法\",{\"1\":{\"160\":1}}],[\"我们已经有了另外一个选择\",{\"1\":{\"142\":1}}],[\"我们运行的程序基本都是运行在用户态\",{\"1\":{\"135\":1}}],[\"我们可以让根节点永久保留在内存中\",{\"1\":{\"919\":1}}],[\"我们可以利用一个堆来维护出现次数最多的前n个数据\",{\"1\":{\"891\":1}}],[\"我们可以为数据建立字典\",{\"1\":{\"891\":1}}],[\"我们可以经过3次这样的划分即可降低到可以接受的程度\",{\"1\":{\"886\":1}}],[\"我们可以将这2^32个数\",{\"1\":{\"886\":1}}],[\"我们可以\",{\"1\":{\"882\":2}}],[\"我们可以开发松耦合应用\",{\"1\":{\"770\":1}}],[\"我们可以指定\",{\"1\":{\"718\":1}}],[\"我们可以使用多个哨兵进行监控\",{\"1\":{\"657\":1}}],[\"我们可以设置\",{\"1\":{\"642\":1}}],[\"我们可以新建一个更合适的索引\",{\"1\":{\"536\":1}}],[\"我们可以对字节码文件进行加密\",{\"1\":{\"180\":1}}],[\"我们可以通过实现\",{\"1\":{\"752\":1}}],[\"我们可以通过计算键的哈希值\",{\"1\":{\"614\":1}}],[\"我们可以通过直接访问这个目录来获取系统信息\",{\"1\":{\"416\":1}}],[\"我们可以通过\",{\"1\":{\"75\":1,\"102\":1}}],[\"我们可以把这些分析后的内容映射成工程分层后的代码了\",{\"1\":{\"1227\":1}}],[\"我们可以把\",{\"1\":{\"47\":1}}],[\"要匹配的字符串\",{\"1\":{\"1188\":1}}],[\"要点\",{\"1\":{\"1077\":1}}],[\"要尽量优先使用组合或者聚合等关联关系来实现\",{\"1\":{\"1064\":1}}],[\"要主动丢弃\",{\"1\":{\"1021\":1}}],[\"要解决这个问题\",{\"1\":{\"1018\":1}}],[\"要解决这个问题的办法\",{\"1\":{\"880\":1}}],[\"要在udp用户数据报之前增加12个字节的伪首部\",{\"1\":{\"1002\":1}}],[\"要提高以太网的信道利用率\",{\"1\":{\"978\":1}}],[\"要排序的数组\",{\"1\":{\"934\":1}}],[\"要统计最热门查询\",{\"1\":{\"893\":1}}],[\"要你按照query的频度排序\",{\"1\":{\"890\":1}}],[\"要将计算公式由hash\",{\"1\":{\"880\":1}}],[\"要将class属性改变一下\",{\"1\":{\"731\":1}}],[\"要把chinese类修改一下\",{\"1\":{\"731\":1}}],[\"要实现代理逻辑类就必须实现java\",{\"1\":{\"725\":1}}],[\"要实现重新偏向是要有条件的\",{\"1\":{\"88\":1}}],[\"要以每秒一次的频率确认\",{\"1\":{\"677\":1}}],[\"要支持随机的插入和删除\",{\"1\":{\"630\":1}}],[\"要进行锁表就会导致主服务器的\",{\"1\":{\"582\":1}}],[\"要建立索引的字段\",{\"1\":{\"527\":1}}],[\"要么给出所要查询的\",{\"1\":{\"1031\":1}}],[\"要么给出ip地址\",{\"1\":{\"1031\":1}}],[\"要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询\",{\"1\":{\"1031\":1}}],[\"要么告诉本地服务器\",{\"1\":{\"1031\":1}}],[\"要么就是先写完\",{\"1\":{\"578\":1}}],[\"要么完全不起作用\",{\"1\":{\"519\":1}}],[\"要么全部不执行\",{\"1\":{\"518\":1}}],[\"要么全部执行成功\",{\"1\":{\"518\":1}}],[\"要阻止其他任何的更新操作\",{\"1\":{\"506\":1}}],[\"要获取一致性视图需要停止对所有表的写入\",{\"1\":{\"491\":1}}],[\"要求界面中的按钮\",{\"1\":{\"1079\":1}}],[\"要求要能根据分数找到该学生的排名\",{\"0\":{\"902\":1}}],[\"要求统计出其中最频繁出现的前10个词\",{\"0\":{\"899\":1}}],[\"要求你按照query的频度排序\",{\"0\":{\"895\":1}}],[\"要求使用的内存不能超过1g\",{\"1\":{\"893\":1}}],[\"要求其他服务器复制这条\",{\"1\":{\"878\":1}}],[\"要求worker进程将所有的socket对应的句柄交给master进程去管理\",{\"1\":{\"837\":1}}],[\"要求的规则去执行\",{\"1\":{\"756\":1}}],[\"要求这个对象实现了methodinterceptor类的intercept方法\",{\"1\":{\"726\":1}}],[\"要求从机进行全量同步\",{\"1\":{\"655\":1}}],[\"要求表中的所有数据都要和主键有完全依赖关系\",{\"1\":{\"464\":1}}],[\"要求访问的磁道与当前磁头所在的磁道距离最近\",{\"1\":{\"163\":1}}],[\"要想解决节点能在哈希环上分配不均匀的问题\",{\"1\":{\"880\":1}}],[\"要想再次获得锁就要再次触发获得锁操作\",{\"1\":{\"668\":1}}],[\"要想修改\",{\"1\":{\"463\":1}}],[\"要想删除\",{\"1\":{\"463\":1}}],[\"要关联一个远程库\",{\"1\":{\"452\":1}}],[\"要注意的是\",{\"1\":{\"430\":1}}],[\"要到\",{\"1\":{\"418\":1}}],[\"要是只取最后\",{\"1\":{\"405\":1}}],[\"要快\",{\"1\":{\"393\":1}}],[\"要快的\",{\"1\":{\"393\":1}}],[\"要慢\",{\"1\":{\"393\":1}}],[\"要移动数据\",{\"1\":{\"393\":1}}],[\"要移动指针\",{\"1\":{\"393\":1}}],[\"要比\",{\"1\":{\"393\":1}}],[\"要优于\",{\"1\":{\"393\":1}}],[\"要有方法重写\",{\"1\":{\"355\":1}}],[\"要恢复的话则使用输入流\",{\"1\":{\"344\":1}}],[\"要真正宣告一个对象死亡\",{\"1\":{\"236\":1}}],[\"要结束该状态进入\",{\"1\":{\"38\":1}}],[\"必为\",{\"1\":{\"948\":1}}],[\"必定会创建新的哈希表\",{\"1\":{\"623\":1}}],[\"必然会调用其它的构造函数\",{\"1\":{\"364\":1}}],[\"必然会被偏向线程id\",{\"1\":{\"88\":1}}],[\"必须能够鉴别发送方和接收方的真实身份\",{\"1\":{\"1055\":1}}],[\"必须能够在同一条物理链路上同时支持多种网络层协议\",{\"1\":{\"975\":1}}],[\"必须将所有数据收集排序整合后给上层使用\",{\"1\":{\"1042\":1}}],[\"必须经过时间等待计时器设置的2msl\",{\"1\":{\"1026\":1}}],[\"必须在建立tcp连接时就约定好\",{\"1\":{\"1013\":1}}],[\"必须通过应用层来实现和控制\",{\"1\":{\"1004\":1}}],[\"必须使通信的两个网络层的实体能够通过协商知道或能够配置彼此的网络层协议\",{\"1\":{\"975\":1}}],[\"必须使用可以在运行时进行数据再平衡的一套系统\",{\"1\":{\"638\":1}}],[\"必须使用固定的\",{\"1\":{\"638\":1}}],[\"必须使用$\",{\"1\":{\"596\":1}}],[\"必须进行两次hash\",{\"1\":{\"884\":1}}],[\"必须迁移改变了映射关系的数据\",{\"1\":{\"880\":1}}],[\"必须附上这个\",{\"1\":{\"804\":1}}],[\"必须是已经注册到\",{\"1\":{\"755\":1}}],[\"必须字段名一样\",{\"1\":{\"751\":1}}],[\"必须指定事务应该如何传播\",{\"1\":{\"740\":1}}],[\"必须释放\",{\"1\":{\"672\":1}}],[\"必须要用一次\",{\"1\":{\"641\":1}}],[\"必须唯一\",{\"1\":{\"620\":1}}],[\"必须都要在从服务器里面执行一遍\",{\"1\":{\"582\":1}}],[\"必须先获得表的\",{\"1\":{\"514\":2}}],[\"必须先删除从表的相关行\",{\"1\":{\"463\":2}}],[\"必须符合搜索条件\",{\"1\":{\"449\":1}}],[\"必须执行\",{\"0\":{\"383\":1}}],[\"必须把变量值同步回主内存\",{\"1\":{\"295\":1}}],[\"必须暂停其他所有工作线程\",{\"1\":{\"254\":1}}],[\"必须相同\",{\"1\":{\"166\":1}}],[\"必须统计每个\",{\"1\":{\"129\":1}}],[\"必须加锁\",{\"1\":{\"129\":1}}],[\"必须首先获得与它对应的\",{\"1\":{\"129\":1}}],[\"必须借助\",{\"1\":{\"105\":1}}],[\"必须显示调用unlock\",{\"1\":{\"94\":1}}],[\"必须清空工作内存中共享变量值\",{\"1\":{\"69\":1}}],[\"必须等待一个\",{\"1\":{\"62\":1}}],[\"成为一个dns客户\",{\"1\":{\"1031\":1}}],[\"成为\",{\"1\":{\"592\":1}}],[\"成功状态码\",{\"1\":{\"1040\":1}}],[\"成功通过\",{\"1\":{\"696\":1}}],[\"成功通过信创认证\",{\"1\":{\"694\":1}}],[\"成功再返回成功\",{\"1\":{\"668\":1}}],[\"成功获取同步状态并退出自旋的条件就是该方法的返回值不小于\",{\"1\":{\"123\":1}}],[\"成功则代表解锁成功\",{\"1\":{\"87\":1}}],[\"成员对象较小的节点会排在前面\",{\"1\":{\"630\":1}}],[\"成员对象\",{\"1\":{\"630\":1}}],[\"成员变量\",{\"1\":{\"735\":2}}],[\"成员变量使用\",{\"1\":{\"409\":1}}],[\"成员变量默认\",{\"1\":{\"362\":1}}],[\"成员变量来表示同步状态\",{\"1\":{\"110\":1}}],[\"成员方法\",{\"1\":{\"83\":1}}],[\"处的\",{\"1\":{\"301\":1}}],[\"处于预提交状态\",{\"1\":{\"578\":1}}],[\"处于\",{\"1\":{\"489\":1}}],[\"处于等待状态的进程并不马上转入执行状态\",{\"1\":{\"148\":1}}],[\"处于阻塞状态的进程\",{\"1\":{\"148\":1}}],[\"处于阻塞态\",{\"1\":{\"85\":1}}],[\"处于用户态的\",{\"1\":{\"134\":1}}],[\"处于内核态的\",{\"1\":{\"134\":2}}],[\"处于唤醒状态\",{\"1\":{\"111\":1}}],[\"处理可能的冲突\",{\"1\":{\"1126\":1}}],[\"处理冲突的方法\",{\"1\":{\"925\":1}}],[\"处理散列冲突的方法\",{\"0\":{\"924\":1}}],[\"处理海量数据问题\",{\"1\":{\"881\":1}}],[\"处理方案\",{\"1\":{\"866\":1}}],[\"处理完数据还没来的及提交\",{\"1\":{\"866\":1}}],[\"处理高并发能力是十分强大的\",{\"1\":{\"824\":1}}],[\"处理所有的写请求并同步给\",{\"1\":{\"820\":1}}],[\"处理异常\",{\"1\":{\"744\":1}}],[\"处理开销更小\",{\"1\":{\"535\":1}}],[\"处理起来更快\",{\"1\":{\"535\":1}}],[\"处理目录的常用命令\",{\"1\":{\"418\":1}}],[\"处理的异常\",{\"1\":{\"384\":1}}],[\"处理\",{\"1\":{\"379\":1,\"589\":1}}],[\"处理类\",{\"1\":{\"349\":1}}],[\"处理以\",{\"1\":{\"162\":1}}],[\"处理器返回一个模型视图\",{\"1\":{\"755\":1}}],[\"处理器\",{\"1\":{\"755\":1,\"756\":1}}],[\"处理器适配器\",{\"1\":{\"755\":1,\"756\":1}}],[\"处理器映射器\",{\"1\":{\"755\":1,\"756\":1}}],[\"处理器通过\",{\"1\":{\"296\":1}}],[\"处理器可以独占任何共享内存\",{\"1\":{\"296\":1}}],[\"处理器可以改变语句对应的机器指令的执行顺序\",{\"1\":{\"71\":1}}],[\"处理器小于4核时\",{\"1\":{\"259\":1}}],[\"处理器核心数量+3\",{\"1\":{\"259\":1}}],[\"处理器分配的时间片\",{\"1\":{\"148\":1}}],[\"处理队列中剩余任务\",{\"1\":{\"63\":1}}],[\"结论\",{\"1\":{\"882\":1}}],[\"结尾的对数据库操作的类\",{\"1\":{\"742\":1}}],[\"结尾的字符串\",{\"1\":{\"624\":1}}],[\"结点最大的孩子数目称为\",{\"1\":{\"919\":1}}],[\"结点包含大中小三个元素和四个孩子\",{\"1\":{\"918\":1}}],[\"结点包含一大一小两个元素和三个孩子\",{\"1\":{\"918\":1}}],[\"结点包含一个元素和两个孩子\",{\"1\":{\"918\":1}}],[\"结点部署架构\",{\"1\":{\"674\":1}}],[\"结点的数量一旦确定不能变化\",{\"1\":{\"638\":1}}],[\"结点的线程等待在\",{\"1\":{\"111\":1}}],[\"结算\",{\"1\":{\"644\":1}}],[\"结束输入或退出shell\",{\"1\":{\"417\":1}}],[\"结束正在运行的程序\",{\"1\":{\"417\":1}}],[\"结束状态\",{\"1\":{\"148\":1}}],[\"结合来实现\",{\"1\":{\"618\":1}}],[\"结合实现赋值操作\",{\"1\":{\"409\":1}}],[\"结合\",{\"1\":{\"141\":1,\"755\":1}}],[\"结构事物\",{\"1\":{\"1093\":1}}],[\"结构化查询语言\",{\"1\":{\"457\":1}}],[\"结构\",{\"0\":{\"84\":1},\"1\":{\"84\":1,\"129\":1,\"630\":1,\"1085\":1,\"1086\":1,\"1087\":1,\"1088\":1,\"1090\":1}}],[\"结果半道被\",{\"1\":{\"1057\":1}}],[\"结果发现处理过程非常耗时\",{\"1\":{\"1042\":1}}],[\"结果归约\",{\"1\":{\"891\":1}}],[\"结果是一样的\",{\"1\":{\"856\":1}}],[\"结果分配\",{\"1\":{\"832\":1}}],[\"结果集执行的内存分页\",{\"1\":{\"753\":1}}],[\"结果\",{\"1\":{\"688\":1}}],[\"结果就是截取了最低的四位值\",{\"1\":{\"405\":1}}],[\"结果一致\",{\"1\":{\"71\":1}}],[\"结果项目\",{\"1\":{\"18\":1}}],[\"括号里的对象\",{\"1\":{\"83\":1}}],[\"俗称\",{\"1\":{\"83\":2}}],[\"标注依赖是否传递\",{\"1\":{\"797\":1}}],[\"标准的ssm框架有四层\",{\"1\":{\"761\":1}}],[\"标准定义的日期和时间表示方法\",{\"1\":{\"475\":1}}],[\"标签也是版本库的一个快照\",{\"1\":{\"450\":1}}],[\"标记为客观下线时\",{\"1\":{\"677\":1}}],[\"标记为主观下线\",{\"1\":{\"677\":1}}],[\"标记gc\",{\"1\":{\"264\":1}}],[\"标记存活的对象\",{\"1\":{\"244\":1}}],[\"标记\",{\"0\":{\"244\":1,\"245\":1,\"246\":1},\"1\":{\"244\":2,\"246\":2,\"261\":1}}],[\"标记的变量会被编译器优化\",{\"1\":{\"79\":1}}],[\"标记的变量不会被编译器优化\",{\"1\":{\"79\":1}}],[\"标量是指一个无法再分解成更小数据的数据\",{\"1\":{\"202\":1}}],[\"标量替换优化技术将会导致一些微妙的变化\",{\"1\":{\"199\":1}}],[\"标志位\",{\"1\":{\"1188\":1}}],[\"标志位设置为\",{\"1\":{\"134\":1}}],[\"标志开始\",{\"1\":{\"623\":1}}],[\"标志\",{\"1\":{\"84\":1}}],[\"标识是一个类似\",{\"1\":{\"1219\":1}}],[\"标识一个方法是重写方法\",{\"1\":{\"338\":1}}],[\"标识\",{\"1\":{\"82\":1}}],[\"取值时如果\",{\"1\":{\"1091\":1}}],[\"取款或转账\",{\"1\":{\"1087\":1}}],[\"取号\",{\"1\":{\"1087\":1}}],[\"取出左子树的根节点\",{\"1\":{\"908\":1}}],[\"取出栈顶节点\",{\"1\":{\"908\":1}}],[\"取出出现频率最大的100个词\",{\"1\":{\"894\":1}}],[\"取出指定行的记录\",{\"1\":{\"487\":1}}],[\"取hash\",{\"1\":{\"894\":1}}],[\"取得处理权\",{\"1\":{\"830\":1}}],[\"取得代之的确实是\",{\"1\":{\"82\":1}}],[\"取结果\",{\"1\":{\"753\":1}}],[\"取模\",{\"1\":{\"681\":1}}],[\"取模来决定放置哪个槽\",{\"1\":{\"679\":1}}],[\"取模分段\",{\"1\":{\"144\":1}}],[\"取交集\",{\"1\":{\"603\":1}}],[\"取最小集返回给应用\",{\"1\":{\"587\":1}}],[\"取合适的分段大小\",{\"1\":{\"587\":1}}],[\"取决于系统的重要性\",{\"1\":{\"576\":1}}],[\"取前\",{\"1\":{\"484\":1}}],[\"取下一个记录的主键\",{\"1\":{\"484\":2}}],[\"取\",{\"1\":{\"473\":1,\"484\":2}}],[\"取回远程仓库的变化\",{\"1\":{\"452\":1}}],[\"取某个标签的版本\",{\"1\":{\"450\":1}}],[\"取到的变量值放入主内存变量中\",{\"1\":{\"74\":1}}],[\"表格等文件\",{\"1\":{\"1108\":1}}],[\"表现层controller层和view层\",{\"1\":{\"761\":1}}],[\"表现层\",{\"0\":{\"764\":1},\"1\":{\"754\":1}}],[\"表和类的一一对应关系\",{\"1\":{\"751\":1}}],[\"表头节点的\",{\"1\":{\"626\":1}}],[\"表的第一维数组空间占用\",{\"1\":{\"623\":1}}],[\"表的记录有唯一区分的字段\",{\"1\":{\"464\":1}}],[\"表进行缩容来减少\",{\"1\":{\"623\":1}}],[\"表因为元素逐渐被删除变得越来越稀疏时\",{\"1\":{\"623\":1}}],[\"表非常满了\",{\"1\":{\"623\":1}}],[\"表根据\",{\"1\":{\"587\":1}}],[\"表在磁盘上的存储结构就变成了树状结构\",{\"1\":{\"548\":1}}],[\"表数据存储顺序与索引顺序无关\",{\"1\":{\"546\":1}}],[\"表锁\",{\"0\":{\"510\":1},\"1\":{\"508\":1}}],[\"表空间是由各个段组成的\",{\"1\":{\"498\":1}}],[\"表空间由段\",{\"1\":{\"498\":1}}],[\"表级锁\",{\"0\":{\"511\":1},\"1\":{\"493\":1}}],[\"表结构文件\",{\"1\":{\"493\":1}}],[\"表结构还在\",{\"1\":{\"483\":2}}],[\"表列名为准\",{\"1\":{\"485\":1}}],[\"表来说\",{\"1\":{\"484\":1}}],[\"表达式\",{\"0\":{\"1251\":1}}],[\"表达式就搞定了\",{\"1\":{\"1089\":1}}],[\"表达式中\",{\"1\":{\"482\":1}}],[\"表达程序间的相互关系\",{\"1\":{\"426\":1}}],[\"表没有指定主键\",{\"1\":{\"468\":1}}],[\"表定义的自增值达到上限后的逻辑是\",{\"1\":{\"468\":1}}],[\"表定义自增值\",{\"1\":{\"468\":1}}],[\"表名为字符串\",{\"1\":{\"596\":1}}],[\"表名作为变量时\",{\"1\":{\"596\":1}}],[\"表名\",{\"1\":{\"459\":1,\"462\":1,\"527\":2,\"702\":1}}],[\"表项\",{\"1\":{\"392\":1}}],[\"表中建立一个唯一索引\",{\"1\":{\"807\":1}}],[\"表中通过\",{\"1\":{\"601\":1}}],[\"表中只有一个\",{\"1\":{\"548\":1}}],[\"表中的数据量也会越来越大\",{\"1\":{\"583\":1}}],[\"表中的数据是直接存储在主键聚簇索引的叶子节点中\",{\"1\":{\"466\":1}}],[\"表中的每一行就存放着一条数据\",{\"1\":{\"456\":1}}],[\"表中\",{\"1\":{\"341\":1,\"623\":1}}],[\"表\",{\"1\":{\"284\":2}}],[\"表明到这个分组为止的所有分组都已经正确收到了\",{\"1\":{\"1011\":1}}],[\"表明了\",{\"1\":{\"391\":1}}],[\"表明\",{\"1\":{\"391\":1}}],[\"表明这个类不能被继承\",{\"1\":{\"355\":1}}],[\"表明有竞争\",{\"1\":{\"87\":1}}],[\"表明锁被释放\",{\"1\":{\"82\":1}}],[\"表示一般与特殊的关系\",{\"1\":{\"1100\":1}}],[\"表示连接\",{\"1\":{\"1042\":1}}],[\"表示资源或页面暂时转移到另一个位置\",{\"1\":{\"1040\":1}}],[\"表示资源或页面永久性地转移到了另一个位置\",{\"1\":{\"1040\":1}}],[\"表示接受到service的消息\",{\"1\":{\"1026\":1}}],[\"表示收到了client的关闭连接请求\",{\"1\":{\"1026\":1}}],[\"表示想要关闭连接\",{\"1\":{\"1026\":1}}],[\"表示我已经收到了数据\",{\"1\":{\"1004\":1}}],[\"表示层\",{\"1\":{\"961\":1}}],[\"表示继续执行\",{\"1\":{\"759\":1}}],[\"表示列表结束\",{\"1\":{\"627\":1}}],[\"表示每次提交事务都write\",{\"1\":{\"571\":1}}],[\"表示每次提交事务都会执行fsync\",{\"1\":{\"571\":1}}],[\"表示每次提交事务都只write\",{\"1\":{\"571\":1}}],[\"表示每次事务提交时都将\",{\"1\":{\"568\":1}}],[\"表示每次事务提交时都只是把\",{\"1\":{\"568\":2}}],[\"表示每分钟能转7200次\",{\"1\":{\"543\":1}}],[\"表示开启这个逻辑\",{\"1\":{\"516\":1}}],[\"表示当前请求结束\",{\"1\":{\"759\":1}}],[\"表示当前的操作对整张表加锁\",{\"1\":{\"510\":1}}],[\"表示当前线程加轻量级锁成功\",{\"1\":{\"87\":1}}],[\"表示只针对当前操作的行进行加锁\",{\"1\":{\"509\":1}}],[\"表示检索从某一个偏移量到记录集的结束所有的记录行\",{\"1\":{\"486\":1}}],[\"表示总共\",{\"1\":{\"473\":1}}],[\"表示这三者皆是\",{\"1\":{\"433\":1}}],[\"表示这个方法会抛出某种类型的异常\",{\"1\":{\"386\":1}}],[\"表示程序间的相互关系\",{\"1\":{\"426\":1}}],[\"表示去到目前的上一级目录\",{\"1\":{\"420\":1}}],[\"表示回到自己的家目录\",{\"1\":{\"420\":1}}],[\"表示将异常抛出给调用者\",{\"1\":{\"386\":1}}],[\"表示的是当我这个动态代理对象在调用方法的时候\",{\"1\":{\"349\":1}}],[\"表示的是我将要给我需要代理的对象提供一组什么接口\",{\"1\":{\"349\":1}}],[\"表示在程序中明确定义的点\",{\"1\":{\"721\":1}}],[\"表示在出现fullgc之前\",{\"1\":{\"324\":1}}],[\"表示在内存出现oom的时候\",{\"1\":{\"324\":1}}],[\"表示minorgc结束后survivor区域中占用空间的期望比例\",{\"1\":{\"322\":1}}],[\"表示打印出所有xx选项的默认值\",{\"1\":{\"319\":1}}],[\"表示索引表的容量\",{\"1\":{\"288\":1}}],[\"表示能获取同步状态\",{\"1\":{\"123\":1}}],[\"表示多个线程获取同一个锁有可能成功\",{\"1\":{\"115\":1}}],[\"表示锁只会被一个线程占用\",{\"1\":{\"115\":1}}],[\"表示阻塞队列\",{\"1\":{\"108\":1}}],[\"表示释放成功\",{\"1\":{\"96\":1}}],[\"表示有线程比当前线程更早请求锁\",{\"1\":{\"96\":1}}],[\"表示有锁重入\",{\"1\":{\"87\":1}}],[\"表示\",{\"1\":{\"26\":1,\"647\":1,\"984\":1,\"1035\":2}}],[\"退出\",{\"1\":{\"89\":1,\"459\":1}}],[\"退出时执行\",{\"1\":{\"82\":1}}],[\"退出方法\",{\"1\":{\"38\":2}}],[\"适配者\",{\"1\":{\"1092\":1}}],[\"适配器\",{\"1\":{\"1092\":1}}],[\"适配器有过滤地址\",{\"1\":{\"979\":1}}],[\"适配器模式中包含的角色及其职责\",{\"1\":{\"1092\":1}}],[\"适配器模式分为\",{\"1\":{\"1092\":1}}],[\"适配器模式\",{\"0\":{\"1092\":1},\"1\":{\"742\":1}}],[\"适用范围\",{\"1\":{\"882\":1,\"883\":1,\"884\":1,\"885\":1,\"886\":1,\"887\":1,\"888\":1,\"889\":1,\"890\":1,\"891\":1}}],[\"适用场景\",{\"1\":{\"477\":1}}],[\"适用于实际系统的共识算法通常具有以下特性\",{\"1\":{\"873\":1}}],[\"适用于实时操作系统\",{\"1\":{\"150\":1}}],[\"适用于服务器硬件都相同的场景\",{\"1\":{\"869\":1}}],[\"适用于数据可靠性不高的纯缓存业务场景\",{\"1\":{\"674\":1}}],[\"适用于不知道最大长度的字段\",{\"1\":{\"477\":1}}],[\"适用于执行时间较长或对峰值性能有要求的程序\",{\"1\":{\"283\":1}}],[\"适用于执行时间较短或对启动性能有要求的程序\",{\"1\":{\"283\":1}}],[\"适用于多进程间的通信\",{\"1\":{\"149\":1}}],[\"适用于两个进程间的通信\",{\"1\":{\"149\":1}}],[\"适用于传递性场景\",{\"1\":{\"62\":1}}],[\"适用于缓存和定时调度\",{\"1\":{\"62\":1}}],[\"适用于延时执行或者周期性任务\",{\"1\":{\"56\":1}}],[\"适用于需要保证顺序执行各个任务\",{\"1\":{\"56\":1}}],[\"适用于任务量已知\",{\"1\":{\"56\":1}}],[\"适当增加内存\",{\"1\":{\"309\":1}}],[\"适合2核2g服务器\",{\"1\":{\"1177\":1}}],[\"适合于监听懒加载的\",{\"1\":{\"1157\":1}}],[\"适合于长作业\",{\"1\":{\"150\":1}}],[\"适合关键字长度不等的情况\",{\"1\":{\"923\":1}}],[\"适合关键字位数很多的情况\",{\"1\":{\"923\":1}}],[\"适合不知道关键字的分布\",{\"1\":{\"923\":1}}],[\"适合大数据量\",{\"1\":{\"885\":1}}],[\"适合用来做外部浏览器接口调用\",{\"1\":{\"806\":1}}],[\"适合用来做内部进程间的调用\",{\"1\":{\"806\":1}}],[\"适合用于存储对象\",{\"1\":{\"622\":1}}],[\"适合高并发操作\",{\"1\":{\"493\":1}}],[\"适合频繁的io操作\",{\"1\":{\"210\":1}}],[\"适应性自旋锁\",{\"1\":{\"82\":1}}],[\"抢锁\",{\"1\":{\"114\":1}}],[\"抢不到再去排队\",{\"1\":{\"81\":1}}],[\"抢一下\",{\"1\":{\"81\":1}}],[\"抢占式\",{\"1\":{\"150\":2}}],[\"抢占式的\",{\"1\":{\"117\":1}}],[\"抢占\",{\"1\":{\"35\":1,\"830\":1}}],[\"非对称加密\",{\"0\":{\"1056\":1},\"1\":{\"1044\":1}}],[\"非对称数字用户线adsl技术对现有的模拟电话用户线进行改造\",{\"1\":{\"968\":1}}],[\"非流水线\",{\"1\":{\"1042\":1}}],[\"非根非叶\",{\"1\":{\"919\":1}}],[\"非递归实现前\",{\"0\":{\"908\":1}}],[\"非全新集群选举时是优中选优\",{\"1\":{\"820\":1}}],[\"非系统级\",{\"1\":{\"759\":1}}],[\"非二进制安全\",{\"1\":{\"624\":1}}],[\"非索引字段条件查询等\",{\"1\":{\"584\":1}}],[\"非唯一辅助索引的插入操作\",{\"1\":{\"574\":1}}],[\"非唯一性索引查询出一条或多条记录\",{\"1\":{\"556\":1}}],[\"非聚簇索引的叶子节点上会存放键的值\",{\"1\":{\"550\":1}}],[\"非聚簇索引都是辅助索引\",{\"1\":{\"548\":1}}],[\"非聚簇索引就是指b+tree的叶子节点上的data\",{\"1\":{\"547\":1}}],[\"非聚簇索引\",{\"1\":{\"546\":1,\"547\":1}}],[\"非主键字段必须直接依赖于主键字段\",{\"1\":{\"455\":1}}],[\"非主键字段要完全依赖主键字段\",{\"1\":{\"455\":1}}],[\"非受检异常\",{\"1\":{\"385\":1}}],[\"非阻塞并发读\",{\"1\":{\"499\":1}}],[\"非阻塞\",{\"1\":{\"380\":1,\"610\":1}}],[\"非阻塞同步\",{\"1\":{\"48\":1,\"142\":1}}],[\"非直接缓冲区\",{\"1\":{\"378\":1}}],[\"非数值型\",{\"1\":{\"316\":1}}],[\"非标准化参数\",{\"1\":{\"315\":1,\"316\":1}}],[\"非堆\",{\"1\":{\"203\":1}}],[\"非虚方法\",{\"1\":{\"194\":2,\"275\":1}}],[\"非常适合对关系数据模型要求不高的软件开发\",{\"1\":{\"749\":1}}],[\"非常适合备份\",{\"1\":{\"648\":1}}],[\"非常适合用于作为数据共享的通道\",{\"1\":{\"108\":1}}],[\"非常方便我们使用\",{\"1\":{\"607\":1}}],[\"非常合适\",{\"1\":{\"477\":1}}],[\"非常耗时\",{\"1\":{\"406\":1}}],[\"非常庞大的\",{\"1\":{\"149\":1}}],[\"非常类似\",{\"1\":{\"120\":1}}],[\"非公平模式\",{\"1\":{\"117\":1}}],[\"非公平锁让获取锁的时间变得更加不确定\",{\"1\":{\"114\":1}}],[\"非公平锁会有更好的性能\",{\"1\":{\"114\":1}}],[\"非公平锁会直接\",{\"1\":{\"114\":1}}],[\"非公平锁在\",{\"1\":{\"114\":1}}],[\"非公平锁在调用\",{\"1\":{\"114\":1}}],[\"非公平锁\",{\"1\":{\"94\":2,\"113\":1}}],[\"非公平锁的概念是如果当前一个线程已经获取到锁了\",{\"1\":{\"81\":1}}],[\"非抢占式都有\",{\"1\":{\"150\":1}}],[\"非抢占式\",{\"1\":{\"150\":1}}],[\"非抢占式算法\",{\"1\":{\"150\":1}}],[\"非抢占\",{\"1\":{\"98\":1}}],[\"重用现有的同类对象\",{\"1\":{\"1091\":1}}],[\"重在\",{\"0\":{\"886\":1}}],[\"重试其它服务器\",{\"1\":{\"813\":1}}],[\"重定向状态码\",{\"1\":{\"1040\":1}}],[\"重定向\",{\"1\":{\"754\":1,\"758\":1,\"993\":1,\"1040\":1}}],[\"重跑一下日志文件相当于还原了数据\",{\"1\":{\"649\":1}}],[\"重建缓存不能在短时间完成\",{\"1\":{\"643\":1}}],[\"重建整个库\",{\"1\":{\"525\":1}}],[\"重启之后\",{\"1\":{\"837\":1}}],[\"重启或者超时消失\",{\"1\":{\"823\":1}}],[\"重启的时候\",{\"1\":{\"656\":1}}],[\"重启的时候可以再次加载进行使用\",{\"1\":{\"610\":1}}],[\"重启时会通过重新执行文件中保存的写命令来重建整个数据库的内容\",{\"1\":{\"649\":1}}],[\"重启后自动从磁盘上加载数据\",{\"1\":{\"642\":1}}],[\"重启mysql回到原来设置\",{\"1\":{\"557\":1}}],[\"重放到中午误删表之前的那个时刻\",{\"1\":{\"576\":1}}],[\"重点做跨域的编排工作\",{\"1\":{\"1238\":1}}],[\"重点加gap锁\",{\"1\":{\"501\":1}}],[\"重点是确认内存中的对象是否是必要的\",{\"1\":{\"298\":1}}],[\"重点是多个线程\",{\"1\":{\"121\":1}}],[\"重点是\",{\"1\":{\"121\":1}}],[\"重复\",{\"1\":{\"890\":1}}],[\"重复多\",{\"1\":{\"890\":1}}],[\"重复消费\",{\"1\":{\"866\":1}}],[\"重复消费问题\",{\"1\":{\"841\":1}}],[\"重复数据\",{\"0\":{\"856\":1}}],[\"重复进行\",{\"1\":{\"501\":1}}],[\"重复步骤\",{\"1\":{\"484\":2}}],[\"重复前一个搜寻\",{\"1\":{\"429\":1}}],[\"重新安装插件\",{\"1\":{\"1136\":1}}],[\"重新对数据和节点做映射\",{\"1\":{\"880\":1}}],[\"重新计算摘要作对比\",{\"1\":{\"1057\":1}}],[\"重新计算索引\",{\"1\":{\"623\":1}}],[\"重新计时\",{\"1\":{\"877\":1}}],[\"重新选举生成的leader并没有这个偏移量导致消息重复\",{\"1\":{\"866\":1}}],[\"重新消费这一批数据\",{\"1\":{\"866\":1}}],[\"重新进行选举\",{\"1\":{\"820\":1}}],[\"重新打包你的\",{\"1\":{\"774\":1}}],[\"重新分片可以将已经分配给某个节点的任意数量的\",{\"1\":{\"682\":1}}],[\"重新向\",{\"1\":{\"677\":1}}],[\"重新更新到slave\",{\"1\":{\"469\":1,\"580\":1}}],[\"重新标记\",{\"1\":{\"259\":1}}],[\"重置当前head为指定commit\",{\"1\":{\"453\":1}}],[\"重置当前分支的head为指定commit\",{\"1\":{\"453\":1}}],[\"重置当前分支的指针为指定commit\",{\"1\":{\"453\":1}}],[\"重置暂存区与工作区\",{\"1\":{\"453\":1}}],[\"重置暂存区的指定文件\",{\"1\":{\"453\":1}}],[\"重做上一次commit\",{\"1\":{\"448\":1}}],[\"重要的配置文件有\",{\"1\":{\"416\":1}}],[\"重载对返回类型没有特殊的要求\",{\"1\":{\"359\":1}}],[\"重载对返回类型没有要求\",{\"1\":{\"359\":1}}],[\"重载发生在一个类中\",{\"1\":{\"359\":1}}],[\"重载的时候\",{\"1\":{\"359\":1}}],[\"重载要求同名方法的参数列表不同\",{\"1\":{\"359\":1}}],[\"重载是一个类中多态性的一种表现\",{\"1\":{\"359\":1}}],[\"重载\",{\"1\":{\"359\":1}}],[\"重载一个方法\",{\"1\":{\"290\":1}}],[\"重排序过程不会影响到单线程程序的执行\",{\"1\":{\"295\":1}}],[\"重量级\",{\"1\":{\"85\":1}}],[\"重量级锁一步步转换\",{\"1\":{\"131\":1}}],[\"重量级锁竞争的时候\",{\"1\":{\"91\":1}}],[\"重量级锁\",{\"1\":{\"84\":1,\"86\":2}}],[\"重量级锁的概念是如果锁已经被持有了\",{\"1\":{\"81\":1}}],[\"重入锁与非重入锁\",{\"1\":{\"81\":1}}],[\"重写时机\",{\"1\":{\"708\":1}}],[\"重写期间的\",{\"1\":{\"708\":1}}],[\"重写后\",{\"1\":{\"651\":1}}],[\"重写是通过\",{\"1\":{\"651\":1}}],[\"重写机制\",{\"0\":{\"651\":1}}],[\"重写要求子类被重写方法与父类被重写方法有相同的参数列表\",{\"1\":{\"359\":1}}],[\"重写发生在子类与父类之间\",{\"1\":{\"359\":1}}],[\"重写与重载的区别\",{\"0\":{\"359\":1}}],[\"重写了\",{\"1\":{\"350\":1}}],[\"重写一个类加载器的\",{\"1\":{\"168\":1}}],[\"重写\",{\"1\":{\"31\":1,\"185\":1,\"342\":1,\"343\":1,\"359\":1}}],[\"相当灵活\",{\"1\":{\"746\":1}}],[\"相当于经过了m2\",{\"1\":{\"986\":1}}],[\"相当于简单选择排序的升级\",{\"1\":{\"937\":1}}],[\"相当于冒泡排序的升级\",{\"1\":{\"935\":1}}],[\"相当于mvc中的c\",{\"1\":{\"756\":1}}],[\"相当于字符串\",{\"1\":{\"624\":1}}],[\"相当于\",{\"1\":{\"423\":1}}],[\"相当于是\",{\"1\":{\"380\":2}}],[\"相当于一个模型分发器\",{\"1\":{\"754\":1}}],[\"相当于一个专门用于\",{\"1\":{\"379\":1}}],[\"相当于一个int\",{\"1\":{\"367\":1}}],[\"相当于两个\",{\"1\":{\"368\":1}}],[\"相当于没有加锁\",{\"1\":{\"104\":1}}],[\"相应地数据操作\",{\"1\":{\"583\":1}}],[\"相应栈中只需要记录堆中的一个地址即可\",{\"1\":{\"198\":1}}],[\"相较于单副本而言最大的特点就是主从实例间数据实时同步\",{\"1\":{\"675\":1}}],[\"相较于把对象的每个字段存成单个\",{\"1\":{\"622\":1}}],[\"相较于b树b+每个非叶子节点存储的关键字数更多\",{\"1\":{\"541\":1}}],[\"相较于cms\",{\"1\":{\"262\":1}}],[\"相互间的关系\",{\"1\":{\"310\":1}}],[\"相比较于http\",{\"1\":{\"1042\":1}}],[\"相比xml\",{\"1\":{\"1035\":1}}],[\"相比html\",{\"1\":{\"1035\":1}}],[\"相比之下\",{\"1\":{\"1019\":1}}],[\"相比栈\",{\"1\":{\"941\":1}}],[\"相比阻塞式的bio\",{\"1\":{\"829\":1}}],[\"相比不需要进行旋转等操作来维护平衡性\",{\"1\":{\"630\":1}}],[\"相比于静态代理\",{\"1\":{\"723\":1}}],[\"相比于\",{\"1\":{\"607\":3,\"720\":1,\"785\":1,\"1044\":1}}],[\"相比于聚簇索引\",{\"1\":{\"549\":1}}],[\"相比前两个可忽略不计\",{\"1\":{\"543\":1}}],[\"相比\",{\"1\":{\"380\":1,\"746\":1,\"805\":1}}],[\"相比cms\",{\"1\":{\"261\":1}}],[\"相比起增量更新算法\",{\"1\":{\"251\":1}}],[\"相同为\",{\"1\":{\"943\":1}}],[\"相同参数请求总是发到同一提供者\",{\"1\":{\"812\":1}}],[\"相同的数据库副本\",{\"1\":{\"661\":1}}],[\"相同的类文件被不同的类加载器加载产生的是两个不同的类\",{\"1\":{\"184\":1}}],[\"相同点\",{\"1\":{\"408\":1,\"411\":1}}],[\"相同\",{\"0\":{\"341\":1},\"1\":{\"341\":1}}],[\"相同才将新的值更新\",{\"1\":{\"81\":1}}],[\"相等不一定就满足\",{\"1\":{\"350\":1}}],[\"相等即两个键值对的哈希值相等\",{\"1\":{\"341\":1}}],[\"相等\",{\"1\":{\"166\":1}}],[\"相等就把\",{\"1\":{\"105\":1}}],[\"相似\",{\"1\":{\"136\":1}}],[\"相对路径或绝对路径\",{\"1\":{\"420\":1}}],[\"相对路径\",{\"1\":{\"418\":1}}],[\"相对cms的缺点\",{\"0\":{\"262\":1}}],[\"相对于悲观锁\",{\"1\":{\"513\":1}}],[\"相对于\",{\"1\":{\"261\":1}}],[\"相对偏移量或者是一个能间接定位到目标的句柄\",{\"1\":{\"172\":1}}],[\"相对来说更简单\",{\"1\":{\"720\":1}}],[\"相对来说\",{\"1\":{\"114\":1}}],[\"相对耗时的任务\",{\"1\":{\"56\":1}}],[\"相关注解\",{\"0\":{\"743\":1}}],[\"相关配置\",{\"1\":{\"647\":1}}],[\"相关垃圾回收器参数\",{\"1\":{\"253\":1}}],[\"相关\",{\"1\":{\"111\":1}}],[\"包进行监视\",{\"1\":{\"1060\":1}}],[\"包超过半连接队列的最大值时\",{\"1\":{\"1060\":1}}],[\"包会长期占用半连接队列\",{\"1\":{\"1060\":1}}],[\"包即可进行校验和纠错\",{\"1\":{\"1042\":1}}],[\"包发送出去\",{\"1\":{\"1042\":1}}],[\"包\",{\"1\":{\"1026\":1,\"1060\":1}}],[\"包对方没收到\",{\"1\":{\"1026\":1}}],[\"包3还没有收到\",{\"1\":{\"1019\":1}}],[\"包后可以再发一个\",{\"1\":{\"1026\":1}}],[\"包后\",{\"1\":{\"1004\":1,\"1060\":1}}],[\"包来说\",{\"1\":{\"982\":1}}],[\"包丢失\",{\"1\":{\"873\":1}}],[\"包里就是我们的代码\",{\"1\":{\"790\":1}}],[\"包使其可执行\",{\"1\":{\"774\":1}}],[\"包使用\",{\"1\":{\"144\":1}}],[\"包或者是\",{\"1\":{\"774\":1}}],[\"包装器设计模式\",{\"1\":{\"742\":1}}],[\"包装类是在堆中分配\",{\"1\":{\"368\":1}}],[\"包装类的缓存\",{\"0\":{\"368\":1},\"1\":{\"368\":1}}],[\"包定义的\",{\"1\":{\"379\":1}}],[\"包外子类\",{\"1\":{\"357\":1}}],[\"包内\",{\"1\":{\"357\":1}}],[\"包含页首\",{\"1\":{\"1208\":1}}],[\"包含以下几种类型\",{\"1\":{\"1087\":1}}],[\"包含创建产品各个子部件的抽象方法的接口\",{\"1\":{\"1086\":1}}],[\"包含<index\",{\"1\":{\"878\":1}}],[\"包含各种表单\",{\"1\":{\"754\":1}}],[\"包含并管理应用中对象的生命周期和配置\",{\"1\":{\"717\":1}}],[\"包含了复杂的业务逻辑和数据逻辑\",{\"1\":{\"748\":1}}],[\"包含了各种bean的定义\",{\"1\":{\"712\":1}}],[\"包含了与类有关的信息\",{\"1\":{\"348\":1}}],[\"包含记录本身\",{\"1\":{\"505\":1}}],[\"包含上一级目录\",{\"1\":{\"422\":1}}],[\"包含文件的属性与权限等等数据\",{\"1\":{\"419\":1}}],[\"包含哪些方法\",{\"0\":{\"350\":1}}],[\"包含使用的垃圾回收器\",{\"1\":{\"253\":1}}],[\"包含\",{\"1\":{\"174\":1,\"335\":1,\"356\":1,\"1115\":1}}],[\"包的方法对类进行反射调用时\",{\"1\":{\"174\":1}}],[\"包括用于判断的逻辑方法和需要子类重写的空方法两种\",{\"1\":{\"1087\":1}}],[\"包括证书认证\",{\"1\":{\"1062\":1}}],[\"包括计算机病毒\",{\"1\":{\"1054\":1}}],[\"包括彻底中断发送的报文\",{\"1\":{\"1054\":1}}],[\"包括请求方法\",{\"1\":{\"1038\":1}}],[\"包括时间戳值\",{\"1\":{\"1007\":1}}],[\"包括网络延迟\",{\"1\":{\"873\":1}}],[\"包括消息幂等性\",{\"1\":{\"841\":1}}],[\"包括主服务器和从服务器\",{\"1\":{\"657\":1}}],[\"包括主键索引\",{\"1\":{\"506\":1}}],[\"包括的变量分别是真正的数据\",{\"1\":{\"622\":1}}],[\"包括结构本身以及操作的时间空间复杂度\",{\"1\":{\"604\":1}}],[\"包括两种协议\",{\"1\":{\"961\":1}}],[\"包括两部分\",{\"1\":{\"568\":1}}],[\"包括两类信息\",{\"1\":{\"225\":1}}],[\"包括myisam\",{\"1\":{\"528\":1}}],[\"包括是否使用索引\",{\"1\":{\"501\":1}}],[\"包括压缩表\",{\"1\":{\"492\":1}}],[\"包括从磁盘读取数据时采用的可预测性读\",{\"1\":{\"491\":1}}],[\"包括校验账户密码\",{\"1\":{\"490\":1}}],[\"包括数据库\",{\"1\":{\"457\":1}}],[\"包括文件改名\",{\"1\":{\"449\":1}}],[\"包括文本字符串\",{\"1\":{\"286\":1}}],[\"包括子目录\",{\"1\":{\"447\":1}}],[\"包括已中断的子程序资料\",{\"1\":{\"426\":1}}],[\"包括其他用户的程序\",{\"1\":{\"426\":1}}],[\"包括私有属性和私有方法\",{\"1\":{\"355\":1}}],[\"包括类\",{\"1\":{\"292\":1}}],[\"包括类信息\",{\"1\":{\"203\":1}}],[\"包括\",{\"1\":{\"287\":1,\"616\":1,\"755\":1,\"979\":1,\"1041\":1}}],[\"包括cpu\",{\"1\":{\"186\":1}}],[\"包括代表类的class对象的equals\",{\"1\":{\"166\":1}}],[\"包括包名\",{\"1\":{\"166\":1}}],[\"包括程序计数器和其他寄存器\",{\"1\":{\"147\":1}}],[\"包括外围设备\",{\"1\":{\"134\":1}}],[\"包括实例字段\",{\"1\":{\"74\":1}}],[\"包中\",{\"1\":{\"108\":1}}],[\"包提供了一个\",{\"1\":{\"106\":1}}],[\"包下面的原子变量类就是使用了乐观锁的一种实现方式\",{\"1\":{\"103\":1}}],[\"包下基于\",{\"1\":{\"81\":1}}],[\"依靠\",{\"1\":{\"660\":1}}],[\"依靠单库的自增id会受到影响\",{\"1\":{\"585\":1}}],[\"依然可以提供服务\",{\"1\":{\"642\":1}}],[\"依然存在单表数据量过大的问题\",{\"1\":{\"585\":1}}],[\"依旧可以\",{\"1\":{\"392\":1}}],[\"依次往右递增\",{\"1\":{\"935\":1}}],[\"依次往左递减\",{\"1\":{\"935\":1}}],[\"依次比较相邻元素的值\",{\"1\":{\"930\":1}}],[\"依次对用hash\",{\"1\":{\"895\":1}}],[\"依次取出来\",{\"1\":{\"576\":1}}],[\"依次执行\",{\"1\":{\"559\":1}}],[\"依次克隆各个可变的引用类型\",{\"1\":{\"343\":1}}],[\"依次包括访问标志\",{\"1\":{\"289\":1,\"290\":1}}],[\"依赖哪些值对象\",{\"1\":{\"1225\":1}}],[\"依赖哪些实体\",{\"1\":{\"1225\":1}}],[\"依赖库安装\",{\"0\":{\"1183\":1}}],[\"依赖关系使用带箭头的虚线来表示\",{\"1\":{\"1096\":1}}],[\"依赖关系是一种使用关系\",{\"1\":{\"1096\":1}}],[\"依赖关系\",{\"0\":{\"1096\":1},\"1\":{\"1095\":1}}],[\"依赖关系被自动注入到需要他们的对象中去\",{\"1\":{\"718\":1}}],[\"依赖倒置原则是实现开闭原则的重要途径之一\",{\"1\":{\"1064\":1}}],[\"依赖倒置原则\",{\"1\":{\"1064\":1}}],[\"依赖冲突\",{\"0\":{\"798\":1}}],[\"依赖范围scope\",{\"0\":{\"797\":1}}],[\"依赖注入也是通过反射机制来实现的\",{\"1\":{\"729\":1}}],[\"依赖注入是通过反射实现的\",{\"1\":{\"718\":1}}],[\"依赖注入就是将实例变量传入到一个对象中去\",{\"1\":{\"718\":1}}],[\"依赖注入\",{\"0\":{\"1159\":1},\"1\":{\"718\":2}}],[\"依赖注入和生命周期管理\",{\"1\":{\"712\":1}}],[\"依赖了对象\",{\"1\":{\"718\":1}}],[\"依赖于\",{\"1\":{\"94\":1}}],[\"依赖于操作系统的系统调用实现的锁\",{\"1\":{\"81\":1}}],[\"依赖\",{\"1\":{\"94\":1,\"759\":1}}],[\"依附于线程的内存模型\",{\"1\":{\"831\":1}}],[\"依附于\",{\"1\":{\"26\":1}}],[\"锁都不加\",{\"1\":{\"523\":1}}],[\"锁超时\",{\"1\":{\"668\":1}}],[\"锁超时等待\",{\"1\":{\"516\":1}}],[\"锁超时机制\",{\"1\":{\"98\":1}}],[\"锁或\",{\"1\":{\"514\":1}}],[\"锁分为共享锁\",{\"1\":{\"500\":1}}],[\"锁分类\",{\"0\":{\"81\":1}}],[\"锁机制\",{\"1\":{\"493\":1,\"519\":1}}],[\"锁住的就是这个聚簇索引\",{\"1\":{\"503\":1}}],[\"锁住的是key\",{\"1\":{\"503\":1}}],[\"锁住终端\",{\"1\":{\"417\":1}}],[\"锁住整个数组\",{\"1\":{\"409\":1}}],[\"锁定一个范围\",{\"1\":{\"504\":1}}],[\"锁定\",{\"1\":{\"294\":1}}],[\"锁状态标志\",{\"1\":{\"225\":1}}],[\"锁写入数据\",{\"1\":{\"131\":1}}],[\"锁的查\",{\"1\":{\"523\":1}}],[\"锁的事务进行回滚\",{\"1\":{\"516\":1}}],[\"锁的分类\",{\"0\":{\"500\":1}}],[\"锁的实现引入了大量的优化\",{\"1\":{\"131\":1}}],[\"锁的粒度\",{\"1\":{\"130\":1}}],[\"锁的最终释放\",{\"1\":{\"96\":1}}],[\"锁队列的一个结点\",{\"1\":{\"110\":1}}],[\"锁高效\",{\"1\":{\"104\":1}}],[\"锁每次只会让一个线程去操作共享资源\",{\"1\":{\"104\":1}}],[\"锁打断\",{\"1\":{\"98\":1}}],[\"锁需要去识别获取锁的线程是否是当前持有锁的线程\",{\"1\":{\"96\":1}}],[\"锁类型和锁数量\",{\"1\":{\"499\":1}}],[\"锁类型\",{\"1\":{\"94\":1}}],[\"锁实现机制\",{\"1\":{\"94\":1}}],[\"锁清除是发生在编译器级别的一种锁优化方式\",{\"1\":{\"92\":1}}],[\"锁清除\",{\"0\":{\"92\":1}}],[\"锁优化\",{\"0\":{\"90\":1}}],[\"锁膨胀\",{\"0\":{\"89\":1}}],[\"锁不仅不存在多线程竞争\",{\"1\":{\"88\":1}}],[\"锁记录对象\",{\"1\":{\"87\":1}}],[\"锁重入不阻塞\",{\"1\":{\"86\":1}}],[\"锁可以升级但不可以降级\",{\"1\":{\"86\":1}}],[\"锁存在四种状态\",{\"1\":{\"86\":1}}],[\"锁升级\",{\"0\":{\"86\":1}}],[\"锁标志位\",{\"1\":{\"84\":1}}],[\"锁是\",{\"1\":{\"83\":1}}],[\"锁是类的\",{\"1\":{\"83\":1}}],[\"锁是当前的实例对象\",{\"1\":{\"83\":1}}],[\"锁计数器\",{\"1\":{\"82\":1}}],[\"锁计数器+1\",{\"1\":{\"82\":1}}],[\"锁粗化\",{\"0\":{\"93\":1},\"1\":{\"82\":1}}],[\"锁消除\",{\"1\":{\"82\":1}}],[\"锁只能有此线程独占\",{\"1\":{\"81\":1}}],[\"锁一旦释放\",{\"1\":{\"81\":1}}],[\"锁设计\",{\"0\":{\"81\":1}}],[\"锁\",{\"0\":{\"80\":1},\"1\":{\"86\":1,\"89\":1,\"129\":1,\"500\":2,\"501\":3,\"503\":1,\"509\":3,\"513\":1,\"514\":7}}],[\"四色建模法\",{\"1\":{\"1216\":1}}],[\"四次挥手\",{\"0\":{\"1026\":1}}],[\"四个月每天学习\",{\"1\":{\"689\":1}}],[\"四个原语实现的\",{\"1\":{\"665\":1}}],[\"四\",{\"0\":{\"80\":1,\"231\":1,\"375\":1}}],[\"能作用于行首和行尾\",{\"1\":{\"1190\":1}}],[\"能生产多等级\",{\"1\":{\"1079\":1}}],[\"能这样做有一个前提\",{\"1\":{\"1042\":1}}],[\"能让被动关闭方接收\",{\"1\":{\"1027\":1}}],[\"能让使用者明确指定在一个长度为\",{\"1\":{\"261\":1}}],[\"能提示发送方降低发送的速率\",{\"1\":{\"1009\":1}}],[\"能产生网络流量的应用程序\",{\"1\":{\"961\":1}}],[\"能经受高负载的考验\",{\"1\":{\"824\":1}}],[\"能减少网络传输字节数\",{\"1\":{\"805\":1}}],[\"能更灵活地对协议字段进行定制\",{\"1\":{\"805\":1}}],[\"能否自己写一个\",{\"0\":{\"804\":1}}],[\"能起到很好的负载均衡的目的\",{\"1\":{\"678\":1}}],[\"能有效的解决数据误操作和数据异常丢失的问题\",{\"1\":{\"675\":1}}],[\"能拿到锁\",{\"1\":{\"672\":1}}],[\"能对应多个\",{\"1\":{\"655\":1}}],[\"能较好的避免这个问题\",{\"1\":{\"587\":1}}],[\"能力\",{\"1\":{\"577\":1}}],[\"能力的\",{\"1\":{\"577\":1}}],[\"能存放\",{\"1\":{\"539\":1}}],[\"能正确地在可用的region中分配新对象\",{\"1\":{\"264\":1}}],[\"能做的所有工作\",{\"1\":{\"236\":1}}],[\"能够直接被javascript解释器解析\",{\"1\":{\"1035\":1}}],[\"能够错误纠正\",{\"1\":{\"961\":1}}],[\"能够容忍数据的少量丢失\",{\"1\":{\"854\":1}}],[\"能够在不间断服务的情况下进行软件版本的升级\",{\"1\":{\"824\":1}}],[\"能够在主库出现故障时自动进行主备切换\",{\"1\":{\"675\":1}}],[\"能够将那些与业务无关\",{\"1\":{\"715\":1}}],[\"能够解决\",{\"1\":{\"676\":1}}],[\"能够识别\",{\"1\":{\"662\":1}}],[\"能够实现故障自动\",{\"1\":{\"660\":1,\"678\":1}}],[\"能够综合利用两者优点\",{\"1\":{\"566\":1}}],[\"能够加速插入操作的插入缓冲区等\",{\"1\":{\"491\":1}}],[\"能够加快读操作并且自动创建的自适应哈希索引\",{\"1\":{\"491\":1}}],[\"能够保证信息在传输过程中不被篡改\",{\"1\":{\"1057\":1}}],[\"能够保证独立性\",{\"1\":{\"467\":1}}],[\"能够保存从\",{\"1\":{\"475\":1}}],[\"能够通知程序进行相应的读写操作\",{\"1\":{\"381\":1}}],[\"能够以极低的性能开销收集jvm的性能数据\",{\"1\":{\"313\":1}}],[\"能够快速定位到真正引用它的堆对象地址\",{\"1\":{\"249\":1}}],[\"能够用于不同计算机之间的进程间通信\",{\"1\":{\"149\":1}}],[\"能够执行系统调用的就只有\",{\"1\":{\"134\":1}}],[\"能够被其他程序获取\",{\"1\":{\"134\":1}}],[\"能够再次调用lock\",{\"1\":{\"96\":1}}],[\"能保证可见性\",{\"1\":{\"79\":1}}],[\"能帮助我们快速熟悉一个设计模式\",{\"1\":{\"50\":1}}],[\"仅携带1字节的数据\",{\"1\":{\"1015\":1}}],[\"仅有首部\",{\"1\":{\"1002\":1}}],[\"仅在urg=1时才有意义\",{\"1\":{\"1007\":1}}],[\"仅在客户进程运行时才动态选择\",{\"1\":{\"1000\":1}}],[\"仅在当前\",{\"1\":{\"734\":2}}],[\"仅含有其子树中最大\",{\"1\":{\"920\":1}}],[\"仅影响该节点在哈希环上顺时针相邻的后继节点\",{\"1\":{\"880\":1}}],[\"仅用于范围为system\",{\"1\":{\"797\":1}}],[\"仅提供了最基本的依赖注入支持\",{\"1\":{\"712\":1}}],[\"仅包含\",{\"1\":{\"645\":1}}],[\"仅需要记录那一条记录被修改成什么了\",{\"1\":{\"572\":1}}],[\"仅保存哪条记录被修改\",{\"1\":{\"572\":1}}],[\"仅加速查询\",{\"1\":{\"548\":1}}],[\"仅仅只是一份内核空间到用户的拷贝\",{\"1\":{\"838\":1}}],[\"仅仅是把对方的\",{\"1\":{\"1003\":1}}],[\"仅仅是\",{\"1\":{\"657\":1}}],[\"仅仅适用于精确查找\",{\"1\":{\"541\":1}}],[\"仅仅需要4\",{\"1\":{\"467\":1}}],[\"仅列出目录本身\",{\"1\":{\"419\":1}}],[\"仅照顾了短进程而忽略了长进程\",{\"1\":{\"150\":1}}],[\"仅存在结点之间的关联关系\",{\"1\":{\"110\":1}}],[\"仅能使用在变量级别\",{\"1\":{\"79\":1}}],[\"仅针对单个处理器中执行的指令序列和单个线程中执行的操作\",{\"1\":{\"76\":1}}],[\"加密技术\",{\"1\":{\"1077\":1}}],[\"加密传输协议\",{\"1\":{\"1048\":1}}],[\"加密流量\",{\"1\":{\"1045\":1}}],[\"加密过程中使用了三种手段\",{\"1\":{\"1044\":1}}],[\"加了首部就下传\",{\"1\":{\"1001\":1}}],[\"加权轮询\",{\"1\":{\"869\":1}}],[\"加权限\",{\"1\":{\"349\":1}}],[\"加入双重检查代码\",{\"1\":{\"1068\":1}}],[\"加入虚拟节点以后的\",{\"1\":{\"681\":1}}],[\"加入了一个新特性来解决主从不一致导致读取到过期数据问题\",{\"1\":{\"664\":1}}],[\"加大\",{\"1\":{\"565\":1}}],[\"加大了系统的整个吞吐量\",{\"1\":{\"104\":1}}],[\"加缓存\",{\"1\":{\"561\":1}}],[\"加速查询\",{\"1\":{\"548\":2}}],[\"加上\",{\"1\":{\"509\":1,\"535\":1}}],[\"加上间隙锁之后\",{\"1\":{\"505\":1}}],[\"加上包装礼盒的总体积可认为是磁盘空间使用量\",{\"1\":{\"442\":1}}],[\"加读锁\",{\"1\":{\"501\":1}}],[\"加记录上的x锁\",{\"1\":{\"501\":1}}],[\"加两把x锁\",{\"1\":{\"501\":2}}],[\"加表级锁\",{\"1\":{\"501\":1}}],[\"加\",{\"1\":{\"501\":3,\"509\":1,\"511\":2}}],[\"加排他锁\",{\"1\":{\"500\":1}}],[\"加共享锁\",{\"1\":{\"500\":1}}],[\"加日志\",{\"1\":{\"349\":1}}],[\"加事务\",{\"1\":{\"349\":1}}],[\"加事务等\",{\"1\":{\"349\":1}}],[\"加一些额外的处理\",{\"1\":{\"349\":1}}],[\"加载该类的\",{\"1\":{\"1075\":1}}],[\"加载到\",{\"1\":{\"771\":1}}],[\"加载spring配置文件时候就会创建单实例对象\",{\"1\":{\"713\":1,\"734\":1}}],[\"加载速度快\",{\"1\":{\"653\":1}}],[\"加载和执行\",{\"1\":{\"208\":1}}],[\"加载实现类\",{\"1\":{\"185\":1}}],[\"加载这些代码的\",{\"1\":{\"185\":1}}],[\"加载这个类的classloader\",{\"1\":{\"166\":1}}],[\"加载名称为name的类\",{\"1\":{\"182\":1}}],[\"加载的时候\",{\"1\":{\"184\":1}}],[\"加载的类除了可以在网络\",{\"1\":{\"180\":1}}],[\"加载的是主存中的数据\",{\"1\":{\"78\":1}}],[\"加载拓展类和应用程序加载器\",{\"1\":{\"176\":1}}],[\"加载阶段完成后\",{\"1\":{\"168\":1}}],[\"加载阶段获取类的二进制字节流的动作\",{\"1\":{\"168\":1}}],[\"加载\",{\"0\":{\"168\":1},\"1\":{\"712\":1,\"744\":1,\"811\":1}}],[\"加轻量级锁失败\",{\"1\":{\"89\":1}}],[\"加锁排队\",{\"1\":{\"642\":1}}],[\"加锁的单位是\",{\"1\":{\"515\":1}}],[\"加锁的其他线程对该变量读可见\",{\"1\":{\"102\":1}}],[\"加锁开销也最大\",{\"1\":{\"509\":1}}],[\"加锁\",{\"1\":{\"87\":1,\"130\":1,\"517\":1,\"1119\":1}}],[\"加锁和解锁不需要额外的消耗\",{\"1\":{\"86\":1}}],[\"加锁从主内存中\",{\"1\":{\"73\":1}}],[\"加锁时限\",{\"1\":{\"98\":1}}],[\"加锁时\",{\"1\":{\"69\":1}}],[\"随即推送到指定的消费接口\",{\"1\":{\"843\":1}}],[\"随从状态\",{\"1\":{\"820\":1}}],[\"随便放\",{\"1\":{\"807\":1}}],[\"随便重排序\",{\"1\":{\"76\":1}}],[\"随机数法\",{\"1\":{\"923\":1}}],[\"随机\",{\"1\":{\"812\":1,\"869\":2}}],[\"随机移除某个\",{\"1\":{\"636\":2}}],[\"随机存储\",{\"1\":{\"391\":1}}],[\"随时可以提交事务\",{\"1\":{\"489\":1}}],[\"随着\",{\"1\":{\"623\":1}}],[\"随着数据逐步增多\",{\"1\":{\"615\":1}}],[\"随着数据量越大\",{\"1\":{\"541\":1}}],[\"随着时间和业务的发展\",{\"1\":{\"583\":1}}],[\"随着业务量的扩展\",{\"1\":{\"579\":1}}],[\"随着hotspot的开发者对g1的不断优化\",{\"1\":{\"262\":1}}],[\"随着jit编译期的发展与逃逸分析技术逐渐成熟\",{\"1\":{\"199\":1}}],[\"随着硬件指令集的发展\",{\"1\":{\"142\":1}}],[\"随后client会等待\",{\"1\":{\"1026\":1}}],[\"随后用==运算符和或\",{\"1\":{\"400\":1}}],[\"随后进行一次筛选\",{\"1\":{\"236\":1}}],[\"随后\",{\"1\":{\"72\":1}}],[\"程序运行出错的概率会非常大\",{\"1\":{\"1064\":1}}],[\"程序运行过程中发生严重错误\",{\"1\":{\"384\":1}}],[\"程序运行过程中\",{\"1\":{\"317\":1}}],[\"程序返回一个签名的token\",{\"1\":{\"1053\":1}}],[\"程序验证\",{\"1\":{\"1053\":1}}],[\"程序就挂了\",{\"1\":{\"866\":1}}],[\"程序就会退出\",{\"1\":{\"143\":1}}],[\"程序员需要修改订单系统的代码\",{\"1\":{\"840\":1}}],[\"程序员直接编写原生态\",{\"1\":{\"746\":1}}],[\"程序启动速度更快\",{\"1\":{\"712\":1}}],[\"程序不会立即回收缩短后多余的字节\",{\"1\":{\"624\":1}}],[\"程序需要捕获\",{\"1\":{\"384\":1}}],[\"程序更加健壮\",{\"1\":{\"345\":1}}],[\"程序从开始到结束所用的时钟时间\",{\"1\":{\"331\":1}}],[\"程序响应时间较长\",{\"1\":{\"307\":1}}],[\"程序响应速度快\",{\"1\":{\"86\":1}}],[\"程序在各种平台下都能达到一致的内存访问效果\",{\"1\":{\"293\":1,\"337\":1}}],[\"程序在各种平台下对内存的访问都能得到一致效果\",{\"1\":{\"65\":1}}],[\"程序如果发现某个虚引用已经被加入到引用队列\",{\"1\":{\"235\":1}}],[\"程序可以在不同的数据库间迁移\",{\"1\":{\"467\":1}}],[\"程序可以通过判断引用队列中是否已经加入了虚引用\",{\"1\":{\"235\":1}}],[\"程序可以独立执行\",{\"1\":{\"161\":1}}],[\"程序的行为异常\",{\"1\":{\"713\":1}}],[\"程序的执行如果超出了锁的超时时间就会出现问题\",{\"1\":{\"670\":1}}],[\"程序的视角来看\",{\"1\":{\"223\":1}}],[\"程序的代码\",{\"1\":{\"136\":1}}],[\"程序能访问到这些字段的数据类型所对应的零值\",{\"1\":{\"221\":1}}],[\"程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法\",{\"1\":{\"202\":1}}],[\"程序中定义的变量\",{\"1\":{\"136\":1}}],[\"程序才能继续执行\",{\"1\":{\"195\":1}}],[\"程序计数器记录当前线程执行的位置\",{\"1\":{\"189\":1}}],[\"程序计数器\",{\"0\":{\"189\":1},\"1\":{\"188\":1}}],[\"程序访问的存储空间也局限于某个区域\",{\"1\":{\"158\":1}}],[\"程序执行局限于某一小部分\",{\"1\":{\"158\":1}}],[\"程序出错或主存储器读写错等\",{\"1\":{\"148\":1}}],[\"程序由静态的指令和数据组成\",{\"1\":{\"139\":1}}],[\"程序\",{\"0\":{\"139\":1},\"1\":{\"139\":1}}],[\"程序段\",{\"1\":{\"136\":3}}],[\"程序次序规则\",{\"1\":{\"75\":1,\"102\":1}}],[\"定理逐步演化而来的\",{\"1\":{\"871\":1}}],[\"定期过期\",{\"1\":{\"632\":1}}],[\"定期\",{\"1\":{\"576\":1}}],[\"定制排序\",{\"1\":{\"390\":1}}],[\"定义生命周期钩子\",{\"1\":{\"1162\":1}}],[\"定义方法\",{\"1\":{\"1162\":1}}],[\"定义侦听器\",{\"1\":{\"1162\":1}}],[\"定义计算属性\",{\"1\":{\"1162\":1}}],[\"定义响应式状态\",{\"1\":{\"1162\":1}}],[\"定义算法骨架\",{\"1\":{\"1087\":1}}],[\"定义一个操作中的算法骨架\",{\"1\":{\"1087\":1}}],[\"定义一个抽象接口以规范准备接收附加责任的对象\",{\"1\":{\"1085\":1}}],[\"定义一个静态枚举类\",{\"1\":{\"1070\":1}}],[\"定义为\",{\"1\":{\"984\":1}}],[\"定义中包括了如下几个表示传播行为的常量\",{\"1\":{\"740\":1}}],[\"定义\",{\"1\":{\"597\":1,\"1079\":1,\"1085\":1,\"1086\":1,\"1087\":1,\"1090\":1,\"1239\":1}}],[\"定义表结构\",{\"1\":{\"493\":1}}],[\"定义程序中各种变量的访问规则\",{\"1\":{\"293\":1}}],[\"定义在\",{\"1\":{\"126\":1}}],[\"定义两种资源共享方式\",{\"1\":{\"112\":1}}],[\"定义了一个公共接口\",{\"1\":{\"1088\":1}}],[\"定义了产品的规范\",{\"1\":{\"1079\":1}}],[\"定义了java编译版本是1\",{\"1\":{\"779\":1}}],[\"定义了在\",{\"1\":{\"721\":1}}],[\"定义了相应的\",{\"1\":{\"721\":1}}],[\"定义了ioc的基本功能\",{\"1\":{\"712\":1}}],[\"定义了由哪个\",{\"1\":{\"349\":1}}],[\"定义了\",{\"1\":{\"74\":1,\"1094\":1,\"1155\":1}}],[\"定位应用程序在哪里\",{\"1\":{\"998\":1}}],[\"定位对应代码\",{\"1\":{\"201\":1}}],[\"定位线程在干嘛\",{\"1\":{\"201\":1}}],[\"定位出的\",{\"1\":{\"131\":1}}],[\"定位死锁\",{\"1\":{\"98\":1}}],[\"定位\",{\"1\":{\"98\":1}}],[\"定时任务检查是否需要重传数据\",{\"1\":{\"1004\":1}}],[\"定时重发\",{\"1\":{\"813\":1}}],[\"定时发送一次统计数据到监控中心\",{\"1\":{\"811\":1}}],[\"定时每分钟发送一次统计到监控中心\",{\"1\":{\"810\":1}}],[\"定时过期\",{\"1\":{\"632\":1}}],[\"定时周期性执行\",{\"1\":{\"56\":1}}],[\"定时等待\",{\"1\":{\"38\":1}}],[\"关心的是\",{\"1\":{\"825\":1}}],[\"关键参数\",{\"1\":{\"1177\":1}}],[\"关键代码\",{\"1\":{\"1091\":1}}],[\"关键功能\",{\"0\":{\"809\":1}}],[\"关键字查询\",{\"1\":{\"888\":1}}],[\"关键字执行顺序\",{\"0\":{\"487\":1}}],[\"关键字修饰\",{\"1\":{\"364\":1}}],[\"关键字修饰的字段在构造器中一旦初始化完成\",{\"1\":{\"295\":1}}],[\"关键字的作用是\",{\"1\":{\"364\":1}}],[\"关键字的作用\",{\"1\":{\"364\":1}}],[\"关键字来引用父类的方法实现\",{\"1\":{\"364\":1}}],[\"关键字一样支持隐式的重进入\",{\"1\":{\"96\":1}}],[\"关键字隐式的支持重进入\",{\"1\":{\"96\":1}}],[\"关键字\",{\"0\":{\"78\":1,\"352\":1,\"479\":1},\"1\":{\"81\":1,\"142\":1,\"409\":1}}],[\"关注的点\",{\"1\":{\"759\":1}}],[\"关\",{\"1\":{\"604\":1}}],[\"关联可以是双向的\",{\"1\":{\"1097\":1}}],[\"关联关系是类与类之间最常用的一种关系\",{\"1\":{\"1097\":1}}],[\"关联关系是对象之间的一种引用关系\",{\"1\":{\"1097\":1}}],[\"关联关系\",{\"0\":{\"1097\":1},\"1\":{\"1095\":1}}],[\"关联表多时\",{\"1\":{\"746\":1}}],[\"关联查询\",{\"0\":{\"485\":1}}],[\"关联后\",{\"1\":{\"452\":1}}],[\"关联一个远程库时必须给远程库指定一个名字\",{\"1\":{\"452\":1}}],[\"关联一个条件队列wait\",{\"1\":{\"94\":1}}],[\"关于排序问题\",{\"1\":{\"630\":1}}],[\"关于数据节点\",{\"1\":{\"622\":1}}],[\"关于列不可再分\",{\"1\":{\"455\":1}}],[\"关于第一范式\",{\"1\":{\"455\":1}}],[\"关于各种相关指令\",{\"1\":{\"135\":1}}],[\"关于主内存与工作内存的交互\",{\"1\":{\"74\":1}}],[\"关系映射能力强\",{\"1\":{\"749\":1}}],[\"关系模型表明了数据库中所存储的数据之间的联系\",{\"1\":{\"456\":1}}],[\"关系型数据库中\",{\"1\":{\"456\":1}}],[\"关系型数据库就是一种建立在关系模型的基础上的数据库\",{\"1\":{\"456\":1}}],[\"关系型数据库介绍\",{\"0\":{\"456\":1}}],[\"关系来复用父加载器的代码\",{\"1\":{\"184\":1}}],[\"关系\",{\"1\":{\"75\":1,\"76\":1,\"427\":1,\"1099\":1}}],[\"关闭等待\",{\"1\":{\"1026\":1}}],[\"关闭的时候却是四次握手\",{\"0\":{\"1024\":1}}],[\"关闭文件或数据库连接等\",{\"1\":{\"346\":1}}],[\"关闭\",{\"1\":{\"59\":1,\"744\":1}}],[\"关闭线程池\",{\"0\":{\"59\":1}}],[\"编写\",{\"1\":{\"1259\":1}}],[\"编写脚本处理代码\",{\"1\":{\"1108\":1}}],[\"编写核心业务代码→将公用代码抽取出来\",{\"1\":{\"719\":1}}],[\"编号\",{\"1\":{\"820\":1}}],[\"编号大\",{\"1\":{\"820\":1}}],[\"编号越大在\",{\"1\":{\"820\":1}}],[\"编码规范\",{\"0\":{\"1264\":1}}],[\"编码不同将直接影响数据的内存占用和读写效率\",{\"1\":{\"637\":1}}],[\"编码优化\",{\"1\":{\"637\":1}}],[\"编码\",{\"1\":{\"617\":1,\"618\":2}}],[\"编辑git配置文件\",{\"1\":{\"446\":1}}],[\"编程式事务每次实现都要单独实现\",{\"1\":{\"739\":1}}],[\"编程式事务\",{\"1\":{\"739\":2}}],[\"编程的时候把解决问题的步骤分析出来\",{\"1\":{\"354\":1}}],[\"编程中的变量不同\",{\"1\":{\"74\":1}}],[\"编译出的\",{\"1\":{\"1200\":1}}],[\"编译\",{\"1\":{\"793\":1}}],[\"编译复杂度将越大\",{\"1\":{\"597\":1}}],[\"编译时异常\",{\"1\":{\"385\":1}}],[\"编译后的机器码会被缓存下来\",{\"1\":{\"283\":1}}],[\"编译阶段\",{\"1\":{\"162\":1}}],[\"编译系统\",{\"0\":{\"162\":1}}],[\"编译优化\",{\"1\":{\"75\":1}}],[\"编译器就自动帮我们调用它相应的函数指针\",{\"1\":{\"804\":1}}],[\"编译器就会自动添加指向外部类实例的字段\",{\"1\":{\"289\":1}}],[\"编译器检测到某段代码可能会发生某些问题\",{\"1\":{\"385\":1}}],[\"编译器也不会通过\",{\"1\":{\"364\":1}}],[\"编译器在编译时擦除了所有类型相关的信息\",{\"1\":{\"345\":1}}],[\"编译器在编译程序的时候并不知道一个对象的实际类型是什么\",{\"1\":{\"277\":1}}],[\"编译器在不改变单线程程序语义放入前提下\",{\"1\":{\"71\":1}}],[\"编译器可知\",{\"1\":{\"274\":1}}],[\"编译器可以对代码做如下优化\",{\"1\":{\"202\":1}}],[\"编译器必须要严格保证这一点\",{\"1\":{\"193\":1}}],[\"编译器容易实现\",{\"1\":{\"190\":1}}],[\"编译器收集的顺序是由语句在源文件中出现的顺序决定的\",{\"1\":{\"173\":1}}],[\"编译器有可能进行指令重排优化\",{\"1\":{\"101\":1,\"1068\":1}}],[\"编译器会进行锁清除\",{\"1\":{\"92\":1}}],[\"编译器和处理器不会对存在数据依赖关系的操作重排序\",{\"1\":{\"76\":1}}],[\"编译器和处理器必须遵循\",{\"1\":{\"76\":1}}],[\"编译器和处理器怎么优化都行\",{\"1\":{\"74\":1}}],[\"编译器优化的重排序\",{\"1\":{\"71\":1}}],[\"控制资源的情况下\",{\"1\":{\"1073\":1}}],[\"控制tcp报文段发送的不同机制\",{\"1\":{\"1016\":1}}],[\"控制信息还使接收端能够检测到所收到的帧中有无差错\",{\"1\":{\"961\":1}}],[\"控制权更大一些\",{\"1\":{\"843\":1}}],[\"控制权翻转\",{\"1\":{\"718\":1}}],[\"控制自己的压力\",{\"1\":{\"843\":1}}],[\"控制拉取消息的速度\",{\"1\":{\"843\":1}}],[\"控制服务线上扩展和上下线\",{\"1\":{\"801\":1}}],[\"控制反转\",{\"1\":{\"770\":1}}],[\"控制反转ioc\",{\"1\":{\"717\":1,\"718\":1}}],[\"控制器负责将视图与模型一一对应起来\",{\"1\":{\"754\":1}}],[\"控制器\",{\"1\":{\"754\":2,\"755\":1}}],[\"控制内存使用\",{\"1\":{\"309\":1}}],[\"控制最大垃圾收集停顿时间\",{\"1\":{\"257\":1}}],[\"控制如何获取锁和释放锁\",{\"1\":{\"109\":1}}],[\"控制\",{\"1\":{\"74\":1,\"637\":1,\"748\":1}}],[\"到某某目的地址应经过路由器r\",{\"1\":{\"993\":1}}],[\"到了2013\",{\"1\":{\"872\":1}}],[\"到模型进行处理\",{\"1\":{\"754\":1}}],[\"到达的时候\",{\"1\":{\"659\":1}}],[\"到过期时间就会立即清除\",{\"1\":{\"632\":1}}],[\"到\",{\"1\":{\"568\":1,\"623\":2,\"660\":1,\"662\":1,\"678\":1,\"919\":1}}],[\"到主键\",{\"1\":{\"484\":2}}],[\"到主内存汇总\",{\"1\":{\"73\":1}}],[\"到主内存\",{\"1\":{\"73\":1}}],[\"到处\",{\"1\":{\"336\":1}}],[\"到文件以便后续分析\",{\"1\":{\"324\":1}}],[\"到工作内存中\",{\"1\":{\"73\":1}}],[\"到时间自动恢复\",{\"1\":{\"37\":1}}],[\"变更引起的风险降低\",{\"1\":{\"1064\":1}}],[\"变为\",{\"1\":{\"628\":1}}],[\"变为空\",{\"1\":{\"623\":1}}],[\"变化为\",{\"1\":{\"880\":1}}],[\"变化来做出业务上的改变等\",{\"1\":{\"817\":1}}],[\"变化\",{\"1\":{\"623\":1}}],[\"变化几率很小\",{\"1\":{\"129\":1}}],[\"变态次数多\",{\"1\":{\"133\":1}}],[\"变态次数少\",{\"1\":{\"133\":1}}],[\"变成主节点继续提供服务\",{\"1\":{\"659\":1}}],[\"变成干净页之后才能复用\",{\"1\":{\"594\":1}}],[\"变成等待干预状态等等\",{\"1\":{\"148\":1}}],[\"变成遍历红黑树\",{\"1\":{\"130\":1}}],[\"变成\",{\"1\":{\"89\":1,\"383\":1}}],[\"变成<style\",{\"1\":{\"24\":1}}],[\"变量替换在dbms中\",{\"1\":{\"596\":1}}],[\"变量\",{\"1\":{\"413\":1,\"1155\":1}}],[\"变量必须实例化后才可以使用\",{\"1\":{\"368\":1}}],[\"变量必须初始化\",{\"1\":{\"346\":1}}],[\"变量或方法的\",{\"1\":{\"358\":1}}],[\"变量仍然有工作内存的拷贝\",{\"1\":{\"337\":1}}],[\"变量不合理的作用域\",{\"1\":{\"304\":1}}],[\"变量不为\",{\"1\":{\"81\":1}}],[\"变量本身的静态类型不会被改变\",{\"1\":{\"277\":1}}],[\"变量槽是可以重用的\",{\"1\":{\"192\":1}}],[\"变量槽的长度可以随着处理器\",{\"1\":{\"192\":1}}],[\"变量来标识是否获取到锁的\",{\"1\":{\"81\":1}}],[\"变量的默认值是\",{\"1\":{\"368\":1}}],[\"变量的读指令前会加入读屏障\",{\"1\":{\"78\":1}}],[\"变量的写\",{\"1\":{\"102\":1}}],[\"变量的写指令后会加入写屏障\",{\"1\":{\"78\":1}}],[\"变量的写操作先行发生于后面对这个变量的读操作\",{\"1\":{\"75\":1,\"102\":1}}],[\"变量时会加入内存屏障保证可见性和有序性\",{\"1\":{\"78\":1}}],[\"变量对其他线程可见\",{\"1\":{\"78\":1}}],[\"变量只会单线程访问就把它当作普通变量\",{\"1\":{\"74\":1}}],[\"变量如何从主内存到本地内存以及从本地内存到主内存\",{\"0\":{\"73\":1}}],[\"那如果只有聚合根存库的话\",{\"1\":{\"1246\":1}}],[\"那样太多了\",{\"1\":{\"1049\":1}}],[\"那样轮询扫描整个\",{\"1\":{\"612\":1}}],[\"那里申请来的证书\",{\"1\":{\"1045\":1}}],[\"那问题来了\",{\"1\":{\"961\":1}}],[\"那我们无法验证数字签名了\",{\"1\":{\"1057\":1}}],[\"那我们开一个750长度的数组\",{\"1\":{\"902\":1}}],[\"那我们锁的就是整个索引树\",{\"1\":{\"508\":1}}],[\"那服务之间还能相互调用吗\",{\"0\":{\"803\":1},\"1\":{\"803\":1}}],[\"那这里为什么会有method这个参数呢\",{\"1\":{\"726\":1}}],[\"那这个变量对应的变量槽就可以交给其他变量来重用\",{\"1\":{\"192\":1}}],[\"那你可以这么做\",{\"1\":{\"576\":1}}],[\"那将占用大量内存空间\",{\"1\":{\"549\":1}}],[\"那锁住的就是命中条件内的索引节点\",{\"1\":{\"508\":1}}],[\"那有没有有序的\",{\"1\":{\"412\":1}}],[\"那说明该元素是同一个\",{\"1\":{\"400\":1}}],[\"那说明该元素哈希冲突了\",{\"1\":{\"341\":1}}],[\"那字段重名就是合法的\",{\"1\":{\"289\":1}}],[\"那设计者在实现记忆集的时候\",{\"1\":{\"249\":1}}],[\"那知道了\",{\"1\":{\"247\":1}}],[\"那基本上它就真的要被回收了\",{\"1\":{\"236\":1}}],[\"那在第二次标记时它将被移出\",{\"1\":{\"236\":1}}],[\"那它将会被第一次标记\",{\"1\":{\"236\":1}}],[\"那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离\",{\"1\":{\"216\":1}}],[\"那必须先执行相应的类加载过程\",{\"1\":{\"214\":1}}],[\"那第0位索引的变量槽默认是用于传递方法所属对象实例的引用\",{\"1\":{\"192\":1}}],[\"那每一个线程的jvm栈容量可以在线程创建的时候独立选定\",{\"1\":{\"190\":1}}],[\"那该怎么办\",{\"1\":{\"185\":1}}],[\"那该接口要在其之前被初化\",{\"1\":{\"174\":1}}],[\"那就是所有消息发往同1个partition\",{\"1\":{\"865\":1}}],[\"那就是\",{\"1\":{\"831\":1}}],[\"那就是支付\",{\"1\":{\"807\":1}}],[\"那就不得不阻塞等待\",{\"1\":{\"829\":1}}],[\"那就会有\",{\"1\":{\"645\":1}}],[\"那就重复步骤\",{\"1\":{\"632\":1}}],[\"那就说明该元素哈希冲突了\",{\"1\":{\"400\":1}}],[\"那就说明元素还是同一个了\",{\"1\":{\"341\":1}}],[\"那就将对应卡表的数组元素的值标识为1\",{\"1\":{\"249\":1}}],[\"那就没有办法简单地进行指针碰撞了\",{\"1\":{\"217\":1}}],[\"那就需要系统调用了\",{\"1\":{\"135\":1}}],[\"那就证明任务还没有执行完毕\",{\"1\":{\"118\":1}}],[\"那\",{\"1\":{\"88\":1}}],[\"那前面的操作都得完成\",{\"1\":{\"72\":1}}],[\"那么首先就要在实体中找到聚合根\",{\"1\":{\"1219\":1}}],[\"那么真实主题角色必须是事先已经存在的\",{\"1\":{\"1083\":1}}],[\"那么所有的客户类都要进行修改\",{\"1\":{\"1077\":1}}],[\"那么所有的客户类都要知道所有子类的细节\",{\"1\":{\"1077\":1}}],[\"那么两个线程都会进入\",{\"1\":{\"1067\":1}}],[\"那么两者性能差异不大\",{\"1\":{\"720\":1}}],[\"那么通过\",{\"1\":{\"1061\":1}}],[\"那么回复一个ack报文\",{\"1\":{\"1049\":1}}],[\"那么如果这个\",{\"1\":{\"1027\":1}}],[\"那么只要服务器端发出确认\",{\"1\":{\"1022\":1}}],[\"那么只需要修改原来的索引即可\",{\"1\":{\"533\":1}}],[\"那么需要b向a发送没有收到的字节流的左右边界\",{\"1\":{\"1013\":1}}],[\"那么需要在pom\",{\"1\":{\"796\":1}}],[\"那么网络包达到主机之后\",{\"1\":{\"999\":1}}],[\"那么传输数据时\",{\"1\":{\"986\":1}}],[\"那么称这个网络为异构网络\",{\"1\":{\"961\":1}}],[\"那么找到小于\",{\"1\":{\"919\":1}}],[\"那么查找某一个关键字的至多需要两次\",{\"1\":{\"919\":1}}],[\"那么查询线程拿到的结果跟表结构对不上\",{\"1\":{\"511\":1}}],[\"那么说明这个值在布隆过滤器中\",{\"1\":{\"882\":1}}],[\"那么可能会引起网络阻塞\",{\"1\":{\"1019\":1}}],[\"那么可能会无限重复下去\",{\"1\":{\"877\":1}}],[\"那么可以将这些jar写入父pom中\",{\"1\":{\"800\":1}}],[\"那么可以只使用\",{\"1\":{\"653\":1}}],[\"那么可以算出一棵高度为\",{\"1\":{\"539\":1}}],[\"那么可以使用轻量级锁来进行优化\",{\"1\":{\"87\":1}}],[\"那么他会更新到较大的\",{\"1\":{\"876\":1}}],[\"那么leader就要一直等待下去\",{\"1\":{\"853\":1}}],[\"那么支持的最大并发数是多少\",{\"1\":{\"836\":1}}],[\"那么效率将会十分低下\",{\"1\":{\"829\":1}}],[\"那么强大\",{\"1\":{\"825\":1}}],[\"那么比较服务器\",{\"1\":{\"820\":1}}],[\"那么服务器中就会存在运行的数据\",{\"1\":{\"820\":1}}],[\"那么定义的方法就是代理对象的逻辑方法\",{\"1\":{\"727\":1}}],[\"那么其最少有两个子树\",{\"1\":{\"919\":1}}],[\"那么其将无法使用cglib动态代理\",{\"1\":{\"715\":1}}],[\"那么其它线程就能看见\",{\"1\":{\"295\":1}}],[\"那么session机制就是通过检查服务器上的\",{\"1\":{\"1052\":1}}],[\"那么spring就会通过jdk\",{\"1\":{\"715\":1}}],[\"那么stringbuffer将不会逃逸出方法\",{\"1\":{\"202\":1}}],[\"那么当服务器数量发生变化时\",{\"1\":{\"681\":1}}],[\"那么当前查询可能要等待或者抛出异常\",{\"1\":{\"513\":1}}],[\"那么当前线程就可以不用进行上下文切换就获得了锁\",{\"1\":{\"91\":1}}],[\"那么正确的命令会被执行\",{\"1\":{\"665\":1}}],[\"那么认为\",{\"1\":{\"659\":1}}],[\"那么认为这次自旋成功的可能性会高\",{\"1\":{\"91\":1}}],[\"那么哨兵之间就会进行一次投票\",{\"1\":{\"657\":1}}],[\"那么最好\",{\"1\":{\"653\":1}}],[\"那么父进程执行\",{\"1\":{\"647\":1}}],[\"那么使用\",{\"1\":{\"645\":1}}],[\"那么第二个\",{\"1\":{\"628\":1}}],[\"那么延迟加重的可能性就会原来越大\",{\"1\":{\"582\":1}}],[\"那么问题来了\",{\"1\":{\"578\":1}}],[\"那么和上面同样的道理\",{\"1\":{\"578\":1}}],[\"那么机器重启后\",{\"1\":{\"578\":1}}],[\"那么备份系统中一定会保存最近半个月的所有\",{\"1\":{\"576\":1}}],[\"那么即时满足了条件\",{\"1\":{\"574\":1}}],[\"那么后面会增加垂直拆分的复杂度\",{\"1\":{\"561\":1}}],[\"那么后面非公平锁和公平锁是一样的\",{\"1\":{\"114\":1}}],[\"那么索引就是整个字符串\",{\"1\":{\"554\":1}}],[\"那么索引也需要动态的修改\",{\"1\":{\"528\":1}}],[\"那么一个超大文件\",{\"1\":{\"904\":1}}],[\"那么一个页可以存放\",{\"1\":{\"539\":1}}],[\"那么一旦有延迟产生\",{\"1\":{\"582\":1}}],[\"那么一次磁盘io的时间大概是9ms左右\",{\"1\":{\"543\":1}}],[\"那么一起进行刷新\",{\"1\":{\"496\":1}}],[\"那么无法使用此索引\",{\"1\":{\"534\":1}}],[\"那么将丢失数据\",{\"1\":{\"854\":1}}],[\"那么将会在每一条聚簇索引后面加\",{\"1\":{\"503\":1}}],[\"那么将保留表中\",{\"1\":{\"487\":1}}],[\"那么将自旋一段时间\",{\"1\":{\"81\":1}}],[\"那么再写入\",{\"1\":{\"411\":1}}],[\"那么线程\",{\"1\":{\"406\":1}}],[\"那么下一个操作请求到了另一台服务器的时候session会丢失\",{\"1\":{\"1052\":1}}],[\"那么下一个线程想获取锁继续执行的话需要经历挂起以及唤醒\",{\"1\":{\"81\":1}}],[\"那么下次再获取锁的时候先查询数据库\",{\"1\":{\"668\":1}}],[\"那么下次调用\",{\"1\":{\"381\":1}}],[\"那么子类的访问修饰符也必须是\",{\"1\":{\"359\":1}}],[\"那么此时\",{\"1\":{\"683\":1}}],[\"那么此时是疑似下线\",{\"1\":{\"683\":1}}],[\"那么此时一定不存在缓存\",{\"1\":{\"645\":1}}],[\"那么此时就需要通过虚拟机的堆参数\",{\"1\":{\"298\":1}}],[\"那么此map就会丢弃该值\",{\"1\":{\"304\":1}}],[\"那么它具有全局唯一的标识\",{\"1\":{\"1219\":1}}],[\"那么它本来就对应红黑树中黑节点\",{\"1\":{\"921\":1}}],[\"那么它可以存储超过\",{\"1\":{\"919\":1}}],[\"那么它会一直保持为\",{\"1\":{\"877\":1}}],[\"那么它会拒绝此次请求\",{\"1\":{\"876\":1}}],[\"那么它们的生命周期与jvm程序一致\",{\"1\":{\"304\":1}}],[\"那么它就和没有任何引用一样\",{\"1\":{\"235\":1}}],[\"那么访问这个变量的每个线程都会有这个变量的本地副本\",{\"1\":{\"299\":1}}],[\"那么在同一个\",{\"1\":{\"1075\":1}}],[\"那么在元素非常多的时候\",{\"1\":{\"916\":1}}],[\"那么在默认情况下项目编译时\",{\"1\":{\"796\":1}}],[\"那么在函数中对参数所进行的修改\",{\"1\":{\"351\":1}}],[\"那么在整个class文件里\",{\"1\":{\"292\":1}}],[\"那么在当前栈帧中再添加一条锁记录作为锁重入的计数\",{\"1\":{\"87\":1}}],[\"那么也是可以合法共存于同一个class文件中的\",{\"1\":{\"290\":1}}],[\"那么肯定有一种编译器能够将java源码编译为字节码\",{\"1\":{\"282\":1}}],[\"那么该网络的子网掩码就使用默认子网掩码\",{\"1\":{\"989\":1}}],[\"那么该url应该是共同的url\",{\"1\":{\"896\":1}}],[\"那么该表每一条记录都会记录到日志中\",{\"1\":{\"572\":1}}],[\"那么该子类的方法会把原来继承过来的父类的方法隐藏\",{\"1\":{\"358\":1}}],[\"那么该对象将会被放置在一个名为f\",{\"1\":{\"236\":1}}],[\"那么该等待进程有可能再也无法改变状态\",{\"1\":{\"98\":1}}],[\"那么虚拟机将这两种情况都视为\",{\"1\":{\"236\":1}}],[\"那么就不应当发生直接的相互调用\",{\"1\":{\"1064\":1}}],[\"那么就使用它\",{\"1\":{\"606\":1}}],[\"那么就使用自然顺序\",{\"1\":{\"412\":1}}],[\"那么就需要去表中查找这1亿条记录是否上锁了\",{\"1\":{\"514\":1}}],[\"那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制\",{\"1\":{\"110\":1}}],[\"那么就是共同的\",{\"1\":{\"896\":1}}],[\"那么就是非阻塞\",{\"1\":{\"380\":1}}],[\"那么就是异步\",{\"1\":{\"380\":1}}],[\"那么就是同步\",{\"1\":{\"380\":1}}],[\"那么就是内存中的对象确实必须存活着\",{\"1\":{\"298\":1}}],[\"那么就会进行两次实例化\",{\"1\":{\"1067\":1}}],[\"那么就会进入分析器\",{\"1\":{\"490\":1}}],[\"那么就会聚集\",{\"1\":{\"304\":1}}],[\"那么就会oom\",{\"1\":{\"304\":1}}],[\"那么就可以对记录做修改\",{\"1\":{\"513\":1}}],[\"那么就可以在所引用的对象的内存被回收之前采取必要的行动\",{\"1\":{\"235\":1}}],[\"那么就可能被优化成栈上分配\",{\"1\":{\"202\":1}}],[\"那么对方在超时后将重发第三次挥手的\",{\"1\":{\"1026\":1}}],[\"那么对象的部分\",{\"1\":{\"202\":1}}],[\"那么对象可以直接在栈上分配内存\",{\"1\":{\"199\":1}}],[\"那么对于这个对象的操作可以不考虑同步\",{\"1\":{\"202\":1}}],[\"那么jvm会抛出一个outofmemoryerror异常\",{\"1\":{\"190\":1}}],[\"那么程序运行的时候\",{\"1\":{\"184\":1}}],[\"那么编译器可以不为这个类生成<clinit>\",{\"1\":{\"173\":1}}],[\"那么停止该指令的执行\",{\"1\":{\"159\":1}}],[\"那么那些子进程将成为孤儿进程\",{\"1\":{\"151\":1}}],[\"那么每个节点都需要通过继承\",{\"1\":{\"131\":1}}],[\"那么直接就获取到锁返回了\",{\"1\":{\"114\":1}}],[\"那么死锁就不会发生\",{\"1\":{\"98\":1}}],[\"那么必须等待直到该资源被释放为止\",{\"1\":{\"98\":1}}],[\"那么前一种工厂模式\",{\"1\":{\"731\":1}}],[\"那么前\",{\"1\":{\"96\":1}}],[\"那么会自动创建一个隐藏的聚簇索引\",{\"1\":{\"503\":1}}],[\"那么会锁上表中的所有记录\",{\"1\":{\"501\":1}}],[\"那么会进入重量级锁的解锁过程\",{\"1\":{\"89\":1}}],[\"那么会对\",{\"1\":{\"46\":1}}],[\"那么新来的线程如果再想获取到锁先\",{\"1\":{\"81\":1}}],[\"那么很多操作都将会变得非常啰嗦\",{\"1\":{\"75\":1}}],[\"那么这棵\",{\"1\":{\"539\":1}}],[\"那么这就是个问题了\",{\"1\":{\"348\":1}}],[\"那么这两个对象也是不相等的\",{\"1\":{\"166\":1}}],[\"那么这两个操作之间必须存在\",{\"1\":{\"75\":1}}],[\"那么这个元素一定不在\",{\"1\":{\"882\":1}}],[\"那么这个客户端创建的所有临时节点都会被移除\",{\"1\":{\"818\":1}}],[\"那么这个时候很有可能造成频繁的\",{\"1\":{\"411\":1}}],[\"那么这个引用始终只能指向这个对象\",{\"1\":{\"371\":1}}],[\"那么这个代理对象就宣称实现了该接口\",{\"1\":{\"349\":1}}],[\"那么这个外部对象也不会被回收\",{\"1\":{\"304\":1}}],[\"那么这个类加载器默认就是应用程序类加载器\",{\"1\":{\"179\":1}}],[\"那么这个进程进入等待状态\",{\"1\":{\"98\":1}}],[\"那么这个线程下一次进入同步代码中的时候可以直接进入\",{\"1\":{\"81\":1}}],[\"那么这个线程的\",{\"1\":{\"34\":1}}],[\"那么\",{\"1\":{\"72\":1,\"75\":1,\"88\":1,\"102\":1,\"106\":1,\"220\":1,\"229\":1,\"230\":1,\"404\":1,\"468\":1,\"521\":1,\"555\":1,\"559\":1,\"640\":1,\"646\":1,\"663\":1,\"820\":1,\"986\":1}}],[\"那么相应的\",{\"1\":{\"35\":1}}],[\"写一些酷酷的东西\",{\"1\":{\"1134\":1}}],[\"写一个静态内部类\",{\"1\":{\"1069\":1}}],[\"写的过程是追加到文件末端\",{\"1\":{\"850\":1}}],[\"写好配置项和默认的配置值\",{\"1\":{\"773\":1}}],[\"写在\",{\"1\":{\"746\":1}}],[\"写在末尾\",{\"1\":{\"708\":1}}],[\"写在开头\",{\"1\":{\"708\":1}}],[\"写请求其实都是在\",{\"1\":{\"683\":1}}],[\"写服务依然必须由\",{\"1\":{\"656\":1}}],[\"写命令执行完后就立即写入磁盘\",{\"1\":{\"650\":1}}],[\"写都转换成了事件\",{\"1\":{\"604\":1}}],[\"写完之后右键右侧的预览赋值图像到剪切板即可\",{\"1\":{\"1274\":1}}],[\"写完\",{\"1\":{\"578\":1}}],[\"写加排他锁\",{\"1\":{\"522\":1}}],[\"写锁之间是互斥的\",{\"1\":{\"511\":1}}],[\"写锁\",{\"1\":{\"500\":1,\"509\":1,\"511\":1}}],[\"写锁支持条件变量\",{\"1\":{\"125\":1}}],[\"写操作也不用阻塞读操作\",{\"1\":{\"499\":1}}],[\"写操作必然会影响执行速度\",{\"1\":{\"193\":1}}],[\"写\",{\"1\":{\"499\":3,\"655\":1,\"661\":1}}],[\"写权限\",{\"1\":{\"430\":1}}],[\"写起\",{\"1\":{\"418\":2}}],[\"写线程会等待\",{\"1\":{\"411\":1}}],[\"写共享变量的主内存副本\",{\"1\":{\"294\":1}}],[\"写次数\",{\"1\":{\"193\":2}}],[\"写写互斥\",{\"1\":{\"125\":1,\"500\":1}}],[\"写入到另外10\",{\"1\":{\"895\":1}}],[\"写入到磁盘的时机\",{\"1\":{\"649\":1}}],[\"写入到磁盘中\",{\"1\":{\"568\":1}}],[\"写入时则对表加排它锁\",{\"1\":{\"492\":1}}],[\"写入磁盘\",{\"1\":{\"489\":1}}],[\"写入物理磁盘的速度\",{\"1\":{\"378\":1}}],[\"写入\",{\"1\":{\"105\":1,\"294\":1,\"807\":1}}],[\"写数据\",{\"1\":{\"73\":1}}],[\"写屏障可以看作在虚拟机层面对\",{\"1\":{\"250\":1}}],[\"写屏障\",{\"0\":{\"250\":1},\"1\":{\"72\":2}}],[\"写到文件系统的\",{\"1\":{\"568\":1}}],[\"写到磁盘\",{\"1\":{\"568\":1}}],[\"写到\",{\"1\":{\"72\":1,\"568\":1,\"571\":1}}],[\"层的队头阻塞问题\",{\"1\":{\"1042\":1}}],[\"层层包装\",{\"1\":{\"964\":1}}],[\"层协议的体系结构\",{\"0\":{\"961\":1}}],[\"层数最大的那个节点的层数\",{\"1\":{\"630\":1}}],[\"层数是\",{\"1\":{\"630\":1}}],[\"层级\",{\"1\":{\"962\":1}}],[\"层级越高\",{\"1\":{\"630\":1}}],[\"层级下\",{\"0\":{\"72\":1}}],[\"层基本组件介绍\",{\"0\":{\"490\":1}}],[\"层\",{\"0\":{\"762\":1},\"1\":{\"488\":1,\"630\":1}}],[\"层和存储引擎层\",{\"1\":{\"488\":1}}],[\"层面实现加锁和释放锁\",{\"1\":{\"94\":1}}],[\"层面\",{\"1\":{\"82\":1}}],[\"层面上是可见和有序的\",{\"1\":{\"72\":1}}],[\"层面下有内存屏障\",{\"1\":{\"72\":1}}],[\"读入要查询的数\",{\"1\":{\"901\":1}}],[\"读入40亿个数\",{\"1\":{\"901\":1}}],[\"读研期间\",{\"1\":{\"687\":1}}],[\"读已提交\",{\"1\":{\"522\":1,\"524\":1}}],[\"读未提交\",{\"1\":{\"522\":1,\"524\":1}}],[\"读加共享锁\",{\"1\":{\"522\":1}}],[\"读读共享\",{\"1\":{\"500\":1}}],[\"读锁之间不互斥\",{\"1\":{\"511\":1}}],[\"读锁\",{\"1\":{\"500\":1,\"509\":1,\"511\":1}}],[\"读锁和写锁都支持锁中断\",{\"1\":{\"125\":1}}],[\"读\",{\"1\":{\"499\":3,\"604\":1,\"655\":1,\"661\":1,\"683\":1}}],[\"读操作的次数远超写操作\",{\"1\":{\"606\":1}}],[\"读操作只读该事务开始前的数据库快照\",{\"1\":{\"499\":1}}],[\"读操作读取的一定是最新效果\",{\"1\":{\"72\":1}}],[\"读权限\",{\"1\":{\"430\":1}}],[\"读哪个那个放在链表的最后面\",{\"1\":{\"414\":1}}],[\"读线程会等待或者当读锁被获取后\",{\"1\":{\"411\":1}}],[\"读线程间是互不阻塞的\",{\"1\":{\"411\":1}}],[\"读光\",{\"1\":{\"381\":1}}],[\"读写更快\",{\"1\":{\"1035\":1}}],[\"读写能力受限的问题\",{\"1\":{\"678\":1}}],[\"读写都在一台mysql上面完成\",{\"1\":{\"579\":1}}],[\"读写分离策略\",{\"1\":{\"675\":1}}],[\"读写分离可以提高数据库的可用性\",{\"1\":{\"579\":1}}],[\"读写分离就是为了数据库能支持更大的并发\",{\"1\":{\"579\":1}}],[\"读写分离一般是一起使用的\",{\"1\":{\"579\":1}}],[\"读写分离的优点\",{\"0\":{\"579\":1}}],[\"读写分离\",{\"1\":{\"561\":1,\"655\":1,\"659\":1,\"661\":1,\"678\":1}}],[\"读写阻塞请求进程\",{\"1\":{\"380\":1}}],[\"读写操作频率很高的数据\",{\"1\":{\"149\":1}}],[\"读写不支持条件变量\",{\"1\":{\"125\":1}}],[\"读写互斥\",{\"1\":{\"125\":1,\"500\":1,\"522\":1,\"821\":1}}],[\"读写锁之间\",{\"1\":{\"511\":1}}],[\"读写锁的升降级策略\",{\"1\":{\"125\":1}}],[\"读写锁将变量切分成了两个部分\",{\"1\":{\"125\":1}}],[\"读写锁机制是基于\",{\"1\":{\"125\":1}}],[\"读写锁维护了一个读锁和一个写锁\",{\"1\":{\"125\":1}}],[\"读写锁在同一时刻允许多个读线程访问\",{\"1\":{\"125\":1}}],[\"读写\",{\"1\":{\"78\":1}}],[\"读数据\",{\"1\":{\"73\":1}}],[\"读屏障\",{\"1\":{\"72\":2}}],[\"读到的还是旧值\",{\"1\":{\"72\":1}}],[\"读取缓冲区\",{\"1\":{\"1177\":1}}],[\"读取列\",{\"1\":{\"954\":1}}],[\"读取行\",{\"1\":{\"954\":1}}],[\"读取一行数据\",{\"1\":{\"952\":1}}],[\"读取一个静态字段\",{\"1\":{\"174\":1}}],[\"读取bean的xml配置文件\",{\"1\":{\"737\":1}}],[\"读取最新数据\",{\"1\":{\"523\":1}}],[\"读取了历史数据\",{\"1\":{\"523\":1}}],[\"读取了几行数据\",{\"1\":{\"521\":1}}],[\"读取已提交\",{\"1\":{\"522\":1}}],[\"读取未提交\",{\"1\":{\"522\":1}}],[\"读取时还要保证其他并发事务不能修改当前记录\",{\"1\":{\"499\":1}}],[\"读取时会对需要读到的所有表加共享锁\",{\"1\":{\"492\":1}}],[\"读取的都是同一份快照\",{\"1\":{\"523\":1}}],[\"读取的总是当前的最新数据\",{\"1\":{\"523\":1}}],[\"读取的是快照\",{\"1\":{\"523\":1}}],[\"读取的是记录的最新版本\",{\"1\":{\"499\":1}}],[\"读取的时候\",{\"1\":{\"72\":1}}],[\"读取共享变量之前\",{\"1\":{\"72\":1}}],[\"读取\",{\"1\":{\"66\":1,\"294\":2,\"337\":1,\"1087\":1}}],[\"看应当从哪一个接口把数据报发送出去\",{\"1\":{\"993\":1}}],[\"看https的工作原理\",{\"1\":{\"959\":1,\"1029\":1}}],[\"看其是否在刚才构建的\",{\"1\":{\"896\":1}}],[\"看一看2\",{\"1\":{\"884\":1}}],[\"看哪些连接发生了变化\",{\"1\":{\"829\":1}}],[\"看起来也更加直观\",{\"1\":{\"630\":1}}],[\"看是不是有消耗资源的sql在运行\",{\"1\":{\"562\":1}}],[\"看看系统是不是可以丢卒保帅\",{\"1\":{\"644\":1}}],[\"看看是否加载了额外的数据\",{\"1\":{\"559\":1}}],[\"看看存不存在\",{\"1\":{\"72\":1}}],[\"看前面并行的概念\",{\"1\":{\"144\":1}}],[\"看作一个环形数组\",{\"1\":{\"47\":1}}],[\"禁止指令重排\",{\"1\":{\"337\":1}}],[\"禁止指令重排序优化\",{\"1\":{\"296\":1}}],[\"禁止hotspot执行system\",{\"1\":{\"326\":1}}],[\"禁止\",{\"1\":{\"72\":1}}],[\"禁用\",{\"1\":{\"72\":2}}],[\"没排过序的\",{\"0\":{\"901\":1}}],[\"没问不说\",{\"1\":{\"632\":1}}],[\"没加索引\",{\"1\":{\"559\":1}}],[\"没法排序了\",{\"1\":{\"412\":1}}],[\"没修改至高速缓存\",{\"1\":{\"72\":1}}],[\"没有生命周期\",{\"1\":{\"1231\":1}}],[\"没有了头\",{\"1\":{\"1099\":1}}],[\"没有第三方监督审核\",{\"1\":{\"1045\":1}}],[\"没有结束标签\",{\"1\":{\"1035\":1}}],[\"没有拥塞\",{\"1\":{\"1019\":1}}],[\"没有缓冲\",{\"1\":{\"1006\":1}}],[\"没有缓存\",{\"1\":{\"368\":1}}],[\"没有表示数据长度的字段\",{\"1\":{\"1006\":1}}],[\"没有边界\",{\"1\":{\"1006\":1}}],[\"没有通过运输层的tcp\",{\"1\":{\"994\":1}}],[\"没有要求结点的左孩子的值和右孩子的值的大小关系\",{\"1\":{\"937\":1}}],[\"没有follower被选举为leader\",{\"1\":{\"866\":1}}],[\"没有指明partition的情况下\",{\"1\":{\"852\":1}}],[\"没有阻塞的情况下\",{\"1\":{\"830\":1}}],[\"没有数据\",{\"1\":{\"820\":1}}],[\"没有数据依赖的才会重排序\",{\"1\":{\"76\":1}}],[\"没有备用结点实时同步数据\",{\"1\":{\"674\":1}}],[\"没有获得锁的线程并不会进入排队队列\",{\"1\":{\"668\":1}}],[\"没有中心节点的说法\",{\"1\":{\"659\":1}}],[\"没有这个\",{\"1\":{\"641\":1}}],[\"没有再次被访问\",{\"1\":{\"632\":1}}],[\"没有原生的集群模式\",{\"1\":{\"610\":1}}],[\"没有因为可能出现死锁而导致的性能消耗\",{\"1\":{\"604\":1}}],[\"没有简单的方案\",{\"1\":{\"589\":1}}],[\"没有\",{\"1\":{\"577\":1}}],[\"没有视图概念\",{\"1\":{\"524\":1}}],[\"没有走任何索引时\",{\"1\":{\"503\":1}}],[\"没有命中缓存\",{\"1\":{\"490\":1}}],[\"没有排序效果\",{\"1\":{\"485\":1}}],[\"没有下标的概念\",{\"1\":{\"392\":1}}],[\"没有区别\",{\"1\":{\"381\":1}}],[\"没有被分配空间\",{\"1\":{\"615\":1}}],[\"没有被外部强引用的情况下\",{\"1\":{\"300\":1}}],[\"没有被其他\",{\"1\":{\"72\":1}}],[\"没有则标识为0\",{\"1\":{\"249\":1}}],[\"没有必要执行\",{\"1\":{\"236\":1}}],[\"没有任何引用链相连的话\",{\"1\":{\"234\":1}}],[\"没有父加载器\",{\"1\":{\"176\":1}}],[\"没有受到保护\",{\"1\":{\"101\":1,\"714\":1}}],[\"没有地方放\",{\"1\":{\"88\":1}}],[\"没有在synchronized的代码块中\",{\"1\":{\"101\":1,\"714\":1}}],[\"没有在\",{\"1\":{\"71\":1}}],[\"没有调用这些方法时\",{\"1\":{\"46\":1}}],[\"没有调用线程的\",{\"1\":{\"34\":1}}],[\"没有足够的内存提供给申请者使用\",{\"1\":{\"45\":1}}],[\"没有实现接口的类不能使用\",{\"1\":{\"727\":1}}],[\"没有实现\",{\"1\":{\"42\":1}}],[\"没有设置\",{\"1\":{\"38\":2}}],[\"了或者出现了网络分区\",{\"1\":{\"672\":1}}],[\"了不到2\",{\"1\":{\"297\":1}}],[\"了就直接返回了\",{\"1\":{\"101\":1,\"1068\":1}}],[\"了\",{\"1\":{\"72\":1,\"199\":1,\"368\":1,\"442\":1,\"617\":1,\"627\":1,\"870\":2,\"1061\":2}}],[\"值与partition均无的情况下\",{\"1\":{\"852\":1}}],[\"值大则胜出\",{\"1\":{\"820\":1}}],[\"值对象的关系\",{\"0\":{\"1233\":1}}],[\"值对象没有唯一标识\",{\"1\":{\"1231\":1}}],[\"值对象\",{\"0\":{\"1231\":1},\"1\":{\"1218\":1,\"1236\":1,\"1239\":1,\"1243\":1}}],[\"值对象缩减比较复杂\",{\"1\":{\"637\":1}}],[\"值对\",{\"1\":{\"1035\":1}}],[\"值对数组长度取模运算\",{\"1\":{\"404\":1}}],[\"值一样按照\",{\"1\":{\"630\":1}}],[\"值排序\",{\"1\":{\"620\":1,\"630\":1}}],[\"值的两个元素的左边元素的下标\",{\"1\":{\"913\":1}}],[\"值的两个元素的右边元素的下标\",{\"1\":{\"912\":1}}],[\"值的\",{\"1\":{\"566\":1,\"678\":2}}],[\"值的大小确定加锁的先后\",{\"1\":{\"98\":1}}],[\"值越大\",{\"1\":{\"556\":1}}],[\"值存储在索引表中\",{\"1\":{\"537\":1}}],[\"值都将不会被包含在索引中\",{\"1\":{\"535\":1}}],[\"值随机插入\",{\"1\":{\"412\":1}}],[\"值找到相应的\",{\"1\":{\"410\":1}}],[\"值新增的那个\",{\"1\":{\"406\":1}}],[\"值做\",{\"1\":{\"405\":1}}],[\"值范围为\",{\"1\":{\"405\":1}}],[\"值传递是对基本型变量而言的\",{\"1\":{\"351\":1}}],[\"值传递是指在调用函数时将实际参数复制一份传递到函数中\",{\"1\":{\"351\":1}}],[\"值传递和引用传递都是传递的栈空间中的内容\",{\"1\":{\"351\":1}}],[\"值传递与引用传递的区别\",{\"0\":{\"351\":1}}],[\"值是否相同\",{\"1\":{\"342\":1}}],[\"值是2的幂\",{\"1\":{\"262\":1}}],[\"值和新数组大小取余计算出原有对象加入新桶内的位置\",{\"1\":{\"406\":1}}],[\"值和\",{\"1\":{\"341\":1,\"400\":1,\"620\":1}}],[\"值相同的\",{\"1\":{\"537\":1}}],[\"值相同\",{\"1\":{\"341\":1,\"400\":1}}],[\"值为\",{\"1\":{\"111\":1,\"118\":1}}],[\"值\",{\"0\":{\"405\":1},\"1\":{\"72\":3,\"342\":1,\"367\":1,\"383\":1,\"400\":1,\"405\":1,\"407\":1,\"475\":1,\"477\":1,\"620\":1,\"630\":1,\"820\":1,\"876\":1,\"892\":1,\"919\":1,\"1035\":1}}],[\"修复的速度也比\",{\"1\":{\"652\":1}}],[\"修改后的\",{\"1\":{\"1266\":1}}],[\"修改文件名为\",{\"1\":{\"1206\":1}}],[\"修改文件权限有两种使用格式\",{\"1\":{\"433\":1}}],[\"修改文件权限\",{\"0\":{\"433\":1}}],[\"修改伪造\",{\"1\":{\"1061\":1}}],[\"修改了发布内容\",{\"1\":{\"1057\":1}}],[\"修改消息内容\",{\"1\":{\"867\":1}}],[\"修改配置文件\",{\"1\":{\"657\":1,\"677\":1}}],[\"修改字符串最多执行\",{\"1\":{\"624\":1}}],[\"修改字符串\",{\"1\":{\"624\":1}}],[\"修改和删除会在\",{\"1\":{\"623\":1}}],[\"修改和删除是需要加锁的\",{\"1\":{\"522\":1}}],[\"修改数据时\",{\"1\":{\"575\":1}}],[\"修改慢查询时间为3秒\",{\"1\":{\"557\":1}}],[\"修改等功能\",{\"1\":{\"388\":1}}],[\"修改\",{\"1\":{\"296\":1,\"1124\":1}}],[\"修改类加载方式\",{\"1\":{\"180\":1}}],[\"修改位\",{\"1\":{\"160\":1}}],[\"修改一个\",{\"1\":{\"81\":1}}],[\"修改的数据可以马上暴露给其他\",{\"1\":{\"72\":1}}],[\"修改了\",{\"1\":{\"72\":1}}],[\"修改完\",{\"1\":{\"72\":1}}],[\"修饰来保证线程安全\",{\"1\":{\"393\":1}}],[\"修饰了\",{\"1\":{\"370\":1}}],[\"修饰内部类\",{\"1\":{\"360\":1}}],[\"修饰一个类时\",{\"1\":{\"355\":1}}],[\"修饰一个类\",{\"1\":{\"346\":1}}],[\"修饰一个方法\",{\"1\":{\"346\":1}}],[\"修饰一个引用\",{\"1\":{\"346\":1}}],[\"修饰一个变量\",{\"1\":{\"346\":1}}],[\"修饰\",{\"0\":{\"371\":1},\"1\":{\"130\":1,\"174\":1,\"355\":2,\"362\":2,\"409\":1,\"410\":1}}],[\"修饰代码块或者方法里才能调用wait\",{\"1\":{\"85\":1}}],[\"修饰代码块\",{\"1\":{\"83\":1}}],[\"修饰静态方法\",{\"1\":{\"83\":1}}],[\"修饰非静态方法\",{\"1\":{\"83\":1}}],[\"修饰方法\",{\"0\":{\"83\":1}}],[\"修饰的是一个引用变量\",{\"1\":{\"371\":1}}],[\"修饰的域成为最终域\",{\"1\":{\"370\":1}}],[\"修饰的递归方法\",{\"1\":{\"96\":1}}],[\"修饰的方法并没有\",{\"1\":{\"82\":1}}],[\"修饰的\",{\"1\":{\"81\":1}}],[\"修饰的变量一旦赋值\",{\"1\":{\"370\":1}}],[\"修饰的变量值不会被持久化和恢复\",{\"1\":{\"364\":1}}],[\"修饰的变量和方法只能在当前类中使用\",{\"1\":{\"358\":1}}],[\"修饰的变量\",{\"1\":{\"71\":1}}],[\"修饰的代码是单线程执行的\",{\"1\":{\"71\":1}}],[\"修饰的代码块中使用时运行时会抛出\",{\"1\":{\"35\":1}}],[\"修饰的代码块中使用\",{\"1\":{\"35\":2}}],[\"修饰符不管是否相同\",{\"1\":{\"289\":1}}],[\"修饰符\",{\"1\":{\"26\":1}}],[\"再发送a请求剩下的部分\",{\"1\":{\"1042\":1}}],[\"再经过\",{\"1\":{\"1027\":1}}],[\"再按序交付上层的应用进程\",{\"1\":{\"1015\":1}}],[\"再按顺序执行打包的所有命令\",{\"1\":{\"665\":1}}],[\"再看左边\",{\"1\":{\"935\":1}}],[\"再看一级缓存中有没有\",{\"1\":{\"752\":1}}],[\"再对全体记录进行一次直接插入排序\",{\"1\":{\"933\":1}}],[\"再对索引记录两边的间隙加上间隙锁\",{\"1\":{\"505\":1}}],[\"再散列函数法\",{\"1\":{\"924\":1}}],[\"再放入右\",{\"1\":{\"908\":1}}],[\"再放左\",{\"1\":{\"908\":1}}],[\"再放右\",{\"1\":{\"908\":1}}],[\"再压左孩子\",{\"1\":{\"908\":1}}],[\"再然后把这个文件为又分成两类\",{\"1\":{\"901\":1}}],[\"再依据常规的排序算法得到总体上出现次数最多的\",{\"1\":{\"892\":1}}],[\"再找出每个小文中出现频率最大的ip\",{\"1\":{\"892\":1}}],[\"再选另外一台服务调用\",{\"1\":{\"811\":1}}],[\"再选择另一台调用\",{\"1\":{\"810\":1}}],[\"再到maven的中央仓库下载所需jar包\",{\"1\":{\"794\":1}}],[\"再顺带拷贝哈希表\",{\"1\":{\"615\":1}}],[\"再说一下\",{\"1\":{\"604\":1}}],[\"再在内存中合并数据\",{\"1\":{\"587\":1}}],[\"再比如说有用户表user\",{\"1\":{\"587\":1}}],[\"再写\",{\"1\":{\"578\":1}}],[\"再写磁盘\",{\"1\":{\"489\":1,\"569\":1}}],[\"再把发送缓存中的所有数据组装成一个报文段发送出去\",{\"1\":{\"1017\":1}}],[\"再把这个地址写入mac帧\",{\"1\":{\"986\":1}}],[\"再把位数组的这几个位置都置为\",{\"1\":{\"645\":1}}],[\"再把\",{\"1\":{\"571\":1}}],[\"再做出相应的调整\",{\"1\":{\"562\":1}}],[\"再重新跑这些\",{\"1\":{\"562\":1}}],[\"再由主键值通过聚簇索引定位到行记录\",{\"1\":{\"549\":1}}],[\"再通过\",{\"1\":{\"961\":1}}],[\"再通过控制器\",{\"1\":{\"754\":1}}],[\"再通过数据页中的page\",{\"1\":{\"547\":1}}],[\"再通过主键值找到数据行的数据页\",{\"1\":{\"547\":1}}],[\"再进行操作\",{\"1\":{\"955\":1}}],[\"再进行了一次当前读\",{\"1\":{\"523\":1}}],[\"再进入到\",{\"1\":{\"416\":1}}],[\"再申请下一个\",{\"1\":{\"468\":1}}],[\"再删除主表\",{\"1\":{\"463\":1}}],[\"再与高\",{\"1\":{\"405\":1}}],[\"再根据\",{\"1\":{\"396\":1}}],[\"再调用引擎接口写入这行新数据\",{\"1\":{\"489\":1}}],[\"再调用\",{\"1\":{\"356\":1}}],[\"再去调用子类的同名方法\",{\"1\":{\"355\":1}}],[\"再有一个工具类\",{\"1\":{\"349\":1}}],[\"再加ｘ锁\",{\"1\":{\"514\":1}}],[\"再加上icmp差错报告报文本来的前8个字节\",{\"1\":{\"993\":1}}],[\"再加上一些控制信息组成的首部\",{\"1\":{\"960\":1}}],[\"再加上\",{\"1\":{\"409\":1}}],[\"再加上被final修饰的方法\",{\"1\":{\"275\":1}}],[\"再加锁统计所有\",{\"1\":{\"129\":1}}],[\"再清理掉整个旧region的全部空间\",{\"1\":{\"264\":1}}],[\"再次确保主分支最新\",{\"1\":{\"1127\":1}}],[\"再次扫描一次\",{\"1\":{\"251\":1}}],[\"再次向主存读取的时候\",{\"1\":{\"72\":1}}],[\"再用这个哈希值通过哈希运算定位到\",{\"1\":{\"129\":1}}],[\"再用\",{\"1\":{\"98\":1}}],[\"再将数据传给\",{\"1\":{\"986\":1}}],[\"再将这个\",{\"1\":{\"878\":1}}],[\"再将这个记录过引用关系的对象为根\",{\"1\":{\"251\":2}}],[\"再将重做日志缓冲刷新到磁盘上的重做日志文件\",{\"1\":{\"568\":1}}],[\"再将doublewrite\",{\"1\":{\"496\":1,\"593\":1}}],[\"再将内存空间分为大小相同的内存块\",{\"1\":{\"153\":1}}],[\"再将各段分页\",{\"1\":{\"153\":1}}],[\"再将\",{\"1\":{\"72\":1}}],[\"再从主内存中获取最新值\",{\"1\":{\"69\":1}}],[\"发散阶段\",{\"0\":{\"1218\":1}}],[\"发给服务器\",{\"1\":{\"1042\":1}}],[\"发往同一个\",{\"1\":{\"856\":1}}],[\"发投票信息\",{\"1\":{\"820\":1}}],[\"发出fin报文段\",{\"1\":{\"1026\":1}}],[\"发出一个段后\",{\"1\":{\"1009\":1}}],[\"发出一个执行若干过程请求\",{\"1\":{\"801\":1}}],[\"发出中断信号\",{\"1\":{\"134\":1}}],[\"发表了一篇\",{\"1\":{\"687\":1}}],[\"发来的同步连接命令\",{\"1\":{\"661\":1}}],[\"发送密文的一方使用对方的公钥进行加密处理\",{\"1\":{\"1056\":1}}],[\"发送缓存用来暂时存放\",{\"1\":{\"1015\":1}}],[\"发送缓冲区的写命令\",{\"1\":{\"655\":1}}],[\"发送方使用摘要算法获得发布内容的摘要\",{\"1\":{\"1057\":1}}],[\"发送方知道只是丢失了个别的报文段\",{\"1\":{\"1019\":1}}],[\"发送方控制拥塞窗口的原则\",{\"1\":{\"1019\":1}}],[\"发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个\",{\"1\":{\"1019\":1}}],[\"发送方要维持一个拥塞窗口\",{\"1\":{\"1019\":1}}],[\"发送方也不要发送太小的报文段\",{\"1\":{\"1018\":1}}],[\"发送方发送的ip数据报是41字节长\",{\"1\":{\"1018\":1}}],[\"发送方又发来1个字节的数据\",{\"1\":{\"1018\":1}}],[\"发送方一般不能再发送数据报\",{\"1\":{\"1015\":1}}],[\"发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据\",{\"1\":{\"1015\":1}}],[\"发送方维持一个发送窗口\",{\"1\":{\"1011\":1}}],[\"发送方产生粘包\",{\"1\":{\"1006\":1}}],[\"发送端的一个计时器期限到了\",{\"1\":{\"1016\":1}}],[\"发送端收到了\",{\"1\":{\"1004\":1}}],[\"发送端发送数据时\",{\"1\":{\"1004\":1}}],[\"发送端和消费端开启多线程生产和消费\",{\"1\":{\"865\":1}}],[\"发送的最后一个\",{\"1\":{\"1027\":1}}],[\"发送的时候既不合并\",{\"1\":{\"1006\":1}}],[\"发送的\",{\"1\":{\"994\":1}}],[\"发送主机无法确定数据报是否到达目标主机\",{\"1\":{\"992\":1}}],[\"发送到本站的帧\",{\"1\":{\"979\":1}}],[\"发送数据就是简单的把数据包封装一下\",{\"1\":{\"1001\":1}}],[\"发送数据有错误就丢弃\",{\"1\":{\"961\":1}}],[\"发送数据时\",{\"1\":{\"961\":1,\"1057\":1}}],[\"发送和消费端都启动多线程来提高并发度\",{\"1\":{\"865\":1}}],[\"发送请求\",{\"0\":{\"836\":1}}],[\"发送一个心跳\",{\"1\":{\"802\":1}}],[\"发送指令\",{\"1\":{\"677\":2}}],[\"发送消息\",{\"1\":{\"673\":1}}],[\"发送特定类型的消息时\",{\"1\":{\"673\":1}}],[\"发送给本地域名服务器\",{\"1\":{\"1031\":1}}],[\"发送给本局域网上一部分站点的帧\",{\"1\":{\"979\":1}}],[\"发送给局域网上所有站点的帧\",{\"1\":{\"979\":1}}],[\"发送给不同的订阅者时\",{\"1\":{\"850\":1}}],[\"发送给客户端\",{\"1\":{\"804\":1}}],[\"发送给\",{\"1\":{\"662\":1}}],[\"发送同步期间新写命令到从库阶段\",{\"1\":{\"662\":1}}],[\"发送相同的写命令\",{\"1\":{\"655\":1}}],[\"发送快照文件\",{\"1\":{\"655\":1}}],[\"发送\",{\"1\":{\"655\":1,\"677\":1,\"878\":1,\"959\":1,\"1026\":1,\"1029\":1}}],[\"发送该数据状态为\",{\"1\":{\"72\":1}}],[\"发布\",{\"1\":{\"1229\":1}}],[\"发布及订阅消息\",{\"0\":{\"673\":1}}],[\"发布订阅\",{\"1\":{\"603\":1,\"673\":1}}],[\"发布一个版本时\",{\"1\":{\"450\":1}}],[\"发现他的范围很小\",{\"1\":{\"902\":1}}],[\"发现自己的\",{\"1\":{\"876\":1}}],[\"发现死锁后\",{\"1\":{\"516\":1}}],[\"发现这个线程\",{\"1\":{\"88\":1}}],[\"发起合并请求\",{\"1\":{\"1127\":1}}],[\"发起了较多的攻击报文\",{\"1\":{\"1060\":1}}],[\"发起三次握手\",{\"1\":{\"959\":1,\"1029\":1}}],[\"发起投票参与竞选\",{\"1\":{\"874\":1}}],[\"发起\",{\"1\":{\"380\":2,\"657\":1}}],[\"发生过多的数据迁移\",{\"1\":{\"880\":1}}],[\"发生变化时\",{\"1\":{\"817\":1}}],[\"发生死锁调试命令\",{\"0\":{\"700\":1}}],[\"发生了交换就将flag赋为true\",{\"1\":{\"930\":1}}],[\"发生了宕机\",{\"1\":{\"683\":1}}],[\"发生了变化\",{\"1\":{\"665\":1}}],[\"发生在tcp三次握手阶段\",{\"1\":{\"1054\":1}}],[\"发生在\",{\"1\":{\"665\":1}}],[\"发生在编译阶段\",{\"1\":{\"277\":1}}],[\"发生内存泄漏的方法只会执行一次\",{\"1\":{\"303\":1}}],[\"发生泄漏的代码会被多次执行\",{\"1\":{\"303\":1}}],[\"发生时\",{\"1\":{\"144\":1}}],[\"发生上下文切换\",{\"1\":{\"105\":1}}],[\"发过来响应消息\",{\"1\":{\"72\":1}}],[\"之上\",{\"1\":{\"1004\":1}}],[\"之外的请求\",{\"1\":{\"665\":1}}],[\"之类的设置\",{\"1\":{\"582\":1}}],[\"之内获取到锁则返回\",{\"1\":{\"517\":1}}],[\"之间枚举值的映射\",{\"0\":{\"1259\":1}}],[\"之间是\",{\"1\":{\"427\":1}}],[\"之间创建物理内存映射文件加快缓冲区数据读\",{\"1\":{\"378\":1}}],[\"之间的报文映射为例总结\",{\"1\":{\"1249\":1}}],[\"之间的\",{\"0\":{\"1123\":1}}],[\"之间的元素个数\",{\"1\":{\"919\":1}}],[\"之间的关系\",{\"1\":{\"725\":1}}],[\"之间的哈希槽\",{\"1\":{\"659\":1}}],[\"之间的随机数\",{\"1\":{\"630\":1}}],[\"之间的数会放到一个名为cache的数组中缓存\",{\"1\":{\"368\":1}}],[\"之间的对应关系\",{\"1\":{\"292\":1}}],[\"之间\",{\"1\":{\"368\":1}}],[\"之间有什么区别\",{\"1\":{\"345\":1}}],[\"之间所有无效的\",{\"1\":{\"301\":1}}],[\"之间碰撞的\",{\"1\":{\"301\":1}}],[\"之所以是部分提交\",{\"1\":{\"520\":1}}],[\"之所以出现快照读的情况\",{\"1\":{\"499\":1}}],[\"之所以效率低是因为所有线程都必须竞争同一把锁\",{\"1\":{\"129\":1}}],[\"之所以用int而不是boolean是因为共享模式时\",{\"1\":{\"110\":1,\"111\":1}}],[\"之前就失去了直接的联系\",{\"1\":{\"718\":1}}],[\"之前版本都不识别该\",{\"1\":{\"653\":1}}],[\"之前提交的记录都不会丢失\",{\"1\":{\"568\":1}}],[\"之前不能包含是因为\",{\"1\":{\"362\":1}}],[\"之前泛型类中的类型参数部分如果没有指定上限\",{\"1\":{\"345\":1}}],[\"之前的版本开发二进制类库进行兼容\",{\"1\":{\"345\":1}}],[\"之前\",{\"1\":{\"220\":1,\"345\":1,\"362\":1,\"409\":1,\"514\":1,\"663\":1,\"665\":1}}],[\"之前累加过的\",{\"1\":{\"129\":1}}],[\"之前对变量的写\",{\"1\":{\"102\":1}}],[\"之前在修改的同时会告诉其他\",{\"1\":{\"72\":1}}],[\"之后报错\",{\"1\":{\"1212\":1}}],[\"之后可以正常编译出\",{\"1\":{\"1206\":1}}],[\"之后可以成为这个\",{\"1\":{\"878\":1}}],[\"之后默认就是响应式的\",{\"1\":{\"1159\":1}}],[\"之后就close了\",{\"1\":{\"1026\":1}}],[\"之后服务器b进入close\",{\"1\":{\"1026\":1}}],[\"之后路由器再找到子网\",{\"1\":{\"989\":1}}],[\"之后弹出打印节点\",{\"1\":{\"908\":1}}],[\"之后我们根据统计结果就可以判断中位数落到那个区域\",{\"1\":{\"886\":1}}],[\"之后有了\",{\"1\":{\"882\":1}}],[\"之后再启动的服务器不管\",{\"1\":{\"820\":1}}],[\"之后包含相同业务\",{\"1\":{\"807\":1}}],[\"之后和jdk代理一样设置代理类是什么\",{\"1\":{\"726\":1}}],[\"之后领导开始招人\",{\"1\":{\"690\":1}}],[\"之后的版本会将断线期间的命令传给从数据库\",{\"1\":{\"655\":1}}],[\"之后的假设用的\",{\"1\":{\"628\":1}}],[\"之后所有命令都会直接追加到新\",{\"1\":{\"651\":1}}],[\"之后修改语句或者修改索引\",{\"1\":{\"559\":1}}],[\"之后会拿到对语句的分析\",{\"1\":{\"556\":1}}],[\"之后通过doublewrite\",{\"1\":{\"496\":1}}],[\"之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据\",{\"1\":{\"490\":1}}],[\"之后要改成尾插法\",{\"0\":{\"403\":1}}],[\"之后取得所定位的桶\",{\"1\":{\"398\":1}}],[\"之后没有任何机制再次对其设置值\",{\"1\":{\"119\":1}}],[\"之后不能控制是否开启自旋功能\",{\"1\":{\"91\":1}}],[\"之后自旋锁是自适应的\",{\"1\":{\"91\":1}}],[\"之后如果再次执行锁重入时\",{\"1\":{\"88\":1}}],[\"之后\",{\"1\":{\"85\":1,\"121\":1,\"126\":1,\"159\":1,\"247\":1,\"398\":1,\"403\":1,\"653\":1,\"665\":2,\"730\":1,\"1025\":1}}],[\"之中\",{\"1\":{\"34\":1}}],[\"大学既有软件专业又有生物专业等\",{\"1\":{\"1079\":1}}],[\"大约需要512m\",{\"1\":{\"901\":1}}],[\"大约有一万行\",{\"0\":{\"899\":1}}],[\"大约会在整个electiontimeout的时间内不可用\",{\"1\":{\"879\":1}}],[\"大数据的排序\",{\"1\":{\"889\":1}}],[\"大数据量的增删改查\",{\"1\":{\"887\":1}}],[\"大数据判断是否存在\",{\"1\":{\"645\":1}}],[\"大的方面可以分为\",{\"1\":{\"1065\":1}}],[\"大的数\",{\"0\":{\"936\":1}}],[\"大的胜出\",{\"1\":{\"820\":1}}],[\"大的\",{\"1\":{\"820\":1}}],[\"大三下决定考研\",{\"1\":{\"689\":1}}],[\"大容量或高性能的业务需求\",{\"1\":{\"676\":1}}],[\"大致思想为\",{\"1\":{\"668\":1}}],[\"大致估算出找到所需的记录所需要读取的行数\",{\"1\":{\"556\":1}}],[\"大体可以分为\",{\"1\":{\"662\":1}}],[\"大于等于配置文件指定的值\",{\"1\":{\"657\":1,\"677\":1}}],[\"大家还是竞争同一个物理机的cpu\",{\"1\":{\"585\":1}}],[\"大量的自动配置\",{\"1\":{\"768\":1}}],[\"大量冗余的代码\",{\"1\":{\"746\":1}}],[\"大量请求直接打到数据库\",{\"1\":{\"645\":1}}],[\"大量使用\",{\"1\":{\"637\":1}}],[\"大量积压\",{\"1\":{\"582\":1}}],[\"大量热数据淘汰\",{\"1\":{\"495\":1}}],[\"大大提升了http的效率\",{\"1\":{\"1042\":1}}],[\"大大提高\",{\"1\":{\"655\":1,\"661\":1}}],[\"大大提高了并发度\",{\"1\":{\"130\":1}}],[\"大大减少检索的数据量\",{\"1\":{\"528\":1}}],[\"大端模式\",{\"1\":{\"347\":1}}],[\"大端模式和小端模式\",{\"0\":{\"347\":1}}],[\"大内存\",{\"1\":{\"268\":1}}],[\"大内核\",{\"0\":{\"133\":1},\"1\":{\"133\":1}}],[\"大部分\",{\"1\":{\"804\":1}}],[\"大部分场景来说不会使用这两者当做缓存\",{\"1\":{\"607\":1}}],[\"大部分关系型数据库都支持事务的四大特性\",{\"1\":{\"456\":1}}],[\"大部分关系型数据库都使用\",{\"1\":{\"456\":1}}],[\"大部分文件系统规定\",{\"1\":{\"442\":1}}],[\"大部分对象都死得早\",{\"1\":{\"240\":1}}],[\"大部分情况下\",{\"1\":{\"106\":1}}],[\"大对象直接分配到old\",{\"1\":{\"220\":1}}],[\"大写p\",{\"1\":{\"201\":2}}],[\"大概10几m字节的内存即可\",{\"1\":{\"883\":1}}],[\"大概需要99m个bit\",{\"1\":{\"883\":1}}],[\"大概\",{\"1\":{\"405\":1}}],[\"大概有四种方式\",{\"1\":{\"728\":1}}],[\"大概有\",{\"1\":{\"149\":1}}],[\"大概的原理就是当每个\",{\"1\":{\"72\":1}}],[\"大小的两倍\",{\"1\":{\"615\":1}}],[\"大小同样为2mb\",{\"1\":{\"496\":1}}],[\"大小进行分割切块\",{\"1\":{\"442\":1}}],[\"大小为2mb\",{\"1\":{\"496\":1}}],[\"大小为\",{\"1\":{\"399\":2}}],[\"大小\",{\"1\":{\"129\":1,\"610\":1}}],[\"大多数网点不需花精力就能维护数据库的一致性\",{\"1\":{\"1032\":1}}],[\"大多数情况下\",{\"1\":{\"88\":1}}],[\"大多基于\",{\"1\":{\"18\":1}}],[\"缓冲池大小\",{\"1\":{\"1177\":1}}],[\"缓冲池中的内存页有三种状态\",{\"1\":{\"594\":1}}],[\"缓冲池污染\",{\"1\":{\"495\":1}}],[\"缓冲池的常见管理算法是lru\",{\"1\":{\"495\":1}}],[\"缓冲池通常以页\",{\"1\":{\"495\":1}}],[\"缓冲池是一种常见的降低磁盘访问的机制\",{\"1\":{\"495\":1}}],[\"缓冲池\",{\"0\":{\"495\":1},\"1\":{\"1091\":1}}],[\"缓冲区数据发送是一个堆压的过程\",{\"1\":{\"1006\":1}}],[\"缓冲区\",{\"1\":{\"71\":1,\"377\":1}}],[\"缓存中存放的数据到达mss\",{\"1\":{\"1016\":1}}],[\"缓存中占用空间更少\",{\"1\":{\"535\":1}}],[\"缓存查询原理\",{\"1\":{\"752\":1}}],[\"缓存被均匀分布的概率就越大\",{\"1\":{\"681\":1}}],[\"缓存使用时无需备用结点\",{\"1\":{\"674\":1}}],[\"缓存降级\",{\"0\":{\"644\":1}}],[\"缓存击穿指并发查同一条数据\",{\"1\":{\"643\":1}}],[\"缓存击穿是指缓存中没有但数据库中有的数据\",{\"1\":{\"643\":1}}],[\"缓存击穿\",{\"0\":{\"643\":1}}],[\"缓存数据的过期时间设置随机\",{\"1\":{\"642\":1}}],[\"缓存数据设置的过期时间是相同的\",{\"1\":{\"642\":1}}],[\"缓存雪崩是不同数据都过期了\",{\"1\":{\"643\":1}}],[\"缓存雪崩是指缓存同一时间大面积的失效\",{\"1\":{\"642\":1}}],[\"缓存雪崩\",{\"0\":{\"642\":1}}],[\"缓存空对象\",{\"1\":{\"641\":1}}],[\"缓存穿透是指查询一个不存在的数据\",{\"1\":{\"641\":1}}],[\"缓存穿透\",{\"0\":{\"641\":1},\"1\":{\"645\":1}}],[\"缓存预热是指系统上线后\",{\"1\":{\"640\":1}}],[\"缓存预热\",{\"0\":{\"640\":1}}],[\"缓存异常\",{\"0\":{\"639\":1}}],[\"缓存不具有一致性\",{\"1\":{\"609\":1}}],[\"缓存分为本地缓存和分布式缓存\",{\"1\":{\"609\":1}}],[\"缓存是深拷贝\",{\"1\":{\"608\":1}}],[\"缓存带来的优势\",{\"1\":{\"606\":1}}],[\"缓存热点数据\",{\"1\":{\"603\":1}}],[\"缓存的副本\",{\"1\":{\"608\":1}}],[\"缓存的命中率也会比b树高\",{\"1\":{\"541\":1}}],[\"缓存的优化\",{\"1\":{\"72\":1}}],[\"缓存\",{\"1\":{\"368\":2,\"493\":1,\"713\":1,\"1124\":1}}],[\"缓存泄漏\",{\"1\":{\"304\":1}}],[\"缓存一致性协议去维护内部缓存和其他处理器缓存的一致性\",{\"1\":{\"296\":1}}],[\"缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域\",{\"1\":{\"296\":1}}],[\"缓存优化在\",{\"1\":{\"72\":1}}],[\"缓存优化\",{\"1\":{\"72\":1}}],[\"缓存行\",{\"1\":{\"72\":1}}],[\"缓存锁是锁缓存行\",{\"1\":{\"72\":1}}],[\"双重检查锁定的问题是\",{\"1\":{\"1068\":1}}],[\"双重检测锁\",{\"0\":{\"1068\":1}}],[\"双重校验锁存在一个问题\",{\"1\":{\"101\":1}}],[\"双重校验锁\",{\"0\":{\"101\":1,\"714\":1}}],[\"双重校验锁不加\",{\"1\":{\"71\":1}}],[\"双方便开始通信\",{\"1\":{\"1022\":1}}],[\"双方在连接不断开的情况下\",{\"1\":{\"1006\":1}}],[\"双层校验锁\",{\"1\":{\"1065\":1}}],[\"双层只是一个例子\",{\"1\":{\"886\":1}}],[\"双层桶划分\",{\"0\":{\"886\":1}}],[\"双堆\",{\"1\":{\"885\":1}}],[\"双十一关闭修改收获地址的服务\",{\"1\":{\"644\":1}}],[\"双端\",{\"1\":{\"626\":1}}],[\"双端队列\",{\"1\":{\"394\":1}}],[\"双向的关联可以用带两个箭头或者没有箭头的实线来表示\",{\"1\":{\"1097\":1}}],[\"双向同时通信\",{\"1\":{\"966\":1}}],[\"双向交替通信\",{\"1\":{\"966\":1}}],[\"双向链表的维护\",{\"1\":{\"414\":1}}],[\"双向\",{\"1\":{\"265\":1,\"469\":1,\"580\":1}}],[\"双向队列\",{\"1\":{\"109\":1}}],[\"双向队列即\",{\"1\":{\"109\":1}}],[\"双亲委派的逆向调用\",{\"1\":{\"185\":1}}],[\"双亲委派模型保证了java程序的稳定运行\",{\"1\":{\"184\":1}}],[\"双亲委派模型要求除了顶层的启动类加载器外\",{\"1\":{\"184\":1}}],[\"双亲委派模型\",{\"1\":{\"184\":1}}],[\"双亲委派机制\",{\"0\":{\"184\":1}}],[\"双亲委派\",{\"1\":{\"181\":1}}],[\"双指针\",{\"1\":{\"6\":1}}],[\"被依赖类\",{\"1\":{\"1096\":1}}],[\"被中间人劫持\",{\"1\":{\"1061\":1}}],[\"被盗用\",{\"0\":{\"1061\":1}}],[\"被动攻击\",{\"1\":{\"1054\":1}}],[\"被动攻击和主动攻击\",{\"0\":{\"1054\":1}}],[\"被动的解决死锁方式\",{\"1\":{\"98\":1}}],[\"被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射\",{\"1\":{\"888\":1}}],[\"被删除\",{\"1\":{\"817\":1}}],[\"被删除了\",{\"1\":{\"427\":1}}],[\"被标记为了已下线\",{\"1\":{\"683\":1}}],[\"被标记为主观下线\",{\"1\":{\"677\":1}}],[\"被当做一个持久化存储使用\",{\"1\":{\"638\":1}}],[\"被当做缓存使用\",{\"1\":{\"638\":1}}],[\"被命中\",{\"1\":{\"490\":1}}],[\"被union\",{\"1\":{\"485\":1}}],[\"被引用列应该具有主键约束或者唯一性约束\",{\"1\":{\"462\":1}}],[\"被许多的\",{\"1\":{\"369\":1}}],[\"被模块导出或者开放的包\",{\"1\":{\"286\":1}}],[\"被声明为final的常量值等\",{\"1\":{\"286\":1}}],[\"被多次执行的循环体\",{\"1\":{\"283\":1}}],[\"被多次调用的方法\",{\"1\":{\"283\":1}}],[\"被default关键字修饰的接口方法\",{\"1\":{\"174\":1}}],[\"被static修饰的变量\",{\"1\":{\"171\":2}}],[\"被打断后对变量的读可见\",{\"1\":{\"102\":1}}],[\"被其它线程抢走而长时间得不到运行\",{\"1\":{\"100\":1}}],[\"被\",{\"1\":{\"71\":1,\"295\":1,\"355\":1,\"364\":1,\"677\":1}}],[\"被调用的线程执行完毕\",{\"1\":{\"38\":2}}],[\"qq\",{\"1\":{\"961\":1,\"1202\":2}}],[\"quic\",{\"1\":{\"1042\":4}}],[\"quickstart\",{\"1\":{\"1179\":1}}],[\"quicksort\",{\"1\":{\"935\":8}}],[\"quick\",{\"1\":{\"938\":1,\"1042\":1}}],[\"quicklist\",{\"0\":{\"629\":1},\"1\":{\"618\":1,\"629\":1}}],[\"qualifier\",{\"1\":{\"743\":1}}],[\"querywrapper\",{\"1\":{\"1117\":1}}],[\"query\",{\"1\":{\"557\":3,\"558\":1,\"566\":3,\"701\":3,\"893\":2,\"895\":10,\"1177\":3,\"1238\":1}}],[\"quer\",{\"1\":{\"557\":1}}],[\"queue支持多个消费者\",{\"1\":{\"844\":1}}],[\"queue<t>\",{\"1\":{\"394\":1}}],[\"queue中的对象进行第二次小规模的标记\",{\"1\":{\"236\":1}}],[\"queue的队列之中\",{\"1\":{\"236\":1}}],[\"queue\",{\"0\":{\"394\":1},\"1\":{\"71\":1,\"72\":5,\"394\":2,\"840\":1}}],[\"q\",{\"0\":{\"1205\":1,\"1211\":1,\"1244\":1},\"1\":{\"312\":2,\"429\":2}}],[\"qps\",{\"1\":{\"64\":1}}],[\"现阶段各种第三方\",{\"1\":{\"1090\":1}}],[\"现有的\",{\"1\":{\"651\":1}}],[\"现象\",{\"1\":{\"295\":1}}],[\"现象和\",{\"1\":{\"295\":1}}],[\"现在觉得还是要懂一些复杂指令\",{\"1\":{\"1121\":1}}],[\"现在都是用token\",{\"1\":{\"1037\":1}}],[\"现在互联网的标准规定\",{\"1\":{\"989\":1}}],[\"现在常使用网络适配器来实现这些协议\",{\"1\":{\"971\":1}}],[\"现在遍历n个数\",{\"1\":{\"893\":1}}],[\"现在交由ioc容器\",{\"1\":{\"718\":1}}],[\"现在是所有对象都被spring控制\",{\"1\":{\"718\":1}}],[\"现在则把对象交给spring的ioc容器管理\",{\"1\":{\"718\":1}}],[\"现在项目已稳步推进\",{\"1\":{\"690\":1}}],[\"现在\",{\"1\":{\"651\":1}}],[\"现在同时拥有父进程和子进程\",{\"1\":{\"651\":1}}],[\"现在由于前一个\",{\"1\":{\"628\":1}}],[\"现在要加\",{\"1\":{\"533\":1}}],[\"现在就是\",{\"1\":{\"489\":1}}],[\"现在最常用的存储引擎是\",{\"1\":{\"488\":1}}],[\"现在可以包含了\",{\"1\":{\"362\":1}}],[\"现在的通信网络采用区别对待\",{\"1\":{\"974\":1}}],[\"现在的机器的内存应该能存下\",{\"1\":{\"898\":1}}],[\"现在的商用java虚拟机大多都优先采用了这种收集算法去回收新生代\",{\"1\":{\"245\":1}}],[\"现在的系统要求百万级甚至千万级的并发量\",{\"1\":{\"30\":1}}],[\"现在问题来了\",{\"1\":{\"185\":1}}],[\"现在启动类加载器\",{\"1\":{\"181\":1}}],[\"现在已经能做到在一根光纤上复用几十路或更多路数的光载波信号\",{\"1\":{\"967\":1}}],[\"现在已经创建完成\",{\"1\":{\"101\":1}}],[\"现在已经是重量级锁了\",{\"1\":{\"89\":1}}],[\"现代处理器采用了指令级并行技术来将多条指令重叠执行\",{\"1\":{\"71\":1}}],[\"将业务逻辑和技术\",{\"1\":{\"1242\":1}}],[\"将文件内的内容复制进个人\",{\"1\":{\"1202\":1}}],[\"将有复用价值的\",{\"1\":{\"1161\":1}}],[\"将本地\",{\"1\":{\"1127\":1}}],[\"将本线程生产出的数据传递给对方\",{\"1\":{\"127\":1}}],[\"将给\",{\"1\":{\"1068\":1}}],[\"将给单例对象指向分配的内存空间\",{\"1\":{\"101\":1}}],[\"将构造方法私有化\",{\"1\":{\"1066\":1}}],[\"将计算的摘要与解密的摘要进行比较\",{\"1\":{\"1057\":1}}],[\"将目的ip全置为1\",{\"1\":{\"1049\":1}}],[\"将重发这个报文段\",{\"1\":{\"1009\":1}}],[\"将丢弃这个报文段和不确认收到此报文段\",{\"1\":{\"1009\":1}}],[\"将保持它首部和数据的检验和\",{\"1\":{\"1009\":1}}],[\"将网络互联起来要使用一些中间设备\",{\"1\":{\"965\":1}}],[\"将应用处理的信息转换为适合网络传输的格式\",{\"1\":{\"961\":1}}],[\"将第2行的数存入数组\",{\"1\":{\"953\":1}}],[\"将第0项常量空出来目的在于\",{\"1\":{\"286\":1}}],[\"将剩下的size个元素重新调整成大顶堆\",{\"1\":{\"937\":1}}],[\"将剩下的前size个元素构成大顶堆\",{\"1\":{\"937\":1}}],[\"将arr\",{\"1\":{\"937\":1}}],[\"将最大值和堆中的最后一个元素交换\",{\"1\":{\"937\":2}}],[\"将最新结果与\",{\"1\":{\"105\":1}}],[\"将nums\",{\"1\":{\"935\":2,\"936\":1}}],[\"将helper中元素复制到arr中的对应位置\",{\"1\":{\"934\":1}}],[\"将左半部分数组的剩余部分复制到helper\",{\"1\":{\"934\":1}}],[\"将右半部分数组的剩余部分复制到helper\",{\"1\":{\"934\":1}}],[\"将原本大量记录数的记录进行分组\",{\"1\":{\"933\":1}}],[\"将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上\",{\"1\":{\"827\":1}}],[\"将它插入到有序表中的适当位置\",{\"1\":{\"932\":1}}],[\"将ip地址分类的好处\",{\"0\":{\"985\":1}}],[\"将i作为当前的最小值\",{\"1\":{\"931\":1}}],[\"将id和库的mapping关系记录在一个单独的库中\",{\"1\":{\"588\":1}}],[\"将所有冲突的元素放在一个公共溢出区\",{\"1\":{\"924\":1}}],[\"将所有关键字为同义词的记录存储在一个单链表中\",{\"1\":{\"924\":1}}],[\"将所有可能存在的数据哈希到一个足够大的\",{\"1\":{\"641\":1}}],[\"将关键字分割再做相加等处理\",{\"1\":{\"923\":1}}],[\"将排序好的\",{\"1\":{\"895\":1}}],[\"将bit\",{\"1\":{\"883\":1}}],[\"将beandefinition注册到了beanfactory之后\",{\"1\":{\"737\":1}}],[\"将bean元素分别转换成一个beandefinition对象\",{\"1\":{\"737\":1}}],[\"将元素添加进布隆过滤器\",{\"1\":{\"882\":1}}],[\"将来自同一ip地址的请求\",{\"1\":{\"869\":1}}],[\"将来无论什么时候\",{\"1\":{\"450\":1}}],[\"将请求分配到连接数最少的服务器上\",{\"1\":{\"869\":1}}],[\"将请求消息\",{\"1\":{\"755\":1}}],[\"将动态的内容转化为静态的内容之后\",{\"1\":{\"825\":1}}],[\"将拒绝本次服务请求\",{\"1\":{\"807\":1}}],[\"将多个项目同时运行就称为聚合\",{\"1\":{\"799\":1}}],[\"将需要进行差错报告的ip数据报的首部和数据字段的前8个字节提取出来\",{\"1\":{\"993\":1}}],[\"将需要继承的jar包的坐标放入标签即可\",{\"1\":{\"800\":1}}],[\"将需要排除的jar包的坐标写在中\",{\"1\":{\"796\":1}}],[\"将需要被序列化的类实现\",{\"1\":{\"344\":1}}],[\"将项目打成jar包\",{\"1\":{\"793\":1}}],[\"将java源文件编译成class文件\",{\"1\":{\"793\":1}}],[\"将springboot项目打包成两个jar\",{\"1\":{\"790\":1}}],[\"将stringtable放到了堆空间中\",{\"1\":{\"207\":1}}],[\"将state变量替换成新的值\",{\"1\":{\"96\":1}}],[\"将渲染结果返回给客户端\",{\"1\":{\"755\":1}}],[\"将模型数据填充到视图中\",{\"1\":{\"755\":1}}],[\"将字符串转换成格式化数字或格式化日期等\",{\"1\":{\"755\":1}}],[\"将帮你做一些额外的工作\",{\"1\":{\"755\":1}}],[\"将得到视图对象返回给用户\",{\"1\":{\"755\":1}}],[\"将web层进行职责解耦\",{\"1\":{\"754\":1}}],[\"将这些较小的数据包进行合并发送\",{\"1\":{\"1006\":1}}],[\"将这些模块分布在各个服务器上\",{\"1\":{\"809\":1}}],[\"将这些复杂的业务逻辑和数据逻辑分离\",{\"1\":{\"748\":1}}],[\"将这个值与topic可用的partition总数取余得到partition值\",{\"1\":{\"852\":1}}],[\"将这个操作记录更新到磁盘里面\",{\"1\":{\"489\":1,\"569\":1}}],[\"将这个要删除的引用记录下来\",{\"1\":{\"251\":1}}],[\"将这个引用记录下来\",{\"1\":{\"251\":1}}],[\"将这个⻚标记为脏⻚\",{\"1\":{\"247\":1}}],[\"将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\",{\"1\":{\"168\":1}}],[\"将事物之间的联系归纳为\",{\"1\":{\"1095\":1}}],[\"将事务规则应用到业务逻辑中\",{\"1\":{\"739\":1}}],[\"将事先保存在\",{\"1\":{\"729\":1}}],[\"将要发生的地方\",{\"1\":{\"721\":1}}],[\"将要得到的变量还是最新的\",{\"1\":{\"72\":1}}],[\"将要得到的变量数据是最新的\",{\"1\":{\"72\":1}}],[\"将核心关注点和横切关注点分离开来\",{\"1\":{\"719\":1}}],[\"将与业务无关\",{\"1\":{\"719\":1}}],[\"将单例对象指向分配的内存空间\",{\"1\":{\"714\":1}}],[\"将单张表的数据切分到多个服务器上去\",{\"1\":{\"585\":1}}],[\"将对应集合的交集\",{\"1\":{\"888\":1}}],[\"将对象转换为指定的响应信息\",{\"1\":{\"755\":1}}],[\"将对象集中处理\",{\"1\":{\"718\":1}}],[\"将对象连接在一起\",{\"1\":{\"718\":1}}],[\"将对象的控制权转移给spring\",{\"1\":{\"712\":1}}],[\"将对所有的\",{\"1\":{\"597\":1}}],[\"将消息提交改为手动提交\",{\"1\":{\"866\":1}}],[\"将消息平均发送到多个partition上\",{\"1\":{\"849\":1}}],[\"将消息推送给消费者\",{\"1\":{\"843\":1}}],[\"将消息发送到指定的频道\",{\"1\":{\"673\":1}}],[\"将消息类型称为通道\",{\"1\":{\"673\":1}}],[\"将发送缓冲区的所有写命令发送给\",{\"1\":{\"662\":1}}],[\"将使用与快照类似的方式\",{\"1\":{\"651\":1}}],[\"将收到的写命令都通过write函数追加到该文件的最后\",{\"1\":{\"649\":1}}],[\"将导致这个不存在的数据每次请求都要到数据库去查询\",{\"1\":{\"641\":1}}],[\"将该用户要访问的数据存在缓存中\",{\"1\":{\"606\":1}}],[\"将热点数据放到内存中\",{\"1\":{\"603\":1}}],[\"将userid为1~9999的记录分到第一个库\",{\"1\":{\"587\":1}}],[\"将系统中的不同业务进行拆分\",{\"1\":{\"585\":1}}],[\"将同一个表按不同的条件分散到多个数据库或多个表中\",{\"1\":{\"585\":1}}],[\"将同步状态值设置为给定值update如果当前同步状态的值等于expect\",{\"1\":{\"110\":1}}],[\"将备份的\",{\"1\":{\"576\":1}}],[\"将更新先记录到change\",{\"1\":{\"574\":1}}],[\"将前一部分同步到磁盘\",{\"1\":{\"568\":1}}],[\"将执行时间超过设定时间的\",{\"1\":{\"557\":1}}],[\"将相当于创建了三个索引\",{\"1\":{\"551\":1}}],[\"将被查询的字段\",{\"1\":{\"550\":1}}],[\"将索引结构与数据分开存储\",{\"1\":{\"546\":1}}],[\"将索引结构与数据放到了一块\",{\"1\":{\"546\":1}}],[\"将复杂\",{\"1\":{\"516\":1}}],[\"将复杂度降低到了\",{\"1\":{\"381\":1}}],[\"将参数\",{\"1\":{\"516\":1}}],[\"将主键索引值和唯一索引值加上记录锁\",{\"1\":{\"506\":1}}],[\"将主导权移交给应用程序\",{\"1\":{\"173\":1}}],[\"将页的大小设置为4k\",{\"1\":{\"498\":1}}],[\"将缓冲池分为老年代和新生代\",{\"1\":{\"495\":1}}],[\"将结果返回给客户端\",{\"1\":{\"489\":1}}],[\"将虚拟表vt9中的记录按照进行排序操作\",{\"1\":{\"487\":1}}],[\"将内容写入到本地的\",{\"1\":{\"469\":1,\"580\":1}}],[\"将内存空间的地址赋值给对应的引用\",{\"1\":{\"714\":1}}],[\"将内存空间分为一个个大小相等的页区\",{\"1\":{\"153\":1}}],[\"将内存缓存中的所有数据追加到新\",{\"1\":{\"651\":1}}],[\"将内存分为大小相同的两块\",{\"1\":{\"245\":1}}],[\"将内存中的数据以命令的方式保存到临时文件中\",{\"1\":{\"651\":1}}],[\"将内存中的所有页面都通过链接指针链成一个循环队列\",{\"1\":{\"160\":1}}],[\"将内存中暂时用不到的信息换出到\",{\"1\":{\"157\":1}}],[\"将输出信息过滤一部分\",{\"1\":{\"443\":1}}],[\"将磁盘按照固定数据块\",{\"1\":{\"442\":1}}],[\"将当前项目放到maven的本地仓库中\",{\"1\":{\"793\":1}}],[\"将当前目录下的所有文件列出来\",{\"1\":{\"419\":1}}],[\"将当前处理器缓存行的数据写回到系统内存\",{\"1\":{\"296\":1}}],[\"将以更加高效的方式进行文件的读写操作\",{\"1\":{\"377\":1}}],[\"将会得到新的单例\",{\"1\":{\"1075\":1}}],[\"将会开启另一个任期\",{\"1\":{\"876\":1}}],[\"将会采用\",{\"1\":{\"725\":1,\"726\":1}}],[\"将会把请求放入队列中排队\",{\"1\":{\"665\":1}}],[\"将会导致无法定位数据库\",{\"1\":{\"587\":1}}],[\"将会被合并\",{\"1\":{\"485\":1}}],[\"将会引起各种安全隐患\",{\"1\":{\"369\":1}}],[\"将会唤醒其后继节点\",{\"1\":{\"122\":1}}],[\"将影响到实际参数\",{\"1\":{\"351\":1}}],[\"将不会影响到实际参数\",{\"1\":{\"351\":1}}],[\"将其中一个文件中的url使用bloom\",{\"1\":{\"896\":1}}],[\"将其切换成新的\",{\"1\":{\"683\":1}}],[\"将其分成3个表user0\",{\"1\":{\"587\":1}}],[\"将其拆分到多个服务器上\",{\"1\":{\"585\":1}}],[\"将其初始化为git代码库\",{\"1\":{\"445\":1}}],[\"将其编译生成代理类的二进制码\",{\"1\":{\"349\":1}}],[\"将其删除以释放内存\",{\"1\":{\"231\":1}}],[\"将实现接口的类的对象传递给它\",{\"1\":{\"349\":1}}],[\"将一些商品信息先加载到缓存中\",{\"1\":{\"640\":1}}],[\"将一些使用较少的历史数据迁移到其他库中\",{\"1\":{\"587\":1}}],[\"将一定要执行的代码放在\",{\"1\":{\"346\":1}}],[\"将一个类的接口转换成客户希望的另外一个接口\",{\"1\":{\"1092\":1}}],[\"将一个网络划分为若干个子网\",{\"1\":{\"989\":1}}],[\"将一个对象存储在\",{\"1\":{\"622\":1}}],[\"将一个方法中包含的所有字节码编译成机器码后再执行\",{\"1\":{\"283\":1}}],[\"将一个\",{\"1\":{\"128\":1}}],[\"将具备两项特性\",{\"1\":{\"296\":1}}],[\"将在堆上创建对象\",{\"1\":{\"231\":1}}],[\"将在每一次运行期间都转化为直接引用\",{\"1\":{\"194\":1}}],[\"将尝试着进行一次\",{\"1\":{\"220\":1}}],[\"将年轻代划分出survivor区\",{\"1\":{\"200\":1}}],[\"将年轻代划分出survivor区的作用\",{\"0\":{\"200\":1}}],[\"将栈顶元素全部缓存在物理的cpu的寄存器中\",{\"1\":{\"193\":1}}],[\"将可重定位目标文件和\",{\"1\":{\"162\":1}}],[\"将汇编文件翻译成可重定位目标文件\",{\"1\":{\"162\":1}}],[\"将各页面分别装入内存块中\",{\"1\":{\"153\":1}}],[\"将进程按逻辑分段\",{\"1\":{\"153\":1}}],[\"将程序的地址空间按照程序自身的逻辑关系划分为若干个段\",{\"1\":{\"153\":1}}],[\"将程序状态字\",{\"1\":{\"134\":1}}],[\"将数据包封装成帧\",{\"1\":{\"961\":1}}],[\"将数据按照范围划分到不同的机子\",{\"1\":{\"891\":1}}],[\"将数据交给不同的机器去处理\",{\"1\":{\"891\":1}}],[\"将数据\",{\"1\":{\"681\":1}}],[\"将数据库的开\",{\"1\":{\"604\":1}}],[\"将数据页读入内存\",{\"1\":{\"574\":1}}],[\"将数据存储与索引放到了一块\",{\"1\":{\"547\":1}}],[\"将数据的\",{\"1\":{\"144\":1}}],[\"将数据状态从共享变为\",{\"1\":{\"72\":1}}],[\"将占有线程设置为\",{\"1\":{\"96\":1}}],[\"将加锁同步的范围扩大\",{\"1\":{\"93\":1}}],[\"将轻量级锁变成重量级锁\",{\"1\":{\"89\":1}}],[\"将线程pid转化为16进制\",{\"1\":{\"201\":1}}],[\"将线程\",{\"1\":{\"88\":1}}],[\"将锁的级别控制在更细粒度的哈希桶数组元素级别\",{\"1\":{\"130\":1}}],[\"将锁对象头中的\",{\"1\":{\"87\":1}}],[\"将锁计数器设为\",{\"1\":{\"82\":1}}],[\"将\",{\"1\":{\"85\":1,\"87\":1,\"89\":2,\"130\":1,\"335\":1,\"563\":2,\"571\":2,\"574\":1,\"587\":1,\"641\":1,\"653\":1,\"659\":1,\"662\":1,\"680\":1,\"708\":1,\"1126\":1,\"1127\":1,\"1139\":1,\"1249\":1}}],[\"将高速缓存的数据写到主存\",{\"1\":{\"72\":1}}],[\"将工作内存修改的共享变量刷新到主内存中\",{\"1\":{\"69\":1}}],[\"将新的任务添加\",{\"1\":{\"60\":1}}],[\"解密后把数据交给应用层\",{\"1\":{\"1047\":1}}],[\"解法\",{\"1\":{\"927\":1}}],[\"解压\",{\"1\":{\"1170\":1}}],[\"解压缩\",{\"1\":{\"804\":1}}],[\"解压后直接就是包名\",{\"1\":{\"790\":1}}],[\"解压文件\",{\"1\":{\"437\":1}}],[\"解除\",{\"1\":{\"746\":1}}],[\"解除代码中的依赖关系\",{\"1\":{\"729\":1}}],[\"解耦后\",{\"1\":{\"841\":1}}],[\"解耦\",{\"1\":{\"729\":1,\"1076\":1,\"1242\":1}}],[\"解释下ioc\",{\"0\":{\"729\":1}}],[\"解释下aop\",{\"0\":{\"719\":1}}],[\"解释一下invoke方法的三个参数\",{\"1\":{\"725\":1}}],[\"解释\",{\"1\":{\"624\":1}}],[\"解析更高效\",{\"1\":{\"1042\":1}}],[\"解析请求对应的\",{\"1\":{\"755\":1}}],[\"解析出数据链路层使用的硬件地址\",{\"1\":{\"986\":1}}],[\"解析出硬件地址\",{\"1\":{\"959\":1,\"1029\":1}}],[\"解析出主服务器已经执行的数据更改并在从服务器中重放\",{\"1\":{\"470\":1,\"581\":1}}],[\"解析出sql\",{\"1\":{\"469\":1,\"580\":1}}],[\"解析和初始化过\",{\"1\":{\"214\":1}}],[\"解析动作主要针对类或接口\",{\"1\":{\"172\":1}}],[\"解析阶段发生的具体时间没有被要求\",{\"1\":{\"172\":1}}],[\"解析阶段是java虚拟机将常量池内的符号引用替换为直接引用的过程\",{\"1\":{\"172\":1}}],[\"解析阶段中发生\",{\"1\":{\"170\":1}}],[\"解析\",{\"0\":{\"172\":1,\"274\":1},\"1\":{\"274\":1,\"277\":1,\"729\":1,\"959\":1,\"1029\":1}}],[\"解决密码验证问题\",{\"1\":{\"1177\":1}}],[\"解决与\",{\"1\":{\"1126\":1}}],[\"解决并发\",{\"1\":{\"1119\":1}}],[\"解决二叉树多次插入新的节点导致不平衡的问题\",{\"1\":{\"921\":1}}],[\"解决线程并发问题\",{\"1\":{\"735\":1}}],[\"解决线程安全问题\",{\"1\":{\"40\":1,\"735\":1,\"1068\":1}}],[\"解决的是非业务代码抽取的问题\",{\"1\":{\"718\":1}}],[\"解决的方案\",{\"1\":{\"694\":1}}],[\"解决缓存穿透\",{\"1\":{\"645\":1}}],[\"解决方法\",{\"1\":{\"643\":1,\"644\":1,\"681\":2,\"986\":1}}],[\"解决方案如下\",{\"1\":{\"1124\":1}}],[\"解决方案是\",{\"1\":{\"1052\":1}}],[\"解决方案是在控制器里面不能写字段\",{\"1\":{\"757\":1}}],[\"解决方案\",{\"1\":{\"409\":1,\"589\":1,\"866\":1,\"880\":1,\"1117\":1,\"1144\":3,\"1206\":1,\"1212\":1,\"1266\":1}}],[\"解决办法\",{\"1\":{\"641\":1,\"642\":1}}],[\"解决业务系统层面的耦合\",{\"1\":{\"585\":1}}],[\"解决\",{\"1\":{\"505\":1}}],[\"解决了并发死链的问题\",{\"1\":{\"409\":1}}],[\"解决活锁方案\",{\"1\":{\"99\":1}}],[\"解决死锁方案\",{\"1\":{\"98\":1}}],[\"解锁终端\",{\"1\":{\"417\":1}}],[\"解锁\",{\"1\":{\"85\":1,\"87\":1,\"294\":1,\"510\":1}}],[\"解锁操作\",{\"1\":{\"75\":1,\"102\":1}}],[\"解锁时\",{\"1\":{\"69\":1}}],[\"从层次上看\",{\"1\":{\"1037\":1}}],[\"从确认号开始\",{\"1\":{\"1007\":1}}],[\"从tcp的首部格式也可以看出\",{\"1\":{\"1006\":1}}],[\"从收到的数据报的首部中提取目的ip地址d\",{\"1\":{\"990\":1}}],[\"从ip数据报的首部无法看出源主机或目的主机所连接的网络是否进行了子网划分\",{\"1\":{\"989\":1}}],[\"从innodb存储引擎的逻辑存储结构来看\",{\"1\":{\"498\":1}}],[\"从上式可以看出\",{\"1\":{\"978\":1}}],[\"从第1个数与第0个数的对比开始\",{\"1\":{\"932\":1}}],[\"从第二范式起\",{\"1\":{\"464\":1}}],[\"从下标较小的元素开始\",{\"1\":{\"930\":1}}],[\"从hw开始向leader进行同步\",{\"1\":{\"855\":1}}],[\"从mq服务中拉取消息进行消费\",{\"1\":{\"843\":1}}],[\"从提供这地址列表中\",{\"1\":{\"811\":1}}],[\"从服务端返回的值也需要序列化反序列化的过程\",{\"1\":{\"804\":1}}],[\"从服务器发送\",{\"1\":{\"657\":2}}],[\"从服务器以及其他\",{\"1\":{\"657\":1}}],[\"从侧面也反应出是松耦合\",{\"1\":{\"718\":1}}],[\"从web系统中的xml文件载入上下文定义信息\",{\"1\":{\"712\":1}}],[\"从此位置沿环顺时针寻找\",{\"1\":{\"681\":1}}],[\"从节点作为备用节点\",{\"1\":{\"678\":1}}],[\"从节点可以扩展主库节点的读能力\",{\"1\":{\"675\":1}}],[\"从库提升为主库提供服务\",{\"1\":{\"675\":1}}],[\"从库就会和主库重新进行一次全量复制\",{\"1\":{\"663\":1}}],[\"从过期字典中随机\",{\"1\":{\"632\":1}}],[\"从哈希表\",{\"1\":{\"615\":1}}],[\"从备份的时间点开始\",{\"1\":{\"576\":1}}],[\"从这个备份恢复到临时库\",{\"1\":{\"576\":1}}],[\"从这些节点开始向下搜索\",{\"1\":{\"234\":1}}],[\"从性能角度出发优先考虑非唯一索引\",{\"1\":{\"555\":1}}],[\"从句的不同也会影响加锁\",{\"1\":{\"501\":1}}],[\"从索引\",{\"1\":{\"484\":4}}],[\"从效率上考虑\",{\"1\":{\"477\":1}}],[\"从空间上考虑\",{\"1\":{\"477\":1}}],[\"从数据库初始化完成\",{\"1\":{\"655\":1}}],[\"从数据库中删除表\",{\"1\":{\"483\":1}}],[\"从数据库中读取\",{\"1\":{\"168\":1}}],[\"从数据库的三大范式来看\",{\"1\":{\"464\":1}}],[\"从表修改外键值\",{\"1\":{\"463\":1}}],[\"从表插入新行\",{\"1\":{\"463\":1}}],[\"从最后一行开始显示\",{\"1\":{\"428\":1}}],[\"从设计层面来说\",{\"1\":{\"362\":1}}],[\"从接口实现的所有\",{\"1\":{\"356\":1}}],[\"从已有类得到继承信息创建新类的过程\",{\"1\":{\"355\":1}}],[\"从网络层使用的ip地址\",{\"1\":{\"986\":1}}],[\"从网络接收数据保存到msg中\",{\"1\":{\"304\":1}}],[\"从网络中获取\",{\"1\":{\"168\":1}}],[\"从代码上检查是否存在某些对象存活时间过长\",{\"1\":{\"298\":1}}],[\"从经验上来说\",{\"1\":{\"262\":1}}],[\"从执行负载的角度\",{\"1\":{\"262\":1}}],[\"从局部上来看是基于标记\",{\"1\":{\"261\":1}}],[\"从整体可以看做标记\",{\"1\":{\"261\":1}}],[\"从gc\",{\"1\":{\"259\":1,\"264\":1}}],[\"从虚拟机的视角来看\",{\"1\":{\"223\":1}}],[\"从文件系统中的\",{\"1\":{\"712\":1}}],[\"从文件加载内存\",{\"1\":{\"647\":1}}],[\"从文件\",{\"1\":{\"212\":1}}],[\"从jdk\",{\"1\":{\"199\":1}}],[\"从软件设计的角度来看\",{\"1\":{\"198\":1}}],[\"从加密文件中获取\",{\"1\":{\"168\":1}}],[\"从zip压缩包中提取\",{\"1\":{\"168\":1}}],[\"从一个进程的运行转到另一个进程上运行\",{\"1\":{\"147\":1}}],[\"从键盘获取数据的操作则是内核态才能做的事情\",{\"1\":{\"134\":1}}],[\"从\",{\"1\":{\"130\":1,\"301\":1,\"583\":1,\"601\":1,\"608\":1,\"663\":1,\"678\":1,\"683\":1,\"804\":1,\"878\":1,\"959\":1,\"1029\":1,\"1040\":1,\"1047\":1}}],[\"从语义上来说存在一个逻辑漏洞\",{\"1\":{\"106\":1}}],[\"从字节码角度来看\",{\"1\":{\"82\":1}}],[\"从工作内存同步回主内存\",{\"1\":{\"74\":1}}],[\"从主内存获取最新共享变量值\",{\"1\":{\"69\":1}}],[\"从而提高子系统的独立性和可移植性\",{\"1\":{\"1090\":1}}],[\"从而提高业务层的体验\",{\"1\":{\"1042\":1}}],[\"从而占用了资源\",{\"1\":{\"1060\":1}}],[\"从而释放系统资源\",{\"1\":{\"1060\":1}}],[\"从而导致目标服务器不响应合法流量请求\",{\"1\":{\"1054\":1}}],[\"从而导致各个consumer压力不均\",{\"1\":{\"859\":1}}],[\"从而在连接延时有很大优势\",{\"1\":{\"1042\":1}}],[\"从而出现某个丢包数据阻塞整个连接的数据使用\",{\"1\":{\"1042\":1}}],[\"从而出现数据分布不均匀的情况\",{\"1\":{\"681\":1}}],[\"从而大大提高了响应速度\",{\"1\":{\"1033\":1}}],[\"从而帮助其正常关闭\",{\"1\":{\"1027\":1}}],[\"从而绕开内核实现用户态的\",{\"1\":{\"1004\":1}}],[\"从而减少了路由表所占的存储空间以及查找路由表的时间\",{\"1\":{\"985\":1}}],[\"从而继续进行\",{\"1\":{\"863\":1}}],[\"从而可以将索引文件保留在内存中\",{\"1\":{\"848\":1}}],[\"从而可以让\",{\"1\":{\"379\":1}}],[\"从而来降低类与类之间的耦合\",{\"1\":{\"712\":1}}],[\"从而很有可能导致系统崩溃\",{\"1\":{\"681\":1}}],[\"从而确定每台机器在哈希环上的位置\",{\"1\":{\"681\":1}}],[\"从而对主从结构中的每台服务器进行监控\",{\"1\":{\"676\":1}}],[\"从而尝试获取下个锁\",{\"1\":{\"672\":1}}],[\"从而执行顺序变成\",{\"1\":{\"665\":1}}],[\"从而监控运行的多个\",{\"1\":{\"657\":1}}],[\"从而梳理出哪些必须誓死保护\",{\"1\":{\"644\":1}}],[\"从而影响缓存的响应时间和吞吐量\",{\"1\":{\"632\":1}}],[\"从而不会被清除\",{\"1\":{\"632\":1}}],[\"从而实现更好的业务解耦和系统扩展性\",{\"1\":{\"1221\":1}}],[\"从而实现aop\",{\"1\":{\"715\":1}}],[\"从而实现对真实对象的操作\",{\"1\":{\"715\":1}}],[\"从而实现一个\",{\"1\":{\"604\":1}}],[\"从而实现同时访问而相不干扰\",{\"1\":{\"40\":1}}],[\"从而需要同时向4个库发起查询\",{\"1\":{\"587\":1}}],[\"从而使得单个表的数据量变小\",{\"1\":{\"585\":1}}],[\"从而使得方法可以被调用\",{\"1\":{\"172\":1}}],[\"从而缓解单个数据库的压力\",{\"1\":{\"585\":1}}],[\"从而达到快速访问节点的目的\",{\"1\":{\"630\":1}}],[\"从而达到提升数据库操作性能的目的\",{\"1\":{\"585\":1}}],[\"从而达到线程安全\",{\"1\":{\"410\":1}}],[\"从而降低系统的耦合度\",{\"1\":{\"1090\":1}}],[\"从而降低代码之间的耦合度\",{\"1\":{\"718\":1}}],[\"从而降低服务器负载\",{\"1\":{\"582\":1}}],[\"从而降低效率\",{\"1\":{\"379\":1}}],[\"从而进行全表扫描\",{\"1\":{\"535\":1}}],[\"从而进入\",{\"1\":{\"38\":1}}],[\"从而产生虚拟表vt3\",{\"1\":{\"487\":1}}],[\"从而解决队头阻塞问题\",{\"1\":{\"1042\":1}}],[\"从而解决\",{\"1\":{\"411\":1}}],[\"从而委托父类完成一些初始化的工作\",{\"1\":{\"364\":1}}],[\"从而改善应用的响应速度和吞吐量\",{\"1\":{\"309\":1}}],[\"从而引起内存泄漏\",{\"1\":{\"304\":1}}],[\"从而造成内存泄漏\",{\"1\":{\"304\":2}}],[\"从而避免了重复复制的操作\",{\"1\":{\"850\":1}}],[\"从而避免了对底层存储系统的查询压力\",{\"1\":{\"641\":1}}],[\"从而避免了不必要的上下文切换和竞争条件\",{\"1\":{\"604\":1}}],[\"从而避免了线程安全问题\",{\"1\":{\"299\":1}}],[\"从而避免内存泄漏\",{\"1\":{\"46\":1}}],[\"从而决定是否要将这个对象分配到堆上\",{\"1\":{\"202\":1}}],[\"从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了\",{\"1\":{\"189\":1}}],[\"从而\",{\"1\":{\"134\":1}}],[\"从而保证了数据的一致性\",{\"1\":{\"578\":1}}],[\"从而保证多线程环境下并发操作安全\",{\"1\":{\"128\":1}}],[\"从而保证一次事务的所有操作都在同一个数据库连接上\",{\"1\":{\"43\":1}}],[\"从而违背了创建线程的初衷\",{\"1\":{\"34\":1}}],[\"从而效率更高\",{\"1\":{\"28\":1,\"139\":1}}],[\"规范大于技巧\",{\"1\":{\"1236\":1,\"1243\":1}}],[\"规范\",{\"0\":{\"1236\":1}}],[\"规划ip地址\",{\"1\":{\"961\":1}}],[\"规则定义一些禁止编译优化的场景\",{\"1\":{\"75\":1}}],[\"规则\",{\"1\":{\"65\":1,\"75\":1,\"102\":1}}],[\"规定了所有的变量都存储在主内存\",{\"1\":{\"337\":1}}],[\"规定了所有的变量都存储在主内存中\",{\"1\":{\"66\":1}}],[\"规定了对共享变量的写操作对其它线程的读操作可见\",{\"1\":{\"102\":1}}],[\"规定了对共享变量的写操作对其他线程的读操作可见\",{\"1\":{\"75\":1}}],[\"规定了虚拟机和计算机内存之间是如何协同工作的\",{\"1\":{\"65\":1}}],[\"规定所有变量都存储在主内存\",{\"1\":{\"65\":1,\"74\":1}}],[\"规避资源耗尽的风险\",{\"1\":{\"59\":1}}],[\"⭐\",{\"0\":{\"65\":1,\"79\":1,\"604\":1,\"654\":1},\"1\":{\"1130\":1}}],[\"三次握手的过程\",{\"1\":{\"1033\":1}}],[\"三次握手\",{\"0\":{\"1022\":1},\"1\":{\"1022\":1}}],[\"三数取其中\",{\"1\":{\"935\":1,\"936\":1}}],[\"三层架构\",{\"1\":{\"754\":1}}],[\"三层架构与mvc的目标一致\",{\"1\":{\"754\":1}}],[\"三层架构与mvc\",{\"0\":{\"754\":1}}],[\"三层架构中\",{\"1\":{\"729\":1}}],[\"三种格式\",{\"1\":{\"572\":1}}],[\"三个短语的缩写\",{\"1\":{\"871\":1}}],[\"三个隐式字段db\",{\"1\":{\"499\":1}}],[\"三个字段返回给客户端\",{\"1\":{\"484\":1}}],[\"三个字段的值\",{\"1\":{\"484\":1}}],[\"三个字符的时候\",{\"1\":{\"477\":1}}],[\"三\",{\"0\":{\"65\":1,\"211\":1,\"365\":1}}],[\"你可以省略这一步\",{\"1\":{\"1197\":1}}],[\"你下一步应当向哪一个域名服务器进行查询\",{\"1\":{\"1031\":1}}],[\"你发的fin报文我收到了\",{\"1\":{\"1024\":1}}],[\"你的\",{\"1\":{\"986\":1}}],[\"你高考考了多少分\",{\"1\":{\"902\":1}}],[\"你只管使用即可\",{\"1\":{\"718\":1}}],[\"你也可以一开始就让\",{\"1\":{\"671\":1}}],[\"你想\",{\"1\":{\"579\":1}}],[\"你读取的行\",{\"1\":{\"523\":1}}],[\"你有几个按键可以按的\",{\"1\":{\"429\":1}}],[\"你就考虑数据库的连接池大小设置\",{\"1\":{\"64\":1}}],[\"你需要什么东西\",{\"1\":{\"718\":1}}],[\"你需要将你一半的\",{\"1\":{\"671\":1}}],[\"你需要做的就是仅仅将\",{\"1\":{\"671\":1}}],[\"你需要\",{\"1\":{\"6\":1}}],[\"下一跳地址\",{\"1\":{\"990\":1}}],[\"下一个值又变为0\",{\"1\":{\"468\":1}}],[\"下图是各种ip地址的网络号字段和主机号字段\",{\"1\":{\"984\":1}}],[\"下⼀个⽬的地\",{\"1\":{\"961\":1}}],[\"下边以5000份做例子\",{\"1\":{\"904\":1}}],[\"下的安全性\",{\"1\":{\"873\":1}}],[\"下创建属于自己的节点\",{\"1\":{\"861\":1}}],[\"下来重新编译布署\",{\"1\":{\"731\":1}}],[\"下次再创建相同的字符串\",{\"1\":{\"1091\":1}}],[\"下次再写\",{\"1\":{\"368\":1}}],[\"下次从缓存中获取则是修改之后的数据\",{\"1\":{\"608\":1}}],[\"下次对于同一个sql\",{\"1\":{\"597\":1}}],[\"下载\",{\"0\":{\"1269\":1}}],[\"下载安装后\",{\"1\":{\"1151\":1}}],[\"下载地址\",{\"1\":{\"1151\":1,\"1269\":1}}],[\"下载远程仓库的所有变动\",{\"1\":{\"452\":1}}],[\"下载一个项目和它的整个代码历史\",{\"1\":{\"445\":1}}],[\"下所有文件包括当前目录和子目录以及子目录的子目录下面的文件\",{\"1\":{\"443\":1}}],[\"下所有文件个数\",{\"0\":{\"443\":1}}],[\"下还提供了一个\",{\"1\":{\"426\":1}}],[\"下有且只有一个根目录\",{\"1\":{\"416\":1}}],[\"下面根据类与类之间的耦合度从弱到强排列\",{\"1\":{\"1095\":1}}],[\"下面是要被索引的文本\",{\"1\":{\"888\":1}}],[\"下面两个工具方式的区别是\",{\"1\":{\"736\":1}}],[\"下面的命令可以用来\",{\"1\":{\"440\":1}}],[\"下面我们来详细说明一下\",{\"1\":{\"296\":1}}],[\"下面再详细写\",{\"1\":{\"260\":1}}],[\"下面列举了一些可供选择的记录精度\",{\"1\":{\"249\":1}}],[\"下面以\",{\"1\":{\"113\":1}}],[\"下任意时刻只有一个进程处于运行状态\",{\"1\":{\"148\":1}}],[\"下游系统抗并发能力\",{\"1\":{\"64\":1}}],[\"下使用的是系统方法\",{\"1\":{\"62\":1}}],[\"使正则表达式更美观\",{\"1\":{\"1190\":1}}],[\"使它们可以相互替换\",{\"1\":{\"1088\":1}}],[\"使它与发送端的时钟同步\",{\"1\":{\"980\":1}}],[\"使同样的构建过程可以创建不同的表示\",{\"1\":{\"1086\":1}}],[\"使同一个客户和该服务器可以继续在这条连接上传送http报文\",{\"1\":{\"1042\":1}}],[\"使该服务器无法提供正常服务\",{\"1\":{\"1054\":1}}],[\"使任何一台计算机都能显示出任何一个万维网服务器上的页面\",{\"1\":{\"1035\":1}}],[\"使网络的效率很低\",{\"1\":{\"1018\":1}}],[\"使两级ip地址变为三级ip地址\",{\"1\":{\"989\":1}}],[\"使其能够承载宽带数字业务\",{\"1\":{\"968\":1}}],[\"使其阶数与硬盘存储的页面大小相匹配\",{\"1\":{\"919\":1}}],[\"使物理层上面的数据连接层感觉不到这些差异\",{\"1\":{\"966\":1}}],[\"使之成为新的有序表\",{\"1\":{\"932\":1}}],[\"使\",{\"1\":{\"662\":1,\"1190\":4}}],[\"使⽤⽔平触发模式时\",{\"1\":{\"613\":1}}],[\"使⽤边缘触发\",{\"1\":{\"613\":1}}],[\"使业务\",{\"1\":{\"516\":1}}],[\"使类或接口附加额外信息\",{\"1\":{\"338\":1}}],[\"使程序易扩展\",{\"1\":{\"355\":1}}],[\"使程序异常终止\",{\"1\":{\"235\":1}}],[\"使程序正确运行起来\",{\"1\":{\"182\":1}}],[\"使得原本由于接口不兼容而不能一起工作的那些类能够一起工作\",{\"1\":{\"1092\":1}}],[\"使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤\",{\"1\":{\"1087\":1}}],[\"使得最小的接口做最多的事情\",{\"1\":{\"1064\":1}}],[\"使得主机尽快释放半连接\",{\"1\":{\"1060\":1}}],[\"使得主从服务器的数据达到一致\",{\"1\":{\"469\":1,\"580\":1}}],[\"使得在发送方不发送很小的报文段的同时\",{\"1\":{\"1018\":1}}],[\"使得或者接收缓存已有足够空间容纳一个最长的报文段\",{\"1\":{\"1018\":1}}],[\"使得它的性能损耗非常少\",{\"1\":{\"1001\":1}}],[\"使得每一个关键字\",{\"1\":{\"922\":1}}],[\"使得每个节点中能够存放更多的\",{\"1\":{\"541\":1}}],[\"使得单一数据库中的数据量变小\",{\"1\":{\"585\":1}}],[\"使得语句可以尽可能的命中索引\",{\"1\":{\"559\":1}}],[\"使得动态增长成为可能\",{\"1\":{\"198\":1}}],[\"使得堆中的内容可以被多个栈共享\",{\"1\":{\"198\":1}}],[\"使得多个进程可以访问同一块内存空间\",{\"1\":{\"149\":1}}],[\"使得效率提升\",{\"1\":{\"105\":1}}],[\"使得编译器和\",{\"1\":{\"78\":1}}],[\"使得缓冲区\",{\"1\":{\"72\":1}}],[\"使得\",{\"1\":{\"64\":1,\"1190\":1}}],[\"使用阿里云镜像源\",{\"1\":{\"1184\":1}}],[\"使用阿里的arthas\",{\"1\":{\"308\":1}}],[\"使用插槽\",{\"1\":{\"1162\":1}}],[\"使用插入排序\",{\"1\":{\"938\":1}}],[\"使用hooks\",{\"1\":{\"1162\":1}}],[\"使用http的url\",{\"1\":{\"1036\":1}}],[\"使用雪花\",{\"1\":{\"1117\":1}}],[\"使用面向对象的继承机制来实现泛化关系\",{\"1\":{\"1100\":1}}],[\"使用第三方提供的组件\",{\"1\":{\"1092\":1}}],[\"使用自己的私钥进行解密\",{\"1\":{\"1056\":1}}],[\"使用虚拟ip向服务器发送请求\",{\"1\":{\"1054\":1}}],[\"使用虚拟节点\",{\"1\":{\"880\":1}}],[\"使用工具自己签发的\",{\"1\":{\"1045\":1}}],[\"使用工厂模式通过\",{\"1\":{\"742\":1}}],[\"使用特定算法压缩头帧\",{\"1\":{\"1042\":1}}],[\"使用特定的方式来进行配置\",{\"1\":{\"767\":1}}],[\"使用流水线方式\",{\"1\":{\"1042\":1}}],[\"使用varchar\",{\"1\":{\"997\":1}}],[\"使用volatile的目的\",{\"1\":{\"714\":1}}],[\"使用volatile修饰保证线程可见性\",{\"1\":{\"110\":1,\"111\":1}}],[\"使用二叉线索查找路由表\",{\"1\":{\"991\":1}}],[\"使用子网划分后\",{\"1\":{\"990\":1}}],[\"使用子网时分组的转发\",{\"0\":{\"990\":1}}],[\"使用子查询优化\",{\"1\":{\"486\":1}}],[\"使用广播信道的数据链路层\",{\"0\":{\"976\":1}}],[\"使用确认和重传机制\",{\"1\":{\"974\":1}}],[\"使用点对点信道的数据链路层\",{\"0\":{\"970\":1}}],[\"使用归并或者快速排序\",{\"1\":{\"938\":1}}],[\"使用双指针\",{\"1\":{\"927\":1}}],[\"使用bigmap\",{\"1\":{\"901\":1}}],[\"使用bit数组来表示某些元素是否存在\",{\"1\":{\"883\":1}}],[\"使用布隆过滤器中的哈希函数对元素值进行计算\",{\"1\":{\"882\":1}}],[\"使用哈希算法的问题\",{\"1\":{\"880\":1}}],[\"使用哈希槽的好处就在于可以方便的添加或移除节点\",{\"1\":{\"680\":1}}],[\"使用心跳机制来触发\",{\"1\":{\"877\":1}}],[\"使用简单\",{\"1\":{\"869\":1}}],[\"使用简单的\",{\"1\":{\"486\":1}}],[\"使用ls命令来查看当前znode中所包含的内容\",{\"1\":{\"823\":1}}],[\"使用什么通信框架\",{\"0\":{\"814\":1}}],[\"使用客户端提供的参数\",{\"1\":{\"801\":1}}],[\"使用者只需要依赖相应功能的starter\",{\"1\":{\"772\":1}}],[\"使用嵌入式的servlet容器\",{\"1\":{\"768\":1}}],[\"使用session\",{\"1\":{\"1052\":1}}],[\"使用spring\",{\"1\":{\"789\":1}}],[\"使用springmvc负责请求的转发和视图管理\",{\"1\":{\"761\":1}}],[\"使用spring实现业务对象的管理\",{\"1\":{\"761\":1}}],[\"使用show\",{\"1\":{\"536\":1}}],[\"使用resulttype进行输出映射\",{\"1\":{\"751\":1}}],[\"使用到了适配器模式\",{\"1\":{\"742\":1}}],[\"使用到某个bean的时候才会注入\",{\"1\":{\"712\":1}}],[\"使用后端数据库默认的隔离级别\",{\"1\":{\"741\":1}}],[\"使用编程式事务无疑是痛苦的\",{\"1\":{\"739\":1}}],[\"使用单例提供的\",{\"1\":{\"1075\":1}}],[\"使用单例的原因\",{\"1\":{\"734\":1}}],[\"使用单线程的多路\",{\"1\":{\"610\":1}}],[\"使用单线程线程池\",{\"1\":{\"51\":1}}],[\"使用来创建类对象\",{\"1\":{\"729\":1}}],[\"使用proxy类来动态创建目标类的代理类\",{\"1\":{\"715\":1,\"725\":1}}],[\"使用相对复杂\",{\"1\":{\"869\":1}}],[\"使用相对路径切换到\",{\"1\":{\"420\":1}}],[\"使用相同的函数\",{\"1\":{\"681\":1}}],[\"使用奇数个哨兵\",{\"1\":{\"657\":1}}],[\"使用操作系统的多进程写时复制技术\",{\"1\":{\"647\":1}}],[\"使用两个全局哈希表\",{\"1\":{\"615\":1}}],[\"使用事件驱动的机制\",{\"1\":{\"612\":1}}],[\"使用底层模型不同\",{\"1\":{\"604\":1}}],[\"使用预编译\",{\"1\":{\"597\":1}}],[\"使用mysql自带的针对跨库的事务一致性方案\",{\"1\":{\"589\":1}}],[\"使用分区\",{\"1\":{\"671\":1}}],[\"使用分布式事务中间件\",{\"1\":{\"589\":1}}],[\"使用分片字段进行范围查找时\",{\"1\":{\"587\":1}}],[\"使用分段锁\",{\"1\":{\"409\":1}}],[\"使用另外一套日志系统\",{\"1\":{\"577\":1}}],[\"使用索引进行行范围查询\",{\"1\":{\"556\":1}}],[\"使用索引可以大大加快数据的检索速度\",{\"1\":{\"528\":1}}],[\"使用唯一索引\",{\"1\":{\"556\":1}}],[\"使用主键或非\",{\"1\":{\"556\":1}}],[\"使用覆盖索引会出现\",{\"1\":{\"556\":1}}],[\"使用短索引\",{\"1\":{\"535\":1}}],[\"使用了随机的electiontimeout来避免上述情况\",{\"1\":{\"877\":1}}],[\"使用了与一个哈希表\",{\"1\":{\"614\":1}}],[\"使用了单线程来轮询描述符\",{\"1\":{\"604\":1}}],[\"使用了并且是脏页\",{\"1\":{\"594\":1}}],[\"使用了并且是干净页\",{\"1\":{\"594\":1}}],[\"使用了函数\",{\"1\":{\"534\":1}}],[\"使用了改善也不大\",{\"1\":{\"532\":1}}],[\"使用了读屏障\",{\"1\":{\"268\":1}}],[\"使用方法如下\",{\"1\":{\"517\":1}}],[\"使用方式\",{\"1\":{\"39\":1}}],[\"使用next\",{\"1\":{\"506\":1}}],[\"使用new关键字\",{\"1\":{\"356\":1}}],[\"使用缓存还是可以的\",{\"1\":{\"490\":1}}],[\"使用utf\",{\"1\":{\"779\":1}}],[\"使用uuid做主键\",{\"1\":{\"589\":1}}],[\"使用uuid后\",{\"1\":{\"467\":1}}],[\"使用union\",{\"1\":{\"485\":1}}],[\"使用import\",{\"1\":{\"1209\":1}}],[\"使用int数据范围有限制\",{\"1\":{\"467\":1}}],[\"使用idea插件\",{\"1\":{\"281\":1}}],[\"使用数据库\",{\"1\":{\"459\":1}}],[\"使用命令git\",{\"1\":{\"452\":2}}],[\"使用命令行指令\",{\"1\":{\"253\":1}}],[\"使用一对多的广播通信方式\",{\"1\":{\"968\":1}}],[\"使用一对一的点对点通信方式\",{\"1\":{\"968\":1}}],[\"使用一致性哈希实现动态扩容\",{\"1\":{\"638\":1}}],[\"使用一致性hash算法\",{\"1\":{\"587\":1}}],[\"使用一次新的commit\",{\"1\":{\"448\":1}}],[\"使用一个单独的机器来存储session\",{\"1\":{\"1052\":1}}],[\"使用一个\",{\"1\":{\"110\":1}}],[\"使用绝对路径切换到\",{\"1\":{\"420\":1}}],[\"使用的http版本\",{\"1\":{\"1038\":1}}],[\"使用的流量控制协议是可变大小的滑动窗口协议\",{\"1\":{\"1009\":1}}],[\"使用的信道主要有以下两种类型\",{\"1\":{\"968\":1}}],[\"使用的是完全不同的连接方式\",{\"1\":{\"1048\":1}}],[\"使用的是非阻塞\",{\"1\":{\"604\":1}}],[\"使用的是非聚簇索引\",{\"1\":{\"547\":1}}],[\"使用的是头插法\",{\"1\":{\"406\":1}}],[\"使用的默认构造器来创建该类的实例\",{\"1\":{\"356\":1}}],[\"使用红黑树来解决链表查询慢的问题\",{\"1\":{\"398\":1}}],[\"使用尾插法\",{\"1\":{\"398\":1}}],[\"使用class\",{\"1\":{\"356\":1}}],[\"使用clone\",{\"1\":{\"212\":1,\"356\":1}}],[\"使用反射技术要求程序必须在一个没有安全限制的环境中运行\",{\"1\":{\"348\":1}}],[\"使用反射机制\",{\"1\":{\"348\":1}}],[\"使用反序列化\",{\"1\":{\"212\":1}}],[\"使用泛型的好处是使代码更加简洁\",{\"1\":{\"345\":1}}],[\"使用java代码获取jvm参数\",{\"0\":{\"327\":1}}],[\"使用jinfo\",{\"1\":{\"317\":2}}],[\"使用top\",{\"1\":{\"562\":1}}],[\"使用tlab\",{\"1\":{\"326\":1}}],[\"使用try\",{\"1\":{\"236\":1}}],[\"使用中间件提高程序效率\",{\"1\":{\"309\":1}}],[\"使用内存分析工具来实时查看jvm状态\",{\"1\":{\"308\":1}}],[\"使用记忆集来避免全堆作为gc\",{\"1\":{\"265\":1}}],[\"使用多个gc线程同时工作\",{\"1\":{\"261\":1}}],[\"使用不同的region来表示eden\",{\"1\":{\"260\":1}}],[\"使用标记\",{\"1\":{\"256\":1}}],[\"使用软引用的情况较多\",{\"1\":{\"235\":1}}],[\"使用直接指针来访问最大的好处就是速度更快\",{\"1\":{\"230\":1}}],[\"使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址\",{\"1\":{\"230\":1}}],[\"使用句柄\",{\"0\":{\"229\":1}}],[\"使用逃逸分析\",{\"1\":{\"202\":1}}],[\"使用最多的解决方案是加锁排队\",{\"1\":{\"642\":1}}],[\"使用最多的是动态代理技术\",{\"1\":{\"168\":1}}],[\"使用最少线程\",{\"1\":{\"144\":1}}],[\"使用消息实现通信\",{\"1\":{\"141\":1}}],[\"使用全局变量\",{\"1\":{\"141\":1}}],[\"使用时\",{\"1\":{\"1057\":1}}],[\"使用时间\",{\"1\":{\"136\":1}}],[\"使用时必须先获取对象锁\",{\"1\":{\"35\":1}}],[\"使用跳表的数据结构进行快速查找\",{\"1\":{\"108\":1}}],[\"使用链表实现\",{\"1\":{\"108\":1}}],[\"使用顺序加锁的方式解决的话\",{\"1\":{\"100\":1}}],[\"使用率飙升\",{\"0\":{\"562\":1}}],[\"使用率\",{\"1\":{\"64\":1}}],[\"使用通知模式实现\",{\"1\":{\"62\":1}}],[\"使用优先级队列实现\",{\"1\":{\"62\":1}}],[\"使用线程池可以进行统一的分配\",{\"1\":{\"53\":1}}],[\"使用线性探测法来解决哈希冲突\",{\"1\":{\"47\":1}}],[\"使用完调用\",{\"1\":{\"669\":1}}],[\"使用完设置null\",{\"1\":{\"304\":1}}],[\"使用完毕后\",{\"1\":{\"119\":1}}],[\"使用完成后\",{\"1\":{\"73\":1}}],[\"使用完\",{\"1\":{\"45\":2,\"300\":1}}],[\"使用场景\",{\"1\":{\"39\":1,\"361\":1,\"513\":2,\"645\":1,\"867\":1,\"882\":1,\"1130\":1}}],[\"使用\",{\"0\":{\"1046\":1,\"1145\":1},\"1\":{\"18\":1,\"26\":1,\"40\":1,\"51\":1,\"87\":1,\"89\":1,\"100\":1,\"101\":1,\"110\":1,\"174\":1,\"281\":1,\"294\":1,\"332\":1,\"355\":1,\"364\":1,\"381\":1,\"391\":1,\"404\":2,\"408\":1,\"409\":1,\"420\":1,\"426\":1,\"475\":2,\"477\":1,\"486\":1,\"519\":1,\"556\":1,\"559\":1,\"603\":1,\"606\":1,\"607\":1,\"612\":1,\"613\":1,\"620\":1,\"624\":1,\"637\":2,\"647\":1,\"665\":1,\"680\":1,\"719\":1,\"728\":1,\"729\":1,\"746\":1,\"753\":1,\"773\":1,\"788\":1,\"804\":1,\"805\":1,\"814\":1,\"996\":1,\"1042\":1,\"1044\":1,\"1061\":1,\"1068\":1,\"1090\":1,\"1139\":1,\"1145\":1,\"1162\":1,\"1163\":1,\"1177\":1}}],[\"销毁都由\",{\"1\":{\"718\":1}}],[\"销毁等操作会消耗不小的\",{\"1\":{\"64\":1}}],[\"销毁时\",{\"1\":{\"42\":1}}],[\"所描完事后\",{\"1\":{\"900\":1}}],[\"所需jar包的版本号\",{\"1\":{\"795\":1}}],[\"所需jar包的模块名\",{\"1\":{\"795\":1}}],[\"所需jar包的项目名\",{\"1\":{\"795\":1}}],[\"所用的条件是\",{\"1\":{\"623\":1}}],[\"所在一个数据页做merge之前\",{\"1\":{\"574\":1}}],[\"所在的指针\",{\"1\":{\"538\":1}}],[\"所在的\",{\"1\":{\"397\":1,\"398\":1}}],[\"所花的时间大部分消耗在哪个部分\",{\"1\":{\"558\":1}}],[\"所对应的\",{\"1\":{\"538\":1}}],[\"所做的更改存储在主内存的缓冲区中\",{\"1\":{\"520\":1}}],[\"所占磁盘空间一样\",{\"1\":{\"478\":1}}],[\"所属的类实现\",{\"1\":{\"412\":1}}],[\"所修饰\",{\"1\":{\"370\":1}}],[\"所拥有的一切\",{\"1\":{\"335\":1}}],[\"所指的是用一种称为\",{\"1\":{\"249\":1}}],[\"所谓的持续连接就是服务器在发送响应后\",{\"1\":{\"1042\":1}}],[\"所谓的是否能一次读入内存\",{\"1\":{\"891\":1}}],[\"所谓拥塞控制就是防止过多的数据注入到网络中\",{\"1\":{\"1019\":1}}],[\"所谓ip\",{\"1\":{\"964\":1}}],[\"所谓everything\",{\"1\":{\"964\":1}}],[\"所谓分发就是\",{\"1\":{\"754\":1}}],[\"所谓编码就是具体使用哪种底层数据结构来实现\",{\"1\":{\"637\":1}}],[\"所谓引用传递是指在调用函数时将实际参数的地址传递到函数中\",{\"1\":{\"351\":1}}],[\"所谓乐观锁就是\",{\"1\":{\"219\":1}}],[\"所谓重入锁\",{\"1\":{\"81\":1}}],[\"所收养\",{\"1\":{\"151\":1}}],[\"所有枚举继承此枚举接口\",{\"1\":{\"1260\":1}}],[\"所有聚合根外的操作\",{\"1\":{\"1245\":1}}],[\"所有选项都理解但不能接受\",{\"1\":{\"975\":1}}],[\"所有选项都接受\",{\"1\":{\"975\":1}}],[\"所有用户在不同的时间占用同样的频带宽度\",{\"1\":{\"967\":1}}],[\"所有用户在同样的时间占用不同的带宽资源\",{\"1\":{\"967\":1}}],[\"所有叶子节点都是黑色\",{\"1\":{\"921\":1}}],[\"所有叶子都处于同一层\",{\"1\":{\"919\":1}}],[\"所有分支结点包含的关键字可以看成索引\",{\"1\":{\"920\":1}}],[\"所有分支结点包含下列数据\",{\"1\":{\"919\":1}}],[\"所有可能相同的\",{\"1\":{\"896\":1}}],[\"所有节点收到投票信息时\",{\"1\":{\"878\":1}}],[\"所有请求被依次分发到每台应用服务器上\",{\"1\":{\"869\":1}}],[\"所有副本\",{\"1\":{\"853\":1}}],[\"所有函数都必须有自己的一个\",{\"1\":{\"804\":1}}],[\"所有主从的优点\",{\"1\":{\"658\":1}}],[\"所有\",{\"1\":{\"624\":1,\"770\":1}}],[\"所有有些设置可以修改\",{\"1\":{\"582\":1}}],[\"所有没有提交的事务的数据自动回滚\",{\"1\":{\"577\":1}}],[\"所有数据都保存在字典中\",{\"1\":{\"623\":1}}],[\"所有数据都被逻辑的存放在一个空间中\",{\"1\":{\"498\":1}}],[\"所有数据都会消失\",{\"1\":{\"494\":1}}],[\"所有跨存储引擎的功能都在这一层实现\",{\"1\":{\"488\":1}}],[\"所有都会被删\",{\"1\":{\"483\":1}}],[\"所有者\",{\"1\":{\"433\":1}}],[\"所有相对于\",{\"1\":{\"391\":1}}],[\"所有操作都是无序的\",{\"1\":{\"295\":1}}],[\"所有操作都是有序的\",{\"1\":{\"295\":1}}],[\"所有依赖静态类型来决定方法执行版本的分派动作\",{\"1\":{\"277\":1}}],[\"所有方法调用的目标方法在class文件里面都是一个常量池中的符号引用\",{\"1\":{\"274\":1}}],[\"所有涉及部分区域收集行为的垃圾收集器\",{\"1\":{\"249\":1}}],[\"所有被同步锁持有的对象\",{\"1\":{\"234\":1}}],[\"所有被使用过的内存都被放在一边\",{\"1\":{\"216\":1}}],[\"所有被屏障拦截的线程才会继续干活\",{\"1\":{\"120\":1}}],[\"所有的\",{\"1\":{\"1157\":1}}],[\"所有的版本都有\",{\"1\":{\"1140\":1}}],[\"所有的工厂类都需要进行修改\",{\"1\":{\"1079\":1}}],[\"所有的访问都经过一遍\",{\"1\":{\"1052\":1}}],[\"所有的安全方法也都是幂等的\",{\"1\":{\"1041\":1}}],[\"所有的网络都必须使用子网掩码\",{\"1\":{\"989\":1}}],[\"所有的follower开始同步数据\",{\"1\":{\"853\":1}}],[\"所有的消费者都属于某个消费者组\",{\"1\":{\"845\":1}}],[\"所有的请求直接怼到数据库\",{\"1\":{\"840\":1}}],[\"所有的被代理对象执行的方法都会被计时\",{\"1\":{\"724\":1}}],[\"所有的类的创建\",{\"1\":{\"718\":1}}],[\"所有的类都会在spring容器中登记\",{\"1\":{\"718\":1}}],[\"所有的键根据哈希函数映射到\",{\"1\":{\"679\":1}}],[\"所有的更新都必须堵住\",{\"1\":{\"594\":1}}],[\"所有的执行的语句当记录到日志中的时候\",{\"1\":{\"572\":1}}],[\"所有的事务依次逐个执行\",{\"1\":{\"522\":1,\"741\":1}}],[\"所有的读写请求都可以当成文件的读写来操作\",{\"1\":{\"380\":1}}],[\"所有的读写线程均阻塞\",{\"1\":{\"125\":1}}],[\"所有的变量都存储在主内存\",{\"1\":{\"294\":1}}],[\"所有的其他数据项目都用于描述元数据\",{\"1\":{\"292\":1}}],[\"所有的字段都还为零\",{\"1\":{\"223\":1}}],[\"所有的对象都分配到堆上也渐渐变得不那么\",{\"1\":{\"199\":1}}],[\"所有的线程都必须等待\",{\"1\":{\"121\":1}}],[\"所有的指令处理掉\",{\"1\":{\"72\":1}}],[\"所有写指令刷入高速缓存\",{\"1\":{\"72\":1}}],[\"所有任务处理完成\",{\"1\":{\"63\":1}}],[\"所以应用较少\",{\"1\":{\"1092\":1}}],[\"所以应用服务器往往是运行在\",{\"1\":{\"825\":1}}],[\"所以需要实现selltickets\",{\"1\":{\"1082\":1}}],[\"所以需要读的可能性是比写的可能大得多的\",{\"1\":{\"606\":1}}],[\"所以主机会选择一个ip地址\",{\"1\":{\"1049\":1}}],[\"所以主从复制\",{\"1\":{\"579\":1}}],[\"所以客户端会有公钥\",{\"1\":{\"1044\":1}}],[\"所以设立一个计时器\",{\"1\":{\"1028\":1}}],[\"所以seq=u+1\",{\"1\":{\"1026\":1}}],[\"所以stack1得先放入左\",{\"1\":{\"908\":1}}],[\"所以规定\",{\"1\":{\"1013\":1}}],[\"所以要实现\",{\"1\":{\"1004\":1}}],[\"所以要么\",{\"1\":{\"412\":1}}],[\"所以是逻辑地址\",{\"1\":{\"981\":1}}],[\"所以网络层就把填充的整数字节丢弃\",{\"1\":{\"980\":1}}],[\"所以觉得进程ap1直接把数据交给了ap2\",{\"1\":{\"963\":1}}],[\"所以右边界\",{\"1\":{\"912\":1}}],[\"所以再定义一个栈\",{\"1\":{\"908\":1}}],[\"所以给定一个数可能在\",{\"1\":{\"901\":1}}],[\"所以总的时间复杂度\",{\"1\":{\"899\":1}}],[\"所以考虑采用hash\",{\"1\":{\"898\":1}}],[\"所以上面第2步可以保证同一个ip不会被散列到不同的小文件上\",{\"1\":{\"892\":1}}],[\"所以通过多次划分\",{\"1\":{\"886\":1}}],[\"所以通过主键索引查询通常只需要\",{\"1\":{\"539\":1}}],[\"所以consumer需要实时记录自己消费到了那个offset\",{\"1\":{\"860\":1}}],[\"所以cms的写屏障实现是直接的同步操作\",{\"1\":{\"262\":1}}],[\"所以幂等性无法保证跨分区跨会话的exactly\",{\"1\":{\"856\":1}}],[\"所以没有聚合根\",{\"1\":{\"1240\":1}}],[\"所以没有粘包问题\",{\"1\":{\"1006\":1}}],[\"所以没有必要等到isr中所有的follower全部接受成功\",{\"1\":{\"854\":1}}],[\"所以没什么实际用处\",{\"1\":{\"413\":1}}],[\"所以省掉了锁带来的开销\",{\"1\":{\"834\":1}}],[\"所以两个服务器的状态依然是\",{\"1\":{\"820\":1}}],[\"所以服务器\",{\"1\":{\"820\":4}}],[\"所以诞生了二级缓存\",{\"1\":{\"752\":1}}],[\"所以尽量避免定义实例变量\",{\"1\":{\"735\":1}}],[\"所以尽量用\",{\"1\":{\"477\":1}}],[\"所以jvm不需要重新编译部署\",{\"1\":{\"731\":1}}],[\"所以java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的\",{\"1\":{\"290\":1}}],[\"所以适合操作命令简单\",{\"1\":{\"674\":1}}],[\"所以首推\",{\"1\":{\"668\":1}}],[\"所以为了压缩\",{\"1\":{\"651\":1}}],[\"所以为了避免多个线程操作同一地址\",{\"1\":{\"219\":1}}],[\"所以算两者的折中\",{\"1\":{\"650\":1}}],[\"所以可能不是立即写到磁盘上\",{\"1\":{\"649\":1}}],[\"所以可以保证安全性\",{\"1\":{\"1056\":1}}],[\"所以可以用来排序\",{\"1\":{\"889\":1}}],[\"所以可以考虑使用hash将ip直接存入内存\",{\"1\":{\"884\":1}}],[\"所以可以运用于高并发的秒杀活动\",{\"1\":{\"603\":1}}],[\"所以可以根据需要指定使用哪个类的加载器\",{\"1\":{\"183\":1}}],[\"所以可以被任意对象调用的方法是定义在\",{\"1\":{\"36\":1}}],[\"所以子进程地址空间内的数据是fork\",{\"1\":{\"647\":1}}],[\"所以系统存在以下问题时需要引入注意\",{\"1\":{\"643\":1}}],[\"所以它的数据迁移规模是\",{\"1\":{\"880\":1}}],[\"所以它的效率更高\",{\"1\":{\"409\":1}}],[\"所以它无法接收到投票的反馈信息\",{\"1\":{\"820\":1}}],[\"所以它\",{\"1\":{\"630\":1}}],[\"所以我们通过动态代理在运行期间动态生成业务类的代理类\",{\"1\":{\"1082\":1}}],[\"所以我们还是要用对称加密来传送消息\",{\"1\":{\"1056\":1}}],[\"所以我们可以基于这个思路分两步来设计该算法\",{\"1\":{\"893\":1}}],[\"所以我们可以考虑把数据库中的部分数据转移到缓存中去\",{\"1\":{\"606\":1}}],[\"所以我们在写一来是才不需要版本号\",{\"1\":{\"779\":1}}],[\"所以我们只要在invoke方法中统一处理\",{\"1\":{\"724\":1}}],[\"所以我们说\",{\"1\":{\"381\":1}}],[\"所以速度比较快\",{\"1\":{\"606\":1}}],[\"所以目前还是叫这种存放记录\",{\"1\":{\"591\":1}}],[\"所以已经提交的事务的数据依然存在\",{\"1\":{\"577\":1}}],[\"所以很慢\",{\"1\":{\"559\":1}}],[\"所以用联合索引的时候很容易写出索引失效的语句\",{\"1\":{\"551\":1}}],[\"所以就保证了\",{\"1\":{\"982\":1}}],[\"所以就不会像\",{\"1\":{\"806\":1}}],[\"所以就提出了一致性\",{\"1\":{\"679\":1}}],[\"所以就是非聚簇索引\",{\"1\":{\"550\":1}}],[\"所以就涉及到两种模式下的转换\",{\"1\":{\"134\":1}}],[\"所以mysql只能用b+tree索引做覆盖索引\",{\"1\":{\"550\":1}}],[\"所以磁盘io是非常高昂的操作\",{\"1\":{\"543\":1}}],[\"所以查询速度要比b树更稳定\",{\"1\":{\"541\":1}}],[\"所以查询会变快\",{\"1\":{\"529\":1}}],[\"所以每次查找的次数都相同\",{\"1\":{\"541\":1}}],[\"所以也不会有连续红节点\",{\"1\":{\"921\":1}}],[\"所以也不会出现不可重复读\",{\"1\":{\"523\":1}}],[\"所以也就无法用于排序\",{\"1\":{\"537\":1,\"541\":1}}],[\"所以语句应该写成create\",{\"1\":{\"533\":1}}],[\"所以无法做到实时持久化\",{\"1\":{\"648\":1}}],[\"所以无法判断任务是否被线程池执行成功与否\",{\"1\":{\"61\":1}}],[\"所以无论其他的事务怎么修改\",{\"1\":{\"523\":1}}],[\"所以称为幻读\",{\"1\":{\"521\":1}}],[\"所以会上升为表锁\",{\"1\":{\"506\":1}}],[\"所以会有内存缓冲区\",{\"1\":{\"72\":1}}],[\"所以说\",{\"1\":{\"1076\":1}}],[\"所以说就算你的字段名和你的实体类的属性名不一样也没关系\",{\"1\":{\"751\":1}}],[\"所以说热插拨\",{\"1\":{\"731\":1}}],[\"所以说当一条\",{\"1\":{\"503\":1}}],[\"所以说系统调用本质也是中断\",{\"1\":{\"134\":1}}],[\"所以干脆直接删掉了\",{\"1\":{\"490\":1}}],[\"所以越往后\",{\"1\":{\"486\":1}}],[\"所以拆成两张表\",{\"1\":{\"455\":1}}],[\"所以你可以多次add不同的文件\",{\"1\":{\"447\":1}}],[\"所以如果第一次创建了字符串对象\",{\"1\":{\"1091\":1}}],[\"所以如果方法是被final修饰的话\",{\"1\":{\"727\":1}}],[\"所以如果一秒内无法获取锁\",{\"1\":{\"672\":1}}],[\"所以如果\",{\"1\":{\"622\":1,\"649\":1}}],[\"所以如果你希望写入的的数据\",{\"1\":{\"411\":1}}],[\"所以如果单例对象持有外部对象的引用\",{\"1\":{\"304\":1}}],[\"所以有必要为多个子系统提供一个统一的接口\",{\"1\":{\"1090\":1}}],[\"所以有1024个数量上限\",{\"1\":{\"829\":1}}],[\"所以有两份对象内存\",{\"1\":{\"411\":1}}],[\"所以有了tlab\",{\"1\":{\"219\":1}}],[\"所以源码中做了优化\",{\"1\":{\"404\":1}}],[\"所以元素在内存中是连续存储的\",{\"1\":{\"392\":1}}],[\"所以当我们有需要使用自定义应用层协议的开发需求的时候\",{\"1\":{\"685\":1}}],[\"所以当调用集合的\",{\"1\":{\"389\":1}}],[\"所以当性能是重要的考量因素时\",{\"1\":{\"354\":1}}],[\"所以只能先回复一个ack报文\",{\"1\":{\"1024\":1}}],[\"所以只能无差别轮询所有流\",{\"1\":{\"381\":1}}],[\"所以只要\",{\"1\":{\"746\":1}}],[\"所以只有在\",{\"1\":{\"85\":1}}],[\"所以非直接缓冲区的读取效率较低\",{\"1\":{\"378\":1}}],[\"所以概念上不适用\",{\"1\":{\"358\":1}}],[\"所以慢慢就出现了面向对象的编程思想\",{\"1\":{\"354\":1}}],[\"所以表现为引用传递\",{\"1\":{\"351\":1}}],[\"所以表现为值传递\",{\"1\":{\"351\":1}}],[\"所以看起来如同直接在主内存中读写访问一般\",{\"1\":{\"337\":1}}],[\"所以造成内存泄漏\",{\"1\":{\"304\":1}}],[\"所以效率比javac高\",{\"1\":{\"282\":1}}],[\"所以停顿时间几乎就耗费在初始标记上\",{\"1\":{\"268\":1}}],[\"所以g1收集器在这个阶段实际并没有额外的停顿\",{\"1\":{\"264\":1}}],[\"所以这叫控制反转\",{\"1\":{\"718\":1}}],[\"所以这个时候我们就加入虚拟节点\",{\"1\":{\"880\":1}}],[\"所以这个事务提交之前\",{\"1\":{\"525\":1}}],[\"所以这个文件实际占用的磁盘空间就是\",{\"1\":{\"442\":1}}],[\"所以这个阶段也是可以与用户线程同时并发的\",{\"1\":{\"259\":1}}],[\"所以这里有\",{\"1\":{\"880\":1}}],[\"所以这里没有阻塞\",{\"1\":{\"380\":1}}],[\"所以这里必须有个阻塞\",{\"1\":{\"380\":1}}],[\"所以这三个都可以认为是同步\",{\"1\":{\"137\":1}}],[\"所以对象访问方式也是由虚拟机实现而定的\",{\"1\":{\"228\":1}}],[\"所以在路由表中就利用cidr地址块来查找目的网络\",{\"1\":{\"991\":1}}],[\"所以在多线程访问的时候有线程安全问题\",{\"1\":{\"757\":1}}],[\"所以在多线程环境下进行类初始化的话可能会引起死锁\",{\"1\":{\"173\":1}}],[\"所以在数据进行提交更新的时候\",{\"1\":{\"513\":1}}],[\"所以在使用tcp时\",{\"1\":{\"1006\":1}}],[\"所以在使用时\",{\"1\":{\"478\":1}}],[\"所以在使用下标的方式循环遍历时性能最好\",{\"1\":{\"391\":1}}],[\"所以在进行写操作的时候\",{\"1\":{\"411\":1}}],[\"所以在同一个构造函数里面有相同的语句\",{\"1\":{\"364\":1}}],[\"所以在方法名\",{\"1\":{\"359\":1}}],[\"所以在运行时不存在任何类型相关的信息\",{\"1\":{\"345\":1}}],[\"所以在常量池的入口需要放置一项u2类型的常量池容量计数值\",{\"1\":{\"286\":1}}],[\"所以在编译阶段javac编译器就根据参数的静态类型决定了会使用哪个重载版本\",{\"1\":{\"277\":1}}],[\"所以在后续的垃圾收集器设计中停顿时间在不断缩短\",{\"1\":{\"254\":1}}],[\"所以在老年代一般不能直接选用这种算法\",{\"1\":{\"246\":1}}],[\"所以在\",{\"1\":{\"200\":1,\"381\":1,\"656\":1,\"659\":1,\"678\":1,\"825\":1}}],[\"所以不可能将其完全加载到内存中处理\",{\"1\":{\"896\":1}}],[\"所以不建议\",{\"1\":{\"669\":1}}],[\"所以不会产生粘包问题\",{\"1\":{\"1002\":1}}],[\"所以不会产生任何锁和死锁\",{\"1\":{\"513\":1}}],[\"所以不会出现缓冲区溢出\",{\"1\":{\"624\":1}}],[\"所以不会上锁\",{\"1\":{\"103\":1}}],[\"所以不需要加gap锁\",{\"1\":{\"501\":1}}],[\"所以不能完全加载到内存中处理\",{\"1\":{\"892\":1}}],[\"所以不能刷新到缓存\",{\"1\":{\"641\":1}}],[\"所以不能被\",{\"1\":{\"362\":1}}],[\"所以不能使用静态方法\",{\"1\":{\"362\":1}}],[\"所以不能设计为基于寄存器的\",{\"1\":{\"190\":1}}],[\"所以后面的3个阶段的全部是基于方法区的存储结构进行的\",{\"1\":{\"170\":1}}],[\"所以轻量级锁让线程等一会\",{\"1\":{\"81\":1}}],[\"所以操作共享变量的时候一定要先加锁\",{\"1\":{\"81\":1}}],[\"所以使用充血模型的时候\",{\"1\":{\"1230\":1}}],[\"所以使用dhpc中继代理\",{\"1\":{\"1049\":1}}],[\"所以使用动态主机配置协议dhcp\",{\"1\":{\"1049\":1}}],[\"所以使用int将会提高应用程序的性能\",{\"1\":{\"467\":1}}],[\"所以使用反射可能会导致意料之外的副作用\",{\"1\":{\"348\":1}}],[\"所以使用\",{\"1\":{\"75\":1,\"648\":1}}],[\"所以线程数一般设置较大\",{\"1\":{\"64\":1}}],[\"所以一个页中能存储多少行数据呢\",{\"1\":{\"539\":1}}],[\"所以一个线程内可以存在多个\",{\"1\":{\"39\":1}}],[\"所以一张表只能有一个主键\",{\"1\":{\"464\":1}}],[\"所以一般开发人员使用applicationcontext会更多\",{\"1\":{\"712\":1}}],[\"所以一般来说\",{\"1\":{\"223\":1}}],[\"所以一般多写的场景下用悲观锁就比较合适\",{\"1\":{\"104\":1}}],[\"所以一般线程数设置的大小等于或者略微大于\",{\"1\":{\"64\":1}}],[\"所以生产者生产完数据之后不用等待消费者处理\",{\"1\":{\"50\":1}}],[\"所以处于阻塞状态\",{\"1\":{\"38\":1}}],[\"所以该状态的可运行是指可以被运行\",{\"1\":{\"38\":1}}],[\"所以\",{\"1\":{\"36\":1,\"86\":1,\"180\":1,\"292\":1,\"300\":1,\"342\":1,\"348\":1,\"391\":2,\"450\":1,\"477\":1,\"490\":1,\"537\":1,\"549\":1,\"577\":1,\"583\":1,\"611\":1,\"804\":1,\"835\":1,\"880\":2,\"893\":1,\"997\":1,\"1001\":2}}],[\"所以任意对象都可以调用\",{\"1\":{\"36\":1}}],[\"所以执行\",{\"1\":{\"35\":1,\"678\":1}}],[\"接线器的形状\",{\"1\":{\"966\":1}}],[\"接受该\",{\"1\":{\"878\":1}}],[\"接受\",{\"1\":{\"874\":1}}],[\"接受请求\",{\"1\":{\"801\":1}}],[\"接受客户端请求\",{\"1\":{\"755\":1}}],[\"接受缓冲区就会将其移出\",{\"1\":{\"612\":1}}],[\"接下来将领域模型映射到工程结构\",{\"1\":{\"1224\":1}}],[\"接下来看看linux\",{\"1\":{\"829\":1}}],[\"接下来就可以想象了吧\",{\"1\":{\"584\":1}}],[\"接下来\",{\"1\":{\"430\":1}}],[\"接下来虚拟机将为新生对象分配内存\",{\"1\":{\"215\":1}}],[\"接着回应b请求\",{\"1\":{\"1042\":1}}],[\"接着就关闭这个连接\",{\"1\":{\"1028\":1}}],[\"接着\",{\"1\":{\"1018\":1}}],[\"接着再用硬件对其中的比特流进行扫描\",{\"1\":{\"973\":1}}],[\"接着通过如下代码建立并生成代理对象\",{\"1\":{\"725\":1}}],[\"接着另一个并发事务\",{\"1\":{\"521\":1}}],[\"接着直接对\",{\"1\":{\"410\":1}}],[\"接着使用\",{\"1\":{\"344\":1}}],[\"接⼝和⽗类等信息\",{\"1\":{\"203\":1}}],[\"接收时验证一样可通过\",{\"1\":{\"1057\":1}}],[\"接收应用层的数据\",{\"1\":{\"1047\":1}}],[\"接收缓存用来暂时存放\",{\"1\":{\"1015\":1}}],[\"接收缓存又有了一些空间\",{\"1\":{\"1015\":1}}],[\"接收方为\",{\"1\":{\"1057\":1}}],[\"接收方接收到内容后\",{\"1\":{\"1057\":1}}],[\"接收方收到这一组数据后\",{\"1\":{\"1042\":1}}],[\"接收方也不要在缓存刚刚有了一点小的空间就急忙把这个很小的窗口大小信息通知给发送方\",{\"1\":{\"1018\":1}}],[\"接收方就发出确认报文\",{\"1\":{\"1018\":1}}],[\"接收方发回确认\",{\"1\":{\"1018\":1}}],[\"接收方一般采用累计确认\",{\"1\":{\"1011\":1}}],[\"接收方对数据包进行排序\",{\"1\":{\"1009\":1}}],[\"接收方采用\",{\"1\":{\"1006\":1}}],[\"接收方产生粘包\",{\"1\":{\"1006\":1}}],[\"接收方的传输层在拨去报文的首部后能够把这些数据正确交付到目的应用进程\",{\"1\":{\"999\":1}}],[\"接收邮件\",{\"1\":{\"1001\":1}}],[\"接收端发送一个\",{\"1\":{\"1004\":1}}],[\"接收端只要找到帧开始定界符\",{\"1\":{\"980\":1}}],[\"接收端将数据送往网络层前删除插入的转义字符\",{\"1\":{\"973\":1}}],[\"接收用户参数\",{\"1\":{\"754\":1}}],[\"接收并载入这个\",{\"1\":{\"662\":1}}],[\"接收并执行写命令\",{\"1\":{\"655\":1}}],[\"接收\",{\"1\":{\"655\":1,\"1162\":1}}],[\"接收来自master上binlog文件的的日志内容\",{\"1\":{\"469\":1,\"580\":1}}],[\"接收来自用户的内容更新\",{\"1\":{\"469\":1,\"580\":1}}],[\"接收进程某个事件已经发生\",{\"1\":{\"149\":1}}],[\"接收到快照文件后丢弃所有旧数据\",{\"1\":{\"655\":1}}],[\"接收到了\",{\"1\":{\"72\":1}}],[\"接收到\",{\"1\":{\"72\":1}}],[\"接收新的任务并处理队列中的任务\",{\"1\":{\"63\":1}}],[\"接口改造为\",{\"1\":{\"1247\":1}}],[\"接口由基础设施层去实现\",{\"1\":{\"1242\":1}}],[\"接口尽量细化\",{\"1\":{\"1064\":1}}],[\"接口隔离原则\",{\"1\":{\"1064\":1}}],[\"接口电缆上电压的范围\",{\"1\":{\"966\":1}}],[\"接口提供方增加一个\",{\"1\":{\"807\":1}}],[\"接口提供方会去\",{\"1\":{\"807\":1}}],[\"接口提供方拿到\",{\"1\":{\"807\":1}}],[\"接口如何保证幂等性\",{\"0\":{\"807\":1}}],[\"接口调用\",{\"1\":{\"806\":1}}],[\"接口来自定义二级缓存\",{\"1\":{\"752\":1}}],[\"接口层增加校验\",{\"1\":{\"641\":1}}],[\"接口并实现了\",{\"1\":{\"391\":1}}],[\"接口并实现\",{\"1\":{\"391\":1}}],[\"接口的比较器\",{\"1\":{\"412\":1}}],[\"接口的\",{\"1\":{\"389\":1}}],[\"接口是一个顺序遍历迭代器\",{\"1\":{\"389\":1}}],[\"接口是专门创建新的迭代器\",{\"1\":{\"389\":1}}],[\"接口是对行为的抽象\",{\"1\":{\"362\":2}}],[\"接口不可以实现方法\",{\"1\":{\"362\":1}}],[\"接口不能定义构造函数\",{\"1\":{\"362\":1}}],[\"接口才可以调用该方法\",{\"1\":{\"350\":1}}],[\"接口索引入口的第一项u2类型的数据为接口计数器\",{\"1\":{\"288\":1}}],[\"接口索引集合就用来描述这个类实现了哪些接口\",{\"1\":{\"288\":1}}],[\"接口等描述信息外\",{\"1\":{\"208\":1}}],[\"接口中定义了\",{\"1\":{\"759\":2}}],[\"接口中定义了五个表示隔离级别的常量\",{\"1\":{\"741\":1}}],[\"接口中可以包含带有具体实现的方法\",{\"1\":{\"362\":1}}],[\"接口中体现\",{\"1\":{\"184\":1}}],[\"接口中的\",{\"1\":{\"33\":2}}],[\"接口也提供了类似\",{\"1\":{\"126\":1}}],[\"接口方法\",{\"1\":{\"39\":1,\"172\":1}}],[\"接口\",{\"0\":{\"126\":1,\"362\":1,\"805\":1},\"1\":{\"31\":1,\"42\":1,\"94\":1,\"343\":2,\"344\":1,\"389\":1,\"390\":2,\"391\":1,\"392\":2,\"407\":1,\"408\":1,\"412\":1,\"759\":2,\"1086\":1,\"1092\":1}}],[\"状态图\",{\"1\":{\"1094\":1,\"1271\":1}}],[\"状态码\",{\"1\":{\"1040\":1}}],[\"状态码分类\",{\"1\":{\"1040\":1}}],[\"状态码及状态描述\",{\"1\":{\"1038\":1}}],[\"状态行\",{\"1\":{\"1038\":3}}],[\"状态不等待一段时间\",{\"1\":{\"1027\":1}}],[\"状态的过程\",{\"1\":{\"144\":1}}],[\"状态的结点将从等待队列转移到同步队列中\",{\"1\":{\"111\":1}}],[\"状态的后继结点的线程执行\",{\"1\":{\"111\":1}}],[\"状态的线程\",{\"1\":{\"85\":1}}],[\"状态信息通过\",{\"1\":{\"110\":1}}],[\"状态\",{\"0\":{\"63\":1},\"1\":{\"63\":1,\"89\":1,\"156\":1,\"489\":3,\"578\":1,\"659\":2,\"820\":4,\"877\":1,\"1022\":3,\"1025\":1,\"1026\":4,\"1027\":1,\"1060\":1}}],[\"状态转换\",{\"1\":{\"38\":1}}],[\"默认主题使用\",{\"1\":{\"1210\":1}}],[\"默认就是\",{\"1\":{\"1197\":1}}],[\"默认路由器ip地址\",{\"1\":{\"1049\":1}}],[\"默认用\",{\"1\":{\"938\":1}}],[\"默认采用\",{\"1\":{\"820\":1}}],[\"默认采用的\",{\"1\":{\"741\":2}}],[\"默认范围\",{\"1\":{\"797\":1}}],[\"默认都是单例的\",{\"1\":{\"734\":1,\"735\":1,\"742\":1}}],[\"默认会每秒进行十次过期扫描\",{\"1\":{\"632\":1}}],[\"默认会选择\",{\"1\":{\"536\":1}}],[\"默认使用哈希表\",{\"1\":{\"615\":1}}],[\"默认使用非公平策略\",{\"1\":{\"62\":1}}],[\"默认支持的隔离级别是\",{\"1\":{\"519\":1}}],[\"默认每个页的大小为16kb\",{\"1\":{\"498\":1}}],[\"默认级别是\",{\"1\":{\"491\":1}}],[\"默认约束\",{\"1\":{\"460\":1}}],[\"默认自带了四个数据库\",{\"1\":{\"459\":1}}],[\"默认分配单元大小是\",{\"1\":{\"442\":1}}],[\"默认值是\",{\"1\":{\"381\":1}}],[\"默认值45\",{\"1\":{\"262\":1}}],[\"默认是默认拒绝策略\",{\"1\":{\"1089\":1}}],[\"默认是8080端口\",{\"1\":{\"786\":1}}],[\"默认是单例的\",{\"1\":{\"735\":1}}],[\"默认是主键\",{\"1\":{\"546\":1}}],[\"默认是大端存储\",{\"1\":{\"347\":1}}],[\"默认是小端存储\",{\"1\":{\"347\":1}}],[\"默认是堆内存的1\",{\"1\":{\"262\":1}}],[\"默认\",{\"1\":{\"343\":1,\"362\":1,\"428\":1,\"854\":1,\"859\":1,\"1190\":1}}],[\"默认打开\",{\"1\":{\"326\":1}}],[\"默认禁用\",{\"1\":{\"326\":1}}],[\"默认输出到标准输出\",{\"1\":{\"325\":1}}],[\"默认与java堆大小一样\",{\"1\":{\"323\":1}}],[\"默认与堆的最大值一致\",{\"1\":{\"209\":1}}],[\"默认没有限制\",{\"1\":{\"323\":1}}],[\"默认为\",{\"1\":{\"566\":1}}],[\"默认为11\",{\"1\":{\"476\":1}}],[\"默认为1g\",{\"1\":{\"323\":1}}],[\"默认为15\",{\"1\":{\"322\":1}}],[\"默认为物理内存的1\",{\"1\":{\"315\":2,\"322\":1}}],[\"默认不显示行号\",{\"1\":{\"434\":1}}],[\"默认不包括diagnostic和experimental的参数\",{\"1\":{\"316\":1}}],[\"默认不使用分代收集\",{\"1\":{\"267\":1}}],[\"默认的分区策略是根据key进行分区的分配\",{\"1\":{\"867\":1}}],[\"默认的事务型存储引擎\",{\"1\":{\"491\":1}}],[\"默认的\",{\"1\":{\"399\":1}}],[\"默认的回收策略也同样是优先处理回收价值最大的region\",{\"1\":{\"267\":1}}],[\"默认的构造方法是\",{\"1\":{\"120\":1}}],[\"默认200ms\",{\"1\":{\"262\":1}}],[\"默认启动的回收线程数是\",{\"1\":{\"259\":1}}],[\"默认只占eden的1\",{\"1\":{\"219\":1}}],[\"默认非抢占式\",{\"1\":{\"150\":1}}],[\"默认非公平锁\",{\"1\":{\"81\":1}}],[\"默认构造方法为非公平模式\",{\"1\":{\"125\":1}}],[\"默认情况下执行\",{\"1\":{\"647\":1}}],[\"默认情况下\",{\"1\":{\"427\":1,\"475\":2,\"505\":1,\"597\":1}}],[\"默认情况下元素按照升序排序\",{\"1\":{\"62\":1}}],[\"默认情况下不保证线程公平\",{\"1\":{\"62\":1}}],[\"来确认客户身份\",{\"1\":{\"1052\":1}}],[\"来确定客户身份的话\",{\"1\":{\"1052\":1}}],[\"来统计每个query出现的次数\",{\"1\":{\"895\":1}}],[\"来阻止follower开始选举\",{\"1\":{\"879\":1}}],[\"来处理控制器抛出的所有异常\",{\"1\":{\"791\":1}}],[\"来渲染视图\",{\"1\":{\"755\":1}}],[\"来调用真正的处理器来处理请求\",{\"1\":{\"755\":1}}],[\"来连接数据库\",{\"1\":{\"746\":1}}],[\"来实例化对象\",{\"1\":{\"729\":1}}],[\"来实现了可靠的数据传输\",{\"1\":{\"1004\":1}}],[\"来实现快照持久化\",{\"1\":{\"647\":1}}],[\"来实现读写不阻塞\",{\"1\":{\"499\":1}}],[\"来实现一个整型控制两种状态的功能\",{\"1\":{\"125\":1}}],[\"来实现锁的分配\",{\"1\":{\"110\":1}}],[\"来实现异步进而提高\",{\"1\":{\"72\":1}}],[\"来实现\",{\"1\":{\"72\":1,\"577\":1,\"620\":1}}],[\"来实现的\",{\"1\":{\"43\":1,\"499\":1,\"563\":1,\"718\":1}}],[\"来生成\",{\"1\":{\"726\":1}}],[\"来重新对外提供服务\",{\"1\":{\"683\":1}}],[\"来求模\",{\"1\":{\"679\":1}}],[\"来进行排\",{\"1\":{\"902\":1}}],[\"来进行\",{\"1\":{\"859\":1}}],[\"来进行数据共享\",{\"1\":{\"678\":1}}],[\"来进行比较的\",{\"1\":{\"412\":1}}],[\"来决定新\",{\"1\":{\"677\":1}}],[\"来分片存储数据\",{\"1\":{\"629\":1}}],[\"来存储ip地址\",{\"1\":{\"997\":1}}],[\"来存储的\",{\"1\":{\"622\":1}}],[\"来存储键值对数据\",{\"1\":{\"399\":1}}],[\"来保证消息顺序性\",{\"1\":{\"865\":1}}],[\"来保证不同节点的线程同步执行\",{\"1\":{\"603\":1}}],[\"来保存一系列二进制数据\",{\"1\":{\"624\":1}}],[\"来保存所有键值对\",{\"1\":{\"614\":1}}],[\"来提高\",{\"1\":{\"582\":1}}],[\"来提供给优化器做选择\",{\"1\":{\"536\":1}}],[\"来对\",{\"1\":{\"558\":1}}],[\"来查看\",{\"1\":{\"557\":1}}],[\"来加锁\",{\"1\":{\"517\":1}}],[\"来设置\",{\"1\":{\"516\":1}}],[\"来解决\",{\"1\":{\"505\":1}}],[\"来解决能避免饥饿\",{\"1\":{\"100\":1}}],[\"来缓解加锁开销与并发影响\",{\"1\":{\"501\":1}}],[\"来执行查询\",{\"1\":{\"489\":1}}],[\"来操作数据库中的数据\",{\"1\":{\"456\":1}}],[\"来源档\",{\"1\":{\"423\":1}}],[\"来源于nio\",{\"1\":{\"209\":1}}],[\"来维护这个顺序的\",{\"1\":{\"414\":1}}],[\"来轮询注册在其上的\",{\"1\":{\"380\":1}}],[\"来构造一个\",{\"1\":{\"344\":1}}],[\"来比较\",{\"1\":{\"342\":1}}],[\"来适当调大参数\",{\"1\":{\"298\":1}}],[\"来屏蔽各种硬件和操作系统的内存访问差异\",{\"1\":{\"293\":1}}],[\"来避免幻读\",{\"1\":{\"523\":2}}],[\"来避免全局扫描\",{\"1\":{\"247\":1}}],[\"来避免指令重排序\",{\"1\":{\"101\":1}}],[\"来了解被引用的对象是否将要被垃圾回收\",{\"1\":{\"235\":1}}],[\"来代替\",{\"1\":{\"203\":1}}],[\"来获取代理对象\",{\"1\":{\"1083\":1}}],[\"来获取\",{\"1\":{\"181\":2}}],[\"来获得同步支持\",{\"1\":{\"131\":2}}],[\"来表示字符串值\",{\"1\":{\"624\":1}}],[\"来表示结束\",{\"1\":{\"336\":1}}],[\"来表示\",{\"1\":{\"160\":1}}],[\"来转换变成物理地址\",{\"1\":{\"153\":1}}],[\"来说\",{\"1\":{\"121\":1,\"203\":1,\"391\":1,\"825\":2}}],[\"来打断死锁\",{\"1\":{\"98\":1}}],[\"来完成握手和加密协商\",{\"1\":{\"1042\":1}}],[\"来完成分页\",{\"1\":{\"753\":1}}],[\"来完成\",{\"1\":{\"75\":1,\"656\":1}}],[\"来合理的设置队列的大小\",{\"1\":{\"64\":1}}],[\"来关闭线程池\",{\"1\":{\"59\":1}}],[\"继而指向两块不同的数据块\",{\"1\":{\"427\":1}}],[\"继续安装requirements\",{\"1\":{\"1144\":1}}],[\"继续安装\",{\"1\":{\"1144\":1}}],[\"继续创建虚拟环境\",{\"1\":{\"1144\":1}}],[\"继续查看和交换后父节点的关系\",{\"1\":{\"937\":1}}],[\"继续拉取消息消费\",{\"1\":{\"843\":1}}],[\"继续提供服务\",{\"1\":{\"803\":1}}],[\"继续开始做自己的事情\",{\"1\":{\"380\":1}}],[\"继续处理现有任务\",{\"1\":{\"59\":1}}],[\"继承抽象构件\",{\"1\":{\"1085\":1}}],[\"继承必须确保超类所拥有的性质在子类中仍然成立\",{\"1\":{\"1064\":1}}],[\"继承spring\",{\"1\":{\"778\":1}}],[\"继承的父类不同\",{\"1\":{\"407\":1}}],[\"继承自spring\",{\"1\":{\"779\":1}}],[\"继承自抽象类\",{\"1\":{\"736\":1}}],[\"继承自\",{\"1\":{\"128\":1,\"129\":1,\"407\":2,\"410\":1}}],[\"继承体系\",{\"1\":{\"32\":1}}],[\"继承整个\",{\"1\":{\"32\":1}}],[\"继承\",{\"0\":{\"800\":1},\"1\":{\"31\":1,\"336\":1,\"354\":1,\"355\":2}}],[\"或从\",{\"1\":{\"1140\":1}}],[\"或通过命令行\",{\"1\":{\"1127\":1}}],[\"或达到接收方缓存的空间的一半大小\",{\"1\":{\"1018\":1}}],[\"或成为cidr记法\",{\"1\":{\"991\":1}}],[\"或路由器\",{\"1\":{\"984\":1}}],[\"或将下一层数据转换成上一层能处理的消息\",{\"1\":{\"961\":1}}],[\"或最小\",{\"1\":{\"920\":1}}],[\"或没有孩子\",{\"1\":{\"918\":3}}],[\"或主机名的后面增加编号来实现\",{\"1\":{\"681\":1}}],[\"或非核心服务影响到核心流程的性能时\",{\"1\":{\"644\":1}}],[\"或删掉误用的索引\",{\"1\":{\"536\":1}}],[\"或修改文件与目录的名称\",{\"1\":{\"418\":1}}],[\"或迭代器遍历就没有\",{\"1\":{\"391\":1}}],[\"或迭代器遍历\",{\"1\":{\"391\":1}}],[\"或jconsole\",{\"1\":{\"308\":1}}],[\"或更多\",{\"1\":{\"249\":1}}],[\"或在实验中\",{\"1\":{\"240\":1}}],[\"或在采用抢先式优先级调度算法的系统中\",{\"1\":{\"148\":1}}],[\"或全部\",{\"1\":{\"202\":1}}],[\"或指向运行时常量池的方法引用\",{\"1\":{\"191\":1}}],[\"或调用一个类的静态方法时\",{\"1\":{\"174\":1}}],[\"或许用其他的线程在你第一次判断的期间\",{\"1\":{\"101\":1}}],[\"或\",{\"0\":{\"358\":1},\"1\":{\"59\":1,\"102\":2,\"277\":1,\"383\":3,\"429\":3,\"444\":1,\"526\":1,\"549\":1,\"556\":1,\"609\":1,\"642\":1,\"645\":1,\"674\":1,\"712\":1,\"755\":1,\"918\":1,\"1121\":1,\"1140\":1,\"1167\":1}}],[\"或者等到接收缓存已有一半空闲的空间\",{\"1\":{\"1018\":1}}],[\"或者主机a刚加上电\",{\"1\":{\"986\":1}}],[\"或者具有以下特点\",{\"1\":{\"915\":1}}],[\"或者栈中还有节点\",{\"1\":{\"908\":1}}],[\"或者如下阐述\",{\"1\":{\"892\":1}}],[\"或者我们不用2bit来进行表示\",{\"1\":{\"883\":1}}],[\"或者ap\",{\"1\":{\"870\":1}}],[\"或者你指定key\",{\"1\":{\"865\":1}}],[\"或者更准确的来说\",{\"1\":{\"825\":1}}],[\"或者说某些步骤的实现与具体的环境相关\",{\"1\":{\"1087\":1}}],[\"或者说\",{\"0\":{\"805\":1}}],[\"或者说当比较规则只有\",{\"1\":{\"390\":1}}],[\"或者不同基站之间切换都不会重连\",{\"1\":{\"1042\":1}}],[\"或者不一致性的结果\",{\"1\":{\"713\":1}}],[\"或者不合适持有外部类的强引用\",{\"1\":{\"361\":1}}],[\"或者秒级持久化\",{\"1\":{\"648\":1}}],[\"或者宕机\",{\"1\":{\"642\":1}}],[\"或者关闭\",{\"1\":{\"582\":1}}],[\"或者采用反过来的顺序\",{\"1\":{\"578\":1}}],[\"或者客户端断开连接时释放锁\",{\"1\":{\"517\":1}}],[\"或者表比较小\",{\"1\":{\"492\":1}}],[\"或者自定义一个实现了\",{\"1\":{\"412\":1}}],[\"或者遇到eagain错误\",{\"1\":{\"381\":1}}],[\"或者写入数据的流进行操作\",{\"1\":{\"381\":1}}],[\"或者是在管理后台手动直接摘掉机器\",{\"1\":{\"802\":1}}],[\"或者是\",{\"1\":{\"770\":1}}],[\"或者是数据量太大造成的\",{\"1\":{\"562\":1}}],[\"或者是从物理磁盘读取数据\",{\"1\":{\"378\":1}}],[\"或者是一些\",{\"1\":{\"142\":1}}],[\"或者从缓冲区写入到通道中\",{\"1\":{\"377\":1}}],[\"或者==都相同\",{\"1\":{\"341\":1,\"400\":1}}],[\"或者叫index\",{\"1\":{\"444\":1}}],[\"或者叫\",{\"1\":{\"277\":1}}],[\"或者可以支持全区域不分代的收集的工作模式\",{\"1\":{\"240\":1}}],[\"或者finalize\",{\"1\":{\"236\":1}}],[\"或者在创建新的线程时没有足够的内存去创建对应的jvm栈\",{\"1\":{\"190\":1}}],[\"或者被java\",{\"1\":{\"177\":1}}],[\"或者被\",{\"1\":{\"176\":1}}],[\"或者显式地删除一个消息队列时\",{\"1\":{\"149\":1}}],[\"或者使用jps定位进程\",{\"1\":{\"98\":1}}],[\"或者初始化时指定\",{\"1\":{\"62\":1}}],[\"或者产生了异常而结束\",{\"1\":{\"38\":1}}],[\"或者\",{\"1\":{\"26\":1,\"486\":1,\"622\":1,\"623\":1,\"641\":1,\"642\":1,\"671\":1,\"836\":2,\"876\":1,\"877\":1,\"1212\":1}}],[\"55\",{\"1\":{\"1168\":2}}],[\"59\",{\"1\":{\"1144\":1}}],[\"598\",{\"1\":{\"439\":1}}],[\"57950978\",{\"1\":{\"1143\":1}}],[\"5g\",{\"1\":{\"1042\":1}}],[\"5xx\",{\"1\":{\"1040\":1}}],[\"5亿个int找它们的中位数\",{\"1\":{\"886\":1}}],[\"5亿个整数中找出不重复的整数\",{\"0\":{\"900\":1}}],[\"5亿个整数中找出不重复的整数的个数\",{\"1\":{\"883\":1,\"886\":1}}],[\"5亿个整数\",{\"0\":{\"900\":1},\"1\":{\"883\":1,\"886\":1,\"900\":1}}],[\"5～20ms\",{\"1\":{\"879\":1}}],[\"503\",{\"1\":{\"1040\":1}}],[\"50\",{\"1\":{\"824\":1,\"953\":1}}],[\"5000\",{\"1\":{\"894\":1}}],[\"500\",{\"1\":{\"555\":1,\"1040\":1}}],[\"5s\",{\"1\":{\"672\":2}}],[\"512m\",{\"1\":{\"1177\":1}}],[\"512\",{\"1\":{\"539\":1,\"618\":1,\"622\":1,\"1033\":1}}],[\"5~1s\",{\"1\":{\"261\":1}}],[\"5region的对象即可判定为大对象\",{\"1\":{\"260\":1}}],[\"5以及之前的版本中与parallel\",{\"1\":{\"256\":1}}],[\"5\",{\"0\":{\"392\":1,\"896\":1,\"1100\":1,\"1205\":1,\"1232\":1,\"1244\":1,\"1245\":1,\"1246\":1,\"1257\":1},\"1\":{\"59\":1,\"304\":1,\"345\":1,\"350\":1,\"383\":1,\"392\":1,\"449\":1,\"488\":3,\"511\":2,\"525\":2,\"531\":1,\"553\":1,\"555\":1,\"616\":1,\"623\":1,\"627\":1,\"628\":1,\"636\":1,\"651\":1,\"672\":2,\"801\":1,\"820\":4,\"874\":1,\"882\":1,\"921\":1,\"938\":1,\"951\":2,\"952\":1,\"953\":1,\"955\":2,\"956\":2,\"961\":1,\"973\":3,\"1038\":1,\"1065\":1,\"1094\":1,\"1139\":2,\"1148\":3,\"1162\":1}}],[\"yaml\",{\"1\":{\"1208\":1}}],[\"your\",{\"1\":{\"1182\":2}}],[\"young区用\",{\"0\":{\"245\":1}}],[\"young\",{\"1\":{\"240\":1,\"263\":1}}],[\"yum\",{\"1\":{\"1167\":1}}],[\"y\",{\"1\":{\"804\":2}}],[\"yml<\",{\"1\":{\"1266\":1}}],[\"yml还有一个缺点\",{\"1\":{\"785\":1}}],[\"yml相对于properties配置的优势\",{\"0\":{\"785\":1}}],[\"yml的资源过滤\",{\"1\":{\"779\":1}}],[\"yml配置数据源信息\",{\"1\":{\"776\":1}}],[\"yml\",{\"1\":{\"775\":1,\"784\":1,\"1198\":1}}],[\"yes\",{\"1\":{\"707\":1,\"708\":2,\"1143\":1,\"1178\":1}}],[\"yellow\",{\"1\":{\"58\":1,\"96\":1,\"118\":1,\"131\":1}}],[\"yield\",{\"1\":{\"35\":5,\"144\":1}}],[\"yiled\",{\"0\":{\"35\":1}}],[\"⑦\",{\"1\":{\"58\":1}}],[\"有生命周期且具有延续性\",{\"1\":{\"1230\":1}}],[\"有利于系统的解耦\",{\"1\":{\"1086\":1}}],[\"有利于分析错误\",{\"1\":{\"58\":1}}],[\"有响应体\",{\"1\":{\"1040\":1}}],[\"有字符串\",{\"1\":{\"1035\":1}}],[\"有错就丢弃\",{\"1\":{\"1002\":1}}],[\"有以下四种不同的中间设备\",{\"1\":{\"965\":1}}],[\"有重复\",{\"0\":{\"898\":1},\"1\":{\"891\":1}}],[\"有10个文件\",{\"0\":{\"895\":1},\"1\":{\"890\":1}}],[\"有17种不同类型的常量\",{\"1\":{\"286\":1}}],[\"有点像鸽巢原理\",{\"1\":{\"886\":1}}],[\"有点类似ioc的思想\",{\"1\":{\"185\":1}}],[\"有碰撞的\",{\"1\":{\"884\":1}}],[\"有几个哈希函数得到几个哈希值\",{\"1\":{\"882\":1}}],[\"有几个构造方法\",{\"1\":{\"399\":1}}],[\"有报告表明能支持高达\",{\"1\":{\"824\":1}}],[\"有四个worker\",{\"1\":{\"836\":1}}],[\"有四种类型的znode\",{\"1\":{\"818\":1}}],[\"有四部分组成\",{\"1\":{\"622\":1}}],[\"有针对分布式系统存在问题的一套解决方案\",{\"1\":{\"815\":1}}],[\"有完善的监控管理功能\",{\"1\":{\"805\":1}}],[\"有流量进来先不要分给我\",{\"1\":{\"802\":1}}],[\"有状态的\",{\"1\":{\"735\":1}}],[\"有消息延时和消息冗余的问题\",{\"1\":{\"660\":1}}],[\"有三种方式\",{\"1\":{\"649\":1}}],[\"有三种不同的编码方式\",{\"1\":{\"617\":1}}],[\"有更好的持久化性\",{\"1\":{\"649\":1}}],[\"有更新操作就更新缓存就好了\",{\"1\":{\"642\":1}}],[\"有更早过期时间的\",{\"1\":{\"636\":1}}],[\"有更高优先级的线程需要运行\",{\"1\":{\"144\":1}}],[\"有事件发生时\",{\"1\":{\"612\":1}}],[\"有了粘包和拆包的可能\",{\"1\":{\"1006\":1}}],[\"有了它我们就可以使用分布式的思想来架构应用\",{\"1\":{\"809\":1}}],[\"有了\",{\"1\":{\"718\":1}}],[\"有了持久化机制\",{\"1\":{\"646\":1}}],[\"有了两次写机制\",{\"1\":{\"593\":1}}],[\"有了redo\",{\"1\":{\"568\":1}}],[\"有没有一个极端的情况呢\",{\"1\":{\"578\":1}}],[\"有大量的\",{\"1\":{\"562\":1}}],[\"有且只有一个聚簇索引\",{\"1\":{\"545\":1}}],[\"有且只有六种情况必须立刻对类进行初始化\",{\"1\":{\"174\":1}}],[\"有效减少头信息大小\",{\"1\":{\"1042\":1}}],[\"有效减少了磁盘io的次数\",{\"1\":{\"529\":1}}],[\"有效应对大并发量的读操作\",{\"1\":{\"675\":1}}],[\"有效避免跨分片查询的问题\",{\"1\":{\"587\":1}}],[\"有效防止\",{\"1\":{\"461\":1,\"596\":1,\"750\":1}}],[\"有线程安全问题\",{\"1\":{\"499\":2}}],[\"有排序效果\",{\"1\":{\"485\":1}}],[\"有些读者可能容易将他们混淆\",{\"1\":{\"716\":1}}],[\"有些时候会猛访问个别服务器上的库\",{\"1\":{\"587\":1}}],[\"有些分片存储最近时间段内的数据\",{\"1\":{\"587\":1}}],[\"有些客户端连接框架会默认连接成功后先执行一个\",{\"1\":{\"526\":1}}],[\"有些数据库中虽然主键不是必须的\",{\"1\":{\"464\":1}}],[\"有些资料major\",{\"1\":{\"240\":1}}],[\"有关\",{\"1\":{\"429\":2,\"623\":1}}],[\"有头尾节点\",{\"1\":{\"412\":1}}],[\"有同步和异步的说法\",{\"1\":{\"380\":1}}],[\"有兼容的返回类型\",{\"1\":{\"359\":1}}],[\"有自动内存管理机制\",{\"1\":{\"336\":1}}],[\"有很可能导致内存泄漏的发生\",{\"1\":{\"304\":1}}],[\"有很大的数据需要存储\",{\"1\":{\"210\":1}}],[\"有计划地避免在整个java堆中进行全区域的垃圾收集\",{\"1\":{\"260\":1}}],[\"有\",{\"1\":{\"247\":1,\"381\":1,\"450\":1,\"488\":1,\"1245\":1}}],[\"有永久代\",{\"1\":{\"204\":2}}],[\"有的对象可能不需要作为一个连续的内存结构存在也可以被访问到\",{\"1\":{\"202\":1}}],[\"有基础类型又要调用回用户的代码\",{\"1\":{\"185\":1}}],[\"有其他文件生成\",{\"1\":{\"168\":1}}],[\"有其他的\",{\"1\":{\"72\":1}}],[\"有两种策略\",{\"1\":{\"516\":1}}],[\"有两种设计方案\",{\"1\":{\"455\":1}}],[\"有两种解决方案\",{\"1\":{\"251\":1}}],[\"有两种退出方式\",{\"1\":{\"195\":1}}],[\"有两种模式\",{\"1\":{\"117\":1}}],[\"有两种情况会调用\",{\"1\":{\"402\":1}}],[\"有两种情况\",{\"1\":{\"87\":2}}],[\"有哪两种模式\",{\"1\":{\"115\":1}}],[\"有直接监测死锁的按钮\",{\"1\":{\"98\":1}}],[\"有一些对象其实我们只需要一个\",{\"1\":{\"713\":1}}],[\"有一定的延时\",{\"1\":{\"684\":1}}],[\"有一个保活计时器\",{\"1\":{\"1022\":1}}],[\"有一个1g大小的一个文件\",{\"0\":{\"894\":1},\"1\":{\"889\":1}}],[\"有一个文件描述符\",{\"1\":{\"612\":1}}],[\"有一个后台线程\",{\"1\":{\"568\":1}}],[\"有一组等待进程\",{\"1\":{\"98\":1}}],[\"有一种情况就是其它线程已经为这个对象加上了轻量级锁\",{\"1\":{\"89\":1}}],[\"有时执行\",{\"1\":{\"1201\":1}}],[\"有时要同多个部门联系\",{\"1\":{\"1090\":1}}],[\"有时把路由器也称为网关\",{\"1\":{\"965\":1}}],[\"有时\",{\"1\":{\"98\":1}}],[\"有时候我们写的代码完全不需要加锁\",{\"1\":{\"92\":1}}],[\"有什么区别\",{\"0\":{\"77\":1}}],[\"有数据依赖的不会重排序\",{\"1\":{\"76\":1}}],[\"有序等特征\",{\"1\":{\"625\":1}}],[\"有序是通过\",{\"1\":{\"412\":1}}],[\"有序\",{\"1\":{\"71\":1}}],[\"有序性\",{\"0\":{\"67\":1},\"1\":{\"67\":1,\"79\":1,\"295\":1}}],[\"有序性和原子性\",{\"1\":{\"65\":1}}],[\"有可能不止一台dhcp中继代理都到了发现报文\",{\"1\":{\"1049\":1}}],[\"有可能是因为某个数据报出现了丢失或者损害\",{\"1\":{\"1020\":1}}],[\"有可能是链表\",{\"1\":{\"398\":1}}],[\"有可能出现低版本的\",{\"1\":{\"648\":1}}],[\"有可能出现\",{\"1\":{\"259\":1}}],[\"有可能会出现由编译器自动添加的方法\",{\"1\":{\"290\":1}}],[\"有可能会出现某些类的路径一样\",{\"1\":{\"180\":1}}],[\"有可能会发生局部的样式污染\",{\"1\":{\"24\":1}}],[\"有可能先阻塞的线程最后才访问队列\",{\"1\":{\"62\":1}}],[\"⑥\",{\"1\":{\"58\":1}}],[\"⑤sql线程读取i\",{\"1\":{\"469\":1,\"580\":1}}],[\"⑤\",{\"1\":{\"58\":1,\"647\":1}}],[\"④i\",{\"1\":{\"469\":1,\"580\":1}}],[\"④\",{\"1\":{\"58\":1,\"647\":1}}],[\"避免由于资源操作时导致的性能或损耗等\",{\"1\":{\"1073\":1}}],[\"避免对共享资源的多重占用\",{\"1\":{\"1071\":1}}],[\"避免对象乱创建导致额外的内存开销\",{\"1\":{\"718\":1}}],[\"避免频繁的创建销毁对象\",{\"1\":{\"1071\":1}}],[\"避免一个全局使用的类频繁创建与销毁对象实例\",{\"1\":{\"1065\":1}}],[\"避免脏读\",{\"1\":{\"752\":1}}],[\"避免活动开始的一瞬间数据压力暴增\",{\"1\":{\"640\":1}}],[\"避免在用户请求的时候\",{\"1\":{\"640\":1}}],[\"避免在用户态与内核态之间来回拷贝数据的技术\",{\"1\":{\"138\":1}}],[\"避免了\",{\"1\":{\"982\":1}}],[\"避免了同步写回的性能开销\",{\"1\":{\"650\":1}}],[\"避免了缩短字符串时所需的内存重分配次数\",{\"1\":{\"624\":1}}],[\"避免了耗时操作\",{\"1\":{\"615\":1}}],[\"避免了加锁操作\",{\"1\":{\"499\":1}}],[\"避免使用\",{\"1\":{\"560\":1}}],[\"避免创建索引的情况\",{\"0\":{\"532\":1}}],[\"避免创建不需要的线程\",{\"1\":{\"144\":1}}],[\"避免大事务\",{\"1\":{\"516\":1}}],[\"避免\",{\"1\":{\"516\":1}}],[\"避免死锁\",{\"1\":{\"516\":1,\"672\":1}}],[\"避免缓冲写带来的问题\",{\"1\":{\"496\":1}}],[\"避免cms那样在最终标记阶段停顿时间过长的缺点\",{\"1\":{\"251\":1}}],[\"避免类的冲突\",{\"1\":{\"180\":1}}],[\"避免指令重排序\",{\"1\":{\"101\":1,\"714\":1,\"1068\":1}}],[\"避免int值累计过大溢出\",{\"1\":{\"96\":1}}],[\"避免浪费内存资源\",{\"1\":{\"58\":1}}],[\"避免出现内存泄露\",{\"1\":{\"45\":1}}],[\"直面外来请求转发给后面的应用服务\",{\"1\":{\"825\":1}}],[\"直至超时\",{\"1\":{\"1060\":1}}],[\"直至服务提供者返回结果\",{\"1\":{\"814\":1}}],[\"直至进行到第一条不满足条件的记录\",{\"1\":{\"501\":1}}],[\"直至\",{\"1\":{\"118\":1}}],[\"直至所有线程的任务都执行完毕\",{\"1\":{\"118\":1}}],[\"直到分解得到的小文件的大小都不超过1m\",{\"1\":{\"894\":1}}],[\"直到它同步完成\",{\"1\":{\"853\":1}}],[\"直到它收集结束\",{\"1\":{\"254\":1}}],[\"直到他们被完全销毁\",{\"1\":{\"718\":1}}],[\"直到拷贝完毕\",{\"1\":{\"615\":1}}],[\"直到内核缓冲区数据被\",{\"1\":{\"613\":1}}],[\"直到碰到第一个不满足\",{\"1\":{\"555\":1}}],[\"直到查找到叶子节点\",{\"1\":{\"538\":1}}],[\"直到事务提交时才会释放\",{\"1\":{\"523\":1}}],[\"直到提交的时候才去锁定\",{\"1\":{\"513\":1}}],[\"直到t释放a上的锁\",{\"1\":{\"509\":1}}],[\"直到不满足\",{\"1\":{\"484\":1}}],[\"直到\",{\"1\":{\"484\":1,\"509\":1,\"623\":1,\"647\":1,\"668\":1,\"927\":1}}],[\"直到该文件描述符上出现第二次可读写事件才会通知你\",{\"1\":{\"381\":1}}],[\"直到下次再有数据流入之前都不会再提示了\",{\"1\":{\"381\":1}}],[\"直到以下事件发生\",{\"1\":{\"350\":1}}],[\"直到获得锁或者被中断\",{\"1\":{\"350\":1}}],[\"直到执行结束\",{\"1\":{\"303\":1}}],[\"直到扫到空\",{\"1\":{\"301\":1}}],[\"直到成功为止\",{\"1\":{\"219\":1}}],[\"直到这个类第一次使用时才初始化\",{\"1\":{\"183\":1}}],[\"直到初始化阶段\",{\"1\":{\"173\":1}}],[\"直到磁头到达该方向上的最后的磁道\",{\"1\":{\"163\":1}}],[\"直到最后一个线程到达屏障时\",{\"1\":{\"120\":1}}],[\"直到有一个许可证可以获得然后拿走一个许可证\",{\"1\":{\"117\":1}}],[\"直到队列非空\",{\"1\":{\"62\":1}}],[\"直到队列不满\",{\"1\":{\"62\":1}}],[\"直到只剩下\",{\"1\":{\"58\":1}}],[\"直接\",{\"1\":{\"1157\":1}}],[\"直接修改\",{\"1\":{\"1156\":1}}],[\"直接定址法\",{\"1\":{\"923\":1}}],[\"直接返回集合中的对象\",{\"1\":{\"1091\":1}}],[\"直接返回\",{\"1\":{\"911\":2}}],[\"直接返回记录上的最新值\",{\"1\":{\"524\":1}}],[\"直接读入内存大约需要16g\",{\"1\":{\"901\":1}}],[\"直接忽略\",{\"1\":{\"813\":1}}],[\"直接压栈即可\",{\"1\":{\"801\":1}}],[\"直接执行\",{\"1\":{\"781\":1}}],[\"直接实现\",{\"1\":{\"759\":1}}],[\"直接编写原生\",{\"1\":{\"749\":1}}],[\"直接把参数压到栈中\",{\"1\":{\"804\":1}}],[\"直接把锁分配给他就可以了\",{\"1\":{\"668\":1}}],[\"直接把值刷新回主内存\",{\"1\":{\"69\":1}}],[\"直接将指明的值作为partition的值\",{\"1\":{\"852\":1}}],[\"直接将数据保存在\",{\"1\":{\"617\":1}}],[\"直接将其覆盖原来的数据页即可\",{\"1\":{\"593\":1}}],[\"直接操作缓存能够承受的请求是远远大于直接访问数据库的\",{\"1\":{\"606\":1}}],[\"直接自己构建了\",{\"1\":{\"604\":1}}],[\"直接提交\",{\"1\":{\"578\":1}}],[\"直接插入这个值\",{\"1\":{\"574\":1}}],[\"直接持久化到磁盘\",{\"1\":{\"568\":1}}],[\"直接过滤掉不满足条件的记录\",{\"1\":{\"553\":1}}],[\"直接通过\",{\"1\":{\"553\":1}}],[\"直接根据对应的叶子地址去查询数据\",{\"1\":{\"550\":1}}],[\"直接用加锁的方式来避免并行访问\",{\"1\":{\"524\":1}}],[\"直接到仓库区\",{\"1\":{\"448\":1}}],[\"直接在操作方法上加\",{\"1\":{\"409\":1}}],[\"直接放入数组中\",{\"1\":{\"397\":1}}],[\"直接可以通过下标访问\",{\"1\":{\"392\":1}}],[\"直接缓冲区通过在操作系统和\",{\"1\":{\"378\":1}}],[\"直接缓冲区\",{\"1\":{\"378\":1}}],[\"直接缓冲区与非直接缓冲区\",{\"0\":{\"378\":1}}],[\"直接有效\",{\"1\":{\"354\":1}}],[\"直接调用\",{\"1\":{\"343\":1,\"356\":1}}],[\"直接简单复制一份\",{\"1\":{\"343\":1}}],[\"直接送入类加载器中\",{\"1\":{\"284\":1}}],[\"直接设置吞吐量大小\",{\"1\":{\"257\":1}}],[\"直接指针\",{\"0\":{\"230\":1}}],[\"直接内存溢出direct\",{\"1\":{\"297\":1}}],[\"直接内存使用场景\",{\"0\":{\"210\":1}}],[\"直接内存\",{\"0\":{\"209\":1},\"1\":{\"209\":1,\"323\":1}}],[\"直接引⽤\",{\"1\":{\"203\":1}}],[\"直接引用是可以直接指向目标的指针\",{\"1\":{\"172\":1}}],[\"直接引用\",{\"1\":{\"172\":1}}],[\"直接重入\",{\"1\":{\"96\":1}}],[\"直接丢弃任务\",{\"1\":{\"60\":1}}],[\"直接抛出异常\",{\"1\":{\"60\":1}}],[\"直接扔给阻塞队列\",{\"1\":{\"50\":1}}],[\"③当master节点的binlog发生变化时\",{\"1\":{\"469\":1,\"580\":1}}],[\"③\",{\"1\":{\"58\":1,\"339\":1,\"647\":1}}],[\"≥\",{\"1\":{\"58\":2,\"398\":1}}],[\"②模型处理完毕后\",{\"1\":{\"754\":1}}],[\"②salve从库连接master主库\",{\"1\":{\"469\":1,\"580\":1}}],[\"②\",{\"1\":{\"58\":1,\"339\":1,\"647\":1}}],[\"①接收请求\",{\"1\":{\"754\":1}}],[\"①当master节点进行insert\",{\"1\":{\"469\":1,\"580\":1}}],[\"①\",{\"1\":{\"58\":1,\"339\":1,\"647\":1}}],[\"耗时\",{\"1\":{\"57\":2}}],[\"耗时所占比例越高\",{\"1\":{\"57\":2}}],[\"通俗来讲就是\",{\"1\":{\"1064\":1}}],[\"通行证\",{\"1\":{\"1052\":1}}],[\"通讯时\",{\"1\":{\"1044\":1}}],[\"通讯\",{\"1\":{\"660\":1}}],[\"通信结束后释放连接\",{\"1\":{\"1022\":1}}],[\"通信的真正端点并不是主机而是主机中的进程\",{\"1\":{\"997\":1}}],[\"通信\",{\"1\":{\"986\":1}}],[\"通信方式分类\",{\"1\":{\"966\":1}}],[\"通信方式的选择\",{\"1\":{\"149\":1}}],[\"通信不必每次都要像\",{\"1\":{\"805\":1}}],[\"通信超时\",{\"1\":{\"659\":1}}],[\"通道表示\",{\"1\":{\"379\":1}}],[\"通道\",{\"0\":{\"379\":1},\"1\":{\"380\":1}}],[\"通常是\",{\"1\":{\"1212\":1}}],[\"通常是一台路由器\",{\"1\":{\"1049\":1}}],[\"通常都是使用工厂模式进行创建\",{\"1\":{\"1086\":1}}],[\"通常称为截获\",{\"1\":{\"1054\":1}}],[\"通常可省略\",{\"1\":{\"1036\":1}}],[\"通常\",{\"1\":{\"997\":1}}],[\"通常需要总数据量可以放入内存\",{\"1\":{\"884\":1}}],[\"通常用在内网和不需要流控等小型服务的场景\",{\"1\":{\"825\":1}}],[\"通常的做法是获取\",{\"1\":{\"679\":1}}],[\"通常的做法是将数据库复制到多个副本部署在不同的服务器上\",{\"1\":{\"655\":1}}],[\"通常哨兵配置数量为单数\",{\"1\":{\"676\":1}}],[\"通常这部分\",{\"1\":{\"653\":1}}],[\"通常一个请求过来之后我们会先查询缓存\",{\"1\":{\"645\":1}}],[\"通常会存在大量键\",{\"1\":{\"637\":1}}],[\"通常会伴随更大的性能影响\",{\"1\":{\"295\":1}}],[\"通常比all快\",{\"1\":{\"556\":1}}],[\"通常情况下\",{\"1\":{\"299\":1,\"549\":1,\"850\":1}}],[\"通常也是占用class文件空间最大的数据项目之一\",{\"1\":{\"286\":1}}],[\"通常只需要设置\",{\"1\":{\"263\":1}}],[\"通常能单独发生收集行为的只是新生代\",{\"1\":{\"240\":1}}],[\"通常访问直接内存的速度会优于java堆\",{\"1\":{\"209\":1}}],[\"通常调用\",{\"1\":{\"59\":1}}],[\"通知信息\",{\"1\":{\"1040\":1}}],[\"通知消费者从队列中拉取消息进行消费\",{\"1\":{\"844\":1}}],[\"通知机制\",{\"1\":{\"816\":1}}],[\"通知类型\",{\"0\":{\"722\":1}}],[\"通知虚拟机自动为静态变量赋值\",{\"1\":{\"292\":1}}],[\"通知线程从\",{\"1\":{\"126\":1}}],[\"通知模式\",{\"1\":{\"126\":2}}],[\"通知\",{\"1\":{\"72\":2,\"677\":1,\"721\":1,\"816\":1}}],[\"通知时\",{\"1\":{\"72\":1}}],[\"通用公式\",{\"1\":{\"57\":1}}],[\"通过不同的具体建造者创建不同类型的地图或人物\",{\"1\":{\"1086\":1}}],[\"通过装饰角色为其添加一些职责\",{\"1\":{\"1085\":1}}],[\"通过重写父类的方法来完成新的功能写起来虽然简单\",{\"1\":{\"1064\":1}}],[\"通过自动重传请求arq可以在不可靠的传输网络上实现可靠的通信\",{\"1\":{\"1004\":1}}],[\"通过和其他路由器交换路由信息\",{\"1\":{\"993\":1}}],[\"通过ip地址这个设备的编号\",{\"1\":{\"961\":1}}],[\"通过id索引定位到第一条满足查询条件的记录\",{\"1\":{\"501\":1}}],[\"通过对待排序序列从前向后\",{\"1\":{\"930\":1}}],[\"通过对这颗红黑树进行操作\",{\"1\":{\"612\":1}}],[\"通过散列函数计算记录的散列地址\",{\"1\":{\"922\":1}}],[\"通过加权的方式\",{\"1\":{\"869\":1}}],[\"通过加锁或者队列来控制读数据库写缓存的线程数量\",{\"1\":{\"642\":1}}],[\"通过分隔符将其转为字符串数组\",{\"1\":{\"955\":1}}],[\"通过分区的leader副本负责数据顺序写入\",{\"1\":{\"865\":1}}],[\"通过分离读锁和写锁使并发性相比排他锁有了很大提升\",{\"1\":{\"125\":1}}],[\"通过给特定\",{\"1\":{\"861\":1}}],[\"通过mq给b\",{\"1\":{\"841\":1}}],[\"通过异步非阻塞的方式来处理请求\",{\"1\":{\"835\":1}}],[\"通过ps\",{\"1\":{\"830\":1}}],[\"通过代理对象调用\",{\"1\":{\"1084\":1}}],[\"通过代理对象来实现真实对象的方法和之前略有不同\",{\"1\":{\"726\":1}}],[\"通过代理服务器来访问服务器的过程就叫正向代理\",{\"1\":{\"826\":1}}],[\"通过反射调用相应的业务服务并拿到业务处理结果\",{\"1\":{\"804\":1}}],[\"通过socket\",{\"1\":{\"829\":1}}],[\"通过systempath来取得\",{\"1\":{\"797\":1}}],[\"通过servletcontext对象获取applicationcontext对象\",{\"1\":{\"736\":1}}],[\"通过实现一个controlleradvice类\",{\"1\":{\"791\":1}}],[\"通过运用像\",{\"1\":{\"770\":1}}],[\"通过把model\",{\"1\":{\"754\":1}}],[\"通过映射来实现\",{\"1\":{\"751\":1}}],[\"通过定义一个resultmap对列名和pojo属性名之间作一个映射关系\",{\"1\":{\"751\":1}}],[\"通过编码的形式来管理和维护事务\",{\"1\":{\"739\":1}}],[\"通过<aop\",{\"1\":{\"728\":2}}],[\"通过控制反转实现了松散耦合\",{\"1\":{\"717\":1}}],[\"通过控制变量值的版本来解决\",{\"1\":{\"106\":1}}],[\"通过建立一个对象代理类\",{\"1\":{\"715\":1}}],[\"通过发布订阅模式切换\",{\"1\":{\"677\":1}}],[\"通过发送命令\",{\"1\":{\"657\":1}}],[\"通过投票机制选择新的\",{\"1\":{\"676\":1}}],[\"通过获取所有能获取的锁后的时间减去第一步的时间\",{\"1\":{\"672\":1}}],[\"通过主从复制可以允许多个\",{\"1\":{\"661\":1}}],[\"通过增加\",{\"1\":{\"660\":1,\"678\":1}}],[\"通过配置文件中的\",{\"1\":{\"647\":1}}],[\"通过调整定时扫描的时间间隔和每次扫描的限定耗时\",{\"1\":{\"632\":1}}],[\"通过调用\",{\"1\":{\"38\":1}}],[\"通过过期时间我们可以指定这个\",{\"1\":{\"632\":1}}],[\"通过它定位到表尾节点的时间复杂度为\",{\"1\":{\"630\":1}}],[\"通过它定位到表头节点的时间复杂度为\",{\"1\":{\"630\":1}}],[\"通过它可以对数据进行连续处理\",{\"1\":{\"438\":1}}],[\"通过在每个节点中维持多个指向其它节点的指针\",{\"1\":{\"630\":1}}],[\"通过在部分加锁和利用\",{\"1\":{\"410\":1}}],[\"通过创建多个\",{\"1\":{\"629\":1}}],[\"通过创建唯一性索引\",{\"1\":{\"528\":1}}],[\"通过记录\",{\"1\":{\"623\":1}}],[\"通过回调函数内核会将其加入到这个就绪事件列表中\",{\"1\":{\"612\":1}}],[\"通过两个方面\",{\"1\":{\"612\":1}}],[\"通过执行sql语句进而执行攻击者所要的操作\",{\"1\":{\"595\":1}}],[\"通过执行特权指令\",{\"1\":{\"134\":1}}],[\"通过修改或者封装jdbc层来实现\",{\"1\":{\"586\":1}}],[\"通过修改类文件\",{\"1\":{\"187\":1}}],[\"通过扩充主机的数量缓解单一数据库的性能问题\",{\"1\":{\"585\":1}}],[\"通过索引覆盖方式直接返回有序数据\",{\"1\":{\"560\":1}}],[\"通过慢查询日志去寻找哪些\",{\"1\":{\"559\":1}}],[\"通过辅助索引首先找到的是主键值\",{\"1\":{\"547\":1}}],[\"通过顺序访问指针来提高区间查询的性能\",{\"1\":{\"538\":1}}],[\"通过显式语句的方式来启动事务\",{\"1\":{\"526\":1}}],[\"通过union连接的sql它们分别单独取出的列数必须相同\",{\"1\":{\"485\":1}}],[\"通过传入\",{\"1\":{\"409\":1}}],[\"通过下标可以直接取数据\",{\"1\":{\"391\":1}}],[\"通过内核和用户空间共享一块内存来实现的\",{\"1\":{\"381\":1}}],[\"通过内置的\",{\"1\":{\"110\":1}}],[\"通过将有读写事件发生的连接重排至头部\",{\"1\":{\"381\":1}}],[\"通过多路复用器\",{\"1\":{\"380\":1}}],[\"通过allocatedirect\",{\"1\":{\"378\":1}}],[\"通过非直接缓冲区\",{\"1\":{\"378\":1}}],[\"通过继承使得子类具有父类的属性和方法\",{\"1\":{\"355\":1}}],[\"通过tomcat运行war包\",{\"1\":{\"317\":1}}],[\"通过更改参数\",{\"1\":{\"309\":1}}],[\"通过gcviewer等工具来分析日志信息\",{\"1\":{\"308\":1}}],[\"通过getname\",{\"1\":{\"181\":1}}],[\"通过constant\",{\"1\":{\"288\":1}}],[\"通过解释器解释执行\",{\"1\":{\"283\":1}}],[\"通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置\",{\"1\":{\"172\":1}}],[\"通过binary\",{\"1\":{\"281\":1}}],[\"通过一趟排序将待排记录分割成独立的两部分\",{\"1\":{\"935\":1}}],[\"通过一个外观角色访问各个子系统的功能\",{\"1\":{\"1090\":1}}],[\"通过一个自动配置和启动的项目来解决这个问题\",{\"1\":{\"770\":1}}],[\"通过一个类的全限定名来获取定义此类的二进制字节流\",{\"1\":{\"168\":1}}],[\"通过一系列位运算和或运算得到的是\",{\"1\":{\"404\":1}}],[\"通过一系列的称为\",{\"1\":{\"234\":1}}],[\"通过逃逸分析\",{\"1\":{\"202\":1}}],[\"通过参数\",{\"1\":{\"199\":1}}],[\"通过这种依赖关系\",{\"1\":{\"769\":1}}],[\"通过这种方式就能保证这个数据逻辑的正确性\",{\"1\":{\"574\":1}}],[\"通过这种方式就可以确保当前\",{\"1\":{\"72\":1}}],[\"通过这种方式就可以让\",{\"1\":{\"72\":1}}],[\"通过这个值\",{\"1\":{\"659\":1}}],[\"通过这个类加载器可以实现逆向访问类\",{\"1\":{\"179\":1}}],[\"通过这些api可以监控我们的应用程序服务器的堆内存使用情况\",{\"1\":{\"327\":1}}],[\"通过这样的措施来保证对代码的有限隔离\",{\"1\":{\"186\":1}}],[\"通过类的全限定名来获取二进制流\",{\"1\":{\"168\":1}}],[\"通过页表对应逻辑地址和物理地址\",{\"1\":{\"153\":1}}],[\"通过循环\",{\"1\":{\"123\":1}}],[\"通过使用不用装饰类及这些装饰类的排列组合\",{\"1\":{\"1085\":1}}],[\"通过使用runtime和managementfactory\",{\"1\":{\"327\":1}}],[\"通过使用本地方法\",{\"1\":{\"197\":1}}],[\"通过使用\",{\"1\":{\"98\":1}}],[\"通过互斥同步方式保证原子性\",{\"1\":{\"68\":1}}],[\"通过线程复用\",{\"1\":{\"53\":1}}],[\"通过线程池创建线程\",{\"1\":{\"31\":1}}],[\"通过查看源码可以发现\",{\"1\":{\"32\":1}}],[\"通过\",{\"1\":{\"31\":1,\"56\":1,\"72\":1,\"88\":1,\"102\":1,\"349\":1,\"378\":1,\"381\":1,\"523\":2,\"612\":1,\"626\":1,\"679\":1,\"736\":2,\"787\":1,\"801\":1,\"822\":1,\"825\":1,\"827\":1,\"1042\":1,\"1092\":1,\"1127\":1,\"1210\":1}}],[\"倍了\",{\"1\":{\"623\":1}}],[\"倍或\",{\"1\":{\"227\":1}}],[\"倍\",{\"1\":{\"57\":1,\"227\":1,\"392\":1,\"623\":1}}],[\"核心工厂类不再负责产品的创建\",{\"1\":{\"1078\":1}}],[\"核心部分\",{\"1\":{\"960\":1}}],[\"核心代码\",{\"1\":{\"933\":1,\"951\":1,\"953\":1,\"954\":1,\"955\":1,\"956\":1}}],[\"核心思想\",{\"1\":{\"871\":1}}],[\"核心思想是\",{\"1\":{\"110\":1}}],[\"核心的性能发挥到极致\",{\"1\":{\"835\":1}}],[\"核心关注点和横切关注点\",{\"1\":{\"719\":1}}],[\"核心函数\",{\"1\":{\"647\":1}}],[\"核心\",{\"1\":{\"622\":1}}],[\"核心线程也不会被销毁\",{\"1\":{\"58\":1}}],[\"核心线程数是\",{\"1\":{\"56\":1}}],[\"核心线程数\",{\"1\":{\"56\":2}}],[\"核心数相等是最为适宜的\",{\"1\":{\"835\":1}}],[\"核心数的\",{\"1\":{\"57\":1}}],[\"核心数\",{\"1\":{\"57\":2}}],[\"最长报文段寿命\",{\"1\":{\"1026\":1}}],[\"最长前缀匹配\",{\"1\":{\"991\":1}}],[\"最上面是应用层\",{\"1\":{\"964\":1}}],[\"最底层的叶子节点形成了一个双向有序链表\",{\"1\":{\"920\":1}}],[\"最高位为1\",{\"1\":{\"901\":1}}],[\"最高位为0\",{\"1\":{\"901\":1}}],[\"最高的隔离级别\",{\"1\":{\"522\":1,\"741\":1}}],[\"最优归并树\",{\"1\":{\"889\":1}}],[\"最小堆求前n大\",{\"1\":{\"885\":1}}],[\"最少链接\",{\"1\":{\"869\":1}}],[\"最少连接\",{\"1\":{\"869\":1}}],[\"最少使用页面置换算法\",{\"1\":{\"160\":1}}],[\"最可靠的一台服务器\",{\"1\":{\"820\":1}}],[\"最直接的例子就是代理\",{\"1\":{\"718\":1}}],[\"最慢\",{\"1\":{\"650\":1}}],[\"最初所有的值均设置为\",{\"1\":{\"645\":1}}],[\"最初的事务修改值\",{\"1\":{\"521\":1}}],[\"最不经常使用\",{\"1\":{\"633\":1}}],[\"最近最少使用算法\",{\"1\":{\"633\":1}}],[\"最近最久未使用\",{\"1\":{\"160\":1}}],[\"最坏情况下所有数据都需要迁移\",{\"1\":{\"880\":1}}],[\"最坏\",{\"1\":{\"630\":1}}],[\"最好\",{\"1\":{\"932\":1}}],[\"最好可以让数据划分后可以一次读入内存\",{\"1\":{\"891\":1}}],[\"最好能满足以下的时间条件\",{\"1\":{\"879\":1}}],[\"最好的解决方案是用构造器参数实现强制依赖\",{\"1\":{\"730\":1}}],[\"最好的办法就是一开始就启动较多实例\",{\"1\":{\"671\":1}}],[\"最好将对象交由\",{\"1\":{\"729\":1}}],[\"最好选择\",{\"1\":{\"720\":1}}],[\"最好通过分库分表解决\",{\"1\":{\"585\":1}}],[\"最好达到\",{\"1\":{\"556\":1}}],[\"最好手动调用remove\",{\"1\":{\"300\":1}}],[\"最外层查询标记为该标识\",{\"1\":{\"556\":1}}],[\"最左前缀原则\",{\"0\":{\"552\":1}}],[\"最左前缀匹配原则\",{\"1\":{\"533\":1}}],[\"最低的隔离级别\",{\"1\":{\"522\":1,\"741\":1}}],[\"最多有个2^32个ip\",{\"1\":{\"892\":1}}],[\"最多2^32个\",{\"1\":{\"884\":1}}],[\"最多只会返回一条记录\",{\"1\":{\"501\":1}}],[\"最多设置8\",{\"1\":{\"262\":1}}],[\"最快\",{\"1\":{\"483\":1}}],[\"最常用的以太网的mtu值是1500\",{\"1\":{\"987\":1}}],[\"最常用的方法\",{\"1\":{\"923\":1}}],[\"最常用的是class\",{\"1\":{\"183\":1}}],[\"最常用在目录的删除\",{\"1\":{\"424\":1}}],[\"最常见的便是类构造器<clinit>\",{\"1\":{\"290\":1}}],[\"最主要的改进就是引入了持续连接\",{\"1\":{\"1042\":1}}],[\"最主要的特点有两个\",{\"1\":{\"991\":1}}],[\"最主要的特点是轻量以及快速\",{\"1\":{\"609\":1}}],[\"最主要的应用是需要低gc延迟\",{\"1\":{\"261\":1}}],[\"最主要的区别就是\",{\"1\":{\"205\":1}}],[\"最新出现\",{\"1\":{\"240\":1}}],[\"最短寻道时间优先算法\",{\"1\":{\"163\":1}}],[\"最终给客户端调用\",{\"1\":{\"1088\":1}}],[\"最终目的\",{\"1\":{\"1064\":1}}],[\"最终向用户呈现一个完整的页面\",{\"1\":{\"959\":1,\"1029\":1}}],[\"最终我们在\",{\"1\":{\"893\":1}}],[\"最终一致性\",{\"1\":{\"871\":1}}],[\"最终通知\",{\"1\":{\"722\":1}}],[\"最终\",{\"1\":{\"672\":1,\"696\":1}}],[\"最终都会导致数据库的活跃连接数增加\",{\"1\":{\"584\":1}}],[\"最终数据库所能承载的数据量\",{\"1\":{\"583\":1}}],[\"最终只好为了清理回滚段\",{\"1\":{\"525\":1}}],[\"最终持有的\",{\"1\":{\"501\":1}}],[\"最终的变量是放在了当前线程的\",{\"1\":{\"299\":1}}],[\"最终是要编译成一个独立的class文件来存储的\",{\"1\":{\"292\":1}}],[\"最终变为字节码指令存储在code属性内\",{\"1\":{\"292\":1}}],[\"最终标记\",{\"1\":{\"264\":1}}],[\"最终形成可以直接被虚拟机使用的java类型\",{\"1\":{\"165\":1}}],[\"最终达到运行时连接的目的\",{\"1\":{\"161\":1}}],[\"最终汇总每个小任务结果后得到大任务结果的框架\",{\"1\":{\"49\":1}}],[\"最佳的上限\",{\"1\":{\"629\":1}}],[\"最佳置换算法\",{\"1\":{\"160\":1}}],[\"最佳线程数=\",{\"1\":{\"57\":1}}],[\"最后确认\",{\"1\":{\"1026\":1}}],[\"最后\",{\"1\":{\"930\":1,\"1031\":1}}],[\"最后要检查\",{\"1\":{\"912\":1,\"913\":1}}],[\"最后就是把这5000个文件进行归并\",{\"1\":{\"894\":1}}],[\"最后是统计功能\",{\"1\":{\"801\":1}}],[\"最后以\",{\"1\":{\"755\":1}}],[\"最后提供一种不依赖于servlet\",{\"1\":{\"736\":1}}],[\"最后攻克了技术难点\",{\"1\":{\"693\":1}}],[\"最后使用算法定位数据访问到相应服务器\",{\"1\":{\"681\":1}}],[\"最后替换原来的文件\",{\"1\":{\"651\":1}}],[\"最后将基准为与i和j相等位置的数字交换\",{\"1\":{\"935\":1}}],[\"最后将\",{\"1\":{\"623\":1}}],[\"最后再进行合并\",{\"1\":{\"895\":1}}],[\"最后再把内存中的数据变动同步到磁盘上\",{\"1\":{\"568\":1}}],[\"最后再跳转到程序计数器所指的新位置\",{\"1\":{\"144\":1}}],[\"最后一步是比较第三行的值是否是\",{\"1\":{\"537\":1}}],[\"最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候\",{\"1\":{\"170\":1}}],[\"最后判断哈希表是否满了\",{\"1\":{\"397\":1}}],[\"最后返回结束\",{\"1\":{\"501\":1}}],[\"最后返回\",{\"1\":{\"349\":1}}],[\"最后通过散列算法定位到元素\",{\"1\":{\"129\":1}}],[\"最基本的互斥同步手段就是\",{\"1\":{\"142\":1}}],[\"最核心的部分\",{\"1\":{\"133\":1}}],[\"最大允许数据包大小\",{\"1\":{\"1177\":1}}],[\"最大报文段长度\",{\"1\":{\"1016\":1}}],[\"最大报文段长度mss\",{\"1\":{\"1007\":1}}],[\"最大需要15个字符\",{\"1\":{\"997\":1}}],[\"最大传输单元\",{\"1\":{\"982\":1}}],[\"最大传送单元\",{\"1\":{\"975\":1}}],[\"最大传送单元mtu\",{\"1\":{\"972\":1}}],[\"最大分段大小\",{\"1\":{\"982\":1}}],[\"最大堆求前n小\",{\"1\":{\"885\":1}}],[\"最大的问题在于网络地址资源有限\",{\"1\":{\"996\":1}}],[\"最大的从节点作为主节点\",{\"1\":{\"677\":1}}],[\"最大的缺陷就是单个进程所打开的\",{\"1\":{\"381\":1}}],[\"最大化利用索引\",{\"1\":{\"560\":1}}],[\"最大显示宽度意思是\",{\"1\":{\"476\":1}}],[\"最大空间\",{\"1\":{\"323\":1}}],[\"最大值为\",{\"1\":{\"476\":1}}],[\"最大值\",{\"1\":{\"62\":1}}],[\"最大线程数\",{\"1\":{\"56\":3}}],[\"种图\",{\"1\":{\"1094\":1}}],[\"种类\",{\"1\":{\"1079\":1}}],[\"种取值情况\",{\"1\":{\"892\":1}}],[\"种缓存淘汰策略\",{\"0\":{\"706\":1}}],[\"种基本数据类型\",{\"0\":{\"616\":1},\"1\":{\"616\":1}}],[\"种方式\",{\"1\":{\"153\":1}}],[\"种常见的进程间的通信方式\",{\"1\":{\"149\":1}}],[\"种常见线程池\",{\"1\":{\"56\":1}}],[\"种常见线程池及选择\",{\"0\":{\"55\":1}}],[\"种原子操作\",{\"1\":{\"74\":1}}],[\"种\",{\"1\":{\"73\":1,\"163\":1,\"1065\":1,\"1094\":4,\"1095\":1}}],[\"种实现\",{\"1\":{\"60\":1}}],[\"种状态\",{\"1\":{\"38\":1}}],[\"还挺形象\",{\"1\":{\"1190\":1}}],[\"还内置了一些其他的\",{\"1\":{\"1134\":1}}],[\"还包含一个返回产品方法\",{\"1\":{\"1086\":1}}],[\"还需要设置一个慢开始门限ssthresh\",{\"1\":{\"1019\":1}}],[\"还需要额外的一个字节来保存此字符串的长度\",{\"1\":{\"997\":1}}],[\"还需要使用写前屏障来跟踪并发时的指针变化情况\",{\"1\":{\"262\":1}}],[\"还必须有一些必要的通信协议来控制这些数据的传输\",{\"1\":{\"971\":1}}],[\"还定义了缓存接口\",{\"1\":{\"752\":1}}],[\"还扩展了其他更完整的功能\",{\"1\":{\"712\":1}}],[\"还处于半自动状态\",{\"1\":{\"660\":1}}],[\"还原数据\",{\"1\":{\"652\":1}}],[\"还没有使用的\",{\"1\":{\"594\":1}}],[\"还记录了相对应的\",{\"1\":{\"570\":1}}],[\"还算稳定\",{\"1\":{\"315\":1}}],[\"还要向源点发送时间超过报文\",{\"1\":{\"993\":1}}],[\"还要从根结点继续查找\",{\"1\":{\"919\":1}}],[\"还要加上一定的冗余空间以避免实际元素可能会意外高出估计值很多\",{\"1\":{\"645\":1}}],[\"还要保证锁定的区间不能插入新的数据\",{\"1\":{\"506\":1}}],[\"还要有一个\",{\"1\":{\"349\":1}}],[\"还要求必须拥有一个与原方法不同的特征签名\",{\"1\":{\"290\":1}}],[\"还要重新处理satb\",{\"1\":{\"264\":1}}],[\"还要记录进程运行情况\",{\"1\":{\"136\":1}}],[\"还能建立可预测的停顿时间模型\",{\"1\":{\"261\":1}}],[\"还具备高吞吐量性能特征\",{\"1\":{\"261\":1}}],[\"还会提高系统的稳定性\",{\"1\":{\"880\":1}}],[\"还会造成一段时间内服务不可用\",{\"1\":{\"657\":1,\"675\":1,\"676\":1}}],[\"还会分配额外未使用的空间\",{\"1\":{\"624\":1}}],[\"还会存放主键a字段用于回表操作\",{\"1\":{\"550\":1}}],[\"还会把由符号引用翻译出来的直接引用也存储在运行时常量池中\",{\"1\":{\"208\":1}}],[\"还会降低系统的稳定性\",{\"1\":{\"53\":1}}],[\"还可以在范围内组合以上大部分内容\",{\"1\":{\"1140\":1}}],[\"还可以使用哪些其他的版本说明符\",{\"1\":{\"1140\":1}}],[\"还可以使用自旋来进行优化\",{\"1\":{\"91\":1}}],[\"还可以对关键字折叠\",{\"1\":{\"923\":1}}],[\"还可以接受\",{\"1\":{\"900\":1}}],[\"还可以按照类似的方法继续往下分\",{\"1\":{\"894\":1}}],[\"还可以正向代理来进行上网等功能\",{\"1\":{\"827\":1}}],[\"还可以连接到其他\",{\"1\":{\"661\":1}}],[\"还可以分开为两个表\",{\"1\":{\"601\":1}}],[\"还可以有其他对象\",{\"1\":{\"234\":1}}],[\"还可以从数据库\",{\"1\":{\"180\":1}}],[\"还是得确认下\",{\"1\":{\"1026\":1}}],[\"还是索引存储空间\",{\"1\":{\"997\":1}}],[\"还是能用的\",{\"1\":{\"803\":1}}],[\"还是如以前一样使用定义的bean\",{\"1\":{\"728\":1}}],[\"还是只能考虑布隆过滤器\",{\"1\":{\"645\":1}}],[\"还是系统故障\",{\"1\":{\"641\":1}}],[\"还是写操作多\",{\"1\":{\"606\":1}}],[\"还是会让整个数据库处理能力成为瓶颈\",{\"1\":{\"585\":1}}],[\"还是会记录所有行的变更\",{\"1\":{\"572\":1}}],[\"还是cpu瓶颈\",{\"1\":{\"584\":1}}],[\"还是有可能会遇到不可预期的结果\",{\"1\":{\"513\":1}}],[\"还是需要评估实际使用的长度来设置字符的长度\",{\"1\":{\"478\":1}}],[\"还是\",{\"1\":{\"393\":1,\"406\":1}}],[\"还是链表更加适合\",{\"1\":{\"374\":1}}],[\"还是在子类中定义的字段都必须记录起来\",{\"1\":{\"226\":1}}],[\"还是旧值\",{\"1\":{\"72\":1}}],[\"还是无效\",{\"1\":{\"72\":1}}],[\"还是独占\",{\"1\":{\"72\":1}}],[\"还是共享\",{\"1\":{\"72\":1}}],[\"还有很多必要的控制信息\",{\"1\":{\"972\":1}}],[\"还有节点没有访问\",{\"1\":{\"908\":1}}],[\"还有各自的次数统计\",{\"1\":{\"897\":1}}],[\"还有就是隐藏客户端ip地址\",{\"1\":{\"826\":1}}],[\"还有resultset结果集的读取等\",{\"1\":{\"748\":1}}],[\"还有单个服务器的磁盘空间\",{\"1\":{\"585\":1}}],[\"还有两种场景会让一个没有提交的事务的\",{\"1\":{\"568\":1}}],[\"还有会发生幻读\",{\"1\":{\"504\":1}}],[\"还有\",{\"1\":{\"412\":1,\"444\":1}}],[\"还有数据可读\",{\"1\":{\"381\":1}}],[\"还有反射机制所需要的\",{\"1\":{\"369\":1}}],[\"还有编译器\",{\"1\":{\"335\":1}}],[\"还有系统类加载器\",{\"1\":{\"234\":1}}],[\"还有一个问题\",{\"1\":{\"1013\":1}}],[\"还有一个就是\",{\"1\":{\"659\":1}}],[\"还有一个用于\",{\"1\":{\"622\":1}}],[\"还有一个特点是\",{\"1\":{\"381\":1}}],[\"还有一项信息是常量池表\",{\"1\":{\"208\":1}}],[\"还有一点和\",{\"1\":{\"35\":1}}],[\"还有记录给进程分配了哪些资源\",{\"1\":{\"136\":1}}],[\"还有像线程内上下文管理器\",{\"1\":{\"39\":1,\"44\":1}}],[\"提取数据报前8个字节是为了得到运输层的端口号\",{\"1\":{\"993\":1}}],[\"提取出某日访问百度次数最多的那个ip\",{\"0\":{\"892\":1},\"1\":{\"884\":1}}],[\"提取\",{\"1\":{\"755\":1}}],[\"提前将相关的缓存数据加载到缓存系统\",{\"1\":{\"640\":1}}],[\"提一下现在\",{\"1\":{\"606\":1}}],[\"提升系统稳定性和负载能力\",{\"1\":{\"585\":1}}],[\"提升查询效率\",{\"1\":{\"585\":1}}],[\"提升执行引擎的执行效率\",{\"1\":{\"193\":1}}],[\"提出查询条件等等\",{\"1\":{\"490\":1}}],[\"提出查询的表\",{\"1\":{\"490\":1}}],[\"提出字段名\",{\"1\":{\"490\":1}}],[\"提出了\",{\"1\":{\"65\":1}}],[\"提交本地修改\",{\"1\":{\"1127\":1}}],[\"提交本地开发分支的修改\",{\"1\":{\"1127\":1}}],[\"提交冲突解决\",{\"1\":{\"1126\":1}}],[\"提交给状态机\",{\"1\":{\"875\":1}}],[\"提交状态\",{\"1\":{\"520\":1}}],[\"提交所有tag\",{\"1\":{\"450\":1}}],[\"提交指定tag\",{\"1\":{\"450\":1}}],[\"提交说明\",{\"1\":{\"449\":1}}],[\"提交时显示所有diff信息\",{\"1\":{\"448\":1}}],[\"提交工作区自上次commit之后的变化\",{\"1\":{\"448\":1}}],[\"提交暂存区的指定文件到仓库区\",{\"1\":{\"448\":1}}],[\"提交暂存区到仓库区\",{\"1\":{\"448\":1}}],[\"提醒用户程序去操作\",{\"1\":{\"381\":1}}],[\"提高内聚\",{\"1\":{\"1064\":1}}],[\"提高程序的灵活度\",{\"1\":{\"1064\":1}}],[\"提高系统的可维护性\",{\"1\":{\"1064\":1}}],[\"提高系统的扩展性和可用性\",{\"1\":{\"660\":1,\"678\":1}}],[\"提高类的可读性\",{\"1\":{\"1064\":1}}],[\"提高复用性\",{\"1\":{\"1064\":1}}],[\"提高消息的吞吐量\",{\"1\":{\"849\":1}}],[\"提高执行效率\",{\"1\":{\"745\":1}}],[\"提高服务器读写负载能力\",{\"1\":{\"655\":1,\"661\":1}}],[\"提高性能\",{\"1\":{\"572\":1,\"805\":1}}],[\"提高区间访问的性能\",{\"1\":{\"538\":1}}],[\"提高了程序的可维护性\",{\"1\":{\"1090\":1}}],[\"提高了代码的安全性\",{\"1\":{\"745\":1}}],[\"提高了网络\",{\"1\":{\"604\":1}}],[\"提高了开发的复杂度\",{\"1\":{\"585\":1}}],[\"提高了区间访问性能\",{\"1\":{\"541\":1}}],[\"提高了性能\",{\"1\":{\"535\":1,\"574\":1}}],[\"提高了数据库并发读写的性能\",{\"1\":{\"499\":1}}],[\"提高了安全性\",{\"1\":{\"355\":1}}],[\"提高整个表的处理能力\",{\"1\":{\"494\":1}}],[\"提高效率\",{\"1\":{\"405\":1,\"560\":1,\"749\":1}}],[\"提高代码的灵活度\",{\"1\":{\"348\":1}}],[\"提高代码复用性\",{\"1\":{\"355\":1,\"1087\":1}}],[\"提高代码复用\",{\"1\":{\"345\":1,\"754\":1}}],[\"提高线程的可管理性\",{\"1\":{\"53\":1}}],[\"提高响应速度\",{\"1\":{\"53\":1}}],[\"提供\",{\"1\":{\"1162\":1}}],[\"提供具体的算法实现\",{\"1\":{\"1088\":1}}],[\"提供分布式服务\",{\"1\":{\"1034\":1}}],[\"提供应用的多路复用\",{\"1\":{\"998\":1}}],[\"提供可靠传输\",{\"1\":{\"961\":1}}],[\"提供无连接的\",{\"1\":{\"961\":1}}],[\"提供面向连接\",{\"1\":{\"961\":1}}],[\"提供两种锁\",{\"1\":{\"821\":1}}],[\"提供相应的路径\",{\"1\":{\"797\":1}}],[\"提供自动配置类对模块内的bean进行自动装配\",{\"1\":{\"772\":1}}],[\"提供对模块的配置项给使用者\",{\"1\":{\"772\":1}}],[\"提供对象关系映射标签\",{\"1\":{\"746\":1}}],[\"提供映射标签\",{\"1\":{\"746\":1}}],[\"提供xml标签\",{\"1\":{\"746\":1}}],[\"提供getapplicationcontext\",{\"1\":{\"736\":1}}],[\"提供方便的\",{\"1\":{\"717\":1}}],[\"提供一个统一的工厂来创建产品对象\",{\"1\":{\"1080\":1}}],[\"提供一个静态的公有方法\",{\"1\":{\"1067\":1,\"1068\":1}}],[\"提供一个公有的静态方法\",{\"1\":{\"1066\":2}}],[\"提供一个持续的事务管理接口\",{\"1\":{\"717\":1}}],[\"提供一个旧值\",{\"1\":{\"105\":1}}],[\"提供服务\",{\"1\":{\"655\":1,\"656\":1,\"661\":1}}],[\"提供的插件接口\",{\"1\":{\"753\":1}}],[\"提供的\",{\"1\":{\"736\":2}}],[\"提供的一个同步框架\",{\"1\":{\"109\":1}}],[\"提供的一个用于并行执行任务的框架\",{\"1\":{\"49\":1}}],[\"提供的这些容器大部分在\",{\"1\":{\"108\":1}}],[\"提供的拒绝策略\",{\"1\":{\"60\":1}}],[\"提供了创建产品的接口\",{\"1\":{\"1079\":1}}],[\"提供了对线程安全的支持\",{\"1\":{\"1069\":1}}],[\"提供了对集合元素排序\",{\"1\":{\"388\":1}}],[\"提供了对集合对象进行基本操作的通用接口方法\",{\"1\":{\"388\":1}}],[\"提供了应用程序之间的通信也就是端到端的通信\",{\"1\":{\"998\":1}}],[\"提供了一些像\",{\"1\":{\"774\":1}}],[\"提供了一些非功能性特征\",{\"1\":{\"770\":1}}],[\"提供了一种分离式的方法来开发\",{\"1\":{\"770\":1}}],[\"提供了一个加全局读锁的方法\",{\"1\":{\"508\":1}}],[\"提供了缓存策略来减少数据库的查询次数\",{\"1\":{\"752\":1}}],[\"提供了复制的功能\",{\"1\":{\"655\":1}}],[\"提供了bgrewriteaof命令\",{\"1\":{\"651\":1}}],[\"提供了大量的特性\",{\"1\":{\"492\":1}}],[\"提供了from\",{\"1\":{\"475\":1}}],[\"提供了两种相似的日期时间类型\",{\"1\":{\"475\":1}}],[\"提供了基于\",{\"1\":{\"109\":1}}],[\"提供了\",{\"1\":{\"60\":1,\"568\":1}}],[\"提供了事务相关的操作\",{\"1\":{\"43\":1}}],[\"先发散后收敛\",{\"1\":{\"1224\":1}}],[\"先判断是否为直接交付\",{\"1\":{\"990\":1}}],[\"先判断类是否能够归属到某一个系统模块中\",{\"1\":{\"181\":1}}],[\"先根据ip数据报的目的网络号找到连接本单位网络上的路由器\",{\"1\":{\"989\":1}}],[\"先在其arp高速缓存中查看有无主机b的ip地址\",{\"1\":{\"986\":1}}],[\"先在运行时动态解析出调用点限定符所引用的方法\",{\"1\":{\"274\":1}}],[\"先找到帧尾以确定帧的边界\",{\"1\":{\"973\":1}}],[\"先找到这个模式的第三者\",{\"1\":{\"50\":1}}],[\"先用硬件扫描整个帧\",{\"1\":{\"973\":2}}],[\"先构建一个节点类\",{\"1\":{\"955\":1}}],[\"先让\",{\"1\":{\"927\":1}}],[\"先放入根\",{\"1\":{\"908\":2}}],[\"先放操作系统缓冲区\",{\"1\":{\"707\":1}}],[\"先压右孩子\",{\"1\":{\"908\":1}}],[\"先是找出频率最高的5个\",{\"1\":{\"904\":1}}],[\"先是通过\",{\"1\":{\"555\":1}}],[\"先利用x\",{\"1\":{\"903\":1}}],[\"先提交\",{\"1\":{\"866\":1}}],[\"先看右边\",{\"1\":{\"935\":1}}],[\"先看看java\",{\"1\":{\"829\":1}}],[\"先看二级缓存中有没有\",{\"1\":{\"752\":1}}],[\"先设计接口然后在设计实现类\",{\"1\":{\"763\":1}}],[\"先检测到这个结果\",{\"1\":{\"657\":1}}],[\"先启动主节点\",{\"1\":{\"655\":1}}],[\"先查询数据库\",{\"1\":{\"640\":1}}],[\"先写\",{\"1\":{\"578\":2}}],[\"先写内存再写redo\",{\"1\":{\"559\":1}}],[\"先把日志写到\",{\"1\":{\"571\":1}}],[\"先把前一个任务\",{\"1\":{\"144\":1}}],[\"先统一在redo\",{\"1\":{\"568\":1}}],[\"先垂直拆分\",{\"1\":{\"561\":1}}],[\"先计算\",{\"1\":{\"537\":1}}],[\"先计算出\",{\"1\":{\"405\":1}}],[\"先加意向锁\",{\"1\":{\"514\":1}}],[\"先取锁再访问\",{\"1\":{\"513\":1}}],[\"先尝试为该记录加上\",{\"1\":{\"513\":1}}],[\"先定位偏移位置的\",{\"1\":{\"486\":1}}],[\"先获得该\",{\"1\":{\"356\":1}}],[\"先获取当前线程\",{\"1\":{\"39\":1}}],[\"先获取当前线程的threadlocalmap变量\",{\"1\":{\"39\":1}}],[\"先比对了他们的哈希值\",{\"1\":{\"342\":1}}],[\"先通过普通索引定位到主键值\",{\"1\":{\"549\":1}}],[\"先通过内存映像工具对dump出来的堆转储快照进行分析\",{\"1\":{\"298\":1}}],[\"先通过两次\",{\"1\":{\"113\":1}}],[\"先进先出\",{\"1\":{\"160\":1,\"840\":1}}],[\"先进先出置换算法\",{\"1\":{\"160\":1}}],[\"先来先服务\",{\"1\":{\"150\":1,\"163\":1}}],[\"先经过一次再散列\",{\"1\":{\"129\":1}}],[\"先到者先拿到锁\",{\"1\":{\"113\":1}}],[\"先执行了3\",{\"1\":{\"714\":1}}],[\"先执行了\",{\"1\":{\"101\":1}}],[\"先行发生于后面对同一个锁的\",{\"1\":{\"75\":1,\"102\":1}}],[\"纵观大多数设计模式\",{\"1\":{\"50\":1}}],[\"该符号指定了软件包能从该依赖接受的更新\",{\"1\":{\"1140\":1}}],[\"该主机还需将ip数据报的源ip全设为0\",{\"1\":{\"1049\":1}}],[\"该主机就在其路由表中增加一个项目\",{\"1\":{\"993\":1}}],[\"该报文段同样不能携带数据\",{\"1\":{\"1022\":1}}],[\"该报文段syn=1\",{\"1\":{\"1022\":1}}],[\"该topic为\",{\"1\":{\"860\":1}}],[\"该之间阈值由replica\",{\"1\":{\"853\":1}}],[\"该值在服务端是一个自增序列\",{\"1\":{\"820\":1}}],[\"该值越大则说明数据越新\",{\"1\":{\"820\":1}}],[\"该节点依旧存在\",{\"1\":{\"818\":1}}],[\"该模式对外有一个统一接口\",{\"1\":{\"1090\":1}}],[\"该模式定义了一系列算法\",{\"1\":{\"1088\":1}}],[\"该模式下\",{\"1\":{\"829\":1}}],[\"该模式通过平衡生产线程和消费线程的工作能力来提高程序整体处理数据的速度\",{\"1\":{\"50\":1}}],[\"该模块将在生产环境中被禁用\",{\"1\":{\"769\":1}}],[\"该列才可以映射成功\",{\"1\":{\"751\":1}}],[\"该\",{\"1\":{\"734\":2}}],[\"该bean仅在当前http\",{\"1\":{\"713\":1}}],[\"该bean仅在http\",{\"1\":{\"713\":1}}],[\"该时间可以忽略不计\",{\"1\":{\"660\":1}}],[\"该策略可以立即清除过期的数据\",{\"1\":{\"632\":1}}],[\"该策略可以最大化地节省\",{\"1\":{\"632\":1}}],[\"该策略是前两者的一个折中方案\",{\"1\":{\"632\":1}}],[\"该业务数据是读操作多\",{\"1\":{\"606\":1}}],[\"该机制允许内核中\",{\"1\":{\"604\":1}}],[\"该级别可以防止脏读\",{\"1\":{\"522\":1}}],[\"该文件只存储表的结构\",{\"1\":{\"494\":1}}],[\"该文件的文件名和表名是相同的\",{\"1\":{\"494\":1}}],[\"该文件内容保存着\",{\"1\":{\"348\":1}}],[\"该用户也是不受影响的\",{\"1\":{\"490\":1}}],[\"该用户具有进入目录的权限\",{\"1\":{\"430\":1}}],[\"该目录下存放的是\",{\"1\":{\"416\":1}}],[\"该接口是一个标记接口\",{\"1\":{\"391\":1}}],[\"该接口包含一个能够产生\",{\"1\":{\"389\":1}}],[\"该接口没有需要实现的方法\",{\"1\":{\"344\":1}}],[\"该代码块都会被执行\",{\"1\":{\"346\":1}}],[\"该注解又通过\",{\"1\":{\"771\":1}}],[\"该注解是\",{\"1\":{\"338\":1}}],[\"该注解是一个标记注解\",{\"1\":{\"338\":1}}],[\"该注解使父类的注解能被其子类继承\",{\"1\":{\"338\":1}}],[\"该map的特点是当除了自身对key的引用外\",{\"1\":{\"304\":1}}],[\"该指令在多核处理器下会引发两件事情\",{\"1\":{\"296\":1}}],[\"该区域内有对象含有跨代指针\",{\"1\":{\"249\":1}}],[\"该对象天生为单例\",{\"1\":{\"1070\":1}}],[\"该对象可以作为目标对象使用\",{\"1\":{\"724\":1}}],[\"该对象里有字段含有跨代指针\",{\"1\":{\"249\":1}}],[\"该对象头\",{\"1\":{\"85\":1}}],[\"该字含跨代指针\",{\"1\":{\"249\":1}}],[\"该类对应的\",{\"1\":{\"1075\":1}}],[\"该类对应的java\",{\"1\":{\"237\":1}}],[\"该类中有一个静态属性\",{\"1\":{\"1069\":1}}],[\"该类有一系列参数\",{\"1\":{\"730\":1}}],[\"该类的类加载器已经被回收\",{\"1\":{\"237\":1}}],[\"该类所有的实例都已经被回收\",{\"1\":{\"237\":1,\"1075\":1}}],[\"该阶段主要工作是进行数据流和控制流分析\",{\"1\":{\"170\":1}}],[\"该算法的特点\",{\"1\":{\"163\":1}}],[\"该算法为每个页面设置一位访问位\",{\"1\":{\"160\":1}}],[\"该置换算法选择在之前时期使用最少的页面作为淘汰页\",{\"1\":{\"160\":1}}],[\"该消息队列才会被真正的删除\",{\"1\":{\"149\":1}}],[\"该进程便由执行状态转变为就绪状态\",{\"1\":{\"148\":1}}],[\"该进程便由就绪状态变为执行状态\",{\"1\":{\"148\":1}}],[\"该进程也不能运行\",{\"1\":{\"148\":1}}],[\"该状态的设计成为实现读写锁的关键\",{\"1\":{\"125\":1}}],[\"该状态标识结点的线程处于可运行状态\",{\"1\":{\"111\":1}}],[\"该标识的结点处于等待队列中\",{\"1\":{\"111\":1}}],[\"该标识指明了该方法是一个同步方法\",{\"1\":{\"82\":1}}],[\"该语句非原子操作\",{\"1\":{\"101\":1,\"1068\":1}}],[\"该资源才会被释放\",{\"1\":{\"98\":1}}],[\"该锁被获取了\",{\"1\":{\"96\":1}}],[\"该锁能够支持一个线程对资源的重复加锁\",{\"1\":{\"96\":1}}],[\"该特性需要解决两个问题\",{\"1\":{\"96\":1}}],[\"该观察结果一般杂乱无序\",{\"1\":{\"67\":1}}],[\"该方法唤醒在该对象上等待的所有线程\",{\"1\":{\"350\":1}}],[\"该方法唤醒在该对象上等待的某个线程\",{\"1\":{\"350\":1}}],[\"该方法是非常重要的一个方法\",{\"1\":{\"350\":1}}],[\"该方法是一个protected\",{\"1\":{\"39\":1}}],[\"该方法用于哈希查找\",{\"1\":{\"350\":1}}],[\"该方法用于释放资源\",{\"1\":{\"350\":1}}],[\"该方法用得比较多\",{\"1\":{\"350\":1}}],[\"该方法会返回一个\",{\"1\":{\"348\":1}}],[\"该方法调用无参的构造器创建对象\",{\"1\":{\"356\":1}}],[\"该方法调用\",{\"1\":{\"123\":1}}],[\"该方法如果获取不到许可就立即返回\",{\"1\":{\"117\":1}}],[\"该方法将class文件加载到内存时\",{\"1\":{\"183\":1}}],[\"该方法将class文件加载到内存的同时\",{\"1\":{\"183\":1}}],[\"该方法将\",{\"1\":{\"96\":1}}],[\"该方法与nonfairtryacquire\",{\"1\":{\"96\":1}}],[\"该方法探测下一个空余地址插入\",{\"1\":{\"47\":1}}],[\"该方法返回当前线程所对应的线程局部变量\",{\"1\":{\"39\":1}}],[\"74\",{\"1\":{\"443\":1}}],[\"711\",{\"1\":{\"422\":1}}],[\"751\",{\"1\":{\"433\":1}}],[\"75\",{\"1\":{\"399\":3,\"1028\":1}}],[\"7中\",{\"1\":{\"207\":1}}],[\"7开始已经默认开启逃逸分析\",{\"1\":{\"199\":1}}],[\"7新加入的动态语言支持时\",{\"1\":{\"174\":1}}],[\"7\",{\"0\":{\"395\":1,\"898\":1,\"1234\":1},\"1\":{\"49\":1,\"59\":1,\"78\":1,\"91\":1,\"128\":1,\"130\":4,\"149\":1,\"204\":1,\"304\":1,\"350\":1,\"477\":1,\"935\":2,\"952\":1,\"953\":2,\"1162\":1}}],[\"框架进行说明\",{\"1\":{\"1226\":1}}],[\"框架就是在\",{\"1\":{\"806\":1}}],[\"框架一般都有注册中心模块\",{\"1\":{\"805\":1}}],[\"框架少不了监控\",{\"1\":{\"804\":1}}],[\"框架都使用\",{\"1\":{\"804\":1}}],[\"框架都提供监控功能\",{\"1\":{\"801\":1}}],[\"框架注册中心\",{\"1\":{\"801\":1}}],[\"框架的好处就显示出来\",{\"1\":{\"805\":1}}],[\"框架的\",{\"1\":{\"736\":1}}],[\"框架的独立应用程序\",{\"1\":{\"736\":1}}],[\"框架的一个很好的替代品\",{\"1\":{\"717\":1}}],[\"框架了\",{\"1\":{\"720\":1}}],[\"框架中用到了哪些设计模式\",{\"0\":{\"742\":1}}],[\"框架中\",{\"1\":{\"338\":1}}],[\"框架是个精心设计的框架\",{\"1\":{\"717\":1}}],[\"框架是\",{\"1\":{\"49\":1}}],[\"框架\",{\"0\":{\"49\":1,\"710\":1,\"804\":1},\"1\":{\"746\":1,\"749\":2}}],[\"互联网连接\",{\"1\":{\"1042\":1}}],[\"互联网上的路由器就能找到离这个dns客户最近的一个根域名服务器\",{\"1\":{\"1030\":1}}],[\"互联网上的每一个网络和每一台主机分配一个\",{\"1\":{\"981\":1}}],[\"互联网是由大量异构网络通过路由器相互连接起来的\",{\"1\":{\"961\":1}}],[\"互联网的组成\",{\"0\":{\"960\":1}}],[\"互相的耦合度很低\",{\"1\":{\"766\":1}}],[\"互动模式\",{\"1\":{\"424\":1}}],[\"互斥访问\",{\"1\":{\"672\":1}}],[\"互斥量\",{\"1\":{\"142\":1}}],[\"互斥\",{\"1\":{\"98\":1}}],[\"互斥同步属于一种悲观的并发策略\",{\"1\":{\"142\":1}}],[\"互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销\",{\"1\":{\"142\":1}}],[\"互斥同步\",{\"1\":{\"48\":1,\"142\":1}}],[\"互不干扰\",{\"1\":{\"39\":1,\"41\":1}}],[\"如数据库\",{\"1\":{\"1239\":1}}],[\"如数据库连接\",{\"1\":{\"304\":1}}],[\"如老师和学生\",{\"1\":{\"1097\":1}}],[\"如办房产证或注册一家公司\",{\"1\":{\"1090\":1}}],[\"如汉堡\",{\"1\":{\"1086\":1}}],[\"如有人只喜欢穿某一个品牌的衣服和鞋\",{\"1\":{\"1079\":1}}],[\"如有差错\",{\"1\":{\"961\":1}}],[\"如电器工厂中的电视机\",{\"1\":{\"1079\":1}}],[\"如农场里既养动物又种植物\",{\"1\":{\"1079\":1}}],[\"如畜牧场只养动物\",{\"1\":{\"1079\":1}}],[\"如工具类\",{\"1\":{\"1077\":1}}],[\"如工厂模式的第三者是工厂类\",{\"1\":{\"50\":1}}],[\"如服务器失效无法完成请求\",{\"1\":{\"1040\":1}}],[\"如请求中有一些错误的语法或不能完成\",{\"1\":{\"1040\":1}}],[\"如请求收到了或正在处理\",{\"1\":{\"1040\":1}}],[\"如客户端发出连接请求\",{\"1\":{\"1023\":1}}],[\"如0\",{\"1\":{\"993\":1}}],[\"如需改正数据\",{\"1\":{\"961\":1}}],[\"如访问共同的数据库\",{\"1\":{\"873\":1}}],[\"如把表中\",{\"1\":{\"807\":1}}],[\"如断电断网\",{\"1\":{\"802\":1}}],[\"如下是老师和学生的关系图\",{\"1\":{\"1097\":1}}],[\"如下\",{\"1\":{\"1087\":1}}],[\"如下图\",{\"1\":{\"880\":1}}],[\"如下图所示\",{\"1\":{\"681\":1}}],[\"如下代码中\",{\"1\":{\"795\":1}}],[\"如关闭数据源自动配置功能\",{\"1\":{\"777\":1}}],[\"如登录\",{\"1\":{\"754\":1}}],[\"如使用\",{\"1\":{\"678\":1}}],[\"如不成功\",{\"1\":{\"655\":1}}],[\"如加入购物车\",{\"1\":{\"644\":1}}],[\"如响应时间慢或不响应\",{\"1\":{\"644\":1}}],[\"如在很多软件系统中需要更换界面主题\",{\"1\":{\"1079\":1}}],[\"如在用户登陆的时候\",{\"1\":{\"641\":1}}],[\"如在用户程序运行过程中\",{\"1\":{\"262\":1}}],[\"如在设计键时\",{\"1\":{\"637\":1}}],[\"如sql中包含\",{\"1\":{\"584\":1}}],[\"如一些函数\",{\"1\":{\"572\":1}}],[\"如左表或者右表\",{\"1\":{\"487\":1}}],[\"如联系方式\",{\"1\":{\"455\":1}}],[\"如随时更改的日志文件\",{\"1\":{\"416\":1}}],[\"如说\",{\"1\":{\"411\":1}}],[\"如读写缓冲区太小\",{\"1\":{\"381\":1}}],[\"如<\",{\"1\":{\"345\":1}}],[\"如hashmap\",{\"1\":{\"304\":1}}],[\"如g1\",{\"1\":{\"249\":1}}],[\"如nullpointexcepiton\",{\"1\":{\"234\":1}}],[\"如基本数据类型对应的class对象\",{\"1\":{\"234\":1}}],[\"如是否启用偏向锁等\",{\"1\":{\"222\":1}}],[\"如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可\",{\"1\":{\"208\":1}}],[\"如保存系统运行的上下文\",{\"1\":{\"198\":1}}],[\"如内存共享\",{\"1\":{\"198\":1}}],[\"如多态\",{\"1\":{\"194\":1}}],[\"如短进程优先的调度算法\",{\"1\":{\"150\":1}}],[\"如输入\",{\"1\":{\"148\":1}}],[\"如进程提出输入\",{\"1\":{\"148\":1}}],[\"如等待某资源为可用或等待\",{\"1\":{\"148\":1}}],[\"如就绪\",{\"1\":{\"147\":1}}],[\"如文件管理\",{\"1\":{\"135\":1}}],[\"如获取资源失败入队\",{\"1\":{\"115\":1}}],[\"如自旋锁\",{\"1\":{\"82\":1}}],[\"如\",{\"1\":{\"68\":1,\"75\":1,\"98\":2,\"109\":1,\"113\":1,\"115\":1,\"134\":1,\"136\":3,\"143\":1,\"144\":2,\"153\":1,\"174\":1,\"342\":1,\"344\":1,\"346\":1,\"354\":1,\"392\":1,\"408\":1,\"416\":1,\"434\":1,\"501\":2,\"516\":1,\"556\":1,\"624\":1,\"637\":1,\"644\":1,\"647\":2,\"668\":1,\"675\":1,\"748\":1,\"754\":1,\"755\":3,\"759\":1,\"801\":1,\"807\":1,\"961\":1,\"1001\":1,\"1004\":1,\"1019\":1,\"1039\":1,\"1047\":1,\"1083\":1,\"1087\":1,\"1088\":1,\"1091\":1,\"1188\":1,\"1190\":1}}],[\"如何将散落的服务聚合在一起\",{\"1\":{\"1245\":1}}],[\"如何进行划分\",{\"1\":{\"1221\":1}}],[\"如何进行传输\",{\"1\":{\"804\":1}}],[\"如何使用\",{\"1\":{\"1203\":1}}],[\"如何使用springboot实现异常处理\",{\"0\":{\"791\":1}}],[\"如何创建套餐\",{\"1\":{\"1086\":1}}],[\"如何在事先不知道真实主题角色的情况下使用代理主题角色\",{\"1\":{\"1083\":1}}],[\"如何防止\",{\"0\":{\"1061\":1}}],[\"如何快速判断这个数是否在那40亿个数当中\",{\"0\":{\"901\":1}}],[\"如何找到n^2个数的中数\",{\"1\":{\"891\":1}}],[\"如何保障无论访问哪个服务节点\",{\"1\":{\"873\":1}}],[\"如何保证\",{\"0\":{\"1009\":1}}],[\"如何保证可靠传输\",{\"0\":{\"1004\":1}}],[\"如何保证可见性\",{\"0\":{\"69\":1}}],[\"如何保证消息数据处理的一致性\",{\"1\":{\"841\":1}}],[\"如何保证高可用高并发性\",{\"0\":{\"654\":1}}],[\"如何保证有序性\",{\"0\":{\"70\":1}}],[\"如何保证原子性\",{\"0\":{\"68\":1}}],[\"如何选择一个\",{\"1\":{\"859\":1}}],[\"如何选择分配方式\",{\"0\":{\"218\":1}}],[\"如何治理\",{\"1\":{\"815\":1}}],[\"如何设计接口才能做到幂等呢\",{\"1\":{\"807\":1}}],[\"如何做到并发且全局有序\",{\"1\":{\"865\":1}}],[\"如何做\",{\"0\":{\"788\":1}}],[\"如何做内存优化\",{\"0\":{\"637\":1}}],[\"如何实现springboot的安全性\",{\"0\":{\"789\":1}}],[\"如何实现的\",{\"1\":{\"759\":1}}],[\"如何实现覆盖索引\",{\"1\":{\"550\":1}}],[\"如何查看字节码文件\",{\"0\":{\"281\":1}}],[\"如何判断一个节点是否还活着\",{\"0\":{\"868\":1}}],[\"如何判断类没用了\",{\"0\":{\"237\":1}}],[\"如何判断是否线程安全\",{\"0\":{\"48\":1}}],[\"如何才能找到类的元数据信息\",{\"1\":{\"222\":1}}],[\"如何获取\",{\"1\":{\"168\":1}}],[\"如何减少上下文切换\",{\"1\":{\"144\":1}}],[\"如何撤销偏向锁\",{\"1\":{\"88\":1}}],[\"如何控制线程执行顺序\",{\"0\":{\"51\":1}}],[\"如果起始位置匹配不成功\",{\"1\":{\"1188\":1}}],[\"如果适用\",{\"1\":{\"1162\":3}}],[\"如果汁\",{\"1\":{\"1086\":1}}],[\"如果按照这种方法使用代理模式\",{\"1\":{\"1083\":1}}],[\"如果接口增加一个方法\",{\"1\":{\"1082\":1}}],[\"如果公钥是伪造的\",{\"1\":{\"1057\":1}}],[\"如果说cookie机制是通过检查客户身上的\",{\"1\":{\"1052\":1}}],[\"如果无效\",{\"1\":{\"1044\":1}}],[\"如果无限制的创建\",{\"1\":{\"53\":1}}],[\"如果队列满了就有可能会出现丢包现象\",{\"1\":{\"1025\":1}}],[\"如果队列不可用\",{\"1\":{\"62\":1}}],[\"如果那个失效的连接请求抵达了服务端\",{\"1\":{\"1022\":1}}],[\"如果立即把大量数据字节注入到网络\",{\"1\":{\"1019\":1}}],[\"如果b向a发送了零窗口的报文段后不久\",{\"1\":{\"1015\":1}}],[\"如果b系统\",{\"1\":{\"841\":1}}],[\"如果收到段的检验和有差错\",{\"1\":{\"1009\":1}}],[\"如果默认路由器发现主机发往某个目的地址的数据报的最佳路由应当经过网络上的另一个路由器r时\",{\"1\":{\"993\":1}}],[\"如果传输层发送到网络层的数据\",{\"1\":{\"982\":1}}],[\"如果传输层还负责这⼀块功能就有点违背设计原则了\",{\"1\":{\"961\":1}}],[\"如果⼀个设备的数据要传输给另⼀个设备\",{\"1\":{\"961\":1}}],[\"如果满足条件则交换\",{\"1\":{\"935\":1}}],[\"如果根节点为\",{\"1\":{\"921\":1}}],[\"如果根结点不是叶结点\",{\"1\":{\"919\":1}}],[\"如果允许有一定的错误率\",{\"1\":{\"896\":1}}],[\"如果允许数据有一点丢失\",{\"1\":{\"650\":1}}],[\"如果xi<xmin\",{\"1\":{\"893\":1}}],[\"如果遍历到的xi大于堆顶元素xmin\",{\"1\":{\"893\":1}}],[\"如果去重后数据可以放入内存\",{\"1\":{\"891\":1}}],[\"如果它小于最大元素\",{\"1\":{\"885\":1}}],[\"如果两边一样多\",{\"1\":{\"884\":1}}],[\"如果两个线程都执行了\",{\"1\":{\"1067\":1}}],[\"如果两个软件实体无须直接通信\",{\"1\":{\"1064\":1}}],[\"如果两个变量的值在区间\",{\"1\":{\"368\":1}}],[\"如果两个方法有相同的名称和特征签名\",{\"1\":{\"290\":1}}],[\"如果值都为\",{\"1\":{\"882\":1}}],[\"如果节点数量发生了变化\",{\"1\":{\"880\":1}}],[\"如果节点是个follower\",{\"1\":{\"868\":1}}],[\"如果系统没有发生\",{\"1\":{\"870\":1}}],[\"如果key相同\",{\"1\":{\"867\":1}}],[\"如果未找到匹配的对象\",{\"1\":{\"1091\":1}}],[\"如果未指定\",{\"1\":{\"867\":1}}],[\"如果未命中缓存\",{\"1\":{\"489\":1}}],[\"如果leader发生故障\",{\"1\":{\"854\":1}}],[\"如果leader收到数据\",{\"1\":{\"853\":1}}],[\"如果producer收到ack就会进行下一轮的发送\",{\"1\":{\"854\":1}}],[\"如果follower长时间没有向leader同步数据\",{\"1\":{\"853\":1}}],[\"如果增加或者移除一个节点\",{\"1\":{\"880\":1}}],[\"如果增加\",{\"1\":{\"840\":1}}],[\"如果增删都是在末尾来操作\",{\"1\":{\"393\":1}}],[\"如果库存系统出现问题\",{\"1\":{\"840\":1}}],[\"如果当socket缓冲区满了\",{\"1\":{\"829\":1}}],[\"如果当前数大于父节点\",{\"1\":{\"937\":1}}],[\"如果当前没有数据可供消费\",{\"1\":{\"858\":1}}],[\"如果当前没有事务\",{\"1\":{\"740\":4}}],[\"如果当前存在事务\",{\"1\":{\"740\":7}}],[\"如果当前机器的主机信息和线程信息在数据库可以查到的话\",{\"1\":{\"668\":1}}],[\"如果当前字节码pc计数器的值已经超出了某个变量的作用域\",{\"1\":{\"192\":1}}],[\"如果当前位置的\",{\"1\":{\"131\":1}}],[\"如果逻辑时钟和数据\",{\"1\":{\"820\":1}}],[\"如果调用失败\",{\"1\":{\"810\":1,\"811\":1}}],[\"如果设置成功\",{\"1\":{\"807\":1}}],[\"如果插入成功\",{\"1\":{\"807\":1}}],[\"如果插入时没有指定\",{\"1\":{\"475\":1}}],[\"如果业务真的慢慢做大\",{\"1\":{\"805\":1}}],[\"如果整个集群都挂了也没问题\",{\"1\":{\"803\":1}}],[\"如果注册中心挂了\",{\"0\":{\"803\":1},\"1\":{\"803\":1}}],[\"如果三次心跳结果都没有返回值\",{\"1\":{\"802\":1}}],[\"如果非要引用\",{\"1\":{\"790\":1}}],[\"如果服务器需要记录该用户状态\",{\"1\":{\"1051\":1}}],[\"如果服务器判断客户端可以继续使用\",{\"1\":{\"1049\":1}}],[\"如果服务器是正常关闭\",{\"1\":{\"759\":1}}],[\"如果服务端正确接收并确认应答\",{\"1\":{\"1022\":1}}],[\"如果服务端收到有\",{\"1\":{\"665\":1}}],[\"如果服务提供者挂了\",{\"0\":{\"802\":1}}],[\"如果查询出来的列名和pojo的属性名不一致\",{\"1\":{\"751\":1}}],[\"如果查询条件带有cusno字段\",{\"1\":{\"587\":1}}],[\"如果用\",{\"1\":{\"749\":1,\"927\":1}}],[\"如果用户主动授信\",{\"1\":{\"1046\":1}}],[\"如果用户需求发生变化\",{\"1\":{\"731\":1}}],[\"如果用户账户密码已通过\",{\"1\":{\"490\":1}}],[\"如果用户线程与收集器并发工作会产生一个严重问题\",{\"1\":{\"251\":1}}],[\"如果用户创建的jar放在此目录下\",{\"1\":{\"177\":1}}],[\"如果需要实现支持多种数据库的软件\",{\"1\":{\"749\":1}}],[\"如果需要解决\",{\"1\":{\"106\":1}}],[\"如果配置了destroy\",{\"1\":{\"733\":1}}],[\"如果关联beanpostprocessor接口\",{\"1\":{\"733\":1}}],[\"如果实现beannameaware接口\",{\"1\":{\"733\":1}}],[\"如果实际的\",{\"1\":{\"380\":1}}],[\"如果下次我想要个英国人我只需要加个新的标签就行了\",{\"1\":{\"731\":1}}],[\"如果目标对象的实现类没有实现接口\",{\"1\":{\"726\":1}}],[\"如果目标对象的实现类实现了接口\",{\"1\":{\"725\":1}}],[\"如果目标文件已经存在\",{\"1\":{\"425\":1}}],[\"如果还有很多的代理方法\",{\"1\":{\"723\":1}}],[\"如果还是没有的话\",{\"1\":{\"547\":1}}],[\"如果ioc+接口情况下\",{\"1\":{\"718\":1}}],[\"如果innodb表中没有索引\",{\"1\":{\"503\":1}}],[\"如果判断单例不为空直接不用执行加锁动作\",{\"1\":{\"714\":1}}],[\"如果判断是完整的\",{\"1\":{\"578\":1}}],[\"如果制造出多个实例就可能会导致一些问题的产生\",{\"1\":{\"713\":1}}],[\"如果简单对服务器数量进行取模\",{\"1\":{\"681\":1}}],[\"如果手动把一台从服务器切换为主服务器\",{\"1\":{\"676\":1}}],[\"如果客户端由于某些原因获取锁失败\",{\"1\":{\"672\":1}}],[\"如果客户端在你实现的api中注册回调\",{\"1\":{\"304\":1}}],[\"如果成功获得\",{\"1\":{\"755\":1}}],[\"如果成功获取锁\",{\"1\":{\"672\":1}}],[\"如果成功加锁\",{\"1\":{\"513\":1}}],[\"如果事务定义过程中发现了问题\",{\"1\":{\"665\":1}}],[\"如果主从库在命令传播时出现了网络闪断\",{\"1\":{\"663\":1}}],[\"如果主机发生异常重启\",{\"1\":{\"571\":1}}],[\"如果集群超过半数以上的\",{\"1\":{\"659\":1}}],[\"如果半数以上的主节点与\",{\"1\":{\"659\":1}}],[\"如果多个\",{\"1\":{\"656\":1}}],[\"如果文件有错误\",{\"1\":{\"651\":1}}],[\"如果从节点执行全量复制操作\",{\"1\":{\"647\":1}}],[\"如果从表中没有和他匹配的\",{\"1\":{\"485\":1}}],[\"如果从表中有和他匹配的\",{\"1\":{\"485\":1}}],[\"如果过期的\",{\"1\":{\"632\":1}}],[\"如果前一节点的长度大于等于\",{\"1\":{\"627\":1}}],[\"如果直接从缓存中取\",{\"1\":{\"608\":1}}],[\"如果觉得有必要使用缓存\",{\"1\":{\"606\":1}}],[\"如果要拓展\",{\"1\":{\"1072\":1}}],[\"如果要使用sack\",{\"1\":{\"1013\":1}}],[\"如果要使用写锁也只能有一个线程使用\",{\"1\":{\"821\":1}}],[\"如果要求的测试用例需要读取二维数组\",{\"1\":{\"954\":1}}],[\"如果要求数据不能丢失任何修改的话\",{\"1\":{\"649\":1}}],[\"如果要存储几百兆字节的文件\",{\"1\":{\"606\":1}}],[\"如果要淘汰的是一个干净页\",{\"1\":{\"594\":1}}],[\"如果写操作多\",{\"1\":{\"606\":1}}],[\"如果命中率很低\",{\"1\":{\"606\":1}}],[\"如果命中了缓存\",{\"1\":{\"489\":1}}],[\"如果频繁用到的查询条件中不带cusno时\",{\"1\":{\"587\":1}}],[\"如果完整就提交\",{\"1\":{\"578\":1}}],[\"如果你准备发布到\",{\"1\":{\"1197\":2}}],[\"如果你指定了partition\",{\"1\":{\"865\":1}}],[\"如果你运气好\",{\"1\":{\"576\":1}}],[\"如果你的服务器内存足够大的话\",{\"1\":{\"645\":1}}],[\"如果你的\",{\"1\":{\"576\":1}}],[\"如果你创建的\",{\"1\":{\"468\":1}}],[\"如果你创建了一个threadlocal变量\",{\"1\":{\"299\":1}}],[\"如果超过这个参数规定的大小\",{\"1\":{\"571\":1}}],[\"如果一趟比较下来没有进行过交换\",{\"1\":{\"930\":1}}],[\"如果一台服务器能够收到来自\",{\"1\":{\"877\":1}}],[\"如果一台服务器收到的请求的\",{\"1\":{\"876\":1}}],[\"如果一直请求一个不存在的缓存\",{\"1\":{\"645\":1}}],[\"如果一开始使用水平拆分\",{\"1\":{\"561\":1}}],[\"如果一个真实主题角色必须对应一个代理主题角色\",{\"1\":{\"1083\":1}}],[\"如果一个网络不划分子网\",{\"1\":{\"989\":1}}],[\"如果一个网络中包含不同的操作系统或者不同的网络架构\",{\"1\":{\"961\":1}}],[\"如果一个\",{\"1\":{\"657\":1,\"677\":1,\"876\":2,\"877\":1}}],[\"如果一个实例距离最后一次有效回复\",{\"1\":{\"677\":1}}],[\"如果一个实例\",{\"1\":{\"657\":1}}],[\"如果一个查询返回的数据为空\",{\"1\":{\"641\":1}}],[\"如果一个查询正在遍历一个表中的数据\",{\"1\":{\"511\":1}}],[\"如果一个程序必须在有安全限制的环境中运行\",{\"1\":{\"348\":1}}],[\"如果一个外部类的实例对象的方法返回了一个内部类的实例对象\",{\"1\":{\"304\":1}}],[\"如果一个类的域被关键字\",{\"1\":{\"370\":1}}],[\"如果一个类已经加载到系统中\",{\"1\":{\"187\":1}}],[\"如果一个类中没有静态语句块\",{\"1\":{\"173\":1}}],[\"如果一个java\",{\"1\":{\"174\":1}}],[\"如果一个对象仅持有虚引用\",{\"1\":{\"235\":1}}],[\"如果一个对象被发现只能从一个线程被访问到\",{\"1\":{\"202\":1}}],[\"如果一个对象的\",{\"1\":{\"88\":1}}],[\"如果一个对象虽然有多个线程要对它进行加锁\",{\"1\":{\"87\":1}}],[\"如果一个操作执行的结果需要对另一个操作可见\",{\"1\":{\"75\":1}}],[\"如果存储的字符串时整数\",{\"1\":{\"617\":1}}],[\"如果存储引擎使用的是myisam\",{\"1\":{\"550\":1}}],[\"如果存在一个值不为\",{\"1\":{\"882\":1}}],[\"如果存在则说明该操作已经执行过了\",{\"1\":{\"807\":1}}],[\"如果存在则返回值\",{\"1\":{\"39\":1}}],[\"如果存在\",{\"1\":{\"647\":1}}],[\"如果存在大量的数据\",{\"1\":{\"467\":1}}],[\"如果都是聚簇索引\",{\"1\":{\"549\":1}}],[\"如果都不满足\",{\"1\":{\"131\":1}}],[\"如果给表加上了主键\",{\"1\":{\"548\":1}}],[\"如果发生\",{\"1\":{\"541\":1}}],[\"如果发现某个\",{\"1\":{\"1060\":1}}],[\"如果发现自己的更新\",{\"1\":{\"878\":1}}],[\"如果发现冲突了\",{\"1\":{\"513\":1}}],[\"如果发现它还有虚引用\",{\"1\":{\"235\":1}}],[\"如果发现它要访问的页不在内存时\",{\"1\":{\"159\":1}}],[\"如果发现锁这个时候被释放了\",{\"1\":{\"114\":1}}],[\"如果哈希冲突很多\",{\"1\":{\"537\":1}}],[\"如果左边的值未确定\",{\"1\":{\"534\":1}}],[\"如果建立\",{\"1\":{\"533\":2}}],[\"如果所有操作成功执行\",{\"1\":{\"520\":1}}],[\"如果所申请的资源被其他等待进程占有\",{\"1\":{\"98\":1}}],[\"如果任何事务已达到失败状态\",{\"1\":{\"520\":1}}],[\"如果任务不一定要执行完可调用\",{\"1\":{\"59\":1}}],[\"如果某个worker挂了\",{\"1\":{\"830\":1}}],[\"如果某个类被标记为final\",{\"1\":{\"715\":1}}],[\"如果某个检查在活动状态下失败\",{\"1\":{\"520\":1}}],[\"如果某些方法中的对象引用没有被返回或者未被外面使用\",{\"1\":{\"199\":1}}],[\"如果该锁没有被任何客户端持有则返回\",{\"1\":{\"517\":1}}],[\"如果该锁被其它客户端持有着则返回\",{\"1\":{\"517\":1}}],[\"如果该锁是当前客户端持有的则返回\",{\"1\":{\"517\":1}}],[\"如果该方法返回\",{\"1\":{\"96\":1}}],[\"如果加锁失败\",{\"1\":{\"513\":1}}],[\"如果加上远程的\",{\"1\":{\"444\":1}}],[\"如果更新条件是唯一索引\",{\"1\":{\"506\":1}}],[\"如果更新条件为索引字段\",{\"1\":{\"506\":1}}],[\"如果更新条件没走索引\",{\"1\":{\"506\":1}}],[\"如果进行全表扫描的当前读\",{\"1\":{\"501\":1}}],[\"如果观察到建立哈希索引可以带来速度提升\",{\"1\":{\"496\":1}}],[\"如果重启或者关机\",{\"1\":{\"494\":1}}],[\"如果内存出现异常就会影响数据\",{\"1\":{\"494\":1}}],[\"如果内存够\",{\"1\":{\"484\":1}}],[\"如果指定了\",{\"1\":{\"492\":1}}],[\"如果指定了上限如\",{\"1\":{\"345\":1}}],[\"如果缓存\",{\"1\":{\"490\":1}}],[\"如果只给定一个参数\",{\"1\":{\"486\":1}}],[\"如果只有\",{\"1\":{\"400\":1}}],[\"如果表中没有显示指定主键\",{\"1\":{\"547\":1}}],[\"如果表中没有定义主键\",{\"1\":{\"546\":1}}],[\"如果表中记录1亿\",{\"1\":{\"514\":1}}],[\"如果表中已经存在\",{\"1\":{\"468\":1}}],[\"如果表中有\",{\"1\":{\"464\":1}}],[\"如果经常有合并表的操作\",{\"1\":{\"467\":1}}],[\"如果经过逃逸分析后发现\",{\"1\":{\"202\":1}}],[\"如果代码没有任何新变化\",{\"1\":{\"448\":1}}],[\"如果原有\",{\"1\":{\"406\":1}}],[\"如果创建简单对象\",{\"1\":{\"1086\":1}}],[\"如果创建对象时直接\",{\"1\":{\"1076\":1}}],[\"如果创建\",{\"1\":{\"404\":1}}],[\"如果创建线程时还未设置\",{\"1\":{\"179\":1}}],[\"如果创建线程数达到\",{\"1\":{\"58\":1}}],[\"如果自己传入初始大小\",{\"1\":{\"399\":1}}],[\"如果第一个不匹配\",{\"1\":{\"398\":1}}],[\"如果桶为空则直接返回\",{\"1\":{\"398\":1}}],[\"如果碰撞了\",{\"1\":{\"397\":1}}],[\"如果删除操作的位置是在中间\",{\"1\":{\"393\":1}}],[\"如果数据无法放入内存\",{\"1\":{\"891\":1}}],[\"如果数据库挂了\",{\"1\":{\"803\":1}}],[\"如果数据库中的对应数据改变之后\",{\"1\":{\"606\":1}}],[\"如果数据页已经在内存中\",{\"1\":{\"575\":1}}],[\"如果数据页在内存中就直接更新\",{\"1\":{\"574\":1}}],[\"如果数据有索引\",{\"1\":{\"528\":1}}],[\"如果数据量有百万级的时\",{\"1\":{\"393\":1}}],[\"如果数量大于\",{\"1\":{\"131\":1}}],[\"如果改变了返回对象的属性\",{\"1\":{\"383\":1}}],[\"如果采用\",{\"1\":{\"381\":1,\"578\":1}}],[\"如果采用固定大小的jvm栈\",{\"1\":{\"190\":1}}],[\"如果阻塞直到完成那么就是传统的阻塞\",{\"1\":{\"380\":1}}],[\"如果子类重写了父类的某个方法\",{\"1\":{\"364\":1}}],[\"如果子线程中要进行大量耗时运算计算某个数据值\",{\"1\":{\"35\":1}}],[\"如果父类和子类中存在同样名称和参数的静态方法\",{\"1\":{\"358\":1}}],[\"如果父类方法在子类中没有被重写\",{\"1\":{\"290\":1}}],[\"如果我提供了一组接口给它\",{\"1\":{\"349\":1}}],[\"如果我们只想下载直接引用的jar包\",{\"1\":{\"796\":1}}],[\"如果我们的项目引用了一个jar包\",{\"1\":{\"796\":1}}],[\"如果我们的切面比较少\",{\"1\":{\"720\":1}}],[\"如果我们要查找定位第一个和最后一个元素\",{\"1\":{\"627\":1}}],[\"如果我们再次添加相同的键\",{\"1\":{\"408\":1}}],[\"如果我们不指定\",{\"1\":{\"399\":1}}],[\"如果我们不想打破双亲委派模型\",{\"1\":{\"185\":1}}],[\"如果我们想要调用操作系统提供的内核态级别的子功能咋办呢\",{\"1\":{\"135\":1}}],[\"如果我们没有启动线程\",{\"1\":{\"34\":1}}],[\"如果比较的是引用数据类型\",{\"1\":{\"340\":1}}],[\"如果比较的对象是基本数据类型\",{\"1\":{\"340\":1}}],[\"如果想实现每一个线程都有自己的专属本地变量该如何解决呢\",{\"1\":{\"299\":1}}],[\"如果虚拟机栈可以动态扩展\",{\"1\":{\"297\":1}}],[\"如果对语句的优化已经无法进行\",{\"1\":{\"559\":1}}],[\"如果对长字符串列进行索引\",{\"1\":{\"535\":1}}],[\"如果对声明了\",{\"1\":{\"296\":1}}],[\"如果对象太老了\",{\"1\":{\"241\":1}}],[\"如果对象太大了\",{\"1\":{\"241\":1}}],[\"如果对象这时候还没有逃脱\",{\"1\":{\"236\":1}}],[\"如果对象要在finalize\",{\"1\":{\"236\":1}}],[\"如果对象在进行可达性分析后发现没有与gc\",{\"1\":{\"236\":1}}],[\"如果对象被多个线程访问\",{\"1\":{\"88\":1}}],[\"如果应用场景需要一个更大范围的原子性保证\",{\"1\":{\"295\":1}}],[\"如果把一个java程序中的信息分为代码\",{\"1\":{\"292\":1}}],[\"如果后面某些指向常量池的索引值的数据在特定情况下需要表达\",{\"1\":{\"286\":1}}],[\"如果始终没有找到合适的方法\",{\"1\":{\"278\":1}}],[\"如果通过则返回这个方法的直接引用\",{\"1\":{\"278\":1}}],[\"如果major\",{\"1\":{\"243\":1}}],[\"如果map不为空移除当前threadlocal对象对应的entry\",{\"1\":{\"39\":1}}],[\"如果之后空间还不足\",{\"1\":{\"243\":1}}],[\"如果弱引用所引用的对象被垃圾回收\",{\"1\":{\"235\":1}}],[\"如果软引用所引用的对象被垃圾回收\",{\"1\":{\"235\":1}}],[\"如果小于就要进行一次\",{\"1\":{\"220\":1}}],[\"如果大于\",{\"1\":{\"220\":1}}],[\"如果不使用简单工厂\",{\"1\":{\"1077\":1}}],[\"如果不携带\",{\"1\":{\"1022\":1}}],[\"如果不能及时收到一个确认\",{\"1\":{\"1009\":1}}],[\"如果不是int是int64\",{\"1\":{\"886\":1}}],[\"如果不进行预热\",{\"1\":{\"640\":1}}],[\"如果不用两阶段提交\",{\"1\":{\"578\":1}}],[\"如果不指定前缀索引\",{\"1\":{\"554\":1}}],[\"如果不同程序会并发存取多个表\",{\"1\":{\"516\":1}}],[\"如果不阻塞\",{\"1\":{\"380\":2}}],[\"如果不对connection\",{\"1\":{\"304\":1}}],[\"如果不存在泄漏\",{\"1\":{\"298\":1}}],[\"如果不存在数据依赖性\",{\"1\":{\"71\":1}}],[\"如果不想浪费50\",{\"1\":{\"246\":1}}],[\"如果不成立的话虚拟机会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小\",{\"1\":{\"220\":1}}],[\"如果条件成立的话\",{\"1\":{\"220\":1}}],[\"如果survivor区中相同年龄的所有对象大小的总和大于survivor空间的一半\",{\"1\":{\"220\":1}}],[\"如果state\",{\"1\":{\"96\":1}}],[\"如果因为冲突失败就重试\",{\"1\":{\"219\":1}}],[\"如果java堆中的内存并不是规整的\",{\"1\":{\"217\":1}}],[\"如果jvm栈是可以动态扩展的\",{\"1\":{\"190\":1}}],[\"如果方法在编译期就确定了具体的调用版本\",{\"1\":{\"194\":1}}],[\"如果被代理类没有实现接口的实现类\",{\"1\":{\"715\":1}}],[\"如果被调用的方法在编译期无法被确定下来\",{\"1\":{\"194\":1}}],[\"如果被请求的共享资源被占用\",{\"1\":{\"110\":1}}],[\"如果被请求的共享资源空闲\",{\"1\":{\"110\":1}}],[\"如果执行实例方法\",{\"1\":{\"192\":1}}],[\"如果访问的是64位数据类型的变量\",{\"1\":{\"192\":1}}],[\"如果访问的是32位数据类型的变量\",{\"1\":{\"192\":1}}],[\"如果线程请求分配的栈容量超过jvm栈允许的最大容量\",{\"1\":{\"190\":1}}],[\"如果线程正在执行一个native方法\",{\"1\":{\"189\":1}}],[\"如果线程正在执行一个java方法\",{\"1\":{\"189\":1}}],[\"如果线程间存在锁竞争\",{\"1\":{\"86\":1}}],[\"如果可以找到归属关系\",{\"1\":{\"181\":1}}],[\"如果引用多个框架的话\",{\"1\":{\"180\":1}}],[\"如果在客户类中存在这种实例化代码\",{\"1\":{\"1077\":1}}],[\"如果在网络中滞留\",{\"1\":{\"1022\":1}}],[\"如果在这一趟排序中\",{\"1\":{\"930\":1}}],[\"如果在follower同步成功之前leader故障\",{\"1\":{\"854\":1}}],[\"如果在spring配置中还配置了init\",{\"1\":{\"733\":1}}],[\"如果在查询数据库和重建缓存\",{\"1\":{\"643\":1}}],[\"如果在规定时间内没有获得锁就返回\",{\"1\":{\"350\":1}}],[\"如果在类型c中找到与常量中的描述符和简单名称都相符的方法\",{\"1\":{\"278\":1}}],[\"如果在java堆中没有内存完成实例分配\",{\"1\":{\"199\":1}}],[\"如果在应用程序的全局范围内都没有设置过\",{\"1\":{\"179\":1}}],[\"如果在尝试加轻量级锁的过程中\",{\"1\":{\"89\":1}}],[\"如果其中某个包丢失了\",{\"1\":{\"1042\":1}}],[\"如果其中的某片的数据丢失了\",{\"1\":{\"982\":1}}],[\"如果其中的有的文件超过了1m大小\",{\"1\":{\"894\":1}}],[\"如果其父类还未初始化\",{\"1\":{\"174\":1}}],[\"如果其他线程也来执行\",{\"1\":{\"85\":1}}],[\"如果类没初始化\",{\"1\":{\"174\":1}}],[\"如果段长过大\",{\"1\":{\"155\":1}}],[\"如果统计过程中容器大小发生了变化\",{\"1\":{\"129\":1}}],[\"如果读锁调用\",{\"1\":{\"125\":1}}],[\"如果有效\",{\"1\":{\"1044\":1}}],[\"如果有则直接向这个ip地址发起http请求\",{\"1\":{\"1031\":1}}],[\"如果有则不去抢锁\",{\"1\":{\"114\":1}}],[\"如果有服务器发现自己的\",{\"1\":{\"876\":1}}],[\"如果有10个消费者\",{\"1\":{\"850\":1}}],[\"如果有变更\",{\"1\":{\"811\":1}}],[\"如果有容器程序可以把这部分处理交给容器\",{\"1\":{\"718\":1}}],[\"如果有要代理的对象\",{\"1\":{\"715\":1}}],[\"如果有客户端提交查询请求\",{\"1\":{\"656\":1}}],[\"如果有需要\",{\"1\":{\"655\":1}}],[\"如果有三台mysql\",{\"1\":{\"579\":1}}],[\"如果有冲突\",{\"1\":{\"514\":1}}],[\"如果有两个线程要同时给一个表加字段\",{\"1\":{\"511\":1}}],[\"如果有权限\",{\"1\":{\"490\":1}}],[\"如果有可能是一个常数\",{\"1\":{\"556\":1}}],[\"如果有可能\",{\"1\":{\"468\":1}}],[\"如果有\",{\"1\":{\"355\":1}}],[\"如果有大量对象需要回收\",{\"1\":{\"244\":1}}],[\"如果有这个接口的实现类发生了初始化\",{\"1\":{\"174\":1}}],[\"如果有取值为\",{\"1\":{\"87\":1}}],[\"如果这时候已经有一个事务在这行记录上持有一个写锁\",{\"1\":{\"559\":1}}],[\"如果这时没有可用资源\",{\"1\":{\"98\":1}}],[\"如果这些被聚合的项目中需要引入相同的jar\",{\"1\":{\"800\":1}}],[\"如果这些类中定义了实例变量\",{\"1\":{\"735\":1}}],[\"如果这些对象占用的内存比较大\",{\"1\":{\"411\":1}}],[\"如果这些容器为静态的\",{\"1\":{\"304\":1}}],[\"如果这次没有把数据全部读写完\",{\"1\":{\"381\":1}}],[\"如果这个内部类对象被长期引用了\",{\"1\":{\"304\":1}}],[\"如果这个class文件表示的是一个接口\",{\"1\":{\"288\":1}}],[\"如果这个对象被判定为确有必要执行finalize\",{\"1\":{\"236\":1}}],[\"如果这个时候恰巧锁没有被占用\",{\"1\":{\"114\":1}}],[\"如果这两次\",{\"1\":{\"114\":1}}],[\"如果没抢到\",{\"1\":{\"113\":1}}],[\"如果没有其他手段来重新分配选票的话\",{\"1\":{\"877\":1}}],[\"如果没有选出\",{\"1\":{\"876\":1}}],[\"如果没有接口这里会报错\",{\"1\":{\"725\":1}}],[\"如果没有开启\",{\"1\":{\"647\":1}}],[\"如果没有正在执行的子进程\",{\"1\":{\"647\":1}}],[\"如果没有持久化机制\",{\"1\":{\"646\":1}}],[\"如果没有这样的索引\",{\"1\":{\"546\":1}}],[\"如果没有特指分布式事务\",{\"1\":{\"518\":1}}],[\"如果没有命中索引\",{\"1\":{\"508\":1}}],[\"如果没有命中\",{\"1\":{\"490\":1}}],[\"如果没有权限\",{\"1\":{\"430\":1,\"490\":1}}],[\"如果没有碰撞\",{\"1\":{\"397\":1}}],[\"如果没有即使地把对象设置成null\",{\"1\":{\"304\":1}}],[\"如果没有\",{\"1\":{\"214\":1,\"355\":1,\"1031\":1}}],[\"如果没有使用双亲委派模型\",{\"1\":{\"184\":1}}],[\"如果没有手动删除对应\",{\"1\":{\"45\":1}}],[\"如果没有在\",{\"1\":{\"35\":1}}],[\"如果提供的旧值\",{\"1\":{\"105\":1}}],[\"如果出现了冲突怎么办\",{\"1\":{\"105\":1}}],[\"如果能确保所有的线程都是按照相同的顺序获得锁\",{\"1\":{\"98\":1}}],[\"如果另一进程申请该资源\",{\"1\":{\"98\":1}}],[\"如果很多次锁的请求都是对同一对象加锁\",{\"1\":{\"93\":1}}],[\"如果取值不为\",{\"1\":{\"87\":1}}],[\"如果替换失败\",{\"1\":{\"87\":1}}],[\"如果替换成功\",{\"1\":{\"87\":1}}],[\"如果使用直接指针访问\",{\"1\":{\"230\":1}}],[\"如果使用句柄的话\",{\"1\":{\"229\":1}}],[\"如果使用了tlab的话\",{\"1\":{\"221\":1}}],[\"如果使用\",{\"1\":{\"85\":1}}],[\"如果锁的计数器为\",{\"1\":{\"82\":1}}],[\"如果抢到了就执行代码\",{\"1\":{\"81\":1}}],[\"如果\",{\"1\":{\"75\":2,\"81\":1,\"102\":1,\"106\":1,\"118\":2,\"300\":1,\"341\":1,\"400\":1,\"412\":1,\"427\":1,\"484\":2,\"489\":1,\"517\":1,\"578\":1,\"630\":1,\"638\":2,\"643\":1,\"659\":1,\"661\":1,\"664\":1,\"752\":1,\"803\":1,\"878\":2,\"1027\":1,\"1061\":1,\"1091\":1}}],[\"如果是发送本站的就收下\",{\"1\":{\"979\":1}}],[\"如果是https连接的话\",{\"1\":{\"959\":1,\"1029\":1}}],[\"如果是00变01\",{\"1\":{\"900\":1}}],[\"如果是本地方法调用\",{\"1\":{\"801\":1}}],[\"如果是会有什么问题\",{\"0\":{\"757\":1}}],[\"如果是用于当做内存数据库\",{\"1\":{\"653\":1}}],[\"如果是数据比较重要\",{\"1\":{\"653\":1}}],[\"如果是数据不那么敏感\",{\"1\":{\"653\":1}}],[\"如果是则将\",{\"1\":{\"623\":1}}],[\"如果是单机部署的mysql\",{\"1\":{\"579\":1}}],[\"如果是mysql导致的\",{\"1\":{\"562\":1}}],[\"如果是连续数值\",{\"1\":{\"560\":1}}],[\"如果是子查询\",{\"1\":{\"560\":1}}],[\"如果是的话可以进行横向或者纵向的分表\",{\"1\":{\"559\":1}}],[\"如果是长连接\",{\"1\":{\"526\":1}}],[\"如果是脏页\",{\"1\":{\"496\":1}}],[\"如果是out\",{\"1\":{\"487\":1}}],[\"如果是其他的类继承当前类是不能访问到\",{\"1\":{\"358\":1}}],[\"如果是其它线程获取本对象上的锁\",{\"1\":{\"87\":1}}],[\"如果是被中断的话就抛出一个\",{\"1\":{\"350\":1}}],[\"如果是内存泄漏\",{\"1\":{\"298\":1}}],[\"如果是类的话\",{\"1\":{\"287\":1}}],[\"如果是\",{\"1\":{\"96\":1,\"476\":1,\"896\":2}}],[\"如果是当前线程再次获取本对象上的锁\",{\"1\":{\"87\":1}}],[\"如果是重量级锁\",{\"1\":{\"81\":1}}],[\"如果是无效\",{\"1\":{\"72\":1}}],[\"如果是修改\",{\"1\":{\"72\":1}}],[\"如果是共享\",{\"1\":{\"72\":1}}],[\"如果是独占\",{\"1\":{\"72\":1}}],[\"如果是多线程访问数据库\",{\"1\":{\"64\":1}}],[\"如果为空表示当前位置可以写入数据\",{\"1\":{\"131\":1}}],[\"如果为空则为该线程创建map并设置初始值\",{\"1\":{\"39\":1}}],[\"如果为\",{\"1\":{\"46\":1,\"412\":1}}],[\"则新建对象\",{\"1\":{\"1091\":1}}],[\"则创建新对象\",{\"1\":{\"1091\":1}}],[\"则创建一个事务作为当前事务的嵌套事务来运行\",{\"1\":{\"740\":1}}],[\"则创建一个新的事务\",{\"1\":{\"740\":1}}],[\"则从服务器的ip地址池中获取一个地址分配给该计算机\",{\"1\":{\"1049\":1}}],[\"则回复nak报文\",{\"1\":{\"1049\":1}}],[\"则弹出警告提示\",{\"1\":{\"1044\":1}}],[\"则url就指到主页\",{\"1\":{\"1036\":1}}],[\"则此域名服务器就暂时成为了dns中的另一个客户\",{\"1\":{\"1031\":1}}],[\"则服务端一直等待客户端发送数据\",{\"1\":{\"1023\":1}}],[\"则向客户端发送确认\",{\"1\":{\"1022\":1}}],[\"则发送方就把第一个数据字节先发送出去\",{\"1\":{\"1017\":1}}],[\"则跳转至下一路由器\",{\"1\":{\"990\":1}}],[\"则传送给该路由\",{\"1\":{\"990\":1}}],[\"则以单播的形式发送一个arp响应分组\",{\"1\":{\"986\":1}}],[\"则以非事务的方式继续运行\",{\"1\":{\"740\":1}}],[\"则mss=1500\",{\"1\":{\"982\":1}}],[\"则立即填入一个\",{\"1\":{\"973\":1}}],[\"则立即返回存储在缓存中的结果\",{\"1\":{\"489\":1}}],[\"则重复上述步骤并向服务器请求这些资源\",{\"1\":{\"959\":1,\"1029\":1}}],[\"则当前数和当前父节点交换\",{\"1\":{\"937\":1}}],[\"则交换顺序\",{\"1\":{\"937\":1}}],[\"则右子树上所有节点的值均大于它的根节点的值\",{\"1\":{\"915\":1}}],[\"则左子树上所有节点的值均小于它的根节点的值\",{\"1\":{\"915\":1}}],[\"则一共需要2亿\",{\"1\":{\"903\":1}}],[\"则count+1\",{\"1\":{\"895\":1}}],[\"则把数据报传送给该路由\",{\"1\":{\"990\":1}}],[\"则把xi放入堆中\",{\"1\":{\"893\":1}}],[\"则把当前事务挂起\",{\"1\":{\"740\":2}}],[\"则应该替换那个最大元素\",{\"1\":{\"885\":1}}],[\"则应当是\",{\"1\":{\"288\":1}}],[\"则拒绝投票给该\",{\"1\":{\"878\":1}}],[\"则被分配到同一个分区\",{\"1\":{\"867\":1}}],[\"则分别进行全局去重\",{\"1\":{\"856\":1}}],[\"则要求数据不重复也不丢失\",{\"1\":{\"856\":1}}],[\"则要转换为红黑树\",{\"1\":{\"131\":1}}],[\"则该follower将从isr中被踢出\",{\"1\":{\"853\":1}}],[\"则该取值等价于\",{\"1\":{\"740\":1}}],[\"则响应服务请求\",{\"1\":{\"807\":1}}],[\"则抛出异常\",{\"1\":{\"740\":2}}],[\"则抛出java\",{\"1\":{\"278\":1}}],[\"则加入该事务\",{\"1\":{\"740\":3}}],[\"则真正锁有效时间为\",{\"1\":{\"672\":1}}],[\"则锁的真正有效时间是\",{\"1\":{\"672\":1}}],[\"则设置成功\",{\"1\":{\"668\":1}}],[\"则在插入指令\",{\"1\":{\"665\":1}}],[\"则返回\",{\"1\":{\"664\":1,\"1188\":1}}],[\"则返回同步之前的数据\",{\"1\":{\"656\":1}}],[\"则正在监视这个\",{\"1\":{\"657\":1,\"677\":1}}],[\"则这个实例会被当前\",{\"1\":{\"677\":1}}],[\"则这个实例会被\",{\"1\":{\"657\":1}}],[\"则采用默认的分区策略\",{\"1\":{\"867\":1}}],[\"则采用\",{\"1\":{\"627\":2}}],[\"则采用row格式保存binlog\",{\"1\":{\"572\":1}}],[\"则直接写入\",{\"1\":{\"623\":1}}],[\"则直接插入\",{\"1\":{\"496\":1,\"574\":1}}],[\"则很少被查询\",{\"1\":{\"587\":1}}],[\"则来自部分提交状态的事务进入提交状态\",{\"1\":{\"520\":1}}],[\"则恢复管理器将数据库回滚到开始执行的原始状态\",{\"1\":{\"520\":1}}],[\"则等待直到事务ａ释放\",{\"1\":{\"514\":1}}],[\"则给用户返回错误的信息\",{\"1\":{\"513\":1}}],[\"则事务进入失败状态\",{\"1\":{\"520\":1}}],[\"则事务\",{\"1\":{\"509\":1}}],[\"则建立哈希索引\",{\"1\":{\"496\":1}}],[\"则先放入到一个\",{\"1\":{\"574\":1}}],[\"则先放入到一个insert\",{\"1\":{\"496\":1}}],[\"则先触发该父类的初始化\",{\"1\":{\"174\":1}}],[\"则依然可以使用它\",{\"1\":{\"492\":1}}],[\"则我们根据查询的页数和查询的记录数可以算出查询的id的范围\",{\"1\":{\"486\":1}}],[\"则显示null\",{\"1\":{\"485\":1}}],[\"则显示匹配的值\",{\"1\":{\"485\":1}}],[\"则差不多\",{\"1\":{\"482\":1}}],[\"则用来改写上一次commit的提交信息\",{\"1\":{\"448\":1}}],[\"则是具有安全性的\",{\"1\":{\"1048\":1}}],[\"则是一个应用执行的容器\",{\"1\":{\"825\":1}}],[\"则是一个\",{\"1\":{\"825\":1}}],[\"则是浅拷贝\",{\"1\":{\"608\":1}}],[\"则是将更新记录在change\",{\"1\":{\"574\":1}}],[\"则是\",{\"1\":{\"413\":1}}],[\"则是锁定当前变量\",{\"1\":{\"79\":1}}],[\"则完全放开了牺牲数据实时性而保证数据最终一致性\",{\"1\":{\"411\":1}}],[\"则旧值将被新值替换\",{\"1\":{\"408\":1}}],[\"则哈希表需要扩容\",{\"1\":{\"399\":1}}],[\"则判断它的下一个是红黑树还是链表\",{\"1\":{\"398\":1}}],[\"则替换原来的值\",{\"1\":{\"397\":1}}],[\"则影响结果\",{\"1\":{\"383\":1}}],[\"则无需自己负责进行读写\",{\"1\":{\"381\":1}}],[\"则比较结果为\",{\"1\":{\"368\":1}}],[\"则比较的是对象的地址值是否相等\",{\"1\":{\"340\":1}}],[\"则比较的是数值是否相等\",{\"1\":{\"340\":1}}],[\"则视为重载\",{\"1\":{\"359\":2}}],[\"则编译错误\",{\"1\":{\"355\":1}}],[\"则类型参数就被替换成类型上限\",{\"1\":{\"345\":1}}],[\"则\",{\"0\":{\"341\":1},\"1\":{\"383\":1,\"427\":1,\"657\":1,\"677\":1}}],[\"则通过事务回滚\",{\"1\":{\"807\":1}}],[\"则通过\",{\"1\":{\"340\":1}}],[\"则可分别对这两部分记录继续进行排序\",{\"1\":{\"935\":1}}],[\"则可明确定位到相应库去查询\",{\"1\":{\"587\":1}}],[\"则可能是io负载非常重或者cpu不够用\",{\"1\":{\"331\":1}}],[\"则可以有效地减轻服务器资源的消耗\",{\"1\":{\"1060\":1}}],[\"则可以根据\",{\"1\":{\"570\":1}}],[\"则可以存储到多个数据块中\",{\"1\":{\"442\":1}}],[\"则可以保证有序性\",{\"1\":{\"79\":1}}],[\"则可以使用在变量\",{\"1\":{\"79\":1}}],[\"则容器中的对象在程序结束之前将不能被释放\",{\"1\":{\"304\":1}}],[\"则计数器值为0\",{\"1\":{\"288\":1}}],[\"则称为变量的\",{\"1\":{\"277\":1}}],[\"则触发major\",{\"1\":{\"243\":1}}],[\"则会在7\",{\"1\":{\"1049\":1}}],[\"则会将\",{\"1\":{\"878\":1}}],[\"则会执行该方法\",{\"1\":{\"759\":1}}],[\"则会进行全量同步\",{\"1\":{\"675\":1}}],[\"则会选择表中的第一个不允许为\",{\"1\":{\"547\":1}}],[\"则会自动在之前补\",{\"1\":{\"476\":1}}],[\"则会按照高位在前的方式分割成若干个8个字节进行存储\",{\"1\":{\"284\":1}}],[\"则会被送到survivor区\",{\"1\":{\"242\":1}}],[\"则会放弃争抢锁\",{\"1\":{\"98\":1}}],[\"则证明此对象是不可用的\",{\"1\":{\"234\":1}}],[\"则证明当前有线程正在持有锁\",{\"1\":{\"81\":1}}],[\"则说明发布内容没有被篡改\",{\"1\":{\"1057\":1}}],[\"则说明已经有序\",{\"1\":{\"930\":1}}],[\"则说明安装成功\",{\"1\":{\"793\":1}}],[\"则说明会同时使用第n和n+1两个变量槽\",{\"1\":{\"192\":1}}],[\"则说明轻量级锁进行了锁膨胀或已经升级为重量级锁\",{\"1\":{\"87\":1}}],[\"则需要自定义多套\",{\"1\":{\"749\":1}}],[\"则需要先触发其初始化\",{\"1\":{\"174\":1}}],[\"则需要进行扩容\",{\"1\":{\"131\":1}}],[\"则第一轮淘汰\",{\"1\":{\"160\":1}}],[\"则进行访问权限校验\",{\"1\":{\"278\":1}}],[\"则进行第二轮扫描\",{\"1\":{\"160\":1}}],[\"则进程由执行状态变为阻塞状态\",{\"1\":{\"148\":1}}],[\"则不消耗序号\",{\"1\":{\"1022\":1}}],[\"则不更新堆\",{\"1\":{\"893\":1}}],[\"则不需要这么高的数据安全\",{\"1\":{\"582\":1}}],[\"则不会创建一个新的对象\",{\"1\":{\"369\":1}}],[\"则不容易分配连续空间\",{\"1\":{\"155\":1}}],[\"则不同\",{\"1\":{\"137\":1}}],[\"则利用\",{\"1\":{\"131\":1}}],[\"则将\",{\"1\":{\"1197\":1}}],[\"则将当前请求资源的线程设置为有效的工作线程\",{\"1\":{\"110\":1}}],[\"则将参数设置到map中去\",{\"1\":{\"39\":1}}],[\"则再次获取锁\",{\"1\":{\"96\":1}}],[\"则表示锁可以被获取\",{\"1\":{\"82\":1}}],[\"则产生溢出\",{\"1\":{\"47\":1}}],[\"且算法的变化不会影响使用算法的客户\",{\"1\":{\"1088\":1}}],[\"且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构\",{\"1\":{\"1079\":1}}],[\"且为\",{\"1\":{\"1061\":1}}],[\"且传送时各帧之间还必须有一定的间隙\",{\"1\":{\"980\":1}}],[\"且地理范围和站点数目均有限\",{\"1\":{\"977\":1}}],[\"且数据的数据量在不断的变化的时候\",{\"1\":{\"942\":1}}],[\"且partition会均衡分布到不同broker上\",{\"1\":{\"849\":1}}],[\"且参数分别为服务器\",{\"1\":{\"820\":1}}],[\"且投票数大于半数则胜出的机制\",{\"1\":{\"820\":1}}],[\"且bootstrap中的属性不能被覆盖\",{\"1\":{\"783\":1}}],[\"且每条数据都有自己的offset\",{\"1\":{\"846\":1}}],[\"且每台\",{\"1\":{\"678\":1}}],[\"且每列都含有重复值可考虑建组合索引\",{\"1\":{\"535\":1}}],[\"且没有回滚\",{\"1\":{\"665\":1}}],[\"且执行的是只读命令也返回\",{\"1\":{\"664\":1}}],[\"且这些语句为隐式提交\",{\"1\":{\"501\":1}}],[\"且效率更高\",{\"1\":{\"997\":1}}],[\"且效率高于\",{\"1\":{\"480\":1}}],[\"且效率大于\",{\"1\":{\"410\":1}}],[\"且在\",{\"1\":{\"468\":1}}],[\"且在每次遍历过程中进行了一堆判断\",{\"1\":{\"391\":1}}],[\"且均为\",{\"1\":{\"430\":1}}],[\"且\",{\"1\":{\"425\":1,\"866\":1,\"919\":1}}],[\"且链表的大小大于\",{\"1\":{\"401\":1}}],[\"且当链表长度\",{\"1\":{\"398\":1}}],[\"且当线程运行时无法被垃圾回收\",{\"1\":{\"46\":1}}],[\"且不能被重新赋值\",{\"1\":{\"346\":1}}],[\"且保证gc\",{\"1\":{\"297\":1}}],[\"且此版本在运行时不可变\",{\"1\":{\"194\":1}}],[\"且运行期保持不变时\",{\"1\":{\"194\":1}}],[\"且可以承受数分钟的数据丢失\",{\"1\":{\"653\":1}}],[\"且可以从其他地方重新生成补回的\",{\"1\":{\"653\":1}}],[\"且可以更方便的存取整个对象\",{\"1\":{\"622\":1}}],[\"且可以查看锁是否获取成功\",{\"1\":{\"94\":1}}],[\"且可近似认为任务线程数可以无限多\",{\"1\":{\"56\":1}}],[\"且前一个操作按顺序排在第二个操作之前\",{\"1\":{\"75\":1}}],[\"且有限多\",{\"1\":{\"56\":1}}],[\"且提高了\",{\"1\":{\"30\":1}}],[\"会很乱\",{\"1\":{\"1163\":1}}],[\"会确保在\",{\"1\":{\"1157\":1}}],[\"会不会产生单例呢\",{\"1\":{\"1075\":1}}],[\"会返回响应\",{\"1\":{\"1060\":1}}],[\"会回答\",{\"1\":{\"1049\":1}}],[\"会回应一个\",{\"1\":{\"1022\":1}}],[\"会缓存\",{\"1\":{\"1040\":1}}],[\"会缓存注册机列表在缓存里\",{\"1\":{\"803\":1}}],[\"会和\",{\"1\":{\"1039\":1}}],[\"会引起三次握手\",{\"1\":{\"1003\":1}}],[\"会引起上下文切换\",{\"1\":{\"144\":1}}],[\"会增大重传数据包的机率\",{\"1\":{\"982\":1}}],[\"会认为它负责将数据从⼀个设备传输到另⼀个设备\",{\"1\":{\"961\":1}}],[\"会进行如下操作\",{\"1\":{\"882\":2}}],[\"会进行数据库拆分处理\",{\"1\":{\"583\":1}}],[\"会有1个rtt的花销\",{\"1\":{\"1042\":1}}],[\"会有大量的请求集中在一个节点上\",{\"1\":{\"880\":1}}],[\"会有多种锁状态\",{\"1\":{\"131\":1}}],[\"会生成一个\",{\"1\":{\"878\":1}}],[\"会发往同1个partition\",{\"1\":{\"865\":1}}],[\"会发起\",{\"1\":{\"675\":1}}],[\"会尽力将这些\",{\"1\":{\"861\":1}}],[\"会持久化一条\",{\"1\":{\"856\":1}}],[\"会造成数据重复\",{\"1\":{\"854\":1}}],[\"会造成大量的\",{\"1\":{\"679\":1}}],[\"会造成大量对象无法回收\",{\"1\":{\"304\":1}}],[\"会从isr中选出一个新的leader\",{\"1\":{\"855\":1}}],[\"会从isr中选举出新的leader\",{\"1\":{\"853\":1}}],[\"会从无锁\",{\"1\":{\"131\":1}}],[\"会触发mq推送机制\",{\"1\":{\"843\":1}}],[\"会监听一定数量的客户端连接\",{\"1\":{\"829\":1}}],[\"会收到\",{\"1\":{\"817\":1}}],[\"会选举出集群中的其他机器作为\",{\"1\":{\"803\":1}}],[\"会选择一个唯一的非空索引代替\",{\"1\":{\"546\":1}}],[\"会创建\",{\"1\":{\"759\":1}}],[\"会清空\",{\"1\":{\"752\":1}}],[\"会清理掉\",{\"1\":{\"300\":1}}],[\"会通过该方法将\",{\"1\":{\"736\":1}}],[\"会通过该抽象类的setapplicationcontext\",{\"1\":{\"736\":1}}],[\"会通知处理程序去读写\",{\"1\":{\"381\":1}}],[\"会通知生产者当前队列可用\",{\"1\":{\"62\":1}}],[\"会继续监听管理\",{\"1\":{\"734\":1}}],[\"会按照下面两种情况进行切换\",{\"1\":{\"725\":1}}],[\"会按顺序写入到binlog中\",{\"1\":{\"469\":1,\"580\":1}}],[\"会占用更少的内存\",{\"1\":{\"712\":1}}],[\"会为父进程要修改的页面创建副本\",{\"1\":{\"647\":1}}],[\"会浪费存储空间\",{\"1\":{\"645\":1}}],[\"会浪费一定的时间去移动和请求\",{\"1\":{\"604\":1}}],[\"会扫描一定数量的数据库的\",{\"1\":{\"632\":1}}],[\"会分配额外的空间\",{\"1\":{\"624\":1}}],[\"会做哈希表收缩\",{\"1\":{\"623\":1}}],[\"会采用\",{\"1\":{\"617\":1,\"619\":1}}],[\"会话层\",{\"1\":{\"961\":1}}],[\"会话会丢失\",{\"1\":{\"869\":1}}],[\"会话缓存\",{\"1\":{\"603\":1}}],[\"会话结束便销毁\",{\"1\":{\"39\":1,\"44\":1}}],[\"会记录所有的逻辑操作\",{\"1\":{\"576\":1}}],[\"会记录所有引擎对数据库的修改\",{\"1\":{\"573\":1}}],[\"会立刻触发merge过程\",{\"1\":{\"574\":1}}],[\"会丢失最近\",{\"1\":{\"571\":1}}],[\"会直接读到\",{\"1\":{\"559\":1}}],[\"会直接影响到gc\",{\"1\":{\"192\":1}}],[\"会执行很快\",{\"1\":{\"559\":1}}],[\"会执行多少时间\",{\"1\":{\"558\":1}}],[\"会执行类的初始化\",{\"1\":{\"183\":1}}],[\"会忽略\",{\"1\":{\"553\":1}}],[\"会降低\",{\"1\":{\"528\":1}}],[\"会降低并发性和性能\",{\"1\":{\"202\":1}}],[\"会检查该表上是否存在意向锁\",{\"1\":{\"514\":1}}],[\"会出现死锁\",{\"0\":{\"509\":1}}],[\"会锁定当前非唯一索引对应的主键索引的值\",{\"1\":{\"506\":1}}],[\"会首先对索引记录加上行锁\",{\"1\":{\"505\":1}}],[\"会优先选择全字段排序\",{\"1\":{\"484\":1}}],[\"会影响排序效率\",{\"1\":{\"484\":1}}],[\"会影响性能\",{\"1\":{\"72\":1,\"757\":1}}],[\"会消耗更多的内存\",{\"1\":{\"478\":1}}],[\"会自动发送\",{\"1\":{\"992\":1}}],[\"会自动调用该方法\",{\"1\":{\"733\":2}}],[\"会自动将\",{\"1\":{\"657\":1}}],[\"会自动添加一个与主键对应的唯一索引\",{\"1\":{\"464\":1}}],[\"会自旋\",{\"1\":{\"118\":1}}],[\"会给客户主机回复一个ack报文\",{\"1\":{\"1049\":1}}],[\"会给自己投票\",{\"1\":{\"820\":4}}],[\"会给缓存带来很大的压力\",{\"1\":{\"606\":1}}],[\"会给你创建一个不可见的\",{\"1\":{\"468\":1}}],[\"会给线程的所负责的区间加锁\",{\"1\":{\"410\":1}}],[\"会给每个线程分配对应的区间\",{\"1\":{\"410\":1}}],[\"会调用\",{\"1\":{\"402\":1}}],[\"会退化为链表\",{\"1\":{\"401\":1}}],[\"会根据模型配置自动生成和执行\",{\"1\":{\"749\":1}}],[\"会根据\",{\"1\":{\"396\":1,\"659\":1,\"755\":1}}],[\"会根据之前保存的执行现场\",{\"1\":{\"139\":1}}],[\"会初始化一个数组\",{\"1\":{\"396\":1}}],[\"会请求总线的使用权\",{\"1\":{\"379\":1}}],[\"会copy一份保存在对方的空间中\",{\"1\":{\"378\":1}}],[\"会一直等到数据到来或者缓冲区已满时才返回\",{\"1\":{\"377\":1}}],[\"会一直监听一个\",{\"1\":{\"377\":1}}],[\"会将请求信息封装成\",{\"1\":{\"1090\":1}}],[\"会将所有传输的信息分割为更小的消息和帧\",{\"1\":{\"1042\":1}}],[\"会将这个\",{\"1\":{\"878\":1}}],[\"会将这个值设置为当前时间\",{\"1\":{\"475\":1}}],[\"会将票投给服务器\",{\"1\":{\"820\":1}}],[\"会将自己执行的写命令\",{\"1\":{\"662\":1}}],[\"会将每个设置了过期时间的\",{\"1\":{\"632\":1}}],[\"会将该语句过一遍查询优化器\",{\"1\":{\"556\":1}}],[\"会将其插入到双向链表的尾部\",{\"1\":{\"412\":1}}],[\"会将其中的一部分符号引用转化为直接引用\",{\"1\":{\"274\":1}}],[\"会将\",{\"1\":{\"368\":1}}],[\"会编译成\",{\"1\":{\"368\":1}}],[\"会因为私有化无法访问\",{\"1\":{\"355\":1}}],[\"会关联到哪一个\",{\"1\":{\"349\":1}}],[\"会被抓包\",{\"1\":{\"1046\":1}}],[\"会被抓包吗\",{\"0\":{\"1046\":1}}],[\"会被标记为客观下线\",{\"1\":{\"677\":1}}],[\"会被自动删除\",{\"1\":{\"669\":1}}],[\"会被后面的事务修改的值覆盖\",{\"1\":{\"521\":1}}],[\"会被清理掉\",{\"1\":{\"300\":1}}],[\"会被回收\",{\"1\":{\"46\":1}}],[\"会使得发送端重传\",{\"1\":{\"1021\":1}}],[\"会使用基于可靠连接的\",{\"1\":{\"1033\":1}}],[\"会使用多个\",{\"1\":{\"645\":1}}],[\"会使用\",{\"1\":{\"299\":1}}],[\"会使对象的锁变成重量级锁\",{\"1\":{\"88\":1}}],[\"会声言处理器的\",{\"1\":{\"296\":1}}],[\"会在内核中缓存\",{\"1\":{\"649\":1}}],[\"会在内部自动将\",{\"1\":{\"622\":1}}],[\"会在内部生成一个名为\",{\"1\":{\"546\":1}}],[\"会在\",{\"1\":{\"537\":1}}],[\"会在判断后放锁\",{\"1\":{\"501\":1}}],[\"会在运行时再确定一个实现该接口的对象\",{\"1\":{\"274\":1}}],[\"会在java堆内存中实例化一个java\",{\"1\":{\"168\":1}}],[\"会尝试成为\",{\"1\":{\"876\":1}}],[\"会尝试触发minor\",{\"1\":{\"243\":1}}],[\"会尝试获取对象的锁\",{\"1\":{\"82\":1}}],[\"会产生多个单例\",{\"1\":{\"1075\":1}}],[\"会产生依赖冲突\",{\"1\":{\"798\":1}}],[\"会产生缓存的雪崩\",{\"1\":{\"681\":1}}],[\"会产生一个appendonly\",{\"1\":{\"649\":1}}],[\"会产生一个同名的\",{\"1\":{\"348\":1}}],[\"会产生外部碎片\",{\"1\":{\"155\":1}}],[\"会产生饥饿\",{\"1\":{\"100\":1}}],[\"会导致事务过长影响性能\",{\"1\":{\"1230\":1}}],[\"会导致很push失败\",{\"1\":{\"843\":1}}],[\"会导致业务系统不可用\",{\"1\":{\"668\":1}}],[\"会导致字典中的数据分散在两个\",{\"1\":{\"623\":1}}],[\"会导致i\",{\"1\":{\"579\":1}}],[\"会导致大量总线用于处理\",{\"1\":{\"379\":1}}],[\"会导致低优先级进程饥饿\",{\"1\":{\"150\":1}}],[\"会导致长进程饥饿\",{\"1\":{\"150\":1}}],[\"会导致写锁永久等待\",{\"1\":{\"125\":1}}],[\"会存储在系统内核中\",{\"1\":{\"144\":1}}],[\"会保存执行现场\",{\"1\":{\"139\":1}}],[\"会阻塞\",{\"1\":{\"647\":1}}],[\"会阻塞在\",{\"1\":{\"137\":1}}],[\"会阻塞插入元素的线程\",{\"1\":{\"62\":1}}],[\"会向所有的\",{\"1\":{\"877\":1}}],[\"会向处理器发送一条\",{\"1\":{\"296\":1}}],[\"会向\",{\"1\":{\"134\":1,\"379\":1}}],[\"会抛出异常\",{\"1\":{\"125\":1}}],[\"会让线程在没有获取锁时\",{\"1\":{\"105\":1}}],[\"会这样觉得\",{\"1\":{\"88\":1}}],[\"会带来额外的锁撤销的消耗\",{\"1\":{\"86\":1}}],[\"会把事务执行过程中对表的修改操作都记录下来\",{\"1\":{\"568\":1}}],[\"会把所有的记录返回\",{\"1\":{\"480\":1}}],[\"会把结果集中重复的记录删掉\",{\"1\":{\"480\":1}}],[\"会把这些对象列进回收范围之中进行第二次回收\",{\"1\":{\"235\":1}}],[\"会把这个对象所对应的类所有的对象都撤销偏向锁\",{\"1\":{\"88\":1}}],[\"会把该指令之前的存在于\",{\"1\":{\"72\":1}}],[\"会把数据库打挂等问题\",{\"1\":{\"64\":1}}],[\"会先获取该数据行所在数据表的对应意向锁\",{\"1\":{\"514\":1}}],[\"会先校验这个\",{\"1\":{\"490\":1}}],[\"会先查询缓存\",{\"1\":{\"490\":1}}],[\"会先在当前线程的栈桢中创建用于存储锁记录的空间\",{\"1\":{\"87\":1}}],[\"会先识别数据的对象状态\",{\"1\":{\"72\":1}}],[\"会先清空工作内存中变量值\",{\"1\":{\"69\":1}}],[\"会对该\",{\"1\":{\"878\":1}}],[\"会对读取的记录进行加锁\",{\"1\":{\"499\":1}}],[\"会对键进行排序\",{\"1\":{\"408\":1}}],[\"会对\",{\"1\":{\"46\":1,\"623\":1}}],[\"都透过这个聚合根访问聚合内部\",{\"1\":{\"1245\":1}}],[\"都透过这个聚合根处理\",{\"1\":{\"1245\":1}}],[\"都已经更新到了最新的状态\",{\"1\":{\"1157\":1}}],[\"都一律先把数据报传送给这个默认路由器\",{\"1\":{\"993\":1}}],[\"都指向头结点\",{\"1\":{\"927\":1}}],[\"都在对应的小文件\",{\"1\":{\"896\":1}}],[\"都在内存中\",{\"1\":{\"592\":1}}],[\"都映射到一个首尾相连的哈希环上\",{\"1\":{\"880\":1}}],[\"都能获得相同的结果\",{\"1\":{\"870\":1,\"873\":1}}],[\"都能加快客户端的访问速度\",{\"1\":{\"826\":1}}],[\"都支持\",{\"1\":{\"746\":1}}],[\"都支持封装\",{\"1\":{\"336\":1}}],[\"都可能拿到锁\",{\"1\":{\"672\":1}}],[\"都可以使用同一个页面缓存\",{\"1\":{\"850\":1}}],[\"都可以给一个\",{\"1\":{\"632\":1}}],[\"都可以指定列宽\",{\"1\":{\"473\":1}}],[\"都可以用来查看文件大小\",{\"1\":{\"442\":1}}],[\"都可以在解析阶段中确定唯一的调用版本\",{\"1\":{\"275\":1}}],[\"都可以优先考虑parallel\",{\"1\":{\"258\":1}}],[\"都宕机了\",{\"1\":{\"659\":1}}],[\"都开启\",{\"1\":{\"653\":1}}],[\"都检查一下\",{\"1\":{\"623\":1}}],[\"都将以每行记录的修改来记录\",{\"1\":{\"572\":1}}],[\"都暂时不需要写入磁盘\",{\"1\":{\"568\":1}}],[\"都用了\",{\"1\":{\"410\":1}}],[\"都需要创建一个新的字符串对象的话\",{\"1\":{\"1091\":1}}],[\"都需要创建一个定时器\",{\"1\":{\"632\":1}}],[\"都需要向producer发送ack\",{\"1\":{\"854\":1}}],[\"都需要经过\",{\"1\":{\"378\":1}}],[\"都需要先根据\",{\"1\":{\"342\":1}}],[\"都有\",{\"1\":{\"919\":1}}],[\"都有一个表明自己在\",{\"1\":{\"875\":1}}],[\"都有这么两个东西\",{\"1\":{\"659\":1}}],[\"都有过期策略\",{\"1\":{\"610\":1}}],[\"都有哪些基本数据类型\",{\"0\":{\"366\":1}}],[\"都有下面的代码\",{\"1\":{\"96\":1}}],[\"都相同的情况下\",{\"1\":{\"359\":1,\"820\":1}}],[\"都重写好配合\",{\"1\":{\"342\":1}}],[\"都打印堆信息\",{\"1\":{\"325\":1}}],[\"都称为静态分派\",{\"1\":{\"277\":1}}],[\"都希望在尽可能对吞吐量影响不太大的前提下\",{\"1\":{\"268\":1}}],[\"都初始化为零值\",{\"1\":{\"221\":1}}],[\"都拥有一组监视器方法\",{\"1\":{\"126\":1}}],[\"都要进入到阻塞队列等待唤醒\",{\"1\":{\"114\":1}}],[\"都不发送icmp差错报告报文\",{\"1\":{\"993\":1}}],[\"都不会影响当前事务的快照读结果\",{\"1\":{\"523\":1}}],[\"都不会引起数据竞争和线程安全问题\",{\"1\":{\"192\":1}}],[\"都不允许出现\",{\"1\":{\"407\":1}}],[\"都不阻塞\",{\"1\":{\"137\":1}}],[\"都不成功\",{\"1\":{\"114\":1}}],[\"都不放弃自己拥有的资源\",{\"1\":{\"98\":1}}],[\"都是按递增次序排序存放的\",{\"1\":{\"919\":1}}],[\"都是一个独立的进程\",{\"1\":{\"835\":1}}],[\"都是一次只允许一个线程访问某个资源\",{\"1\":{\"117\":1}}],[\"都是为了解耦和\",{\"1\":{\"754\":1}}],[\"都是返回对象信息\",{\"1\":{\"751\":1}}],[\"都是数据库操作对象\",{\"1\":{\"745\":1}}],[\"都是无状态的\",{\"1\":{\"735\":1}}],[\"都是先生成代理对象\",{\"1\":{\"727\":1}}],[\"都是通过在invocationhandler中的invoke方法调用的\",{\"1\":{\"724\":1}}],[\"都是以处理二进制方式来处理\",{\"1\":{\"624\":1}}],[\"都是以页为单位存放数据的\",{\"1\":{\"591\":1}}],[\"都是基于内存的缓存\",{\"1\":{\"610\":1}}],[\"都是文件名\",{\"1\":{\"427\":2}}],[\"都是\",{\"1\":{\"381\":1}}],[\"都是面向对象语言\",{\"1\":{\"336\":1}}],[\"都是常见的互斥实现方式\",{\"1\":{\"142\":1}}],[\"都是可重入锁\",{\"1\":{\"81\":1}}],[\"都是悲观锁\",{\"1\":{\"81\":1}}],[\"都同步到主存中\",{\"1\":{\"78\":1}}],[\"都仅靠\",{\"1\":{\"75\":1}}],[\"都必须使用不一样的名称\",{\"1\":{\"289\":1}}],[\"都必须返回到最初方法被调用时的位置\",{\"1\":{\"195\":1}}],[\"都必须通过系统调用方式向操作系统提出服务请求\",{\"1\":{\"135\":1}}],[\"都必须在工作内存中进行\",{\"1\":{\"66\":1,\"294\":1,\"337\":1}}],[\"都必须要标识它们操作线程的锁\",{\"1\":{\"36\":1}}],[\"都会带上最后一个\",{\"1\":{\"878\":1}}],[\"都会随机化一个新的electiontimeout\",{\"1\":{\"877\":1}}],[\"都会到\",{\"1\":{\"861\":1}}],[\"都会实时记录自己消费到了哪个offset\",{\"1\":{\"846\":1}}],[\"都会对该值进行加\",{\"1\":{\"820\":1}}],[\"都会对应一个编号在\",{\"1\":{\"659\":1}}],[\"都会给你映射出来\",{\"1\":{\"751\":1}}],[\"都会调用\",{\"1\":{\"722\":1}}],[\"都会调用一个函数来进行\",{\"1\":{\"414\":1}}],[\"都会收到此消息\",{\"1\":{\"673\":1}}],[\"都会访问到数据库中\",{\"1\":{\"640\":1}}],[\"都会执行一次渐进式\",{\"1\":{\"623\":1}}],[\"都会记录在日志文件中\",{\"1\":{\"566\":1}}],[\"都会被加上x锁\",{\"1\":{\"501\":1}}],[\"都会被放在\",{\"1\":{\"136\":1}}],[\"都会维护一个索引表\",{\"1\":{\"464\":1}}],[\"都会要求确认\",{\"1\":{\"447\":1}}],[\"都会返回它的事件\",{\"1\":{\"381\":1}}],[\"都会阻塞掉\",{\"1\":{\"377\":1}}],[\"都会按照刚刚开始扫描那一刻的对象图快照来进行搜索\",{\"1\":{\"251\":1}}],[\"都会面临相同的问题\",{\"1\":{\"249\":1}}],[\"都会回收它的内存\",{\"1\":{\"235\":1}}],[\"都会回收它的的内存\",{\"1\":{\"45\":1}}],[\"都会找一个第三者出来进行解耦\",{\"1\":{\"50\":1}}],[\"操作有着本质区别\",{\"1\":{\"1003\":1}}],[\"操作与\",{\"1\":{\"1003\":1}}],[\"操作建立连接\",{\"1\":{\"1003\":1}}],[\"操作次数非常多\",{\"1\":{\"916\":1}}],[\"操作次数更少\",{\"1\":{\"541\":1}}],[\"操作过程中父进程\",{\"1\":{\"647\":1}}],[\"操作创建子进程\",{\"1\":{\"647\":2,\"648\":1}}],[\"操作给服务器带来过大的负担\",{\"1\":{\"623\":1}}],[\"操作不是一次性完成\",{\"1\":{\"623\":1}}],[\"操作缓存就是直接操作内存\",{\"1\":{\"606\":1}}],[\"操作表的顺序\",{\"1\":{\"556\":1}}],[\"操作即可查找到数据\",{\"1\":{\"539\":1}}],[\"操作就是快照读\",{\"1\":{\"499\":1}}],[\"操作就会误认为它从来没有被改变过\",{\"1\":{\"106\":1}}],[\"操作同段\",{\"1\":{\"410\":1}}],[\"操作和\",{\"1\":{\"409\":1}}],[\"操作已经完成的时候会得到\",{\"1\":{\"380\":1}}],[\"操作以后就立即返回\",{\"1\":{\"380\":1}}],[\"操作的时候\",{\"1\":{\"511\":1}}],[\"操作的话\",{\"1\":{\"405\":1}}],[\"操作的结果就是散列值的高位全部归零\",{\"1\":{\"405\":1}}],[\"操作的发起者\",{\"1\":{\"380\":1}}],[\"操作的独立处理器\",{\"1\":{\"379\":1}}],[\"操作是否就绪\",{\"1\":{\"380\":1}}],[\"操作并等待或者轮询的去查看\",{\"1\":{\"380\":1}}],[\"操作再将结果返回给你\",{\"1\":{\"380\":1}}],[\"操作其实分成了两个步骤\",{\"1\":{\"380\":1}}],[\"操作时用一个线程去处理就可以了\",{\"1\":{\"380\":1}}],[\"操作时\",{\"1\":{\"379\":1}}],[\"操作之前\",{\"1\":{\"295\":1}}],[\"操作具有原子性\",{\"1\":{\"295\":1}}],[\"操作数栈中元素的数据类型必须与字节码指令的序列严格匹配\",{\"1\":{\"193\":1}}],[\"操作数栈的每一个元素都可以是包括long和double在内的任意java数据类型\",{\"1\":{\"193\":1}}],[\"操作数栈的深度都不会超过在max\",{\"1\":{\"193\":1}}],[\"操作数栈的最大深度也在编译的时候被写入到code属性的max\",{\"1\":{\"193\":1}}],[\"操作数栈\",{\"0\":{\"193\":1},\"1\":{\"190\":1,\"191\":1}}],[\"操作数据过程中不加锁\",{\"1\":{\"81\":1}}],[\"操作完成\",{\"1\":{\"148\":1}}],[\"操作最大的不同之处就在于它虽然也是要从磁盘读取数据\",{\"1\":{\"138\":1}}],[\"操作系统将数据从磁盘文件中读取到内核空间的页面缓存\",{\"1\":{\"850\":1}}],[\"操作系统控制的写回\",{\"1\":{\"650\":1}}],[\"操作系统会自动将物理内存映射文件中的数据写入物理内存中\",{\"1\":{\"378\":1}}],[\"操作系统或虚拟机实现的不同而发生变化\",{\"1\":{\"192\":1}}],[\"操作系统负责将需要的动态库加载到内存中\",{\"1\":{\"161\":1}}],[\"操作系统引入了虚拟内存\",{\"1\":{\"153\":1}}],[\"操作系统采取的便是这种调度算法\",{\"1\":{\"150\":1}}],[\"操作系统重启\",{\"1\":{\"149\":1}}],[\"操作系统要记录\",{\"1\":{\"136\":1}}],[\"操作系统来选择具体运行哪个处理函数\",{\"1\":{\"135\":1}}],[\"操作系统\",{\"1\":{\"134\":1,\"1106\":1}}],[\"操作系统在内核态运行\",{\"1\":{\"134\":1}}],[\"操作系统的特征\",{\"0\":{\"132\":1}}],[\"操作用于统计元素的数量\",{\"1\":{\"129\":1}}],[\"操作里只需要读所以不用加锁\",{\"1\":{\"129\":1}}],[\"操作来保证并发的安全性\",{\"1\":{\"128\":1}}],[\"操作去抢锁\",{\"1\":{\"113\":1}}],[\"操作又称为\",{\"1\":{\"105\":1}}],[\"操作无法成功\",{\"1\":{\"89\":1}}],[\"操作\",{\"1\":{\"45\":1,\"72\":2,\"74\":1,\"75\":1,\"88\":1,\"102\":1,\"377\":2,\"379\":1,\"380\":2,\"501\":1,\"523\":1,\"535\":1,\"538\":1,\"574\":1,\"645\":1,\"647\":1,\"657\":1,\"668\":1,\"746\":1,\"807\":1,\"820\":1,\"1016\":1,\"1040\":1}}],[\"后门入侵\",{\"1\":{\"1054\":1}}],[\"后来收到了确认\",{\"1\":{\"1023\":1}}],[\"后两位的11是为了告诉适配器\",{\"1\":{\"980\":1}}],[\"后序遍历\",{\"0\":{\"908\":1},\"1\":{\"908\":1}}],[\"后序遍历的区别是第几次到达这个节点的时候打印\",{\"1\":{\"907\":1}}],[\"后的一个\",{\"1\":{\"973\":1}}],[\"后的值将它们映射到不同的机子上处理\",{\"1\":{\"891\":1}}],[\"后的值\",{\"1\":{\"891\":1}}],[\"后的接口顺序从左到右排列在接口索引集合中\",{\"1\":{\"288\":1}}],[\"后处理数据的时候出现异常\",{\"1\":{\"866\":1}}],[\"后交给\",{\"1\":{\"804\":1}}],[\"后置通知\",{\"1\":{\"722\":1}}],[\"后会发送一个\",{\"1\":{\"662\":1}}],[\"后还会引入数据不一致的问题\",{\"1\":{\"656\":1}}],[\"后还可以\",{\"0\":{\"371\":1}}],[\"后退指针\",{\"1\":{\"630\":1}}],[\"后期分片集群扩容时\",{\"1\":{\"587\":1}}],[\"后期如果想对整个分片集群扩容时\",{\"1\":{\"587\":1}}],[\"后台线程会主动写盘\",{\"1\":{\"568\":1}}],[\"后台进行处理插入\",{\"1\":{\"565\":1}}],[\"后者是\",{\"1\":{\"1048\":1}}],[\"后者返回null\",{\"1\":{\"736\":1}}],[\"后者主要是内存中\",{\"1\":{\"575\":1}}],[\"后者的所有变化都将被前者抵消\",{\"1\":{\"453\":1}}],[\"后者在外部不可被访问\",{\"1\":{\"274\":1}}],[\"后续新建目录时为目录下的\",{\"1\":{\"1206\":1}}],[\"后续再次获取还是修改之前的数据\",{\"1\":{\"608\":1}}],[\"后续进行机器备份的时候\",{\"1\":{\"578\":1}}],[\"后续只要这个连接不断开\",{\"1\":{\"490\":1}}],[\"后续操作步骤如同\",{\"1\":{\"410\":1}}],[\"后续的算法都是对其不足进行改进得到\",{\"1\":{\"244\":1}}],[\"后续的任何操作\",{\"1\":{\"75\":1,\"102\":1}}],[\"后对\",{\"1\":{\"409\":1}}],[\"后面有4n字节是根据需要而增加的选项\",{\"1\":{\"1007\":1}}],[\"后面连续到达的比特流都属于同一个mac帧\",{\"1\":{\"980\":1}}],[\"后面每次调用在这个整数上自增\",{\"1\":{\"852\":1}}],[\"后面四个字节才是前一个节点的真实长度数据\",{\"1\":{\"627\":1}}],[\"后面出现\",{\"1\":{\"556\":1}}],[\"后面接口的索引表不再占用任何字节\",{\"1\":{\"288\":1}}],[\"后面的数字\",{\"1\":{\"991\":1}}],[\"后面的代码会执行\",{\"1\":{\"383\":2}}],[\"后面的\",{\"1\":{\"277\":1}}],[\"后面的指令查不到前面指令的执行结果\",{\"1\":{\"72\":1}}],[\"后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点\",{\"1\":{\"122\":1}}],[\"后执行2\",{\"1\":{\"714\":1}}],[\"后执行\",{\"1\":{\"101\":1}}],[\"后\",{\"1\":{\"45\":2,\"114\":1,\"468\":1,\"555\":1,\"559\":1,\"578\":2,\"655\":1,\"755\":1,\"801\":1}}],[\">会在挂载时注入对应名称的\",{\"1\":{\"1155\":1}}],[\">right\",{\"1\":{\"956\":1}}],[\">left\",{\"1\":{\"956\":1}}],[\">nums\",{\"1\":{\"936\":3}}],[\">>\",{\"0\":{\"944\":1},\"1\":{\"934\":1,\"943\":1,\"1199\":2,\"1200\":2,\"1212\":1}}],[\">>>=\",{\"1\":{\"949\":1}}],[\">>>\",{\"1\":{\"405\":1}}],[\">操作系统将数据从socket缓冲区复制到网卡接口\",{\"1\":{\"850\":1}}],[\">应用程序将读到的数据写回内核空间并放入到socket缓冲区\",{\"1\":{\"850\":1}}],[\">应用程序将数据从内核空间读入到用户空间缓冲区\",{\"1\":{\"850\":1}}],[\">c\",{\"1\":{\"798\":1}}],[\">currentthread\",{\"1\":{\"45\":1}}],[\">x\",{\"1\":{\"798\":2}}],[\">b\",{\"1\":{\"798\":1}}],[\">bean的销毁\",{\"1\":{\"733\":1}}],[\">bean的使用\",{\"1\":{\"733\":1}}],[\">bean的初始化\",{\"1\":{\"733\":1}}],[\">a\",{\"1\":{\"798\":1}}],[\">handleradapter\",{\"1\":{\"755\":1}}],[\"><\",{\"1\":{\"736\":1}}],[\">存储引擎\",{\"1\":{\"489\":1}}],[\">可以接受任何\",{\"1\":{\"345\":1}}],[\">则会被转译成普通的\",{\"1\":{\"345\":1}}],[\">0\",{\"1\":{\"261\":1}}],[\">jdk8\",{\"1\":{\"203\":1}}],[\">jdk7\",{\"1\":{\"203\":1}}],[\">轻量级锁\",{\"1\":{\"131\":1}}],[\">\",{\"1\":{\"58\":1,\"96\":1,\"118\":1,\"131\":3,\"134\":2,\"148\":4,\"153\":1,\"345\":4,\"349\":1,\"394\":3,\"398\":1,\"481\":2,\"489\":11,\"517\":2,\"533\":1,\"556\":1,\"584\":4,\"642\":1,\"713\":1,\"734\":1,\"755\":6,\"804\":1,\"820\":1,\"867\":2,\"911\":1,\"912\":1,\"913\":1,\"930\":1,\"931\":1,\"932\":1,\"933\":2,\"935\":3,\"937\":4,\"947\":2,\"982\":1,\"983\":2,\"1006\":1,\"1123\":1,\"1134\":1,\"1177\":1,\"1260\":2}}],[\">=1\",{\"1\":{\"1140\":1}}],[\">=povit\",{\"1\":{\"936\":1}}],[\">=array\",{\"1\":{\"935\":1}}],[\">=target\",{\"1\":{\"912\":1}}],[\">=\",{\"1\":{\"57\":1,\"368\":1,\"486\":2,\"912\":1,\"932\":1,\"933\":2,\"935\":2}}],[\">enrty\",{\"1\":{\"45\":1}}],[\">threadlocalmap\",{\"1\":{\"45\":1}}],[\">主页<\",{\"1\":{\"26\":1}}],[\"内排序与外排序相结合\",{\"1\":{\"895\":1}}],[\"内置了\",{\"1\":{\"780\":1,\"1134\":1}}],[\"内置在eclipse中\",{\"1\":{\"282\":1}}],[\"内有效\",{\"1\":{\"734\":2}}],[\"内层判断防止多次实例化对象\",{\"1\":{\"714\":1}}],[\"内层判断为了防止多次实例化对象\",{\"1\":{\"101\":1,\"1068\":1}}],[\"内连接\",{\"1\":{\"485\":1}}],[\"内容\",{\"1\":{\"1161\":1}}],[\"内容被盗窃\",{\"1\":{\"1061\":1}}],[\"内容包括\",{\"1\":{\"1049\":1}}],[\"内容可能包括空字符串\",{\"1\":{\"624\":1}}],[\"内容后\",{\"1\":{\"469\":1,\"580\":1}}],[\"内容是jvm的指令\",{\"1\":{\"280\":1}}],[\"内核里维护了一个链表来记录就绪事件\",{\"1\":{\"612\":1}}],[\"内核会一直监听这些套接字上的连接请求和数据请求\",{\"1\":{\"604\":1}}],[\"内核就会采用类似\",{\"1\":{\"381\":1}}],[\"内核线程将数据从内核态拷贝到用户态\",{\"1\":{\"380\":1}}],[\"内核态\",{\"1\":{\"134\":3}}],[\"内核态和用户态是操作系统运行的两种级别\",{\"1\":{\"134\":1}}],[\"内核态和用户态\",{\"0\":{\"134\":1}}],[\"内核\",{\"1\":{\"133\":1}}],[\"内部也不影响注入\",{\"1\":{\"1155\":1}}],[\"内部封装了jdbc\",{\"1\":{\"746\":1}}],[\"内部所有涉及\",{\"1\":{\"647\":1}}],[\"内部针对不同类型存在编码的概念\",{\"1\":{\"637\":1}}],[\"内部使用文件事件处理器file\",{\"1\":{\"611\":1}}],[\"内部使用双向链表将等待线程链接起来\",{\"1\":{\"109\":1}}],[\"内部做了很多优化\",{\"1\":{\"491\":1}}],[\"内部是靠\",{\"1\":{\"414\":1}}],[\"内部是通过=红黑树来实现\",{\"1\":{\"412\":1}}],[\"内部除了继承\",{\"1\":{\"412\":1}}],[\"内部维护了一个双向链表\",{\"1\":{\"412\":1}}],[\"内部维护这\",{\"1\":{\"109\":1}}],[\"内部节点是有序的吗\",{\"1\":{\"412\":1}}],[\"内部定义了一个对象锁\",{\"1\":{\"409\":1}}],[\"内部数组初始化大小为\",{\"1\":{\"407\":2}}],[\"内部数组初始化大小不同\",{\"1\":{\"407\":1}}],[\"内部grow\",{\"1\":{\"392\":1}}],[\"内部类\",{\"1\":{\"410\":1}}],[\"内部类不依赖于外部类\",{\"1\":{\"361\":1}}],[\"内部类可以单独创建\",{\"1\":{\"361\":1}}],[\"内部类持有外部类\",{\"1\":{\"304\":1}}],[\"内部暴露\",{\"1\":{\"348\":1}}],[\"内部碎片\",{\"1\":{\"154\":1}}],[\"内部碎片和外部碎片最明显的区别就是内部碎片能够明确指出这部分内存属于哪个进程\",{\"1\":{\"154\":1}}],[\"内部通过链表\",{\"1\":{\"108\":1}}],[\"内部的\",{\"1\":{\"39\":1,\"41\":1}}],[\"内存优化\",{\"1\":{\"1177\":1}}],[\"内存开销会很大\",{\"1\":{\"1091\":1}}],[\"内存资源的占用也远小于\",{\"1\":{\"1001\":1}}],[\"内存不足以容纳这2\",{\"0\":{\"900\":1}}],[\"内存不足错误\",{\"1\":{\"384\":1}}],[\"内存限制是4g\",{\"0\":{\"896\":1}}],[\"内存限制大小是1m\",{\"0\":{\"894\":1},\"1\":{\"889\":1}}],[\"内存可以当输入缓冲区使用\",{\"1\":{\"889\":1}}],[\"内存可以打开\",{\"1\":{\"381\":1}}],[\"内存的可用性较低\",{\"1\":{\"658\":1}}],[\"内存淘汰策略用于处理内存不足时的需要申请额外空间的数据\",{\"1\":{\"636\":1}}],[\"内存淘汰机制\",{\"0\":{\"633\":1}}],[\"内存数据集大小上升到一定大小后\",{\"1\":{\"635\":1}}],[\"内存数据写入到磁盘后\",{\"1\":{\"592\":1}}],[\"内存相关\",{\"0\":{\"634\":1}}],[\"内存命中率更高\",{\"1\":{\"585\":1}}],[\"内存能加载更多的数据\",{\"1\":{\"585\":1}}],[\"内存也会受非常大的影响\",{\"1\":{\"585\":1}}],[\"内存以及\",{\"1\":{\"558\":1}}],[\"内存和磁盘上的内容就一致了\",{\"1\":{\"592\":1}}],[\"内存和\",{\"1\":{\"535\":1}}],[\"内存就会占用\",{\"1\":{\"411\":1}}],[\"内存里会同时驻扎两个对\",{\"1\":{\"411\":1}}],[\"内存是放不下的\",{\"1\":{\"405\":1}}],[\"内存使用最直接的方式就是缩减键\",{\"1\":{\"637\":1}}],[\"内存使用量\",{\"1\":{\"558\":1}}],[\"内存使用情况\",{\"1\":{\"312\":1}}],[\"内存使用率\",{\"1\":{\"64\":1}}],[\"内存占用较低\",{\"1\":{\"627\":1}}],[\"内存占用问题\",{\"1\":{\"411\":1}}],[\"内存占用\",{\"1\":{\"310\":1}}],[\"内存分配与垃圾回收参数列表\",{\"0\":{\"270\":1}}],[\"内存分配完成之后\",{\"1\":{\"221\":1}}],[\"内存分配策略\",{\"0\":{\"220\":1}}],[\"内存分配的并发问题\",{\"0\":{\"219\":1}}],[\"内存中的日志缓存\",{\"1\":{\"568\":1}}],[\"内存中进⾏存储\",{\"1\":{\"203\":1}}],[\"内存中给页面留的位置是有限的\",{\"1\":{\"160\":1}}],[\"内存\",{\"1\":{\"186\":1,\"440\":1,\"583\":1,\"585\":1,\"671\":1}}],[\"内存空间不足以容纳这2\",{\"1\":{\"883\":1,\"886\":1}}],[\"内存空间不够时\",{\"1\":{\"157\":1}}],[\"内存空间连续\",{\"0\":{\"627\":1},\"1\":{\"627\":1}}],[\"内存空间连续节省内存\",{\"1\":{\"619\":1}}],[\"内存空间的碎片化\",{\"1\":{\"244\":1}}],[\"内存空间利用率高\",{\"1\":{\"155\":1}}],[\"内存碎片\",{\"0\":{\"154\":1}}],[\"内存管理主要有\",{\"1\":{\"153\":1}}],[\"内存管理主要是做什么的\",{\"0\":{\"153\":1}}],[\"内存管理机制\",{\"0\":{\"152\":1}}],[\"内存管理\",{\"1\":{\"135\":1}}],[\"内存交互操作一共有\",{\"1\":{\"73\":1}}],[\"内存系统的重排序\",{\"1\":{\"71\":1}}],[\"内存模型中\",{\"1\":{\"295\":1}}],[\"内存模型保证了\",{\"1\":{\"295\":1}}],[\"内存模型三大特性\",{\"0\":{\"295\":1}}],[\"内存模型jmm\",{\"0\":{\"293\":1}}],[\"内存模型是围绕着在并发过程中如何处理原子性\",{\"1\":{\"74\":1}}],[\"内存模型是一种规范\",{\"1\":{\"65\":1}}],[\"内存模型的规范\",{\"1\":{\"65\":1}}],[\"内存模型\",{\"0\":{\"65\":1},\"1\":{\"65\":1,\"66\":1}}],[\"内存溢出\",{\"1\":{\"45\":1,\"607\":1}}],[\"内存泄漏\",{\"0\":{\"302\":1},\"1\":{\"307\":1}}],[\"内存泄漏的第三个常见来源是监听器和其他回调\",{\"1\":{\"304\":1}}],[\"内存泄漏的另一个常见来源是缓存\",{\"1\":{\"304\":1}}],[\"内存泄漏的堆积终将导致内存溢出\",{\"1\":{\"45\":1}}],[\"内存泄漏的根源是\",{\"1\":{\"45\":1}}],[\"内存泄漏是指程序中已动态分配的堆内存由于某种原因程序未释放或者无法释放\",{\"1\":{\"45\":1}}],[\"内存泄漏相关概念\",{\"1\":{\"45\":1}}],[\"内存泄露问题\",{\"0\":{\"45\":1}}],[\"存ip地址\",{\"0\":{\"997\":1}}],[\"存到文件里面就可以了\",{\"1\":{\"896\":1}}],[\"存入第一个行第2个数\",{\"1\":{\"953\":1}}],[\"存入第一个行第1个数\",{\"1\":{\"953\":1}}],[\"存入\",{\"1\":{\"484\":2}}],[\"存活的极端情况\",{\"1\":{\"246\":1}}],[\"存活的对象年龄+1\",{\"1\":{\"241\":1}}],[\"存活下来的对象\",{\"1\":{\"242\":1}}],[\"存放我们常用的表中记录的那种类型的页\",{\"1\":{\"591\":1}}],[\"存放的不是数据本身\",{\"1\":{\"546\":1}}],[\"存放系统管理员使用的二进制可执行文件\",{\"1\":{\"416\":1}}],[\"存放库文件\",{\"1\":{\"416\":1}}],[\"存放共享数据\",{\"1\":{\"416\":1}}],[\"存放应用程序\",{\"1\":{\"416\":1}}],[\"存放着系统最基本的动态连接共享库\",{\"1\":{\"416\":1}}],[\"存放二进制可执行文件\",{\"1\":{\"416\":1}}],[\"存放数据的\",{\"1\":{\"299\":1}}],[\"存放对象实例\",{\"1\":{\"199\":1}}],[\"存放在\",{\"1\":{\"647\":1}}],[\"存放在方法属性表集合中一个名为\",{\"1\":{\"290\":1}}],[\"存放在栈中\",{\"1\":{\"198\":1}}],[\"存放在堆中\",{\"1\":{\"198\":1}}],[\"存放在内存中\",{\"1\":{\"149\":1}}],[\"存在的问题\",{\"1\":{\"880\":1}}],[\"存在的意向锁是否与自己准备加的锁冲突\",{\"1\":{\"514\":1}}],[\"存在不同格式的\",{\"1\":{\"648\":1}}],[\"存在\",{\"1\":{\"461\":1,\"568\":1,\"596\":1,\"750\":1}}],[\"存在继承的情况下\",{\"1\":{\"363\":1}}],[\"存在互相引用关系的两个对象\",{\"1\":{\"239\":1}}],[\"存在于实际的磁盘介质或者文件系统\",{\"1\":{\"149\":1}}],[\"存在则直接取\",{\"1\":{\"72\":1}}],[\"存储这些对象\",{\"1\":{\"1091\":1}}],[\"存储利用率高\",{\"1\":{\"922\":1}}],[\"存储到\",{\"1\":{\"896\":1}}],[\"存储节点\",{\"1\":{\"880\":1}}],[\"存储了消息的offset\",{\"1\":{\"846\":1}}],[\"存储了该线程以读\",{\"1\":{\"294\":1}}],[\"存储消息的中间件\",{\"1\":{\"840\":1}}],[\"存储数据\",{\"1\":{\"818\":1}}],[\"存储数据的仓库\",{\"1\":{\"457\":1}}],[\"存储分布在多个节点\",{\"1\":{\"660\":1,\"678\":1}}],[\"存储大量数据时\",{\"1\":{\"637\":1}}],[\"存储一些\",{\"1\":{\"606\":1}}],[\"存储一个uuid要花费更多的空间\",{\"1\":{\"467\":1}}],[\"存储结构\",{\"1\":{\"493\":1}}],[\"存储引擎为每行数据内置的\",{\"1\":{\"547\":1}}],[\"存储引擎有两大类索引\",{\"1\":{\"545\":1}}],[\"存储引擎有一个特殊的功能叫\",{\"1\":{\"537\":1}}],[\"存储引擎最小存储单元是页\",{\"1\":{\"539\":1}}],[\"存储引擎会在找到\",{\"1\":{\"535\":1}}],[\"存储引擎用到的很少\",{\"1\":{\"494\":1}}],[\"存储引擎默认使用哈希\",{\"1\":{\"494\":1}}],[\"存储引擎的表实际对应一个磁盘文件\",{\"1\":{\"494\":1}}],[\"存储引擎使用在内存中的数据来创建表\",{\"1\":{\"494\":1}}],[\"存储引擎描述的是表的存储方式\",{\"1\":{\"490\":1}}],[\"存储引擎\",{\"1\":{\"488\":1,\"489\":1}}],[\"存储密码的\",{\"1\":{\"477\":1}}],[\"存储在\",{\"1\":{\"413\":1}}],[\"存储高效\",{\"1\":{\"404\":1}}],[\"存储形式\",{\"1\":{\"372\":1}}],[\"存储\",{\"1\":{\"294\":1,\"407\":1,\"478\":1}}],[\"存储类型是一个\",{\"1\":{\"43\":1}}],[\"存储的值是每个值占用的字节再加上一个用来记录其长度的字节\",{\"1\":{\"477\":1}}],[\"存储的是当前内核运行状态的一系列特殊文件\",{\"1\":{\"416\":1}}],[\"存储的是\",{\"1\":{\"203\":1}}],[\"存储的\",{\"1\":{\"42\":1,\"617\":1}}],[\"存东西\",{\"1\":{\"39\":1}}],[\"其本质还是高内聚低耦合\",{\"1\":{\"1221\":1}}],[\"其类图如下所示\",{\"1\":{\"1100\":1,\"1101\":1}}],[\"其序号为u\",{\"1\":{\"1026\":1}}],[\"其重传时间应比数据在分组传输的平均往返时间更长一些\",{\"1\":{\"1011\":1}}],[\"其缓存还是空的\",{\"1\":{\"986\":1}}],[\"其首部会有一个总长度字段\",{\"1\":{\"980\":1}}],[\"其信息字段包含特定的配置请求\",{\"1\":{\"975\":1}}],[\"其数据传输的单位是用户数据报\",{\"1\":{\"961\":1}}],[\"其数据传输的单位是报文段\",{\"1\":{\"961\":1}}],[\"其定义的是应用进程间通信和交互的规则\",{\"1\":{\"961\":1}}],[\"其任务是转发收到的分组\",{\"1\":{\"960\":1}}],[\"其只允许在固定的一端插入和删除元素操作\",{\"1\":{\"940\":1}}],[\"其左右子树的高度最多相差\",{\"1\":{\"916\":1}}],[\"其正确性主要是源于复制状态机的性质\",{\"1\":{\"873\":1}}],[\"其来源于对大规模互联网系统分布式实践的总结\",{\"1\":{\"871\":1}}],[\"其能够对代理中的数据作缓冲\",{\"1\":{\"826\":1}}],[\"其逻辑为从连接池\",{\"1\":{\"804\":1}}],[\"其次才考虑使用继承关系来实现\",{\"1\":{\"1064\":1}}],[\"其次就是\",{\"1\":{\"805\":1}}],[\"其次\",{\"1\":{\"803\":1,\"820\":4,\"825\":1}}],[\"其次在序列化工具选择上\",{\"1\":{\"637\":1}}],[\"其不需要提供任何接口只需要一个非抽象类就能完成动态代理\",{\"1\":{\"726\":1}}],[\"其不依赖于操作系统核心\",{\"1\":{\"143\":1}}],[\"其必须实现invocationhandler接口的invoke方法\",{\"1\":{\"725\":1}}],[\"其管理这些对象的创建和依赖关系\",{\"1\":{\"718\":1}}],[\"其可以避免服务宕机导致的锁无法释放\",{\"1\":{\"668\":1}}],[\"其最小值是8\",{\"1\":{\"1002\":1}}],[\"其最终目的是保证核心服务可用\",{\"1\":{\"644\":1}}],[\"其最主要的原因是它很难解决对象之间相互循环引用的问题\",{\"1\":{\"233\":1}}],[\"其添加\",{\"1\":{\"622\":1}}],[\"其有两个数组构成\",{\"1\":{\"622\":1}}],[\"其底层实现方式\",{\"1\":{\"604\":1}}],[\"其前导列一定是使用最频繁的列\",{\"1\":{\"535\":1}}],[\"其目的是用于处理读写冲突\",{\"1\":{\"499\":1}}],[\"其速度比使用\",{\"1\":{\"494\":1}}],[\"其作用是查询某个范围内的数据\",{\"1\":{\"482\":1}}],[\"其作用类似于\",{\"1\":{\"416\":1}}],[\"其主功能是可以做负载均衡和安全防护\",{\"1\":{\"826\":1}}],[\"其主要原因是程序没有细致地过滤用户输入的数据\",{\"1\":{\"595\":1}}],[\"其主要目的是定义程序中各种变量的访问规则\",{\"1\":{\"74\":1}}],[\"其主键值在从表里存在便阻止删除\",{\"1\":{\"463\":1}}],[\"其外键值不是主表的主键值便阻止插入\",{\"1\":{\"463\":1}}],[\"其\",{\"1\":{\"449\":1}}],[\"其示意图如下\",{\"1\":{\"438\":1}}],[\"其原理是在数据后面添加供差错监测用的冗余码\",{\"1\":{\"974\":1}}],[\"其原理是哨兵进程向所有的\",{\"1\":{\"657\":1}}],[\"其原理主要是利用\",{\"1\":{\"81\":1}}],[\"其原因如上所述\",{\"1\":{\"427\":1}}],[\"其它数据也不会受到影响\",{\"1\":{\"880\":1}}],[\"其它进程还在工作\",{\"1\":{\"834\":1}}],[\"其它\",{\"1\":{\"677\":1}}],[\"其它服务器依然可以提供服务\",{\"1\":{\"661\":1}}],[\"其它存储引擎不支持在线热备份\",{\"1\":{\"491\":1}}],[\"其它的构造函数必然也会有\",{\"1\":{\"364\":1}}],[\"其它线程有可能通过\",{\"1\":{\"295\":1}}],[\"其它线程能够立即得知这个修改\",{\"1\":{\"295\":1}}],[\"其生命周期和jvm的生命周期相同\",{\"1\":{\"304\":1}}],[\"其根源在于虚方法调用指令invokevirtual的执行逻辑\",{\"1\":{\"278\":1}}],[\"其余依赖插件版本\",{\"1\":{\"1139\":1}}],[\"其余正常运行的\",{\"1\":{\"683\":1}}],[\"其余阶段也是要完全暂停用户线程的\",{\"1\":{\"264\":1}}],[\"其余的数字就可以清掉了\",{\"1\":{\"904\":1}}],[\"其余的follower会先将各自的log文件高于hw的部分截掉\",{\"1\":{\"855\":1}}],[\"其余的命令仍会被执行\",{\"1\":{\"665\":1}}],[\"其余的行为包括serial收集器可用的所有控制参数\",{\"1\":{\"255\":1}}],[\"其余的类加载器都应有自己的父类加载器\",{\"1\":{\"184\":1}}],[\"其大小不受\",{\"1\":{\"209\":1}}],[\"其区别只是虚拟机栈为虚拟机执行java方法\",{\"1\":{\"197\":1}}],[\"其后所有的类加载器都继承于classloader\",{\"1\":{\"182\":1}}],[\"其字面量形式定义在\",{\"1\":{\"172\":1}}],[\"其中成员对象是整体对象的一部分\",{\"1\":{\"1098\":1}}],[\"其中泛化和实现的耦合度相等\",{\"1\":{\"1095\":1}}],[\"其中取号\",{\"1\":{\"1087\":1}}],[\"其中ack报文是用来应答的\",{\"1\":{\"1024\":1}}],[\"其中第一个丢失\",{\"1\":{\"1023\":1}}],[\"其中编号3的包始终没有收到\",{\"1\":{\"1019\":1}}],[\"其中写入的整数表示从1900年1月1日到当前时刻有多少秒\",{\"1\":{\"993\":1}}],[\"其中16位的标识\",{\"1\":{\"987\":1}}],[\"其中基础类型用\",{\"1\":{\"938\":1}}],[\"其中有些是相同的\",{\"1\":{\"890\":1}}],[\"其中有两个哈希表\",{\"1\":{\"623\":1}}],[\"其中的this代表当前对象\",{\"1\":{\"726\":1}}],[\"其中的val\",{\"1\":{\"130\":1}}],[\"其中ioc就是控制反转\",{\"1\":{\"712\":1}}],[\"其中主节点提供读写操作\",{\"1\":{\"678\":1}}],[\"其中每一个元素都需要制定一个\",{\"1\":{\"620\":1}}],[\"其中每个地址分别对应着物理内存上面的每一个页的首地址\",{\"1\":{\"156\":1}}],[\"其中包含了许多信息\",{\"1\":{\"556\":1}}],[\"其中包含的有另一文件的位置信息\",{\"1\":{\"427\":1}}],[\"其中一部分记录的关键字均比另一部分记录的关键字小\",{\"1\":{\"935\":1}}],[\"其中一个文件中数的个数<=10亿\",{\"1\":{\"901\":1}}],[\"其中一个文件中数的个数<=20亿\",{\"1\":{\"901\":1}}],[\"其中一个要等另一个执行完才能开始执行\",{\"1\":{\"511\":1}}],[\"其中一级页表中每一个地址对应着一个二级页表的首地址\",{\"1\":{\"156\":1}}],[\"其中外查询与子查询都可以使用索引\",{\"1\":{\"482\":1}}],[\"其中子查询可以使用索引\",{\"1\":{\"482\":1}}],[\"其中最重要的就是称为stage\",{\"1\":{\"444\":1}}],[\"其中\",{\"1\":{\"128\":1,\"430\":1,\"488\":1,\"501\":1,\"676\":1,\"712\":1,\"771\":1,\"875\":1,\"919\":2}}],[\"其中较出名的是\",{\"1\":{\"72\":1}}],[\"其参数表示屏障拦截的线程数量\",{\"1\":{\"120\":1}}],[\"其实没啥好写的\",{\"1\":{\"1255\":1}}],[\"其实这就是一个策略接口\",{\"1\":{\"1089\":1}}],[\"其实本质上就是\",{\"0\":{\"886\":1}}],[\"其实它就是由下面三个注解组成的\",{\"1\":{\"771\":1}}],[\"其实它只是一个产生代理对象的工具类\",{\"1\":{\"349\":1}}],[\"其实就是设置将真实对象转换为什么类型的\",{\"1\":{\"726\":1}}],[\"其实就是在写内存和日志\",{\"1\":{\"592\":1}}],[\"其实应该再减去时钟漂移\",{\"1\":{\"672\":1}}],[\"其实无须知道到底哪一行被锁了\",{\"1\":{\"514\":1}}],[\"其实仅仅重写\",{\"1\":{\"342\":1}}],[\"其实是更烦琐的\",{\"1\":{\"262\":1}}],[\"其实即编写了数据结构\",{\"1\":{\"198\":1}}],[\"其实\",{\"1\":{\"198\":1,\"771\":1,\"1004\":1,\"1033\":1}}],[\"其实也就是线程安全\",{\"1\":{\"142\":1}}],[\"其实使用了tryreleaseshared方法以\",{\"1\":{\"118\":1}}],[\"其实并没有实际的许可证这个对象\",{\"1\":{\"117\":1}}],[\"其实都是提供的乐观锁\",{\"1\":{\"103\":1}}],[\"其实到底还是通过\",{\"1\":{\"32\":1}}],[\"其他情况\",{\"1\":{\"740\":1}}],[\"其他程序也要占\",{\"1\":{\"669\":1}}],[\"其他进程如果发现有锁就进行等待\",{\"1\":{\"643\":1}}],[\"其他的事务无法进行修改\",{\"1\":{\"523\":1}}],[\"其他的优化方法\",{\"1\":{\"309\":1}}],[\"其他事物必须等待该事务提交之后\",{\"1\":{\"513\":1}}],[\"其他事务不能再对a加任何锁\",{\"1\":{\"509\":1}}],[\"其他事务只能再对\",{\"1\":{\"509\":1}}],[\"其他事务就不能在这个间隙修改或者插入记录\",{\"1\":{\"505\":1}}],[\"其他每个人都从这个\",{\"1\":{\"452\":1}}],[\"其他用户\",{\"1\":{\"433\":1}}],[\"其他方法就被称为\",{\"1\":{\"275\":1}}],[\"其他方法为虚方法\",{\"1\":{\"194\":1}}],[\"其他均使用内置的jvm线程执行gc的多线程操作\",{\"1\":{\"260\":1}}],[\"其他收集器都只用到了写后屏障\",{\"1\":{\"250\":1}}],[\"其他所有的类加载器都继承于java\",{\"1\":{\"176\":1}}],[\"其他考虑用\",{\"1\":{\"149\":1}}],[\"其他段的数据也能被其他线程访问\",{\"1\":{\"129\":1}}],[\"其他共享模式下的线程也能占用\",{\"1\":{\"110\":1,\"111\":1}}],[\"其他线程无法再获得到锁\",{\"1\":{\"668\":1}}],[\"其他线程等待\",{\"1\":{\"642\":1}}],[\"其他线程调用了\",{\"1\":{\"350\":1}}],[\"其他线程调用了该对象的\",{\"1\":{\"350\":2}}],[\"其他线程必须等到持有锁的线程释放锁后才能获取锁\",{\"1\":{\"115\":1}}],[\"其他线程使用该对象\",{\"1\":{\"88\":1}}],[\"其他线程可以尝试获取锁\",{\"1\":{\"82\":1}}],[\"其他线程还可以继续获取锁\",{\"1\":{\"81\":1}}],[\"其他线程不可以继续获取锁\",{\"1\":{\"81\":1}}],[\"其他线程如果再想获取到锁的话需要排队\",{\"1\":{\"81\":1}}],[\"其他线程被阻塞住\",{\"1\":{\"79\":1}}],[\"其他\",{\"0\":{\"272\":1,\"326\":1},\"1\":{\"72\":2,\"190\":1,\"477\":1}}],[\"其内部\",{\"1\":{\"42\":1}}],[\"功能开发完成\",{\"1\":{\"1127\":1}}],[\"功能特性\",{\"1\":{\"966\":1}}],[\"功能的实现\",{\"1\":{\"742\":1}}],[\"功能更加强大\",{\"1\":{\"720\":1}}],[\"功能丰富的java\",{\"1\":{\"313\":1}}],[\"功能性更全面\",{\"1\":{\"94\":1}}],[\"功能\",{\"1\":{\"42\":1,\"121\":1,\"882\":1,\"1130\":1}}],[\"设想一种情况\",{\"1\":{\"1018\":1}}],[\"设多了会造成\",{\"1\":{\"835\":1}}],[\"设少了会浪费\",{\"1\":{\"835\":1}}],[\"设定权限\",{\"1\":{\"433\":2}}],[\"设定一个超时间隔\",{\"1\":{\"350\":1}}],[\"设备\",{\"1\":{\"136\":1}}],[\"设计一个系统时知道了算法所需的关键步骤\",{\"1\":{\"1087\":1}}],[\"设计一个简单\",{\"1\":{\"922\":1}}],[\"设计出可以重复利用的子单元流程模块\",{\"1\":{\"764\":1}}],[\"设计模式六大原则\",{\"0\":{\"1064\":1}}],[\"设计模式\",{\"0\":{\"1063\":1,\"1173\":1},\"1\":{\"718\":1}}],[\"设计简单\",{\"1\":{\"492\":1}}],[\"设计方案的好处\",{\"1\":{\"42\":1}}],[\"设计过程\",{\"0\":{\"41\":1}}],[\"设置正确的\",{\"0\":{\"1197\":1}}],[\"设置搜索时显示通道地址\",{\"1\":{\"1143\":1}}],[\"设置cwnd=ssthresh=cwnd\",{\"1\":{\"1019\":1}}],[\"设置相应的bit位\",{\"1\":{\"901\":1}}],[\"设置多少个\",{\"0\":{\"835\":1}}],[\"设置节点的具体值\",{\"1\":{\"823\":1}}],[\"设置字符编码\",{\"1\":{\"759\":1}}],[\"设置作用域\",{\"1\":{\"734\":1}}],[\"设置beanid\",{\"1\":{\"733\":1}}],[\"设置步骤麻烦\",{\"1\":{\"731\":1}}],[\"设置scope值是prototype时\",{\"1\":{\"713\":1,\"734\":1}}],[\"设置scope值是singleton时\",{\"1\":{\"713\":1,\"734\":1}}],[\"设置stw工作线程数的值\",{\"1\":{\"262\":1}}],[\"设置获取锁最多用\",{\"1\":{\"672\":1}}],[\"设置热点数据永远不过期\",{\"1\":{\"643\":1}}],[\"设置一个\",{\"1\":{\"668\":1}}],[\"设置一个定时任务脚本\",{\"1\":{\"640\":1}}],[\"设置一些阈值进行报警等处理\",{\"1\":{\"327\":1}}],[\"设置过期时间的键空间选择性移除\",{\"1\":{\"636\":1}}],[\"设置过低会直接影响吞吐量\",{\"1\":{\"263\":1}}],[\"设置键的过期时间\",{\"1\":{\"603\":1}}],[\"设置内存的最大使用量以及淘汰策略来保证缓存的命中率\",{\"1\":{\"603\":1}}],[\"设置成一个比较大的值\",{\"1\":{\"571\":1}}],[\"设置提交代码时的用户信息\",{\"1\":{\"446\":1}}],[\"设置的参数进行截取\",{\"1\":{\"753\":1}}],[\"设置的稍大一点也可以\",{\"1\":{\"645\":1}}],[\"设置的过小\",{\"1\":{\"645\":1}}],[\"设置的目录里查找符合条件的文件\",{\"1\":{\"434\":1}}],[\"设置的不要过于严苛\",{\"1\":{\"263\":1}}],[\"设置\",{\"1\":{\"381\":1,\"516\":1,\"563\":1,\"623\":1,\"669\":1,\"1060\":1}}],[\"设置tlab大小\",{\"1\":{\"326\":1}}],[\"设置klass\",{\"1\":{\"323\":1}}],[\"设置大于此阈值的对象直接分配在old区\",{\"1\":{\"322\":1}}],[\"设置老年代与年轻代的比值\",{\"1\":{\"322\":1}}],[\"设置eden与一个survivor区大小的比例\",{\"1\":{\"322\":1}}],[\"设置年轻代最大值为1024m\",{\"1\":{\"322\":1}}],[\"设置年轻代初始值为1024m\",{\"1\":{\"322\":1}}],[\"设置年轻代大小为2g\",{\"1\":{\"322\":1}}],[\"设置每个线程的栈大小为128k\",{\"1\":{\"321\":1}}],[\"设置每个region的大小\",{\"1\":{\"262\":1}}],[\"设置java线程堆栈大小\",{\"1\":{\"315\":1}}],[\"设置对打java堆大小\",{\"1\":{\"315\":1,\"322\":1}}],[\"设置对象头\",{\"0\":{\"222\":1}}],[\"设置初始java堆大小\",{\"1\":{\"315\":1}}],[\"设置初始和最大的元空间大小\",{\"1\":{\"203\":1}}],[\"设置最大的停顿时间\",{\"1\":{\"263\":1}}],[\"设置最大内存大小设定\",{\"1\":{\"199\":1}}],[\"设置堆的最大内存\",{\"1\":{\"263\":1}}],[\"设置触发并发gc周期的java堆的占用率阈值\",{\"1\":{\"262\":1}}],[\"设置并发标记的线程数\",{\"1\":{\"262\":1}}],[\"设置期望达到的最大gc停顿时间\",{\"1\":{\"262\":1}}],[\"设置栈大小的指令\",{\"1\":{\"190\":1}}],[\"设置同步状态的值\",{\"1\":{\"110\":1}}],[\"设置同步状态成功则表示当前线程获取了锁\",{\"1\":{\"96\":1}}],[\"设置到锁对象头的\",{\"1\":{\"88\":1}}],[\"设置为大于\",{\"1\":{\"563\":1}}],[\"设置为parallelgcthread的1\",{\"1\":{\"262\":1}}],[\"设置为公平模式\",{\"1\":{\"125\":1}}],[\"设置为\",{\"1\":{\"85\":1,\"89\":1,\"516\":1,\"563\":1,\"568\":3,\"571\":1,\"582\":1,\"1197\":1}}],[\"设置公平锁\",{\"1\":{\"81\":1}}],[\"设置值\",{\"1\":{\"39\":1}}],[\"设置当前线程的线程局部变量的值\",{\"1\":{\"39\":1}}],[\"设置了\",{\"1\":{\"38\":2}}],[\"侧重点\",{\"1\":{\"40\":1}}],[\"以下文档中给出的聚合根实践中\",{\"1\":{\"1240\":1}}],[\"以下的\",{\"1\":{\"1077\":2}}],[\"以下模式\",{\"1\":{\"718\":1}}],[\"以验证数据内容的完整性\",{\"1\":{\"1057\":1}}],[\"以单播的形式向dhcp服务器转发此报文\",{\"1\":{\"1049\":1}}],[\"以udp用户数据报方式\",{\"1\":{\"1031\":1}}],[\"以u1\",{\"1\":{\"284\":1}}],[\"以减少网络拥塞的发生\",{\"1\":{\"1019\":1}}],[\"以太网不需要使用帧结束定界符\",{\"1\":{\"980\":1}}],[\"以太网的\",{\"1\":{\"982\":1}}],[\"以太网的mac层\",{\"0\":{\"979\":1}}],[\"以太网的连线的长度受到限制\",{\"1\":{\"978\":1}}],[\"以太网的信道利用率\",{\"0\":{\"978\":1}}],[\"以还原成原来的比特流\",{\"1\":{\"973\":1}}],[\"以判断是否是二叉搜索树为例\",{\"1\":{\"956\":1}}],[\"以字符串形式作为输入\",{\"1\":{\"955\":1}}],[\"以字符串的形式\",{\"1\":{\"952\":1}}],[\"以反转链表为例\",{\"1\":{\"955\":1}}],[\"以达到整个序列有序的目的\",{\"1\":{\"935\":1}}],[\"以英文为例\",{\"1\":{\"888\":1}}],[\"以典型的\",{\"1\":{\"874\":1}}],[\"以partition为单位进行读写\",{\"1\":{\"852\":1}}],[\"以实现负载均衡\",{\"1\":{\"849\":1}}],[\"以实现让\",{\"1\":{\"337\":1}}],[\"以便适时选择恰当的算法类\",{\"1\":{\"1088\":1}}],[\"以便发现是否有浏览器向它发出连接建立请求\",{\"1\":{\"1037\":1}}],[\"以便故障恢复后继续消费\",{\"1\":{\"860\":1}}],[\"以便出错时恢复\",{\"1\":{\"846\":1}}],[\"以便随后的write操作使用\",{\"1\":{\"294\":1}}],[\"以便随后的load动作使用\",{\"1\":{\"294\":1}}],[\"以将系统的紧耦合关系转化为松耦合关系\",{\"1\":{\"748\":1}}],[\"以非事务方式运行\",{\"1\":{\"740\":2}}],[\"以非公平锁为例\",{\"1\":{\"96\":1}}],[\"以前开发的系统存在满足新系统功能需求的类\",{\"1\":{\"1092\":1}}],[\"以前我们总是要在a中自己编写代码来获得一个connection对象\",{\"1\":{\"718\":1}}],[\"以前我们使用的大部分引用实际上都是强引用\",{\"1\":{\"235\":1}}],[\"以前是它控制其他对象\",{\"1\":{\"718\":1}}],[\"以每秒一次的频率向它所知的\",{\"1\":{\"677\":1}}],[\"以分布式的方式运行\",{\"1\":{\"671\":1}}],[\"以节省内存\",{\"1\":{\"619\":1}}],[\"以获取一个\",{\"1\":{\"608\":1}}],[\"以新闻系统举例\",{\"1\":{\"601\":1}}],[\"以上两种level的混合使用\",{\"1\":{\"572\":1}}],[\"以联合索引\",{\"1\":{\"551\":1}}],[\"以确保就是要查找的行\",{\"1\":{\"537\":1}}],[\"以解决批量数据访问\",{\"1\":{\"495\":1}}],[\"以解决预读失效的问题\",{\"1\":{\"495\":1}}],[\"以\",{\"1\":{\"490\":1,\"534\":1,\"1240\":1}}],[\"以弃用\",{\"1\":{\"490\":1}}],[\"以第一个sql\",{\"1\":{\"485\":1}}],[\"以来的秒数\",{\"1\":{\"475\":1}}],[\"以一种可排序的\",{\"1\":{\"475\":1}}],[\"以人们较易阅读的\",{\"1\":{\"441\":1}}],[\"以数字方式显示地址和端口号\",{\"1\":{\"435\":1}}],[\"以三个为一组\",{\"1\":{\"430\":1}}],[\"以防外界通过该构造方法创建多个实例\",{\"1\":{\"1066\":1}}],[\"以防存储大量数据时超出\",{\"1\":{\"629\":1}}],[\"以防止\",{\"1\":{\"427\":1}}],[\"以防出问题\",{\"1\":{\"101\":1,\"714\":1}}],[\"以用户为主的格式来显示程序状况\",{\"1\":{\"426\":1}}],[\"以初始长度\",{\"1\":{\"405\":1}}],[\"以事件为中心的编程思想\",{\"1\":{\"354\":1}}],[\"以此将真实对象与动态对象绑定\",{\"1\":{\"725\":1}}],[\"以此类推\",{\"1\":{\"587\":2,\"901\":1}}],[\"以此对语句进行分析以及重写\",{\"1\":{\"559\":1}}],[\"以此来辨认用户状态\",{\"1\":{\"1051\":1}}],[\"以此来检测对方是否在线\",{\"1\":{\"683\":1}}],[\"以此来保证变更表结构操作的安全性\",{\"1\":{\"511\":1}}],[\"以此来排除哈希值不同的两个对象一定不等\",{\"1\":{\"342\":1}}],[\"以此降低对内存的读\",{\"1\":{\"193\":1}}],[\"以日期格式输出gc发生的时间戳\",{\"1\":{\"325\":1}}],[\"以日期的形式\",{\"1\":{\"270\":1}}],[\"以描述某些场景专有的信息\",{\"1\":{\"291\":1}}],[\"以基准时间的形式\",{\"1\":{\"270\":1}}],[\"以极高概率满足\",{\"1\":{\"261\":1}}],[\"以给用户带来良好的交互体验\",{\"1\":{\"259\":1}}],[\"以应对被使用的内存中所有对象都100\",{\"1\":{\"246\":1}}],[\"以保证以太网的mac帧长不小于64字节\",{\"1\":{\"980\":1}}],[\"以保证所有语句能在slave得到和在master端执行时候相同的结果\",{\"1\":{\"572\":1}}],[\"以保证下一次minor\",{\"1\":{\"242\":1}}],[\"以保证其描述的信息符合\",{\"1\":{\"170\":1}}],[\"以往永久代经常因为内存不够\",{\"1\":{\"205\":1}}],[\"以后则每隔\",{\"1\":{\"1028\":1}}],[\"以后会定期遍历这个字典来删除到期的\",{\"1\":{\"632\":1}}],[\"以后已经不再使用\",{\"1\":{\"626\":1}}],[\"以后\",{\"1\":{\"203\":1}}],[\"以后只要不发生竞争\",{\"1\":{\"88\":1}}],[\"以meta\",{\"1\":{\"185\":1}}],[\"以使每次的寻道时间最短\",{\"1\":{\"163\":1}}],[\"以磁盘文件的方式存在\",{\"1\":{\"149\":1}}],[\"以恢复任务的执行\",{\"1\":{\"144\":1}}],[\"以jps为例\",{\"1\":{\"98\":1}}],[\"以及包图\",{\"1\":{\"1094\":1}}],[\"以及序列化的情况下\",{\"1\":{\"1075\":1}}],[\"以及服务器怎样把文档传送给浏览器\",{\"1\":{\"1037\":1}}],[\"以及收到相应的确认的时间\",{\"1\":{\"1012\":1}}],[\"以及流量的控制\",{\"1\":{\"998\":1}}],[\"以及把整数格式的ip转换成字符串的inet\",{\"1\":{\"997\":1}}],[\"以及把接收到的帧中的数据取出并上交给网络层\",{\"1\":{\"968\":1}}],[\"以及运输层报文的发送序号\",{\"1\":{\"993\":1}}],[\"以及13位的片偏移用来ip报文的分片和重组\",{\"1\":{\"987\":1}}],[\"以及消费者消费数据的对象都是leader\",{\"1\":{\"845\":1}}],[\"以及消息中间件本身的持久化和稳定性可靠性\",{\"1\":{\"841\":1}}],[\"以及数据存取机制\",{\"1\":{\"748\":1}}],[\"以及相应的\",{\"1\":{\"721\":1}}],[\"以及恒生的微服务框架\",{\"1\":{\"687\":1}}],[\"以及其他\",{\"1\":{\"677\":1}}],[\"以及与客户端通信的应用协议不一样\",{\"1\":{\"604\":1}}],[\"以及切分后对数据的定位\",{\"1\":{\"585\":1}}],[\"以及指向主键值的指针\",{\"1\":{\"547\":1}}],[\"以及指向主键的指针\",{\"1\":{\"545\":1}}],[\"以及指向master的一个指针叫head\",{\"1\":{\"444\":1}}],[\"以及行的间隙都会被加锁\",{\"1\":{\"523\":1}}],[\"以及两阶段提交机制来保证事务的原子性\",{\"1\":{\"519\":1}}],[\"以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中\",{\"1\":{\"513\":1}}],[\"以及creator\",{\"1\":{\"499\":1}}],[\"以及每次commit发生变更的文件\",{\"1\":{\"449\":1}}],[\"以及每次使用前立即从主内存刷新\",{\"1\":{\"295\":1}}],[\"以及字节数\",{\"1\":{\"439\":1}}],[\"以及动态的区域容量大小\",{\"1\":{\"268\":1}}],[\"以及notifyall\",{\"1\":{\"126\":1}}],[\"以及\",{\"1\":{\"81\":2,\"142\":1,\"203\":1,\"687\":1}}],[\"以及如何同步访问的共享变量\",{\"1\":{\"65\":1}}],[\"以空间换时间\",{\"1\":{\"40\":1}}],[\"以时间换空间\",{\"1\":{\"40\":1}}],[\"以在不同的地点在线编辑\",{\"1\":{\"1\":1}}],[\"原\",{\"1\":{\"1266\":1}}],[\"原为0\",{\"1\":{\"1177\":1}}],[\"原队首也就是第一个\",{\"1\":{\"628\":1}}],[\"原本是\",{\"1\":{\"628\":1}}],[\"原数组大小的\",{\"1\":{\"623\":1}}],[\"原⼦性由undo\",{\"1\":{\"519\":1}}],[\"原来索引\",{\"1\":{\"406\":1}}],[\"原因是怕最后一个\",{\"1\":{\"1026\":1}}],[\"原因是它是基于链表来存储的\",{\"1\":{\"381\":1}}],[\"原因\",{\"1\":{\"559\":1,\"582\":1,\"642\":1}}],[\"原因很简单\",{\"1\":{\"533\":1}}],[\"原因就是因为使用了虚拟内存\",{\"1\":{\"157\":1}}],[\"原生复制的弊端在早期的版本中也会比较突出\",{\"1\":{\"675\":1}}],[\"原生支持浮点运算\",{\"1\":{\"473\":1}}],[\"原生的注解多用于标记和检查\",{\"1\":{\"338\":1}}],[\"原生的\",{\"1\":{\"338\":1}}],[\"原生就有可能将指令进行重排\",{\"1\":{\"71\":1}}],[\"原始快照搜索能够减少并发标记和重新标记阶段的消耗\",{\"1\":{\"251\":1}}],[\"原始快照\",{\"1\":{\"251\":2,\"264\":1}}],[\"原先引起异常的指令就可以继续执行\",{\"1\":{\"159\":1}}],[\"原子地用新文件替换旧文件\",{\"1\":{\"651\":1}}],[\"原子地\",{\"1\":{\"110\":1}}],[\"原子更新带有版本号的引用类型\",{\"1\":{\"106\":1}}],[\"原子性没有得到满足\",{\"1\":{\"669\":1}}],[\"原子性\",{\"0\":{\"67\":1},\"1\":{\"67\":1,\"295\":1,\"519\":3}}],[\"原则二\",{\"1\":{\"515\":1}}],[\"原则一\",{\"1\":{\"515\":1}}],[\"原则非常重要\",{\"1\":{\"75\":1}}],[\"原则\",{\"1\":{\"67\":1,\"122\":1,\"677\":1}}],[\"原理理解更繁琐\",{\"1\":{\"676\":1}}],[\"原理与serial相同\",{\"1\":{\"256\":1}}],[\"原理是遍历线程池中的工作线程\",{\"1\":{\"59\":1}}],[\"原理\",{\"0\":{\"85\":1,\"110\":1,\"129\":1,\"130\":1,\"1044\":1},\"1\":{\"39\":2,\"40\":1,\"78\":1,\"184\":1,\"299\":1,\"655\":1,\"672\":1,\"677\":1,\"801\":1}}],[\"原地\",{\"1\":{\"6\":1}}],[\"同属交换排序类\",{\"1\":{\"935\":1}}],[\"同\",{\"1\":{\"835\":1}}],[\"同服务器\",{\"1\":{\"820\":1}}],[\"同理\",{\"1\":{\"804\":1}}],[\"同业存款交易平台开发时由于其报文结构和状态流转过程的复杂性\",{\"1\":{\"693\":1}}],[\"同意建立连接\",{\"1\":{\"1023\":1}}],[\"同意\",{\"1\":{\"677\":1,\"878\":1}}],[\"同样的请求被执行一次与连续执行多次的效果是一样的\",{\"1\":{\"1041\":1}}],[\"同样的磁盘\",{\"1\":{\"850\":1}}],[\"同样通过计算的散列地址\",{\"1\":{\"922\":1}}],[\"同样是以阻塞的方式完成数据同步\",{\"1\":{\"656\":1}}],[\"同样可以采用映射的方法\",{\"1\":{\"892\":1}}],[\"同样可以接受其他\",{\"1\":{\"656\":1}}],[\"同样可以显著减少查询中分组和排序的时间\",{\"1\":{\"528\":1}}],[\"同样有着用于存放大对象的humongous\",{\"1\":{\"267\":1}}],[\"同名的方法如果有不同的参数列表\",{\"1\":{\"359\":2}}],[\"同一种数不可能被散列到不同的小文件上\",{\"1\":{\"897\":1}}],[\"同一会话周期内\",{\"1\":{\"869\":1}}],[\"同一事务的消息可能会出现重启后被删除的情况\",{\"1\":{\"864\":1}}],[\"同一用户对于同一操作的一次请求与多次请求\",{\"1\":{\"856\":1}}],[\"同一个topic\",{\"1\":{\"861\":1}}],[\"同一个业务\",{\"1\":{\"808\":2}}],[\"同一个线程在没有释放锁之前无法再次获得该锁\",{\"1\":{\"668\":1}}],[\"同一条线程里面\",{\"1\":{\"191\":1}}],[\"同一时刻\",{\"1\":{\"191\":1}}],[\"同一时刻只能有一个线程对数据进行操作\",{\"1\":{\"67\":1}}],[\"同一时间只能有一个线程获取到锁\",{\"1\":{\"115\":1}}],[\"同步主分支到本地开发分支\",{\"0\":{\"1126\":1}}],[\"同步代码块\",{\"1\":{\"1065\":1}}],[\"同步方法\",{\"1\":{\"1065\":1}}],[\"同步收到\",{\"1\":{\"1022\":1}}],[\"同步已发送\",{\"1\":{\"1022\":1}}],[\"同步syn\",{\"1\":{\"1007\":1}}],[\"同步日志\",{\"1\":{\"874\":1}}],[\"同步操作执行完后\",{\"1\":{\"662\":1}}],[\"同步命令\",{\"1\":{\"662\":1}}],[\"同步期间\",{\"1\":{\"656\":1}}],[\"同步改变缓存中相应的数据即可\",{\"1\":{\"606\":1}}],[\"同步磁盘\",{\"1\":{\"496\":1}}],[\"同步非阻塞\",{\"1\":{\"380\":1}}],[\"同步阻塞\",{\"1\":{\"380\":1}}],[\"同步省略\",{\"1\":{\"202\":1}}],[\"同步\",{\"1\":{\"143\":1,\"380\":5,\"820\":2}}],[\"同步是指在多个线程并发访问共享数据时\",{\"1\":{\"142\":1}}],[\"同步关键字配合\",{\"1\":{\"126\":1}}],[\"同步器\",{\"1\":{\"120\":1}}],[\"同步块时\",{\"1\":{\"89\":1}}],[\"同步通知\",{\"1\":{\"72\":2}}],[\"同核心\",{\"1\":{\"72\":1}}],[\"同时把对应的领域服务敲定之后\",{\"1\":{\"1227\":1}}],[\"同时解决懒加载问题\",{\"1\":{\"1068\":1}}],[\"同时接口中的方法尽量少\",{\"1\":{\"1064\":1}}],[\"同时使用证书中的公钥加密随机数\",{\"1\":{\"1044\":1}}],[\"同时使用缓存一致性机制来确保修改的原子性\",{\"1\":{\"296\":1}}],[\"同时选择一个初始序号seq=x\",{\"1\":{\"1022\":1}}],[\"同时继续对随后到达的数据进行缓存\",{\"1\":{\"1017\":1}}],[\"同时路由器的路由表中也必须有子网掩码这一栏\",{\"1\":{\"989\":1}}],[\"同时以太网的帧长不能太短\",{\"1\":{\"978\":1}}],[\"同时走\",{\"1\":{\"927\":1}}],[\"同时每个小文件中不同的数一定不会大于2亿种\",{\"1\":{\"897\":1}}],[\"同时记录当前出现次数最多的那个\",{\"1\":{\"892\":1}}],[\"同时知道这个区域中的第几大数刚好是中位数\",{\"1\":{\"886\":1}}],[\"同时查找两个位置\",{\"1\":{\"884\":1}}],[\"同时用两个哈希函数进行计算\",{\"1\":{\"884\":1}}],[\"同时返回给\",{\"1\":{\"878\":1}}],[\"同时返回代理对象\",{\"1\":{\"725\":1}}],[\"同时要求\",{\"1\":{\"866\":1}}],[\"同时不同的\",{\"1\":{\"856\":1}}],[\"同时不允许以任何方式单独访问其中一个\",{\"1\":{\"192\":1}}],[\"同时为了快速定位大文件中消息位置\",{\"1\":{\"846\":1}}],[\"同时有多个消费者订阅此topic\",{\"1\":{\"844\":1}}],[\"同时支持\",{\"1\":{\"725\":1}}],[\"同时支持两种锁\",{\"1\":{\"113\":1}}],[\"同时也选择一个初始序号seq=y\",{\"1\":{\"1022\":1}}],[\"同时也是用户功能中的最底层\",{\"1\":{\"997\":1}}],[\"同时也支持异步调用\",{\"1\":{\"814\":1}}],[\"同时也把你交给其他需要你的东西\",{\"1\":{\"718\":1}}],[\"同时也保护了目标对象\",{\"1\":{\"715\":1}}],[\"同时也提供了设置缓存有效时间等功能\",{\"1\":{\"607\":1}}],[\"同时也提供了集群方案\",{\"1\":{\"607\":1}}],[\"同时数据定位算法不变\",{\"1\":{\"681\":1}}],[\"同时需要通知业务方变更配置\",{\"1\":{\"675\":1}}],[\"同时收到多个\",{\"1\":{\"661\":1}}],[\"同时发现\",{\"1\":{\"657\":1}}],[\"同时提供了哨兵命令\",{\"1\":{\"657\":1}}],[\"同时由于前部分是\",{\"1\":{\"653\":1}}],[\"同时由于region数量比传统收集器的分代数量明显要多得多\",{\"1\":{\"265\":1}}],[\"同时结合\",{\"1\":{\"653\":1}}],[\"同时代码复杂度会增大\",{\"1\":{\"643\":1}}],[\"同时读缓存没读到数据\",{\"1\":{\"643\":1}}],[\"同时读取\",{\"1\":{\"72\":1}}],[\"同时存在多个监听套接字和已连接套接字\",{\"1\":{\"604\":1}}],[\"同时主从同步也会丢失这一条数据\",{\"1\":{\"578\":1}}],[\"同时主键索引也是唯一索引\",{\"1\":{\"548\":1}}],[\"同时系统会定期做整库备份\",{\"1\":{\"576\":1}}],[\"同时观察cpu使用率是否下降\",{\"1\":{\"562\":1}}],[\"同时优化过程中查询列值会转成常量\",{\"1\":{\"556\":1}}],[\"同时叶子节点中存放的就是整张表的行记录数据\",{\"1\":{\"547\":1}}],[\"同时在哈希表中保存指向每个数据行的指针\",{\"1\":{\"537\":1}}],[\"同时会锁上聚簇索引内的所有gap\",{\"1\":{\"501\":1}}],[\"同时会向其他\",{\"1\":{\"72\":1}}],[\"同时这些记录在主键索引上的记录也会被加锁\",{\"1\":{\"501\":1}}],[\"同时找到聚簇索引另一把x锁加到聚簇索引\",{\"1\":{\"501\":2}}],[\"同时还在代理类中封装了其他方法\",{\"1\":{\"1083\":1}}],[\"同时还可能存在具有相同数目的数据\",{\"1\":{\"891\":1}}],[\"同时还可以解决脏读\",{\"1\":{\"499\":1}}],[\"同时还提供\",{\"1\":{\"610\":1}}],[\"同时还有一个日志模块\",{\"1\":{\"488\":1}}],[\"同时将这个更新操作记录到\",{\"1\":{\"489\":1}}],[\"同时重置暂存区和工作区\",{\"1\":{\"453\":1}}],[\"同时重置暂存区\",{\"1\":{\"453\":1}}],[\"同时保证内存可见性\",{\"1\":{\"409\":1}}],[\"同时保留不含\",{\"1\":{\"26\":1}}],[\"同时\",{\"1\":{\"359\":1,\"412\":1,\"489\":1,\"501\":1,\"569\":1,\"668\":1}}],[\"同时子类也可以新增新的属性和方法\",{\"1\":{\"355\":1}}],[\"同时中断处理中的任务\",{\"1\":{\"63\":1}}],[\"同包或者不同包的子类\",{\"1\":{\"39\":1}}],[\"当值对象发生改变时只能替换\",{\"1\":{\"1231\":1}}],[\"当接收到浏览器发送过来的请求\",{\"1\":{\"1090\":1}}],[\"当接收方来不及处理发送方的数据\",{\"1\":{\"1009\":1}}],[\"当接收方udp发现收到的报文中的目的端口号不正确\",{\"1\":{\"1002\":1}}],[\"当工厂方法模式中抽象工厂与具体工厂合并\",{\"1\":{\"1080\":1}}],[\"当抽象工厂模式中每一个具体工厂类只创建一个产品对象\",{\"1\":{\"1080\":1}}],[\"当产品族中需要增加一个新的产品时\",{\"1\":{\"1079\":1}}],[\"当增加一个新的产品族时\",{\"1\":{\"1079\":1}}],[\"当正常连接建立起来后再分配\",{\"1\":{\"1060\":1}}],[\"当达到一定阈值时拆除这些连接\",{\"1\":{\"1060\":1}}],[\"当攻击的\",{\"1\":{\"1060\":1}}],[\"当浏览器再请求该网站时\",{\"1\":{\"1051\":1}}],[\"当进行区域传送\",{\"1\":{\"1033\":1}}],[\"当进程调度程序按一种选定的策略从中选中一个就绪进程\",{\"1\":{\"148\":1}}],[\"当权限服务器回答一个查询请求时\",{\"1\":{\"1032\":1}}],[\"当域名服务器已从缓存中删去某项信息后又被请求查询该项信息\",{\"1\":{\"1032\":1}}],[\"当根域名服务器收到本地域名服务器发出的迭代查询请求报文时\",{\"1\":{\"1031\":1}}],[\"当场close\",{\"1\":{\"1026\":1}}],[\"当a连续收到3个重复确认包2的ack时\",{\"1\":{\"1019\":1}}],[\"当cwnd>ssthresh时\",{\"1\":{\"1019\":1}}],[\"当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时\",{\"1\":{\"1017\":1}}],[\"当滑动窗口为\",{\"1\":{\"1015\":1}}],[\"当网络拥塞时\",{\"1\":{\"1009\":1}}],[\"当fin=1表示此报文段的发送方的数据已发送完毕\",{\"1\":{\"1007\":1}}],[\"当存储ipv4地址时\",{\"1\":{\"997\":1}}],[\"当存储的所有数据都是整数\",{\"1\":{\"619\":1}}],[\"当存储的值已经存在时返回\",{\"1\":{\"413\":1}}],[\"当终点在预先规定的时间内不能收到一个数据报的全部数据片时\",{\"1\":{\"993\":1}}],[\"当路由器或目的主机收到的数据报的首部中有的字段的值不正确时\",{\"1\":{\"993\":1}}],[\"当路由器或主机不能交付数据报时就向源点发送终点不可达报文\",{\"1\":{\"993\":1}}],[\"当路由器收到生存时间为零的数据报时\",{\"1\":{\"993\":1}}],[\"当主机要发送数据报时\",{\"1\":{\"993\":1}}],[\"当主机a要向主机b发送ip数据报时\",{\"1\":{\"986\":1}}],[\"当主服务器宕机后\",{\"1\":{\"657\":1,\"675\":1,\"676\":1}}],[\"当上层使用ip协议时\",{\"1\":{\"980\":1}}],[\"当末位是1时\",{\"1\":{\"949\":1}}],[\"当问题关心最近一次的操作\",{\"1\":{\"942\":1}}],[\"当p2越界\",{\"1\":{\"934\":1}}],[\"当p1越界\",{\"1\":{\"934\":1}}],[\"当整个序列基本有序时\",{\"1\":{\"933\":1}}],[\"当过滤器返回\",{\"1\":{\"882\":1}}],[\"当leader崩溃时\",{\"1\":{\"879\":1}}],[\"当leader发生故障之后\",{\"1\":{\"853\":1}}],[\"当服务器之间进行通信时会交换当前的\",{\"1\":{\"876\":1}}],[\"当原leader挂了之后\",{\"1\":{\"866\":1}}],[\"当生产者产生消息后也会尽量投递到不同\",{\"1\":{\"861\":1}}],[\"当具有相同主键的消息的时候\",{\"1\":{\"856\":1}}],[\"当broker故障时有可能丢失数据\",{\"1\":{\"854\":1}}],[\"当bean不再被使用时\",{\"1\":{\"733\":1}}],[\"当isr中的follower完成数据的同步之后\",{\"1\":{\"853\":1}}],[\"当innodb扫描索引记录的时候\",{\"1\":{\"505\":1}}],[\"当消费者不可用时\",{\"1\":{\"843\":1}}],[\"当消费者消费后\",{\"1\":{\"62\":1}}],[\"当客户端与多个子系统之间存在很大的联系时\",{\"1\":{\"1090\":1}}],[\"当客户端与服务器建立连接之后\",{\"1\":{\"829\":1}}],[\"当客户端向\",{\"1\":{\"1033\":1}}],[\"当客户端需要进行远程调用时\",{\"1\":{\"804\":1}}],[\"当该\",{\"1\":{\"817\":1}}],[\"当目录节点发生变化\",{\"1\":{\"817\":1}}],[\"当出现了网络分区的时候\",{\"1\":{\"870\":1}}],[\"当出现失败\",{\"1\":{\"813\":1}}],[\"当出现死锁以后\",{\"1\":{\"516\":1}}],[\"当项目自身被依赖时\",{\"1\":{\"797\":1}}],[\"当项目编译时\",{\"1\":{\"794\":1}}],[\"当访问服务器的资源时\",{\"1\":{\"759\":1}}],[\"当访问量剧增\",{\"1\":{\"644\":1}}],[\"当事务方法被另一个事务方法调用时\",{\"1\":{\"740\":1}}],[\"当单例中存在竞争状态\",{\"1\":{\"735\":1}}],[\"当切面太多的话\",{\"1\":{\"720\":1}}],[\"当代理对象调用真实对象的方法时\",{\"1\":{\"715\":1,\"725\":1}}],[\"当释放锁的时候\",{\"1\":{\"668\":1}}],[\"当其它主节点\",{\"1\":{\"659\":1}}],[\"当其他线程调用了\",{\"1\":{\"111\":1}}],[\"当后面的哨兵也检测到主服务器不可用\",{\"1\":{\"657\":1}}],[\"当哨兵监测到\",{\"1\":{\"657\":1}}],[\"当多个\",{\"1\":{\"656\":1,\"678\":1}}],[\"当多个线程需要相同的锁\",{\"1\":{\"98\":1}}],[\"当子进程完成重写工作时\",{\"1\":{\"651\":1}}],[\"当子进程将快照写入临时文件完毕后\",{\"1\":{\"647\":1}}],[\"当父进程处理写请求时\",{\"1\":{\"647\":1}}],[\"当成\",{\"1\":{\"637\":1}}],[\"当数据到达较快而网络速率较慢时\",{\"1\":{\"1017\":1}}],[\"当数据字段的长度小于46个字节时\",{\"1\":{\"980\":1}}],[\"当数据量一定时\",{\"1\":{\"978\":1}}],[\"当数据量大时\",{\"1\":{\"627\":1}}],[\"当数据中存在与帧结束符相同的数据\",{\"1\":{\"973\":1}}],[\"当数据是有ascii码组成的文本文件时\",{\"1\":{\"972\":1}}],[\"当数据写入到对应的\",{\"1\":{\"659\":1}}],[\"当数组大小大于\",{\"1\":{\"401\":1}}],[\"当负载因子<0\",{\"1\":{\"623\":1}}],[\"当被监控的服务器出现问题时\",{\"1\":{\"677\":1}}],[\"当被监控的\",{\"1\":{\"613\":2}}],[\"当被监控的文件描述符上有可读写事件发生时\",{\"1\":{\"381\":1}}],[\"当内存不足以容纳新写入数据时\",{\"1\":{\"636\":6}}],[\"当内存数据页跟磁盘数据页内容不一致的时候\",{\"1\":{\"592\":1}}],[\"当内存空间不足\",{\"1\":{\"235\":1}}],[\"当更新内容同时分布在不同库中\",{\"1\":{\"589\":1}}],[\"当uid=1时\",{\"1\":{\"587\":1}}],[\"当当网的\",{\"1\":{\"586\":1}}],[\"当由于某些原因导致事务执行失败\",{\"1\":{\"570\":1}}],[\"当脏页写入到磁盘\",{\"1\":{\"559\":1}}],[\"当计算机访问一个地址的数据的时候\",{\"1\":{\"543\":1}}],[\"当某个\",{\"1\":{\"582\":1,\"612\":1,\"683\":1}}],[\"当某个索引值被使用的非常频繁时\",{\"1\":{\"537\":1}}],[\"当某个线程调用本地方法时\",{\"1\":{\"197\":1}}],[\"当时看\",{\"1\":{\"525\":1}}],[\"当两个指针都不越界时\",{\"1\":{\"934\":1}}],[\"当两个或多个事务选择同一行\",{\"1\":{\"521\":1}}],[\"当两个及以上的事务\",{\"1\":{\"516\":1}}],[\"当两个线程都到达同步点时这两个线程就可以交换数据\",{\"1\":{\"127\":1}}],[\"当要对表做结构变更操作\",{\"1\":{\"511\":1}}],[\"当要删除引用关系时\",{\"1\":{\"251\":1}}],[\"当你需要什么\",{\"1\":{\"1077\":1}}],[\"当你需要让整个库处于只读状态的时候\",{\"1\":{\"508\":1}}],[\"当你的数据不断增长\",{\"1\":{\"671\":1}}],[\"当你输入\",{\"1\":{\"477\":1}}],[\"当刷新一个脏页时\",{\"1\":{\"496\":1}}],[\"当全部io请求发送完毕后\",{\"1\":{\"496\":1}}],[\"当选择了执行方案后\",{\"1\":{\"490\":1}}],[\"当一台主机同时连两个网络时\",{\"1\":{\"984\":1}}],[\"当一次io时\",{\"1\":{\"543\":1}}],[\"当一页写满\",{\"1\":{\"466\":1}}],[\"当一个复杂系统的子系统很多时\",{\"1\":{\"1090\":1}}],[\"当一个系统的功能越来越强\",{\"1\":{\"1090\":1}}],[\"当一个流出现丢包影响范围非常小\",{\"1\":{\"1042\":1}}],[\"当一个元素加入布隆过滤器中的时候\",{\"1\":{\"882\":1}}],[\"当一个表的数据不断增多时\",{\"1\":{\"585\":1}}],[\"当一个事物所以一行数据的时候\",{\"1\":{\"513\":1}}],[\"当一个文件的内容较大时\",{\"1\":{\"442\":1}}],[\"当一个变量被定义成volatile后\",{\"1\":{\"296\":1}}],[\"当一个变量被声明为\",{\"1\":{\"69\":1}}],[\"当一个对象被存储进hashset之后\",{\"1\":{\"304\":1}}],[\"当一个对象到\",{\"1\":{\"234\":1}}],[\"当一个对象在方法中被定义后\",{\"1\":{\"202\":1}}],[\"当一个方法开始执行后\",{\"1\":{\"195\":1}}],[\"当一个方法被调用时\",{\"1\":{\"192\":1}}],[\"当一个类加载器收到类加载的请求时\",{\"1\":{\"184\":1}}],[\"当一个接口中定义了jdk8新加入的默认方法\",{\"1\":{\"174\":1}}],[\"当一个线程占用锁访问其中一个段的数据时\",{\"1\":{\"129\":1}}],[\"当一个进程申请资源时\",{\"1\":{\"98\":1}}],[\"当一个偏向锁如果撤销次数到达\",{\"1\":{\"88\":1}}],[\"当设置主键时\",{\"1\":{\"464\":1}}],[\"当没存满时\",{\"1\":{\"442\":1}}],[\"当新元素加入\",{\"1\":{\"410\":1}}],[\"当红黑树大小为\",{\"1\":{\"401\":1}}],[\"当链表长度达到阈值\",{\"1\":{\"403\":1}}],[\"当链表长度\",{\"1\":{\"398\":1}}],[\"当添加元素发现容量满了时\",{\"1\":{\"392\":1}}],[\"当比较规则有多个\",{\"1\":{\"390\":1}}],[\"当比较规则不会发生改变时\",{\"1\":{\"390\":1}}],[\"当创建一个\",{\"1\":{\"369\":1}}],[\"当用户调用\",{\"1\":{\"612\":1}}],[\"当用\",{\"1\":{\"355\":1,\"558\":1}}],[\"当我们把领域对象进行进一步的细化之后\",{\"1\":{\"1227\":1}}],[\"当我们恰当的使用\",{\"1\":{\"770\":1}}],[\"当我们需要判断一个元素是否存在于布隆过滤器的时候\",{\"1\":{\"882\":1}}],[\"当我们需要创建一个对象的时候\",{\"1\":{\"718\":1}}],[\"当我们需要增加或减少一个节点时\",{\"1\":{\"679\":1}}],[\"当我们需要运行这个字节码文件时候\",{\"1\":{\"180\":1}}],[\"当我们的存取的\",{\"1\":{\"659\":1}}],[\"当我们的sql命中了索引\",{\"1\":{\"508\":1}}],[\"当我们向布隆过滤器中添加数据时\",{\"1\":{\"645\":1}}],[\"当我们使用\",{\"1\":{\"606\":1}}],[\"当我们在事务中尝试对数据进行更改\",{\"1\":{\"568\":1}}],[\"当我们为表建立多个索引时\",{\"1\":{\"549\":1}}],[\"当我们通过代理对象调用一个方法的时候\",{\"1\":{\"349\":1}}],[\"当想要给实现了某个接口的类中的方法\",{\"1\":{\"349\":1}}],[\"当编译一个新类时\",{\"1\":{\"348\":1}}],[\"当发送方收到对第一个确认后\",{\"1\":{\"1017\":1}}],[\"当发布者通过\",{\"1\":{\"673\":1}}],[\"当发生\",{\"1\":{\"342\":1}}],[\"当发生oom的时候\",{\"1\":{\"324\":1}}],[\"当发现读屏障的指令时\",{\"1\":{\"72\":1}}],[\"当发现写屏障的指令时\",{\"1\":{\"72\":1}}],[\"当需要创建的对象是一系列相互关联或相互依赖的产品族时\",{\"1\":{\"1079\":1}}],[\"当需要按照一定的顺序来处理数据\",{\"1\":{\"942\":1}}],[\"当需要移除节点时\",{\"1\":{\"680\":1}}],[\"当需要增加节点时\",{\"1\":{\"680\":1}}],[\"当需要新的内存页\",{\"1\":{\"594\":1}}],[\"当需要恢复到指定的某一秒时\",{\"1\":{\"576\":1}}],[\"当需要更新一个数据页时\",{\"1\":{\"574\":1}}],[\"当需要从数据库查询的表有上万条记录的时候\",{\"1\":{\"486\":1}}],[\"当需要取出一个\",{\"1\":{\"396\":1}}],[\"当需要存储一个键值对对象时\",{\"1\":{\"396\":1}}],[\"当需要描述同一类型但数量不定的多个数据时\",{\"1\":{\"284\":1}}],[\"当需要调用一个类的方法的时候\",{\"1\":{\"172\":1}}],[\"当插入新的引用关系时\",{\"1\":{\"251\":1}}],[\"当判断⼀个卡⻚中有存在对象的跨代引⽤时\",{\"1\":{\"247\":1}}],[\"当空间碎片过多\",{\"1\":{\"246\":1}}],[\"当server端收到fin报文时\",{\"1\":{\"1024\":1}}],[\"当survivor空间不足以容纳一次minor\",{\"1\":{\"245\":1}}],[\"当spi的服务提供者多于一个的时候\",{\"1\":{\"185\":1}}],[\"当这一块的内存使用完后\",{\"1\":{\"245\":1}}],[\"当这些对象不再使用时\",{\"1\":{\"231\":1}}],[\"当放生minor\",{\"1\":{\"242\":1}}],[\"当eden空间不足时\",{\"1\":{\"242\":1}}],[\"当垃圾回收器准备回收一个对象时\",{\"1\":{\"235\":1}}],[\"当引用失效\",{\"1\":{\"233\":1}}],[\"当java堆非常大时\",{\"1\":{\"261\":1}}],[\"当java程序在jvm上运行时\",{\"1\":{\"231\":1}}],[\"当java虚拟机遇到一条字节码new指令时\",{\"1\":{\"214\":1}}],[\"当jvm花太多时间执行垃圾回收并且只能回收很少的堆空间时\",{\"1\":{\"200\":1}}],[\"当jvm执行invokestatic指令时会初始化类\",{\"1\":{\"174\":1}}],[\"当jvm执行putstatic指令时会初始化类\",{\"1\":{\"174\":1}}],[\"当jvm执行getstatic指令时会初始化类\",{\"1\":{\"174\":1}}],[\"当jvm执行new指令时会初始化类\",{\"1\":{\"174\":1}}],[\"当常量池无法再申请到内存时会抛出outofmemoryerror异常\",{\"1\":{\"208\":1}}],[\"当把对象拆开会发现\",{\"1\":{\"198\":1}}],[\"当有足够数量的\",{\"1\":{\"657\":1,\"677\":1}}],[\"当有数据被读之后\",{\"1\":{\"612\":1}}],[\"当有一条记录需要更新的时候\",{\"1\":{\"489\":1,\"569\":1}}],[\"当有\",{\"1\":{\"379\":1,\"628\":1}}],[\"当有了字节码文件或者没有反编译的手段\",{\"1\":{\"180\":1}}],[\"当有更高优先级的进程要运行而被迫让出处理机时\",{\"1\":{\"148\":1}}],[\"当使用到该方法时\",{\"1\":{\"1067\":1}}],[\"当使用代理对象的调度方法\",{\"1\":{\"725\":1}}],[\"当使用\",{\"1\":{\"637\":1}}],[\"当使用多态方式调用方法时\",{\"1\":{\"355\":1}}],[\"当使用serial\",{\"1\":{\"218\":1}}],[\"当使用jdk\",{\"1\":{\"174\":1}}],[\"当使用信号量的时候\",{\"1\":{\"142\":1}}],[\"当虚拟机启动时\",{\"1\":{\"174\":1}}],[\"当遇到单机内存\",{\"1\":{\"678\":1}}],[\"当遇到了进程退出\",{\"1\":{\"646\":1}}],[\"当遇到需要占用8个字节以上空间的数据项时\",{\"1\":{\"284\":1}}],[\"当遇到\",{\"1\":{\"174\":1,\"992\":1}}],[\"当所访问的信息不在内存时\",{\"1\":{\"159\":1}}],[\"当程序中只剩下守护线程时\",{\"1\":{\"143\":1}}],[\"当外围设备完成用户的请求操作后\",{\"1\":{\"134\":1}}],[\"当对数据进行存储或访问时\",{\"1\":{\"880\":1}}],[\"当对表中的数据进行增删改的时候\",{\"1\":{\"528\":1}}],[\"当对一个表做增删改查\",{\"1\":{\"511\":1}}],[\"当对象\",{\"1\":{\"718\":2}}],[\"当对象被反序列化时\",{\"1\":{\"364\":1}}],[\"当对象们所占内存超过最大堆的大小限制就能出现这个异常\",{\"1\":{\"297\":1}}],[\"当对象图扫描完成以后\",{\"1\":{\"264\":1}}],[\"当对象实例数据部分没有对齐时\",{\"1\":{\"227\":1}}],[\"当对\",{\"1\":{\"129\":1}}],[\"当调用者\",{\"1\":{\"801\":1}}],[\"当调用了\",{\"1\":{\"665\":1}}],[\"当调用\",{\"1\":{\"118\":1,\"517\":1}}],[\"当然还有一个全连接队列\",{\"1\":{\"1025\":1}}],[\"当然还有更好的方法\",{\"1\":{\"891\":1}}],[\"当然不一定\",{\"1\":{\"1020\":1}}],[\"当然这样导致维护次数增加\",{\"1\":{\"891\":1}}],[\"当然在更新每条数据的出现次数的时候\",{\"1\":{\"891\":1}}],[\"当然在真正执行缓存查询的时候还是会校验用户的权限\",{\"1\":{\"490\":1}}],[\"当然我们也可以基于\",{\"1\":{\"685\":1}}],[\"当然我们可以做一些缓解的措施\",{\"1\":{\"582\":1}}],[\"当然可以通过\",{\"1\":{\"678\":1}}],[\"当然为了满足业务的高可用性\",{\"1\":{\"674\":1}}],[\"当然是从以可靠性为主\",{\"1\":{\"668\":1}}],[\"当然由于\",{\"1\":{\"649\":1}}],[\"当然也不能重复了\",{\"1\":{\"413\":1}}],[\"当然也不能覆盖\",{\"1\":{\"358\":1}}],[\"当然\",{\"1\":{\"114\":1,\"236\":1,\"262\":1,\"501\":1,\"536\":1,\"655\":1,\"923\":1}}],[\"当同步状态为\",{\"1\":{\"96\":1}}],[\"当撤销偏向锁达到阈值\",{\"1\":{\"88\":1}}],[\"当执行\",{\"1\":{\"82\":1}}],[\"当线程使用\",{\"1\":{\"118\":1}}],[\"当线程要获取锁时\",{\"1\":{\"113\":1}}],[\"当线程退出\",{\"1\":{\"87\":1}}],[\"当线程数设置较大时\",{\"1\":{\"64\":1}}],[\"当线程请求数\",{\"1\":{\"58\":1}}],[\"当往队列里插入一个元素时\",{\"1\":{\"62\":1}}],[\"当队列满了的时候\",{\"1\":{\"1021\":1}}],[\"当队列满时\",{\"1\":{\"62\":1}}],[\"当队列为空时\",{\"1\":{\"62\":1}}],[\"当任务到达时\",{\"1\":{\"53\":1}}],[\"当前事件发生后又会有什么后果\",{\"1\":{\"1216\":1}}],[\"当前系统业务所期待的接口\",{\"1\":{\"1092\":1}}],[\"当前访问的是从库\",{\"1\":{\"664\":1}}],[\"当前访问的\",{\"1\":{\"664\":1}}],[\"当前一节点的长度小于\",{\"1\":{\"627\":1}}],[\"当前读的\",{\"1\":{\"501\":1}}],[\"当前读\",{\"1\":{\"499\":2,\"523\":2}}],[\"当前的事务版本号\",{\"1\":{\"499\":1}}],[\"当前的threadloca的引用作为key\",{\"1\":{\"39\":1}}],[\"当前页\",{\"1\":{\"486\":1}}],[\"当前光标到行尾\",{\"1\":{\"417\":1}}],[\"当前光标到行首\",{\"1\":{\"417\":1}}],[\"当前哈希表的大小\",{\"1\":{\"397\":1}}],[\"当前类需要事先cloneable接口\",{\"1\":{\"212\":1}}],[\"当前最新的安全机制实现\",{\"1\":{\"186\":1}}],[\"当前线程必须是该对象的拥有者\",{\"1\":{\"350\":1}}],[\"当前线程再加入到队列中等待唤醒\",{\"1\":{\"113\":1}}],[\"当前线程等待其他线程已拥有的资源\",{\"1\":{\"98\":1}}],[\"当前线程拥有其他线程需要的资源\",{\"1\":{\"98\":1}}],[\"当前线程可以立马获取到\",{\"1\":{\"81\":1}}],[\"当前线程挂起\",{\"1\":{\"81\":1}}],[\"当前线程获取不到锁\",{\"1\":{\"81\":2}}],[\"当前变量在寄存器\",{\"1\":{\"79\":1}}],[\"当前\",{\"1\":{\"45\":1,\"72\":1,\"643\":1}}],[\"当\",{\"1\":{\"42\":1,\"85\":1,\"89\":2,\"119\":1,\"134\":1,\"144\":1,\"379\":1,\"623\":2,\"635\":1,\"649\":1,\"655\":1,\"657\":1,\"661\":1,\"669\":1,\"676\":1,\"677\":1,\"683\":1,\"846\":1,\"861\":1,\"882\":1,\"938\":2,\"1009\":1}}],[\"当指定时间到了又会自动恢复可运行状态\",{\"1\":{\"35\":1}}],[\"向其他节点并发发送消息的平均响应时间\",{\"1\":{\"879\":1}}],[\"向其它发送通知\",{\"1\":{\"677\":1}}],[\"向kafka中发布消息的角色\",{\"1\":{\"845\":1}}],[\"向服务器端发送\",{\"1\":{\"1060\":1}}],[\"向服务器发送数据\",{\"1\":{\"829\":1}}],[\"向服务端发送\",{\"1\":{\"804\":1}}],[\"向注册中心订阅自己所需的服务\",{\"1\":{\"811\":1}}],[\"向注册中心注册自己提供的服务\",{\"1\":{\"811\":1}}],[\"向客户端响应结果\",{\"1\":{\"754\":1}}],[\"向所有\",{\"1\":{\"677\":1}}],[\"向所有的节点广播该\",{\"1\":{\"878\":1}}],[\"向所有的\",{\"1\":{\"655\":1}}],[\"向右遍历时且最后一个值不满足等值条件的时候\",{\"1\":{\"515\":1}}],[\"向上搜寻\",{\"1\":{\"429\":1}}],[\"向上翻动一页\",{\"1\":{\"429\":1}}],[\"向下翻动一页\",{\"1\":{\"429\":2}}],[\"向下搜寻\",{\"1\":{\"429\":2}}],[\"向\",{\"1\":{\"39\":1,\"755\":1,\"801\":1}}],[\"数值\",{\"1\":{\"1035\":1}}],[\"数值型\",{\"1\":{\"316\":1}}],[\"数字证书\",{\"0\":{\"1057\":1},\"1\":{\"1057\":1}}],[\"数字证书中包含证书持有者\",{\"1\":{\"1044\":1}}],[\"数字签名是非对称加密算法和摘要算法的一种应用\",{\"1\":{\"1057\":1}}],[\"数字签名\",{\"0\":{\"1057\":1},\"1\":{\"1057\":1,\"1062\":1}}],[\"数字分析法\",{\"1\":{\"923\":1}}],[\"数字集很大\",{\"1\":{\"882\":1}}],[\"数字法\",{\"1\":{\"433\":1}}],[\"数和服务器的\",{\"1\":{\"835\":1}}],[\"数量来实现动态负载均衡\",{\"1\":{\"861\":1}}],[\"数量以及\",{\"1\":{\"861\":1}}],[\"数量值或者按照utf\",{\"1\":{\"284\":1}}],[\"数量变少\",{\"1\":{\"42\":1}}],[\"数据字典更大\",{\"1\":{\"1259\":1}}],[\"数据目录\",{\"1\":{\"1177\":1}}],[\"数据传输完毕后\",{\"1\":{\"1023\":1}}],[\"数据传递过程\",{\"0\":{\"963\":1}}],[\"数据偏移\",{\"1\":{\"1007\":1}}],[\"数据包请求连接就会被服务器丢弃\",{\"1\":{\"1060\":1}}],[\"数据包之间并没有状态上的联系\",{\"1\":{\"1001\":1}}],[\"数据包不会超过\",{\"1\":{\"982\":1}}],[\"数据无法访问目标时\",{\"1\":{\"992\":1}}],[\"数据报文一到达\",{\"1\":{\"1060\":1}}],[\"数据报封装的是无法交付的\",{\"1\":{\"994\":1}}],[\"数据报能够成功的到达目的主机\",{\"1\":{\"992\":1}}],[\"数据报的总长度\",{\"1\":{\"987\":1}}],[\"数据都不会超过双方\",{\"1\":{\"982\":1}}],[\"数据压缩协商\",{\"1\":{\"975\":1}}],[\"数据链路\",{\"1\":{\"971\":1}}],[\"数据链路和帧\",{\"0\":{\"971\":1}}],[\"数据链路层向上提供可靠的传输服务\",{\"1\":{\"974\":1}}],[\"数据链路层主要属于计算机网络的低层\",{\"1\":{\"968\":1}}],[\"数据链路层把网络层交下来的ip数据报添加首部和尾部封装成帧发送到链路上\",{\"1\":{\"968\":1}}],[\"数据链路层使用的中间设备叫做交换机\",{\"1\":{\"965\":1}}],[\"数据链路层不仅要检错\",{\"1\":{\"961\":1}}],[\"数据链路层\",{\"1\":{\"961\":2,\"962\":1}}],[\"数据层将网络层交下来的ip数据报组装成帧\",{\"1\":{\"961\":1}}],[\"数据渲染页面\",{\"1\":{\"959\":1,\"1029\":1}}],[\"数据划分\",{\"1\":{\"891\":1}}],[\"数据处理和消息提交放在一个事务里\",{\"1\":{\"866\":1}}],[\"数据处理能力都将遭遇瓶颈\",{\"1\":{\"583\":1}}],[\"数据发送不同分区\",{\"1\":{\"865\":1}}],[\"数据发送到同一个分区中\",{\"1\":{\"865\":1}}],[\"数据复制次数为4\",{\"1\":{\"850\":1}}],[\"数据不会被清除\",{\"1\":{\"844\":1}}],[\"数据改变\",{\"1\":{\"817\":1}}],[\"数据准备好了之后\",{\"1\":{\"804\":1}}],[\"数据准备的过程\",{\"1\":{\"137\":1}}],[\"数据源的配置以及有关数据库连接的参数都在spring的配置文件中进行配置\",{\"1\":{\"762\":1}}],[\"数据验证\",{\"1\":{\"755\":1}}],[\"数据格式化\",{\"1\":{\"755\":1}}],[\"数据转换\",{\"1\":{\"755\":1}}],[\"数据分片\",{\"0\":{\"679\":1}}],[\"数据分片相对比较均匀\",{\"1\":{\"587\":1}}],[\"数据通过异步复制\",{\"1\":{\"678\":1}}],[\"数据节点中的主节点的高可用切换\",{\"1\":{\"676\":1}}],[\"数据节点中\",{\"1\":{\"676\":1}}],[\"数据节点或多组数据节点\",{\"1\":{\"676\":1}}],[\"数据节点的线形扩展\",{\"1\":{\"676\":1}}],[\"数据集群\",{\"1\":{\"676\":1}}],[\"数据丢失\",{\"1\":{\"674\":1}}],[\"数据之前双向同步\",{\"1\":{\"668\":1}}],[\"数据副本\",{\"1\":{\"660\":1,\"678\":1}}],[\"数据按照\",{\"1\":{\"660\":1,\"678\":1}}],[\"数据更少的丢失\",{\"1\":{\"653\":1}}],[\"数据更新到高速缓存以及主存中\",{\"1\":{\"72\":1}}],[\"数据量大\",{\"1\":{\"890\":1,\"891\":1}}],[\"数据量大的时候\",{\"1\":{\"640\":1}}],[\"数据量非常大的时候\",{\"1\":{\"640\":1}}],[\"数据量不大的时候\",{\"1\":{\"640\":1}}],[\"数据量少的表不要使用索引\",{\"1\":{\"532\":1}}],[\"数据结构\",{\"0\":{\"616\":1}}],[\"数据结构简单\",{\"1\":{\"604\":1}}],[\"数据结构优化很好\",{\"1\":{\"604\":1}}],[\"数据页\",{\"1\":{\"591\":1}}],[\"数据迁移问题\",{\"1\":{\"660\":1}}],[\"数据迁移\",{\"1\":{\"589\":1}}],[\"数据较大\",{\"1\":{\"585\":1}}],[\"数据多次扩展难度和维护量极大\",{\"1\":{\"585\":1}}],[\"数据切分就是将数据分散存储到多个数据库中\",{\"1\":{\"585\":1}}],[\"数据一致性\",{\"0\":{\"855\":1}}],[\"数据一致性问题\",{\"1\":{\"411\":1}}],[\"数据一致后称为干净页\",{\"1\":{\"559\":1}}],[\"数据紧密型很高\",{\"1\":{\"541\":1}}],[\"数据表中的数据都是存储在页中的\",{\"1\":{\"539\":1}}],[\"数据唯一性差的字段不要使用索引\",{\"1\":{\"532\":1}}],[\"数据的读取都是不加锁的\",{\"1\":{\"522\":1}}],[\"数据的可见性和有序性\",{\"1\":{\"72\":1}}],[\"数据保持一致\",{\"1\":{\"519\":1}}],[\"数据定义语句\",{\"1\":{\"501\":1}}],[\"数据操作语句\",{\"1\":{\"501\":1}}],[\"数据文件分段\",{\"0\":{\"848\":1}}],[\"数据文件由多个数据块\",{\"1\":{\"543\":1}}],[\"数据文件\",{\"1\":{\"493\":1}}],[\"数据以紧密格式存储\",{\"1\":{\"492\":1}}],[\"数据进去\",{\"1\":{\"411\":1}}],[\"数据进行操作的代码\",{\"1\":{\"383\":1}}],[\"数据在两个地址空间中传输时\",{\"1\":{\"378\":1}}],[\"数据到接收方\",{\"1\":{\"1006\":1}}],[\"数据到达接收端后放入接收缓存\",{\"1\":{\"1004\":1}}],[\"数据到达\",{\"1\":{\"377\":1}}],[\"数据到工作内存\",{\"1\":{\"73\":1}}],[\"数据总是从通道读取到缓冲区中\",{\"1\":{\"377\":1}}],[\"数据插入或删除\",{\"1\":{\"372\":1}}],[\"数据查找方面\",{\"1\":{\"372\":1}}],[\"数据类型\",{\"0\":{\"365\":1,\"471\":1},\"1\":{\"610\":1,\"624\":1}}],[\"数据加载到内存\",{\"1\":{\"139\":1}}],[\"数据从内核空间拷贝到用户进程缓冲区的过程\",{\"1\":{\"137\":1}}],[\"数据段即b+树的叶子节点\",{\"1\":{\"498\":1}}],[\"数据段是给进程自己用的\",{\"1\":{\"136\":1}}],[\"数据段\",{\"1\":{\"129\":1,\"136\":2}}],[\"数据依赖性\",{\"1\":{\"76\":1}}],[\"数据\",{\"1\":{\"73\":2,\"591\":2,\"804\":1,\"820\":3,\"880\":2}}],[\"数据库索引\",{\"0\":{\"887\":1},\"1\":{\"891\":1}}],[\"数据库无关性好\",{\"1\":{\"749\":1}}],[\"数据库是一个单点\",{\"1\":{\"668\":1}}],[\"数据库就会\",{\"1\":{\"606\":1}}],[\"数据库并提供多种语言的\",{\"1\":{\"603\":1}}],[\"数据库并发场景\",{\"1\":{\"499\":1}}],[\"数据库并发太多影响其\",{\"1\":{\"64\":1}}],[\"数据库分片常用的分片的方法\",{\"0\":{\"588\":1}}],[\"数据库分片的两种常见方案\",{\"0\":{\"586\":1}}],[\"数据库分布式核心内容无非就是数据切分\",{\"1\":{\"585\":1}}],[\"数据库可能是分布式在不同的实例和不同的主机上\",{\"1\":{\"585\":1}}],[\"数据库连接池\",{\"1\":{\"1091\":1}}],[\"数据库连接数\",{\"1\":{\"585\":1}}],[\"数据库连接等可以用到\",{\"1\":{\"39\":1,\"44\":1}}],[\"数据库缓存放不下\",{\"1\":{\"584\":1}}],[\"数据库中的数据量不一定是可控的\",{\"1\":{\"583\":1}}],[\"数据库在宕机重启后能够保证\",{\"1\":{\"577\":1}}],[\"数据库增量备份和恢复\",{\"1\":{\"571\":1}}],[\"数据库访问磁盘数据的基本单位\",{\"1\":{\"543\":1}}],[\"数据库磁盘io\",{\"1\":{\"543\":1}}],[\"数据库里面它可能用到的回滚记录都必须保留\",{\"1\":{\"525\":1}}],[\"数据库里面会创建一个视图\",{\"1\":{\"524\":1}}],[\"数据库一般都不会用\",{\"1\":{\"522\":1}}],[\"数据库事务可以保证多个对数据库的操作\",{\"1\":{\"518\":1}}],[\"数据库事务有什么作用呢\",{\"1\":{\"518\":1}}],[\"数据库的设计非常灵活\",{\"1\":{\"601\":1}}],[\"数据库的读分为快照读和当前读\",{\"1\":{\"523\":1}}],[\"数据库的隔离等级\",{\"1\":{\"499\":1}}],[\"数据库的三大范式\",{\"0\":{\"455\":1}}],[\"数据库重新启动的时候会保证数据库恢复到崩溃前的状态\",{\"1\":{\"493\":1}}],[\"数据库异常崩溃后的安全恢复\",{\"1\":{\"493\":1}}],[\"数据库管理人员等\",{\"1\":{\"457\":1}}],[\"数据库管理系统\",{\"1\":{\"457\":2}}],[\"数据库系统是一个通称\",{\"1\":{\"457\":1}}],[\"数据库系统\",{\"1\":{\"457\":1}}],[\"数据库\",{\"1\":{\"457\":1,\"751\":1,\"881\":1}}],[\"数据库表中不能出现重复记录\",{\"1\":{\"455\":1}}],[\"数组中的一个元素可以记录32个整数\",{\"1\":{\"903\":1}}],[\"数组中的元素可以是基本数据类型也可以是对象\",{\"1\":{\"785\":1}}],[\"数组中每个元素都是integer类型的\",{\"1\":{\"903\":1}}],[\"数组中\",{\"1\":{\"875\":1}}],[\"数组大小翻倍\",{\"1\":{\"402\":1}}],[\"数组保存所有\",{\"1\":{\"396\":1}}],[\"数组+链表结构\",{\"1\":{\"396\":1}}],[\"数组汇总的每一项又是一个链表\",{\"1\":{\"396\":1}}],[\"数组类型转换异常\",{\"1\":{\"385\":1}}],[\"数组类型不通过类加载器创建\",{\"1\":{\"168\":1}}],[\"数组角标越界异常\",{\"1\":{\"385\":1}}],[\"数组应用场景\",{\"1\":{\"373\":1}}],[\"数组和链表的应用场景\",{\"0\":{\"373\":1}}],[\"数组和链表的区别\",{\"0\":{\"372\":1}}],[\"数组有越界问题\",{\"1\":{\"372\":1}}],[\"数组的每一个元素对应保存一个数据\",{\"1\":{\"627\":1}}],[\"数组的初始大小才\",{\"1\":{\"405\":1}}],[\"数组的线性查找速度快\",{\"1\":{\"372\":1}}],[\"数组的数据进行修改时\",{\"1\":{\"129\":1}}],[\"数组是一块连续的空间\",{\"1\":{\"372\":1}}],[\"数组进行扩容\",{\"1\":{\"129\":1}}],[\"数组等方式实现了这个接口\",{\"1\":{\"108\":1}}],[\"数组\",{\"0\":{\"4\":1},\"1\":{\"128\":1,\"129\":1,\"395\":2,\"1035\":1}}],[\"实体中的属性全部展开\",{\"1\":{\"1246\":1}}],[\"实体既然是聚合根中的一个属性\",{\"1\":{\"1246\":1}}],[\"实体是聚合根中的一个属性\",{\"1\":{\"1240\":1}}],[\"实体执行命令\",{\"1\":{\"1234\":1}}],[\"实体和事件的关系\",{\"0\":{\"1234\":1}}],[\"实体代码应该包括属性和行为\",{\"1\":{\"1230\":1}}],[\"实体具有唯一标识\",{\"1\":{\"1230\":1}}],[\"实体\",{\"0\":{\"1230\":1,\"1233\":1},\"1\":{\"751\":1,\"1236\":1,\"1243\":1}}],[\"实质执行的是\",{\"1\":{\"1084\":1}}],[\"实质\",{\"1\":{\"737\":1}}],[\"实质化之后调用\",{\"1\":{\"733\":1}}],[\"实质上\",{\"1\":{\"391\":1,\"399\":1}}],[\"实在是担心排序内存太小\",{\"1\":{\"484\":1}}],[\"实时的从leader中同步数据\",{\"1\":{\"845\":1}}],[\"实时性相对于push方式会低一些\",{\"1\":{\"843\":1}}],[\"实时查看\",{\"1\":{\"557\":1}}],[\"实时查看和修改jvm配置参数\",{\"1\":{\"312\":1}}],[\"实时显示系统中各个进程的资源占用情况\",{\"1\":{\"436\":1}}],[\"实际使用中\",{\"1\":{\"1057\":1}}],[\"实际场景中的⽹络环节是错综复杂的\",{\"1\":{\"961\":1}}],[\"实际中我们没有那么多节点\",{\"1\":{\"880\":1}}],[\"实际是将之前的去重操作放在了数据上游来做\",{\"1\":{\"856\":1}}],[\"实际是三个步骤\",{\"1\":{\"101\":1,\"1068\":1}}],[\"实际选择的索引\",{\"1\":{\"702\":1}}],[\"实际生产中\",{\"1\":{\"657\":1,\"675\":1}}],[\"实际开发中有可能一张表数据太多\",{\"1\":{\"455\":1}}],[\"实际开发中可以增加随机睡眠时间来解决活锁\",{\"1\":{\"99\":1}}],[\"实际情况往往是这样\",{\"1\":{\"452\":1}}],[\"实际类型\",{\"1\":{\"277\":1}}],[\"实际上输出这个\",{\"1\":{\"1090\":1}}],[\"实际上相当于ssl的后续版本\",{\"1\":{\"1062\":1}}],[\"实际上ip地址是标志一台主机\",{\"1\":{\"984\":1}}],[\"实际上可能想直接将数据均分到不同的机子上进行处理\",{\"1\":{\"891\":1}}],[\"实际上就是在原代码逻辑前后增加一些代码逻辑\",{\"1\":{\"1081\":1}}],[\"实际上就是map\",{\"1\":{\"891\":1}}],[\"实际上就是多路复用\",{\"1\":{\"377\":1}}],[\"实际上应该指去除重复后的数据量\",{\"1\":{\"891\":1}}],[\"实际上很多所谓的\",{\"1\":{\"806\":1}}],[\"实际上已经不存在热点\",{\"1\":{\"643\":1}}],[\"实际上主从同步延迟根本没有什么一招制敌的办法\",{\"1\":{\"582\":1}}],[\"实际上也只有普通索引可以使用\",{\"1\":{\"574\":1}}],[\"实际上它是可以持久化的数据\",{\"1\":{\"574\":1}}],[\"实际上\",{\"1\":{\"568\":1,\"886\":1,\"1057\":1}}],[\"实际上才发生了一次io\",{\"1\":{\"543\":1}}],[\"实际上现在很多互联网业务数据记录大小通常就是\",{\"1\":{\"539\":1}}],[\"实际上只需要\",{\"1\":{\"464\":1}}],[\"实际上是指出了tcp报文段的首部长度\",{\"1\":{\"1007\":1}}],[\"实际上是\",{\"1\":{\"381\":1}}],[\"实际上大多就是老年代\",{\"1\":{\"245\":1}}],[\"实际上该对象此时还没有完全初始化\",{\"1\":{\"101\":1,\"1068\":1}}],[\"实例化阶段主要是通过反射或者cglib对bean进行实例化\",{\"1\":{\"737\":1}}],[\"实例化之前调用\",{\"1\":{\"733\":1}}],[\"实例化一个类时\",{\"1\":{\"729\":1}}],[\"实例化对象需要分为三个步骤\",{\"1\":{\"714\":1}}],[\"实例化\",{\"1\":{\"712\":1,\"733\":2}}],[\"实例上呢\",{\"0\":{\"680\":1}}],[\"实例发送一个\",{\"1\":{\"677\":1}}],[\"实例成功获取锁\",{\"1\":{\"672\":1}}],[\"实例从第一台机器迁移到第二台机器\",{\"1\":{\"671\":1}}],[\"实例从一台服务迁移到另外一台服务器而已\",{\"1\":{\"671\":1}}],[\"实例变量\",{\"1\":{\"363\":2}}],[\"实例变量将会在对象实例化时随着对象一起分配在java堆中\",{\"1\":{\"171\":1}}],[\"实例数据部分是对象真正存储的有效信息\",{\"1\":{\"226\":1}}],[\"实例数据\",{\"0\":{\"226\":1}}],[\"实例数据和对齐填充\",{\"1\":{\"224\":1}}],[\"实例构造器\",{\"1\":{\"194\":1,\"275\":1}}],[\"实例没创建\",{\"1\":{\"101\":1}}],[\"实例和\",{\"1\":{\"45\":1}}],[\"实例\",{\"1\":{\"39\":1,\"348\":1,\"657\":1,\"671\":1,\"672\":2,\"734\":2}}],[\"实例需要在多个方法中共享\",{\"1\":{\"39\":1,\"44\":1}}],[\"实现代码的开发落地\",{\"1\":{\"1224\":1}}],[\"实现代理逻辑方法\",{\"1\":{\"725\":1}}],[\"实现关系使用带空心三角箭头的虚线来表示\",{\"1\":{\"1101\":1}}],[\"实现关系是接口与实现类之间的关系\",{\"1\":{\"1101\":1}}],[\"实现关系\",{\"0\":{\"1101\":1}}],[\"实现系统的部分功能\",{\"1\":{\"1090\":1}}],[\"实现抽象类中所定义的抽象方法和钩子方法\",{\"1\":{\"1087\":1}}],[\"实现抽象装饰的相关方法\",{\"1\":{\"1085\":1}}],[\"实现抽象构件\",{\"1\":{\"1085\":1}}],[\"实现多路并行并不依赖于建立多个tcp连接\",{\"1\":{\"1042\":1}}],[\"实现会话粘滞\",{\"1\":{\"869\":1}}],[\"实现高性能\",{\"1\":{\"840\":1}}],[\"实现数据发布\",{\"1\":{\"816\":1}}],[\"实现数据序列化\",{\"1\":{\"804\":1}}],[\"实现更大的吞吐量和并发数\",{\"1\":{\"805\":1}}],[\"实现热部署有哪几种方式\",{\"0\":{\"782\":1}}],[\"实现配置文件的功能\",{\"1\":{\"777\":1}}],[\"实现自动配置功能\",{\"1\":{\"771\":1}}],[\"实现自定义插件\",{\"1\":{\"753\":1}}],[\"实现类要单一\",{\"1\":{\"1064\":1}}],[\"实现类支持不同的\",{\"1\":{\"756\":1}}],[\"实现类对象\",{\"1\":{\"725\":1}}],[\"实现该接口的setapplicationcontext\",{\"1\":{\"736\":1}}],[\"实现接口\",{\"1\":{\"736\":1}}],[\"实现接口会更好一些\",{\"1\":{\"32\":1}}],[\"实现里面的invoke方法\",{\"1\":{\"725\":1}}],[\"实现具有依赖关系的对象之间的解耦\",{\"1\":{\"718\":1}}],[\"实现复杂\",{\"1\":{\"678\":1}}],[\"实现分布式锁的方式名叫\",{\"1\":{\"672\":1}}],[\"实现分布式锁\",{\"0\":{\"669\":1}}],[\"实现快速故障恢复\",{\"1\":{\"655\":1,\"661\":1}}],[\"实现方案\",{\"1\":{\"640\":1}}],[\"实现方式\",{\"1\":{\"343\":1,\"890\":1}}],[\"实现考虑\",{\"1\":{\"630\":1}}],[\"实现却更简单\",{\"1\":{\"630\":1}}],[\"实现可以做到稳定性\",{\"1\":{\"930\":1,\"932\":1,\"934\":1}}],[\"实现可以节省不少\",{\"1\":{\"622\":1}}],[\"实现可重入\",{\"1\":{\"96\":1}}],[\"实现了抽象策略定义的接口\",{\"1\":{\"1088\":1}}],[\"实现了抽象产品角色所定义的接口\",{\"1\":{\"1079\":1}}],[\"实现了类似\",{\"1\":{\"1042\":1}}],[\"实现了disposablebean接口的bean\",{\"1\":{\"737\":1}}],[\"实现了initializingbean接口的bean\",{\"1\":{\"737\":1}}],[\"实现了ioc原则\",{\"1\":{\"718\":1}}],[\"实现了beanpostprocessor接口的bean\",{\"1\":{\"737\":1}}],[\"实现了需要代理的类接口\",{\"1\":{\"715\":1}}],[\"实现了空间预分配和惰性空间释放两种策略\",{\"1\":{\"624\":1}}],[\"实现了四个标准的隔离级别\",{\"1\":{\"491\":1}}],[\"实现了\",{\"1\":{\"392\":2,\"659\":1,\"678\":1}}],[\"实现了这个接口的集合对象支持迭代\",{\"1\":{\"389\":1}}],[\"实现对象排序的方式有两种\",{\"1\":{\"390\":1}}],[\"实现对象的浅复制\",{\"1\":{\"350\":1}}],[\"实现跨平台的最核心的部分\",{\"1\":{\"335\":1}}],[\"实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟\",{\"1\":{\"268\":1}}],[\"实现同样的功能需要更多的指令\",{\"1\":{\"190\":1}}],[\"实现不同的中间件隔离\",{\"1\":{\"180\":1}}],[\"实现虚拟技术的两个关键点\",{\"1\":{\"157\":1}}],[\"实现简单高效\",{\"1\":{\"129\":1}}],[\"实现公平锁\",{\"1\":{\"94\":1}}],[\"实现的是本地缓存\",{\"1\":{\"609\":1}}],[\"实现的\",{\"1\":{\"81\":1,\"103\":1,\"408\":1}}],[\"实现一种可重入锁\",{\"1\":{\"81\":1}}],[\"实现原理\",{\"1\":{\"62\":1,\"729\":1,\"737\":1}}],[\"实现\",{\"1\":{\"31\":1,\"62\":1,\"617\":1,\"619\":2,\"622\":1,\"642\":2,\"655\":1,\"661\":2,\"668\":2,\"754\":1,\"799\":1,\"800\":1,\"882\":1,\"1042\":2,\"1065\":1,\"1077\":1,\"1086\":1}}],[\"每人一个\",{\"1\":{\"1051\":1}}],[\"每发送一组数据就对这组数据进行异或运算\",{\"1\":{\"1042\":1}}],[\"每发生一次minor\",{\"1\":{\"241\":1}}],[\"每得到一个新的rtt\",{\"1\":{\"1012\":1}}],[\"每从网络上收到一个mac帧就先用硬件检查mac帧中的目的地址\",{\"1\":{\"979\":1}}],[\"每⼀台设备的⽹卡都会有⼀个\",{\"1\":{\"961\":1}}],[\"每行一个词\",{\"0\":{\"899\":1}}],[\"每台服务器需要处理的请求数目相同\",{\"1\":{\"869\":1}}],[\"每台机器上的数据是一样的\",{\"1\":{\"658\":1}}],[\"每执行一个写命令就像\",{\"1\":{\"655\":1}}],[\"每执行一个线程\",{\"1\":{\"51\":1}}],[\"每秒钟写入磁盘一次\",{\"1\":{\"650\":1}}],[\"每处理一个请求时\",{\"1\":{\"615\":1}}],[\"每条记录都发生改变\",{\"1\":{\"572\":1}}],[\"每条线程有自己的工作内存\",{\"1\":{\"74\":1}}],[\"每条线程还有自己的工作内存\",{\"1\":{\"66\":1}}],[\"每隔一定字节的数据建立一条索引\",{\"1\":{\"848\":1}}],[\"每隔一定时间把数据库中的超时数据清理一遍\",{\"1\":{\"668\":1}}],[\"每隔一定的时间\",{\"1\":{\"632\":1}}],[\"每隔一秒把缓冲区中的内容写入磁盘\",{\"1\":{\"650\":1}}],[\"每隔\",{\"1\":{\"568\":1}}],[\"每页数据量\",{\"1\":{\"486\":1}}],[\"每天\",{\"1\":{\"452\":1}}],[\"每插入一个放在最后面一个\",{\"1\":{\"414\":1}}],[\"每一种链路层协议都规定了所能传送的帧的数据部分长度上限\",{\"1\":{\"972\":1}}],[\"每一层对应的网络协议有哪些\",{\"0\":{\"962\":1}}],[\"每一帧包括数据和必要的控制信息\",{\"1\":{\"961\":1}}],[\"每一条会修改数据的sql都会记录在binlog中\",{\"1\":{\"572\":1}}],[\"每一条对数据进行修改的\",{\"1\":{\"566\":1}}],[\"每一次请求被拦截资源时执行\",{\"1\":{\"759\":1}}],[\"每一次会话都会产生一个新的\",{\"1\":{\"734\":1}}],[\"每一次\",{\"1\":{\"734\":1}}],[\"每一次http请求都会创建一个新的bean\",{\"1\":{\"713\":2}}],[\"每一次io读取的数据我们称之为一页\",{\"1\":{\"543\":1}}],[\"每一次gc前和gc后\",{\"1\":{\"325\":1}}],[\"每一行必须唯一\",{\"1\":{\"455\":1}}],[\"每一个网点都有一个服务器进程\",{\"1\":{\"1037\":1}}],[\"每一个叶节点包含所对应别的网络前缀和子网掩码\",{\"1\":{\"991\":1}}],[\"每一个客户端的请求都包含一条需要被复制状态机\",{\"1\":{\"878\":1}}],[\"每一个客户端连接\",{\"1\":{\"380\":1}}],[\"每一个任期的开始都是一次选举\",{\"1\":{\"876\":1}}],[\"每一个事件成为\",{\"1\":{\"875\":1}}],[\"每一个节点负责维护一部分槽以及槽所映射的键值数据\",{\"1\":{\"679\":1}}],[\"每一个动态代理类都必须要实现\",{\"1\":{\"349\":1}}],[\"每一个层次的类加载器都是如此\",{\"1\":{\"184\":1}}],[\"每一个线性地址都由第一级页表\",{\"1\":{\"156\":1}}],[\"每一个线程维护一个\",{\"1\":{\"39\":1}}],[\"每一个页表的大小均为\",{\"1\":{\"156\":1}}],[\"每一个进程都有一个\",{\"1\":{\"156\":1}}],[\"每一个\",{\"1\":{\"62\":1,\"875\":1,\"877\":1}}],[\"每当发现\",{\"1\":{\"973\":1}}],[\"每当发生散列地址冲突时\",{\"1\":{\"924\":1}}],[\"每当主服务器执行客户端发送写命令时\",{\"1\":{\"662\":1}}],[\"每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作\",{\"1\":{\"294\":1}}],[\"每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作\",{\"1\":{\"294\":1}}],[\"每当有一个地方引用它\",{\"1\":{\"233\":1}}],[\"每次更新\",{\"1\":{\"1139\":1}}],[\"每次发送的\",{\"1\":{\"982\":1}}],[\"每次调整的最大次数是\",{\"1\":{\"937\":1}}],[\"每次调度时选择当前已经到达就绪队列且运行时间最短的进程\",{\"1\":{\"150\":1}}],[\"每次划分只得到一个比上一次划分少一个记录的子序列\",{\"1\":{\"935\":1}}],[\"每次把最小的值交换到前面\",{\"1\":{\"931\":1}}],[\"每次把最大的值交换到后面\",{\"1\":{\"930\":1}}],[\"每次进入新一轮的投票后\",{\"1\":{\"820\":1}}],[\"每次进行bgsave操作都要执行\",{\"1\":{\"648\":1}}],[\"每次请求都会创建一个新的\",{\"1\":{\"734\":1}}],[\"每次请求都会创建一个新的bean实例\",{\"1\":{\"713\":1}}],[\"每次删除元素时\",{\"1\":{\"623\":1}}],[\"每次对字典执行添加\",{\"1\":{\"623\":1}}],[\"每次增删改查\",{\"1\":{\"623\":1}}],[\"每次操作时都传入整个\",{\"1\":{\"612\":1}}],[\"每次写入1m\",{\"1\":{\"593\":1}}],[\"每次访问都是落到单一的库上\",{\"1\":{\"585\":1}}],[\"每次查询时会产生大量的io\",{\"1\":{\"584\":1}}],[\"每次查找数据时\",{\"1\":{\"549\":1}}],[\"每次读取数据花费的时间可以分为寻道时间\",{\"1\":{\"543\":1}}],[\"每次都获取⼀个新的read\",{\"1\":{\"499\":1}}],[\"每次1mb顺序的写入到共享表空间的物理磁盘上\",{\"1\":{\"496\":1}}],[\"每次插入新的记录\",{\"1\":{\"466\":1}}],[\"每次本地提交后\",{\"1\":{\"452\":1}}],[\"每次扩容通过\",{\"1\":{\"406\":1}}],[\"每次\",{\"1\":{\"381\":1}}],[\"每次执行增删改查查操作时\",{\"1\":{\"623\":1}}],[\"每次执行\",{\"1\":{\"303\":1}}],[\"每次根据允许的收集时间\",{\"1\":{\"260\":1}}],[\"每次只要对引用进行更新\",{\"1\":{\"250\":1}}],[\"每次minor\",{\"1\":{\"247\":1}}],[\"每次不加锁而是假设没有冲突而去完成某项操作\",{\"1\":{\"219\":1}}],[\"每次去拿数据的时候都认为别人不会修改\",{\"1\":{\"103\":1}}],[\"每次重入仍然需要执行\",{\"1\":{\"88\":1}}],[\"每次指向到synchronized代码块时\",{\"1\":{\"87\":1}}],[\"每次使用ctrl+s时\",{\"1\":{\"282\":1}}],[\"每次使用其中的一块\",{\"1\":{\"245\":1}}],[\"每次使用都需要从主存中读取\",{\"1\":{\"79\":1}}],[\"每次使用它都到主存中进行读取\",{\"1\":{\"78\":1}}],[\"每次获取副本值时\",{\"1\":{\"39\":1,\"41\":1}}],[\"每个子域都可以作为一个独立的微服务进行设计和开发\",{\"1\":{\"1221\":1}}],[\"每个学生也可向多个老师学\",{\"1\":{\"1097\":1}}],[\"每个老师可以教多个学生\",{\"1\":{\"1097\":1}}],[\"每个项目两天\",{\"1\":{\"1032\":1}}],[\"每个字段都是2个字节\",{\"1\":{\"1002\":1}}],[\"每个字段是原子性的不能再分\",{\"1\":{\"455\":1}}],[\"每个非根的分支结点\",{\"1\":{\"919\":1}}],[\"每个结点的值都大于或等于其左右孩子结点的值\",{\"1\":{\"937\":1}}],[\"每个结点的值\",{\"1\":{\"919\":1}}],[\"每个结点拥有\",{\"1\":{\"918\":1}}],[\"每个数分配2bit\",{\"1\":{\"900\":1}}],[\"每个url各占64字节\",{\"0\":{\"896\":1}}],[\"每个查询串的长度为1\",{\"0\":{\"893\":1}}],[\"每个小文件最多包含\",{\"1\":{\"892\":1}}],[\"每个机器最多存o\",{\"1\":{\"891\":1}}],[\"每个机器上有n个数\",{\"1\":{\"891\":1}}],[\"每个不超过255字节\",{\"1\":{\"890\":1}}],[\"每个文件的每一行存放的都是用户的query\",{\"0\":{\"895\":1}}],[\"每个文件的每一行都存放的是用户的query\",{\"1\":{\"890\":1}}],[\"每个文件的query都可能重复\",{\"0\":{\"895\":1},\"1\":{\"890\":1}}],[\"每个文件1g\",{\"0\":{\"895\":1},\"1\":{\"890\":1}}],[\"每个文档指向了一个它所包含的索引项的序列\",{\"1\":{\"888\":1}}],[\"每个号码为8位数字\",{\"1\":{\"883\":1}}],[\"每个副本最后的一个offset\",{\"1\":{\"855\":1}}],[\"每个partition通过调整以适应它所在的机器\",{\"1\":{\"852\":1}}],[\"每个partition是一个有序的队列\",{\"1\":{\"845\":1}}],[\"每个分区多个副本的从角色\",{\"1\":{\"845\":1}}],[\"每个分区多个副本的主角色\",{\"1\":{\"845\":1}}],[\"每个worker支持最大的连接数是1024\",{\"1\":{\"836\":1}}],[\"每个请求按访问\",{\"1\":{\"832\":1}}],[\"每个请求按时间顺序逐一分配到不同的后端服务器\",{\"1\":{\"832\":1}}],[\"每个服务器一定会处于以下三个状态中的一个\",{\"1\":{\"874\":1}}],[\"每个服务器启动后先选自己\",{\"1\":{\"820\":1}}],[\"每个服务器具有相同的库和表\",{\"1\":{\"585\":1}}],[\"每个接口分别封装各自的业务处理的方法\",{\"1\":{\"763\":1}}],[\"每个模型都有一个service接口\",{\"1\":{\"763\":1}}],[\"每个参数代表一个对其他类的依赖\",{\"1\":{\"730\":1}}],[\"每个计算结果位置都放置一个此服务节点\",{\"1\":{\"681\":1}}],[\"每个客户端对某个方法加锁时\",{\"1\":{\"668\":1}}],[\"每个客户端连接过来后\",{\"1\":{\"377\":1}}],[\"每个写命令执行完\",{\"1\":{\"650\":1}}],[\"每个设置过期时间的\",{\"1\":{\"632\":1}}],[\"每个层都带有两个属性\",{\"1\":{\"630\":1}}],[\"每个实例都保存了一份缓存\",{\"1\":{\"609\":1}}],[\"每个评论都有一个parent\",{\"1\":{\"601\":1}}],[\"每个表中只包含一部分数据\",{\"1\":{\"585\":1}}],[\"每个节点的存放数据上限为1m\",{\"1\":{\"818\":1}}],[\"每个节点都会存储当前的\",{\"1\":{\"876\":1}}],[\"每个节点都可以包含多层指针\",{\"1\":{\"630\":1}}],[\"每个节点都包含score\",{\"1\":{\"630\":1}}],[\"每个节点都有\",{\"1\":{\"622\":1}}],[\"每个节点只存储了主键和一个存储了子节点指针的列表\",{\"1\":{\"542\":1}}],[\"每个节点要保存相邻结点指针\",{\"1\":{\"372\":1}}],[\"每个基于\",{\"1\":{\"494\":1}}],[\"每个commit占据一行\",{\"1\":{\"449\":1}}],[\"每个class文件的头4个字节被称为魔数\",{\"1\":{\"285\":1}}],[\"每个用户都有一个自己的目录\",{\"1\":{\"416\":1}}],[\"每个类都有一个\",{\"1\":{\"348\":1}}],[\"每个thread中都具备一个threadlocalmap\",{\"1\":{\"299\":1}}],[\"每个记录精确到一块内存区域\",{\"1\":{\"249\":1}}],[\"每个记录精确到一个对象\",{\"1\":{\"249\":1}}],[\"每个记录精确到一个机器字长\",{\"1\":{\"249\":1}}],[\"每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用\",{\"1\":{\"194\":1}}],[\"每个栈帧都包括了局部变量表\",{\"1\":{\"191\":1}}],[\"每个方法被执行时\",{\"1\":{\"190\":1}}],[\"每个页面\",{\"1\":{\"153\":1}}],[\"每个协程拥有自己的执行栈\",{\"1\":{\"139\":1}}],[\"每个线程有自己\",{\"1\":{\"571\":1}}],[\"每个线程一个\",{\"1\":{\"571\":1}}],[\"每个线程遇到外部未准备好的时候\",{\"1\":{\"377\":1}}],[\"每个线程拥有自己的栈空间并且占用一些\",{\"1\":{\"377\":1}}],[\"每个线程还有自己的工作内存\",{\"1\":{\"337\":1}}],[\"每个线程轮流执行\",{\"1\":{\"144\":1}}],[\"每个线程都有一个私有的工作内存\",{\"1\":{\"294\":1}}],[\"每个线程都可以拥有自己的消息队列\",{\"1\":{\"141\":1}}],[\"每个线程都是一个线程\",{\"1\":{\"136\":1}}],[\"每个线程调用await方法告诉\",{\"1\":{\"120\":1}}],[\"每个线程需要有自己单独的实例\",{\"1\":{\"39\":1,\"44\":1}}],[\"每个\",{\"1\":{\"39\":1,\"41\":1,\"42\":1,\"85\":1,\"117\":1,\"645\":1,\"657\":2,\"677\":1,\"678\":1,\"679\":1,\"834\":1,\"835\":2,\"861\":2,\"878\":1}}],[\"由基础层依赖领域层实现这个接口\",{\"1\":{\"1242\":1}}],[\"由子类实现\",{\"1\":{\"1087\":1}}],[\"由具体子类实现\",{\"1\":{\"1087\":1}}],[\"由具体建造者来创建其各个零部件\",{\"1\":{\"1086\":1}}],[\"由具体工厂来创建\",{\"1\":{\"1079\":1}}],[\"由小到大逐渐增大发送窗口\",{\"1\":{\"1019\":1}}],[\"由发送方的应用程序指明发送\",{\"1\":{\"1016\":1}}],[\"由4个字段组成\",{\"1\":{\"1002\":1}}],[\"由网络前缀和下一跳地址组成\",{\"1\":{\"991\":1}}],[\"由大量网络和连接这些网络的路由器组成\",{\"1\":{\"960\":1}}],[\"由所有连接在互联网上的主机组成\",{\"1\":{\"960\":1}}],[\"由容器包装为httpresponse返回给客户端\",{\"1\":{\"959\":1,\"1029\":1}}],[\"由容器去维护具体的对象\",{\"1\":{\"718\":1}}],[\"由group+partition+topic来唯一确定offset\",{\"1\":{\"860\":1}}],[\"由leader维护\",{\"1\":{\"853\":1}}],[\"由一些事件自动触发\",{\"1\":{\"759\":1}}],[\"由一个统一的证书管理机构来管理所有需要发送数据方的公钥\",{\"1\":{\"1057\":1}}],[\"由一个工厂类根据传入的参数\",{\"1\":{\"737\":1}}],[\"由一个字节长度的\",{\"1\":{\"280\":1}}],[\"由我们根据自己业务开发\",{\"1\":{\"756\":1}}],[\"由它调用其它组件处理用户的请求\",{\"1\":{\"756\":1}}],[\"由它所完成的功能决定\",{\"1\":{\"155\":1}}],[\"由主动行为变为了被动行为\",{\"1\":{\"718\":1}}],[\"由代理对象控制原对象的引用\",{\"1\":{\"715\":1}}],[\"由领头的\",{\"1\":{\"677\":1}}],[\"由操作系统决定何时将缓冲区内容写回磁盘\",{\"1\":{\"650\":1}}],[\"由操作系统负责将内存中暂时用不到的信息换出到外存\",{\"1\":{\"159\":1}}],[\"由操作系统负责将所需信息从外存调入内存\",{\"1\":{\"159\":1}}],[\"由操作系统负责将所需信息从磁盘调入内存\",{\"1\":{\"157\":1}}],[\"由三部分组成\",{\"1\":{\"623\":1}}],[\"由第一行开始显示文件内容\",{\"1\":{\"428\":1}}],[\"由根目录\",{\"1\":{\"418\":1}}],[\"由多个无符号数或者其他表作为数据项构成的复合数据类型\",{\"1\":{\"284\":1}}],[\"由多条收集器线程并行完成的\",{\"1\":{\"264\":1}}],[\"由数组实现\",{\"1\":{\"192\":1}}],[\"由数组组成的有界阻塞队列\",{\"1\":{\"62\":1}}],[\"由系统决定\",{\"1\":{\"155\":1}}],[\"由用户态进行调度的多任务模型\",{\"1\":{\"139\":1}}],[\"由其它线程调用\",{\"1\":{\"98\":1}}],[\"由链表结构组成的有界阻塞队列\",{\"1\":{\"62\":1}}],[\"由于很难建立起正常连接\",{\"1\":{\"1060\":1}}],[\"由于非对称加密的方式不需要发送用来解密的私钥\",{\"1\":{\"1056\":1}}],[\"由于http是一种无状态的协议\",{\"1\":{\"1051\":1}}],[\"由于域名改动并不频繁\",{\"1\":{\"1032\":1}}],[\"由于名字到地址的绑定并不经常改变\",{\"1\":{\"1032\":1}}],[\"由于采用网络前缀这种记法\",{\"1\":{\"991\":1}}],[\"由于一个cidr地址块中有很多地址\",{\"1\":{\"991\":1}}],[\"由于ip地址使用软件实现的\",{\"1\":{\"981\":1}}],[\"由于incrby命令可以实现原子性的递增\",{\"1\":{\"603\":1}}],[\"由于比较复杂\",{\"1\":{\"965\":1}}],[\"由于单链表不知道其长度\",{\"1\":{\"927\":1}}],[\"由于broadcasttime和mtbf是由系统决定的属性\",{\"1\":{\"879\":1}}],[\"由于可能同一时刻出现多个\",{\"1\":{\"877\":1}}],[\"由于事务状态得到保存\",{\"1\":{\"863\":1}}],[\"由于consumer在消费过程中可能会出现断电宕机等故障\",{\"1\":{\"860\":1}}],[\"由于消息topic由多个partition组成\",{\"1\":{\"849\":1}}],[\"由于在同一个线程内\",{\"1\":{\"831\":1}}],[\"由于在实际开发过程中\",{\"1\":{\"219\":1}}],[\"由于服务器\",{\"1\":{\"820\":2}}],[\"由于其它机器还没有启动\",{\"1\":{\"820\":1}}],[\"由于不在同一个内存空间\",{\"1\":{\"801\":1}}],[\"由于不需要移动存活对象\",{\"1\":{\"259\":1}}],[\"由于new操作的次数减少\",{\"1\":{\"713\":1}}],[\"由于主从延迟导致读取到过期数据怎么处理\",{\"0\":{\"664\":1}}],[\"由于绝大部分都是\",{\"1\":{\"653\":1}}],[\"由于快照方式是在一定间隔时间做一次\",{\"1\":{\"649\":1}}],[\"由于有些服务是无法降级的\",{\"1\":{\"644\":1}}],[\"由于缓存不命中时\",{\"1\":{\"641\":1}}],[\"由于没有设置真正的过期时间\",{\"1\":{\"643\":1}}],[\"由于没有\",{\"1\":{\"578\":1}}],[\"由于表结构修改\",{\"1\":{\"572\":1}}],[\"由于记录的只是执行语句\",{\"1\":{\"572\":1}}],[\"由于日志以二进制方式存储\",{\"1\":{\"566\":1}}],[\"由于访问\",{\"1\":{\"559\":1}}],[\"由于索引定义了唯一性\",{\"1\":{\"555\":1}}],[\"由于这些事务随时可能访问数据库里面的任何数据\",{\"1\":{\"525\":1}}],[\"由于额外的加锁机制产生了额外的开销\",{\"1\":{\"513\":1}}],[\"由于过滤是由mysql\",{\"1\":{\"501\":1}}],[\"由于合并比较耗时\",{\"1\":{\"485\":1}}],[\"由于底层是数组实现\",{\"1\":{\"392\":1}}],[\"由于面向对象有封装\",{\"1\":{\"354\":1}}],[\"由于反射允许代码执行一些在正常情况下不被允许的操作\",{\"1\":{\"348\":1}}],[\"由于多核的原因\",{\"1\":{\"331\":1}}],[\"由于多个线程可能更改全局变量\",{\"1\":{\"141\":1}}],[\"由于常量池中常量的数量是不固定的\",{\"1\":{\"286\":1}}],[\"由于静态类型在编译期可知\",{\"1\":{\"277\":1}}],[\"由于g1对写屏障的复杂操作要比cms消耗更多的运算资源\",{\"1\":{\"262\":1}}],[\"由于g1的卡表结构复杂\",{\"1\":{\"262\":1}}],[\"由于垃圾回收器是一个优先级很低的线程\",{\"1\":{\"235\":1}}],[\"由于对象访问在java中非常频繁\",{\"1\":{\"230\":1}}],[\"由于对象还没有初始化\",{\"1\":{\"101\":1,\"714\":1}}],[\"由于reference类型在\",{\"1\":{\"228\":1}}],[\"由于栈只能向上增长\",{\"1\":{\"198\":1}}],[\"由于操作数是存储在内存中的\",{\"1\":{\"193\":1}}],[\"由于基于栈式架构的虚拟机所使用的零地址指令更加紧凑\",{\"1\":{\"193\":1}}],[\"由于局部变量表是建立在线程堆栈中的\",{\"1\":{\"192\":1}}],[\"由于跨平台设计\",{\"1\":{\"190\":1}}],[\"由于磁头移动规律与电梯运行相似\",{\"1\":{\"163\":1}}],[\"由于轻量级锁在没有竞争时\",{\"1\":{\"88\":1}}],[\"由于wait\",{\"1\":{\"85\":1}}],[\"由于处理器为了提高程序运行效率\",{\"1\":{\"70\":1}}],[\"由于指令重排序\",{\"1\":{\"67\":1}}],[\"由于\",{\"1\":{\"45\":1,\"393\":1,\"578\":1,\"624\":1,\"647\":1,\"648\":1,\"677\":1,\"678\":1,\"820\":1,\"872\":1,\"921\":1,\"986\":1,\"1072\":1,\"1124\":1,\"1259\":1}}],[\"由\",{\"1\":{\"39\":1,\"41\":1,\"85\":1,\"379\":1,\"458\":1,\"655\":1,\"661\":1,\"874\":1,\"875\":1}}],[\"kfc\",{\"1\":{\"1086\":3}}],[\"kn\",{\"1\":{\"919\":1}}],[\"k2\",{\"1\":{\"919\":1}}],[\"k1\",{\"1\":{\"919\":1}}],[\"k个数\",{\"1\":{\"893\":1}}],[\"kafka保证\",{\"1\":{\"865\":1}}],[\"kafka中发送1条消息的时候\",{\"1\":{\"865\":1}}],[\"kafka中zookeeper的作用\",{\"0\":{\"861\":1}}],[\"kafka只能保证partition内消息顺序有序\",{\"1\":{\"865\":1}}],[\"kafka引入了一个新的组件transaction\",{\"1\":{\"863\":1}}],[\"kafka0\",{\"1\":{\"860\":1}}],[\"kafka使用了\",{\"1\":{\"850\":1}}],[\"kafka为用户提供了三种可靠性级别\",{\"1\":{\"854\":1}}],[\"kafka为什么这么快\",{\"0\":{\"850\":1}}],[\"kafka为每个分段后的数据文件建立了索引文件\",{\"1\":{\"848\":1}}],[\"kafka采取了分片和索引的机制来加速定位\",{\"1\":{\"846\":1}}],[\"kafka文件存储是通过本地落盘的方式存储的\",{\"1\":{\"846\":1}}],[\"kafka的两种分配策略\",{\"1\":{\"859\":1}}],[\"kafka的消费者在消费数据时会传入一个时长参数timeout\",{\"1\":{\"858\":1}}],[\"kafka的消费模式主要有两种\",{\"1\":{\"844\":1}}],[\"kafka的消费模式\",{\"0\":{\"844\":1}}],[\"kafka的消息会有多个订阅者\",{\"1\":{\"850\":1}}],[\"kafka的producer生产数据\",{\"1\":{\"850\":1}}],[\"kafka的log文件以1g\",{\"1\":{\"846\":1}}],[\"kafka的文件存储\",{\"0\":{\"846\":1}}],[\"kafka提供了副本机制\",{\"1\":{\"845\":1}}],[\"kafka可以正常的工作\",{\"1\":{\"845\":1}}],[\"kafka基础架构\",{\"0\":{\"845\":1}}],[\"kafka会默认保留一段时间\",{\"1\":{\"844\":1}}],[\"kafka\",{\"1\":{\"843\":1,\"856\":2,\"861\":3,\"867\":2}}],[\"k=5\",{\"1\":{\"555\":2}}],[\"kb\",{\"1\":{\"442\":2}}],[\"kbytes\",{\"1\":{\"441\":1}}],[\"ki\",{\"1\":{\"919\":2}}],[\"killall\",{\"1\":{\"426\":2}}],[\"kill\",{\"1\":{\"426\":3,\"436\":1}}],[\"kit\",{\"1\":{\"335\":1}}],[\"k\",{\"0\":{\"927\":1,\"936\":1},\"1\":{\"399\":2,\"539\":1,\"610\":2,\"645\":1,\"893\":3,\"919\":5,\"927\":3,\"936\":8}}],[\"klass\",{\"1\":{\"85\":1,\"86\":1}}],[\"keras\",{\"1\":{\"1108\":1}}],[\"keep\",{\"1\":{\"453\":1,\"1038\":1,\"1039\":1,\"1042\":1}}],[\"keepalivetime\",{\"1\":{\"58\":6}}],[\"keygen\",{\"1\":{\"1202\":1}}],[\"key比较多\",{\"1\":{\"884\":1}}],[\"key来定义\",{\"1\":{\"865\":1}}],[\"key即可\",{\"1\":{\"668\":1}}],[\"keyexist\",{\"1\":{\"641\":1}}],[\"keyset\",{\"1\":{\"957\":1}}],[\"keys\",{\"1\":{\"638\":1,\"678\":1,\"1202\":2}}],[\"keyword\",{\"1\":{\"449\":1}}],[\"key==null\",{\"1\":{\"405\":1}}],[\"key是别的region的起始地址\",{\"1\":{\"265\":1}}],[\"key\",{\"0\":{\"46\":1,\"405\":1,\"505\":1,\"957\":1},\"1\":{\"39\":2,\"41\":1,\"43\":1,\"45\":1,\"46\":1,\"131\":2,\"299\":1,\"300\":3,\"316\":1,\"342\":2,\"396\":1,\"397\":3,\"398\":5,\"405\":3,\"407\":2,\"410\":1,\"412\":4,\"413\":3,\"461\":2,\"462\":6,\"490\":3,\"491\":1,\"492\":1,\"505\":3,\"506\":3,\"515\":3,\"517\":4,\"523\":1,\"527\":1,\"538\":2,\"541\":1,\"556\":2,\"596\":2,\"601\":4,\"603\":1,\"607\":1,\"614\":1,\"619\":1,\"623\":2,\"632\":15,\"636\":6,\"637\":3,\"641\":2,\"642\":3,\"643\":5,\"645\":1,\"659\":2,\"660\":2,\"664\":2,\"665\":2,\"668\":3,\"669\":3,\"672\":1,\"678\":6,\"679\":4,\"680\":3,\"681\":1,\"702\":1,\"705\":4,\"750\":2,\"771\":1,\"807\":1,\"865\":1,\"867\":1,\"880\":2,\"884\":4,\"892\":1,\"922\":2,\"923\":3,\"1091\":2,\"1177\":1}}],[\"kylinos\",{\"1\":{\"18\":1}}],[\"对业务涉及到的参与者\",{\"1\":{\"1216\":1}}],[\"对修改关闭\",{\"1\":{\"1064\":1}}],[\"对拓展开放\",{\"1\":{\"1064\":1}}],[\"对公钥进行认证和加密\",{\"1\":{\"1057\":1}}],[\"对方拿到证书后\",{\"1\":{\"1057\":1}}],[\"对方接收到加密信息后\",{\"1\":{\"1056\":1}}],[\"对方法体进行修改或重写\",{\"1\":{\"359\":1}}],[\"对系统安全性非常重要\",{\"1\":{\"1055\":1}}],[\"对访问网路的权限进行控制\",{\"1\":{\"1055\":1}}],[\"对网页内容加密返回给浏览器\",{\"1\":{\"1044\":1}}],[\"对称密钥加密是指加密和解密使用同一个密钥的方式\",{\"1\":{\"1056\":1}}],[\"对称加密的加密效率通常为非对称加密的千倍左右\",{\"1\":{\"1056\":1}}],[\"对称加密\",{\"0\":{\"1056\":1}}],[\"对称加密和非对称加密\",{\"1\":{\"1044\":1}}],[\"对称秘钥的对称加密\",{\"1\":{\"1044\":1}}],[\"对按序到达的最后一个分组发送确认\",{\"1\":{\"1011\":1}}],[\"对第一个分片的数据报片的所有后序数据报片\",{\"1\":{\"993\":1}}],[\"对具有特殊地址\",{\"1\":{\"993\":1}}],[\"对具有多播地址的数据报\",{\"1\":{\"993\":1}}],[\"对icmp差错报告报文\",{\"1\":{\"993\":1}}],[\"对改变路由的解释\",{\"1\":{\"993\":1}}],[\"对路由表的每一行中的子网掩码与d相与\",{\"1\":{\"990\":1}}],[\"对路由器直接相连的网络逐个检查\",{\"1\":{\"990\":1}}],[\"对外暴露一个获取user对象的静态方法\",{\"1\":{\"1070\":1}}],[\"对外仍然表现为一个网络\",{\"1\":{\"989\":1}}],[\"对外提供服务\",{\"1\":{\"683\":1}}],[\"对外提供了\",{\"1\":{\"637\":1}}],[\"对外提供键值存储服务的主要流程\",{\"1\":{\"604\":1}}],[\"对等层\",{\"1\":{\"963\":1}}],[\"对右半部分排序\",{\"1\":{\"934\":1}}],[\"对左半部分排序\",{\"1\":{\"934\":1}}],[\"对关键字平方再取中间几位作为地址\",{\"1\":{\"923\":1}}],[\"对每一个小文件用哈希表来统计其中每种数出现的次数\",{\"1\":{\"897\":1}}],[\"对每个\",{\"1\":{\"896\":1}}],[\"对每个小文件\",{\"1\":{\"894\":1}}],[\"对这10个文件进行归并排序\",{\"1\":{\"895\":1}}],[\"对这两种锁的定义做介绍\",{\"1\":{\"113\":1}}],[\"对海量数据的增删改查进行处理\",{\"1\":{\"887\":1}}],[\"对给定元素再次进行相同的哈希计算\",{\"1\":{\"882\":1}}],[\"对存储节点进行哈希计算\",{\"1\":{\"880\":1}}],[\"对存在控制依赖的操作重排序\",{\"1\":{\"76\":2}}],[\"对性能有很大影响\",{\"1\":{\"856\":1}}],[\"对实时性要求比较高的\",{\"1\":{\"843\":1}}],[\"对消费者可用性要求比较高\",{\"1\":{\"843\":1}}],[\"对消费者性能要求比较高\",{\"1\":{\"843\":1}}],[\"对比数据\",{\"1\":{\"820\":1}}],[\"对比\",{\"0\":{\"815\":1}}],[\"对开发人员的要求也高\",{\"1\":{\"805\":1}}],[\"对开发人员编写\",{\"1\":{\"746\":1}}],[\"对请求消息进行数据格式化\",{\"1\":{\"755\":1}}],[\"对请求消息进行数据转换\",{\"1\":{\"755\":1}}],[\"对请求\",{\"1\":{\"755\":1}}],[\"对servlet进行封装\",{\"1\":{\"755\":1}}],[\"对一些\",{\"1\":{\"735\":1}}],[\"对一个变量执行\",{\"1\":{\"295\":1}}],[\"对一个\",{\"1\":{\"75\":1,\"102\":1}}],[\"对类成员的访问以及异常处理程序块的执行等等\",{\"1\":{\"721\":1}}],[\"对已有方法进行增强\",{\"1\":{\"719\":1}}],[\"对话框\",{\"1\":{\"713\":1}}],[\"对服务器的数量\",{\"1\":{\"679\":1}}],[\"对大多数用户来说这操作起来可能比较麻烦\",{\"1\":{\"671\":1}}],[\"对此进行了优化\",{\"1\":{\"660\":1}}],[\"对写为\",{\"1\":{\"641\":1}}],[\"对内存很友好\",{\"1\":{\"632\":1}}],[\"对内存要求较高\",{\"1\":{\"493\":1}}],[\"对缓存数据的任何操作都会同时修改缓存中的数据\",{\"1\":{\"608\":1}}],[\"对缓存行标记状态\",{\"1\":{\"72\":1}}],[\"对评论的回复是另一张表\",{\"1\":{\"601\":1}}],[\"对多个字段同时建立的索引\",{\"1\":{\"551\":1}}],[\"对文本的内容进行分词\",{\"1\":{\"548\":1}}],[\"对文件系统来说是完全平等的\",{\"1\":{\"427\":1}}],[\"对文件的读写一般要经过内核态和用户态的切换\",{\"1\":{\"380\":1}}],[\"对同一字段的多次读取结果都是一致的\",{\"1\":{\"522\":1,\"741\":1}}],[\"对同类对象抽象出其共性\",{\"1\":{\"354\":1}}],[\"对数据进行加密\",{\"1\":{\"1047\":1}}],[\"对数据进行哈希映射\",{\"1\":{\"880\":1}}],[\"对数据进行分片\",{\"1\":{\"659\":1}}],[\"对数据更新具备高可用性\",{\"1\":{\"870\":1}}],[\"对数据库表进行\",{\"1\":{\"754\":1}}],[\"对数据库进行操作\",{\"1\":{\"749\":1}}],[\"对数据库造成流量的压力\",{\"1\":{\"640\":1}}],[\"对数据的可靠性要求不是很高\",{\"1\":{\"854\":1}}],[\"对数据的操作都是基于内存的\",{\"1\":{\"646\":1}}],[\"对数据的访问只能通过定义的方法\",{\"1\":{\"355\":1}}],[\"对数据操作也简单\",{\"1\":{\"604\":1}}],[\"对数据对象\",{\"1\":{\"509\":1}}],[\"对虚拟表vt8中的记录进行去重\",{\"1\":{\"487\":1}}],[\"对虚拟表vt6进行\",{\"1\":{\"487\":1}}],[\"对虚拟表vt5进行cube或者rollup操作\",{\"1\":{\"487\":1}}],[\"对虚拟表vt4进行分组操作\",{\"1\":{\"487\":1}}],[\"对虚拟表vt3进行where条件过滤\",{\"1\":{\"487\":1}}],[\"对虚拟表vt1进行on筛选\",{\"1\":{\"487\":1}}],[\"对from左边的表和右边的表计算笛卡尔积\",{\"1\":{\"487\":1}}],[\"对管线无用\",{\"1\":{\"429\":1}}],[\"对读线程而言\",{\"1\":{\"411\":1}}],[\"对单位时间内完成的工作量的量度\",{\"1\":{\"310\":1}}],[\"对从\",{\"1\":{\"301\":1}}],[\"对字段无效\",{\"1\":{\"278\":1}}],[\"对字节码描述的信息进行语义分析\",{\"1\":{\"170\":1}}],[\"对各个region的回收价值和成本进行排序\",{\"1\":{\"264\":1}}],[\"对用户线程做另一个短暂的暂停\",{\"1\":{\"264\":1}}],[\"对用户是透明的\",{\"1\":{\"155\":1}}],[\"对cpu资源敏感\",{\"1\":{\"259\":1}}],[\"对垃圾内存的回收速度\",{\"1\":{\"235\":1}}],[\"对堆垃圾回收前的第一步就是要判断哪些对象已经死亡\",{\"1\":{\"232\":1}}],[\"对齐填充\",{\"0\":{\"227\":1}}],[\"对永久代进行调优比较困难\",{\"1\":{\"206\":1}}],[\"对栈来说\",{\"1\":{\"190\":1}}],[\"对应关系\",{\"1\":{\"922\":1}}],[\"对应一个存储位置\",{\"1\":{\"922\":1}}],[\"对应一个栈帧入栈到出栈\",{\"1\":{\"190\":1}}],[\"对应\",{\"1\":{\"900\":1}}],[\"对应同级别的有jboss\",{\"1\":{\"825\":1}}],[\"对应产生的数据文件为\",{\"1\":{\"647\":1}}],[\"对应到的是user1\",{\"1\":{\"587\":1}}],[\"对应sql\",{\"1\":{\"501\":1}}],[\"对应动态连接\",{\"1\":{\"194\":1}}],[\"对应静态解析\",{\"1\":{\"194\":1}}],[\"对应当前方法以及当前类\",{\"1\":{\"191\":1}}],[\"对应的哈希槽\",{\"1\":{\"680\":1}}],[\"对应的所有\",{\"1\":{\"659\":1}}],[\"对应的风险是\",{\"1\":{\"571\":1}}],[\"对应的是user2\",{\"1\":{\"587\":1}}],[\"对应的是\",{\"1\":{\"568\":1}}],[\"对应的故障处理程序可通过从磁盘加载该页的方法来排除故障\",{\"1\":{\"159\":1}}],[\"对应的阻塞队列\",{\"1\":{\"56\":1}}],[\"对应的\",{\"1\":{\"46\":1}}],[\"对jvm来说\",{\"1\":{\"187\":1}}],[\"对java来说\",{\"1\":{\"187\":1}}],[\"对就绪状态的进程\",{\"1\":{\"148\":1}}],[\"对资源的共享方式\",{\"0\":{\"112\":1}}],[\"对其他变量的读可见\",{\"1\":{\"102\":1}}],[\"对其他线程得知它结束后的读可见\",{\"1\":{\"102\":1}}],[\"对变量默认值\",{\"1\":{\"102\":1}}],[\"对该对象的任何操作都不会影响\",{\"1\":{\"608\":1}}],[\"对该同步状态进行原子操作实现对其值的修改\",{\"1\":{\"110\":1}}],[\"对该线程开时候对该变量读可见\",{\"1\":{\"102\":1}}],[\"对该值进行\",{\"1\":{\"72\":1}}],[\"对接下来其他线程对该变量的读可见\",{\"1\":{\"102\":1}}],[\"对锁的实现引入了大量的优化\",{\"1\":{\"82\":1}}],[\"对\",{\"1\":{\"78\":2,\"131\":1,\"484\":2,\"624\":2,\"665\":1,\"676\":1,\"880\":1,\"902\":1,\"1060\":1}}],[\"对线程\",{\"1\":{\"75\":1,\"102\":1}}],[\"对共享变量的修改在相同时刻只允许一个\",{\"1\":{\"72\":1}}],[\"对象图\",{\"1\":{\"1094\":1}}],[\"对象适配器模式是将现有组件库中已经实现的组件适配器类中\",{\"1\":{\"1092\":1}}],[\"对象发现是一个名为\",{\"1\":{\"1090\":1}}],[\"对象肯定是一个\",{\"1\":{\"1090\":1}}],[\"对象没有任何地方被引用\",{\"1\":{\"1075\":1}}],[\"对象指向分配的内存空间\",{\"1\":{\"1068\":1}}],[\"对象和数组\",{\"1\":{\"1035\":1}}],[\"对象被销毁\",{\"1\":{\"759\":1}}],[\"对象对应的拦截器list\",{\"1\":{\"755\":1}}],[\"对象对查询结果集进行分页\",{\"1\":{\"753\":1}}],[\"对象以及\",{\"1\":{\"755\":1}}],[\"对象关系映射\",{\"1\":{\"746\":1}}],[\"对象关联的方法\",{\"1\":{\"348\":1}}],[\"对象关联的字段\",{\"1\":{\"348\":1}}],[\"对象资源\",{\"1\":{\"744\":1}}],[\"对象注入\",{\"1\":{\"736\":2}}],[\"对象无需自行创建或管理它的依赖关系\",{\"1\":{\"718\":1}}],[\"对象a\",{\"1\":{\"718\":2}}],[\"对象们给出它们的依赖\",{\"1\":{\"717\":1}}],[\"对象中没有实例变量\",{\"1\":{\"735\":1}}],[\"对象中有实例变量\",{\"1\":{\"735\":1}}],[\"对象中\",{\"1\":{\"574\":1}}],[\"对象中的引用数据类型\",{\"1\":{\"343\":1}}],[\"对象缓存下来\",{\"1\":{\"597\":1}}],[\"对象缓存\",{\"1\":{\"369\":1}}],[\"对象时开始是用\",{\"1\":{\"622\":1}}],[\"对象时\",{\"1\":{\"369\":1,\"396\":1,\"404\":1}}],[\"对象进行比较时\",{\"1\":{\"368\":1}}],[\"对象上\",{\"1\":{\"349\":1}}],[\"对象来对生成的代理对象进行加载\",{\"1\":{\"349\":1}}],[\"对象修改后的哈希值与最初的不同\",{\"1\":{\"304\":1}}],[\"对象调用set方法设置的值\",{\"1\":{\"299\":1}}],[\"对象分配频率或年代提升频率变化很大\",{\"1\":{\"261\":1}}],[\"对象分配规则\",{\"1\":{\"255\":1}}],[\"对象精度\",{\"1\":{\"249\":1}}],[\"对象所占用的空间就可以被回收\",{\"1\":{\"232\":1}}],[\"对象所需内存的大小在类加载完成后便可完全确定\",{\"1\":{\"215\":1}}],[\"对象是否需要回收\",{\"0\":{\"232\":1}}],[\"对象在内存中的布局可以分为\",{\"1\":{\"224\":1}}],[\"对象创建的注解\",{\"1\":{\"743\":1}}],[\"对象创建的过程\",{\"1\":{\"213\":1}}],[\"对象创建很大或者survivor区没法存下该对象\",{\"1\":{\"241\":1}}],[\"对象创建才刚开始\",{\"1\":{\"223\":1}}],[\"对象promotion策略\",{\"0\":{\"220\":1}}],[\"对象实例的创建在jvm中十分频繁\",{\"1\":{\"219\":1}}],[\"对象头\",{\"0\":{\"225\":1},\"1\":{\"224\":1}}],[\"对象头会有不同的设置方式\",{\"1\":{\"222\":1}}],[\"对象头包含两个部分\",{\"1\":{\"85\":1,\"86\":1}}],[\"对象头和\",{\"1\":{\"82\":1}}],[\"对象都内置了一个\",{\"1\":{\"85\":1}}],[\"对象锁\",{\"1\":{\"83\":1}}],[\"对象锁的的拥有者线程才可以执行\",{\"1\":{\"82\":1}}],[\"对象终结规则\",{\"1\":{\"75\":1,\"102\":1}}],[\"对象的子实现类对象\",{\"1\":{\"1090\":1}}],[\"对象的形式返回\",{\"1\":{\"755\":1}}],[\"对象的创建就是通过beanfactory\",{\"1\":{\"712\":1}}],[\"对象的对象头占\",{\"1\":{\"631\":1}}],[\"对象的数组\",{\"1\":{\"349\":1}}],[\"对象的加载\",{\"1\":{\"348\":1}}],[\"对象的话\",{\"1\":{\"299\":1}}],[\"对象的字段存在着跨代指针\",{\"1\":{\"249\":1}}],[\"对象的访问定位\",{\"0\":{\"228\":1}}],[\"对象的第三部分是对齐填充\",{\"1\":{\"227\":1}}],[\"对象的内存布局\",{\"0\":{\"224\":1}}],[\"对象的哈希码被频繁地使用\",{\"1\":{\"369\":1}}],[\"对象的哈希码\",{\"1\":{\"222\":1}}],[\"对象的实例化\",{\"0\":{\"211\":1}}],[\"对象的属性其实就是数据\",{\"1\":{\"198\":1}}],[\"对象的\",{\"1\":{\"75\":1,\"102\":1,\"222\":1,\"339\":1,\"344\":1,\"356\":2}}],[\"对象\",{\"0\":{\"339\":1},\"1\":{\"39\":1,\"41\":1,\"43\":2,\"83\":1,\"89\":1,\"101\":1,\"126\":1,\"247\":1,\"339\":1,\"344\":1,\"348\":3,\"349\":3,\"354\":1,\"356\":2,\"409\":1,\"413\":1,\"597\":1,\"641\":1,\"712\":1,\"718\":3,\"736\":3,\"742\":1,\"747\":1,\"755\":1,\"759\":2,\"1035\":1,\"1076\":1,\"1090\":1,\"1156\":1}}],[\"对于这一工作中最常用的版本管理工具\",{\"1\":{\"1121\":1}}],[\"对于这个问题\",{\"1\":{\"304\":1}}],[\"对于新产品的创建\",{\"1\":{\"1078\":1}}],[\"对于相同的数据\",{\"1\":{\"1042\":1}}],[\"对于应用层交下来的报文\",{\"1\":{\"1002\":1}}],[\"对于tcp\",{\"1\":{\"993\":2}}],[\"对于保证可靠性的tcp协议来说\",{\"1\":{\"982\":1}}],[\"对于通知质量较差的无线传输链路\",{\"1\":{\"974\":1}}],[\"对于通信质量较好的有线链路\",{\"1\":{\"974\":1}}],[\"对于任何两个相同的层次\",{\"1\":{\"963\":1}}],[\"对于队列来说\",{\"1\":{\"941\":1}}],[\"对于散列表长为\",{\"1\":{\"923\":1}}],[\"对于每个词x\",{\"1\":{\"894\":1}}],[\"对于每一个小文件\",{\"1\":{\"892\":1}}],[\"对于每一个属性\",{\"1\":{\"291\":1}}],[\"对于consumer而言\",{\"1\":{\"864\":1}}],[\"对于同一个\",{\"1\":{\"861\":1}}],[\"对于同一个文件的多处变化\",{\"1\":{\"447\":1}}],[\"对于重传时间的设置\",{\"1\":{\"1012\":1}}],[\"对于重要的数据\",{\"1\":{\"856\":1}}],[\"对于重量级对象而言\",{\"1\":{\"713\":1}}],[\"对于某些不太重要的数据\",{\"1\":{\"854\":1}}],[\"对于某个具体的对象而言\",{\"1\":{\"718\":1}}],[\"对于消费者来说\",{\"1\":{\"843\":3}}],[\"对于关系模型要求高的软件\",{\"1\":{\"749\":1}}],[\"对于多次重复执行的\",{\"1\":{\"745\":1}}],[\"对于多个下游应用的情况\",{\"1\":{\"856\":1}}],[\"对于多个等值查询则没有这种限制\",{\"1\":{\"534\":1}}],[\"对于多个范围条件查询\",{\"1\":{\"534\":1}}],[\"对于实现了这些aware接口的bean\",{\"1\":{\"737\":1}}],[\"对于频繁使用的对象\",{\"1\":{\"713\":1}}],[\"对于bean创建\",{\"1\":{\"712\":1}}],[\"对于发现的问题我会记录文档\",{\"1\":{\"691\":1}}],[\"对于映射为不同\",{\"1\":{\"678\":1}}],[\"对于小\",{\"1\":{\"660\":1}}],[\"对于所有新执行的写入命令\",{\"1\":{\"651\":1}}],[\"对于高并发的流量\",{\"1\":{\"640\":1}}],[\"对于存储相同的数据内容\",{\"1\":{\"637\":1}}],[\"对于存储和计算来说是没有意义的\",{\"1\":{\"472\":1}}],[\"对于修改字符串\",{\"1\":{\"624\":1}}],[\"对于数据的修改\",{\"1\":{\"568\":1}}],[\"对于唯一索引来说\",{\"1\":{\"555\":1,\"574\":2}}],[\"对于普通索引来说\",{\"1\":{\"555\":1,\"574\":2}}],[\"对于当前读\",{\"1\":{\"523\":1}}],[\"对于快照读\",{\"1\":{\"523\":1}}],[\"对于非叶子结点\",{\"1\":{\"542\":1}}],[\"对于非常容易产生死锁的业务部分\",{\"1\":{\"516\":1}}],[\"对于非聚集索引的插入或者更新操作\",{\"1\":{\"496\":1}}],[\"对于非公平锁只要\",{\"1\":{\"96\":1}}],[\"对于只读数据\",{\"1\":{\"492\":1}}],[\"对于目录\",{\"1\":{\"430\":3}}],[\"对于文件\",{\"1\":{\"430\":3}}],[\"对于添加和删除操作\",{\"1\":{\"393\":1}}],[\"对于随机访问\",{\"1\":{\"393\":1}}],[\"对于没有分配到处理线程的连接就会被阻塞或者被拒绝\",{\"1\":{\"380\":1}}],[\"对于需要经常插入和删除元素\",{\"1\":{\"373\":1}}],[\"对于想要快速访问数据\",{\"1\":{\"373\":1}}],[\"对于两个非\",{\"1\":{\"368\":1}}],[\"对于不需要过于精确的场合\",{\"1\":{\"645\":1}}],[\"对于不满足条件的记录\",{\"1\":{\"501\":1}}],[\"对于不经常更新的数据来说\",{\"1\":{\"490\":1}}],[\"对于不想进行序列化的变量\",{\"1\":{\"364\":1}}],[\"对于不同的线程\",{\"1\":{\"39\":1,\"41\":1}}],[\"对于对象中的基本数据类型\",{\"1\":{\"343\":1}}],[\"对于单核处理器环境中\",{\"1\":{\"254\":1}}],[\"对于单独线程中的每个操作\",{\"1\":{\"75\":1}}],[\"对于内存比较大的实例会造成长时间阻塞\",{\"1\":{\"647\":1}}],[\"对于内存资源受限的环境\",{\"1\":{\"254\":1}}],[\"对于内存中的某个值\",{\"1\":{\"105\":1}}],[\"对于64位的数据类型\",{\"1\":{\"192\":1}}],[\"对于它的读写也可以使用普通的\",{\"1\":{\"149\":1}}],[\"对于其他线程得知\",{\"1\":{\"102\":1}}],[\"对于接下来\",{\"1\":{\"102\":1}}],[\"对于\",{\"1\":{\"18\":1,\"121\":1,\"203\":1,\"368\":1,\"484\":1,\"537\":1,\"624\":2,\"676\":1,\"825\":2,\"982\":1,\"1001\":1}}],[\"在领域层定义好\",{\"1\":{\"1242\":1}}],[\"在领域分层方面\",{\"1\":{\"1226\":1}}],[\"在事件风暴中\",{\"1\":{\"1234\":1}}],[\"在事务之间执行\",{\"1\":{\"559\":1}}],[\"在事务前面\",{\"1\":{\"516\":1}}],[\"在行为里面只涉及业务逻辑的内存操作\",{\"1\":{\"1230\":1}}],[\"在容器宽高渲染完成后渲染\",{\"1\":{\"1163\":1}}],[\"在组合关系中\",{\"1\":{\"1099\":1}}],[\"在现实生活中\",{\"1\":{\"1090\":1}}],[\"在现有分支与指定的远程分支之间\",{\"1\":{\"451\":1}}],[\"在具体子类中可以继承或重写它\",{\"1\":{\"1087\":1}}],[\"在具体的开发中可以将我们的流程进行抽象的归纳\",{\"1\":{\"764\":1}}],[\"在抽象类中已经实现\",{\"1\":{\"1087\":2}}],[\"在抽象类中声明\",{\"1\":{\"1087\":1}}],[\"在面向对象程序设计过程中\",{\"1\":{\"1087\":1}}],[\"在传统的代理模式中\",{\"1\":{\"1083\":1}}],[\"在传输层与应用层之间利用数据加密技术保障传输数据的安全\",{\"1\":{\"1047\":1}}],[\"在传输稳定上要弱于\",{\"1\":{\"1001\":1}}],[\"在创建一个对象时不向客户暴露内部细节\",{\"1\":{\"1076\":1}}],[\"在创建对象或调用方法的时候才明确下具体的类型\",{\"1\":{\"345\":1}}],[\"在软件复用时\",{\"1\":{\"1064\":1}}],[\"在被动攻击中\",{\"1\":{\"1054\":1}}],[\"在被通知的方法调用之前和调用之后执行自定义的行为\",{\"1\":{\"722\":1}}],[\"在真正发送数据包之前需要花费一些时间\",{\"1\":{\"1042\":1}}],[\"在客户端和服务器端记录了之前发送的键值对\",{\"1\":{\"1042\":1}}],[\"在客户端断开时会自动释放\",{\"1\":{\"510\":1}}],[\"在请求和响应头设置connection\",{\"1\":{\"1042\":1}}],[\"在指挥者中不涉及具体产品的信息\",{\"1\":{\"1086\":1}}],[\"在指明的url下存储一个文档\",{\"1\":{\"1040\":1}}],[\"在指定的时间范围内确认\",{\"1\":{\"657\":1,\"677\":1}}],[\"在指定目录下查找文件\",{\"1\":{\"434\":1}}],[\"在响应中都指明绑定有效存在的时间值\",{\"1\":{\"1032\":1}}],[\"在域名服务器中广泛使用了高速缓存\",{\"1\":{\"1032\":1}}],[\"在确认报文中把ack置1\",{\"1\":{\"1026\":1}}],[\"在确定元素插入位置和判断元素是否相等时\",{\"1\":{\"342\":1}}],[\"在上面的描述中\",{\"1\":{\"1140\":1}}],[\"在上面工作都完成之后\",{\"1\":{\"223\":1}}],[\"在上图中的点4\",{\"1\":{\"1019\":1}}],[\"在首部的选项中加上允许sack的选项\",{\"1\":{\"1013\":1}}],[\"在首次\",{\"1\":{\"399\":1}}],[\"在停止等待协议中\",{\"1\":{\"1010\":1}}],[\"在收到确认后再发下一个分组\",{\"1\":{\"1009\":1,\"1010\":1}}],[\"在连接时用来同步序号\",{\"1\":{\"1007\":1}}],[\"在连接建立后所有传送的报文段都必须把ack设置为1\",{\"1\":{\"1007\":1}}],[\"在包头首部添加数据报的长度\",{\"1\":{\"1006\":1}}],[\"在终点交付报文时必须使用\",{\"1\":{\"1002\":1}}],[\"在终端里输入\",{\"1\":{\"416\":1}}],[\"在添加首部后就下交给网络层\",{\"1\":{\"1002\":1}}],[\"在保存ipv4地址时\",{\"1\":{\"997\":1}}],[\"在互联网中主机的数量远大于路由器的数量\",{\"1\":{\"993\":1}}],[\"在互联网的主机中也要有一个路由表\",{\"1\":{\"993\":1}}],[\"在主机中也需要\",{\"1\":{\"1032\":1}}],[\"在主机刚开始工作时\",{\"1\":{\"993\":1}}],[\"在主机arp高速缓存中存放一个从ip地址到硬件地址的映射表\",{\"1\":{\"986\":1}}],[\"在主从模式下\",{\"1\":{\"657\":1}}],[\"在建立三次握手的过程中\",{\"1\":{\"982\":1}}],[\"在局域网中\",{\"1\":{\"979\":1}}],[\"在以太网上传送数据时是以帧为单位来传送的\",{\"1\":{\"980\":1}}],[\"在以太网中定义了参数a\",{\"1\":{\"978\":1}}],[\"在以评论为主的树形结构中\",{\"1\":{\"601\":1}}],[\"在接收方\",{\"1\":{\"1047\":1}}],[\"在接收一个帧时\",{\"1\":{\"973\":1}}],[\"在接到开发任务时我一般会根据任务的截止时间拆分出多个\",{\"1\":{\"691\":1}}],[\"在控制字符前插入转义字符\",{\"1\":{\"973\":1}}],[\"在光纤干线和用户之间广泛使用无源光网络pon\",{\"1\":{\"968\":1}}],[\"在光标处粘贴剪切的内容\",{\"1\":{\"417\":1}}],[\"在物理层上所传数据的单位是比特\",{\"1\":{\"961\":1}}],[\"在两个相邻节点间的链路上传送帧\",{\"1\":{\"961\":1}}],[\"在tcp第三次握手的时候\",{\"1\":{\"1042\":1}}],[\"在tcp的实现中广泛使用nagle\",{\"1\":{\"1017\":1}}],[\"在tcp\",{\"1\":{\"961\":1,\"975\":1}}],[\"在timeout时间内获取锁\",{\"1\":{\"517\":1}}],[\"在网络层也可以使路由器采用适当的分组丢弃策略\",{\"1\":{\"1019\":1}}],[\"在网络层协议状态\",{\"1\":{\"975\":1}}],[\"在网络核心部分起特殊作用的是路由器\",{\"1\":{\"960\":1}}],[\"在网络上传输数据普遍采用的都是大端模式\",{\"1\":{\"347\":1}}],[\"在浏览器中输入\",{\"0\":{\"959\":1,\"1029\":1}}],[\"在另一端进行删除数据操作的特殊线性表\",{\"1\":{\"941\":1}}],[\"在存储时\",{\"1\":{\"922\":1}}],[\"在存储一个新的key时\",{\"1\":{\"884\":1}}],[\"在作为数据库索引的数据结构时的弊端\",{\"1\":{\"916\":1}}],[\"在插入\",{\"1\":{\"916\":1}}],[\"在插件的拦截方法内拦截待执行的\",{\"1\":{\"753\":1}}],[\"在2\",{\"0\":{\"900\":1}}],[\"在正确实现的条件下\",{\"1\":{\"1041\":1}}],[\"在正向索引中\",{\"1\":{\"888\":1}}],[\"在正常的情况下\",{\"1\":{\"874\":1}}],[\"在将该区域分成2^20个子区域\",{\"1\":{\"886\":1}}],[\"在位数组中把对应下标的值置为\",{\"1\":{\"882\":1}}],[\"在这种关系中\",{\"1\":{\"1101\":1}}],[\"在这种节点分布不均匀的情况下\",{\"1\":{\"880\":1}}],[\"在这个阶段还有一些细节需要明确\",{\"1\":{\"1224\":1}}],[\"在这个阶段spring又给我们暴露了很多的扩展点\",{\"1\":{\"737\":1}}],[\"在这个类中interceptor就是代理逻辑方法\",{\"1\":{\"726\":1}}],[\"在这个事务还没有结束时\",{\"1\":{\"521\":1}}],[\"在这个同步点两个线程可以交换彼此的数据\",{\"1\":{\"127\":1}}],[\"在大多数情况下只有一个服务器会率先超时\",{\"1\":{\"877\":1}}],[\"在发送方\",{\"1\":{\"1047\":1}}],[\"在发送端\",{\"1\":{\"973\":2}}],[\"在发起选举后\",{\"1\":{\"877\":1}}],[\"在发生gc时打印内存回收详细的日志\",{\"1\":{\"325\":1}}],[\"在发生\",{\"1\":{\"220\":1}}],[\"在选举开始时\",{\"1\":{\"876\":1}}],[\"在选举过程中越新权重越大\",{\"1\":{\"820\":1}}],[\"在最坏的情况下也只会造成可用性问题\",{\"1\":{\"873\":1}}],[\"在轮询\",{\"1\":{\"869\":1}}],[\"在维护\",{\"1\":{\"861\":1}}],[\"在启动时\",{\"1\":{\"861\":1}}],[\"在初始化的时候会被分配一个pid\",{\"1\":{\"856\":1}}],[\"在初始化时保存\",{\"1\":{\"736\":1}}],[\"在0\",{\"1\":{\"856\":1}}],[\"在linux\",{\"1\":{\"829\":1}}],[\"在了解epoll多路复用之前\",{\"1\":{\"829\":1}}],[\"在配置集群时设置的\",{\"1\":{\"820\":1}}],[\"在工作时需要一个\",{\"1\":{\"820\":1}}],[\"在增删改查中\",{\"1\":{\"807\":1}}],[\"在所有进程中都是唯一确定的\",{\"1\":{\"804\":1}}],[\"在本类内部创建对象实例\",{\"1\":{\"1066\":1}}],[\"在本地生成一个随机数\",{\"1\":{\"1044\":1}}],[\"在本地调用中\",{\"1\":{\"804\":1}}],[\"在本线程内观察\",{\"1\":{\"295\":1}}],[\"在远程调用时\",{\"1\":{\"804\":1}}],[\"在重启之前先主动通知注册中心\",{\"1\":{\"802\":1}}],[\"在重载时是通过参数的静态类型而不是实际类型作为判定依据的\",{\"1\":{\"277\":1}}],[\"在聚合多个项目时\",{\"1\":{\"800\":1}}],[\"在聚簇索引之上创建的索引称之为辅助索引\",{\"1\":{\"547\":1,\"548\":1}}],[\"在pom\",{\"1\":{\"798\":1}}],[\"在此时\",{\"1\":{\"798\":1}}],[\"在命令行输入mvn\",{\"1\":{\"793\":1}}],[\"在spring\",{\"1\":{\"784\":1}}],[\"在serializable隔离级别下\",{\"1\":{\"501\":1}}],[\"在set方法还没调用而先调用了get方法时才执行\",{\"1\":{\"39\":1}}],[\"在application\",{\"1\":{\"776\":1,\"786\":1}}],[\"在项目的pom文件中定义使用的依赖\",{\"1\":{\"773\":1}}],[\"在mq方需要考虑至少推送成功一次\",{\"1\":{\"843\":1}}],[\"在maven中\",{\"1\":{\"795\":1}}],[\"在maven的依赖中加入spring\",{\"1\":{\"772\":1}}],[\"在mybatis的接口中\",{\"1\":{\"776\":1}}],[\"在mysql的主键上创建的索引就是主键索引\",{\"1\":{\"548\":1}}],[\"在myisam下主键索引是非聚集索引\",{\"1\":{\"547\":1}}],[\"在该类中加载\",{\"1\":{\"771\":1}}],[\"在该bean死亡时spring会帮我们调用接口中的方法\",{\"1\":{\"737\":1}}],[\"在层与层之前我们只需要知道接口的定义\",{\"1\":{\"766\":1}}],[\"在整个请求结束之后\",{\"1\":{\"759\":1}}],[\"在返回值前面加\",{\"1\":{\"758\":2}}],[\"在填充\",{\"1\":{\"755\":1}}],[\"在目前的企业应用系统设计中\",{\"1\":{\"748\":1}}],[\"在目前实现中\",{\"1\":{\"660\":1}}],[\"在业务方法上添加\",{\"1\":{\"739\":1}}],[\"在业务service层进行业务计算\",{\"1\":{\"584\":1}}],[\"在业务service来看就是\",{\"1\":{\"584\":1}}],[\"在需要对方回信时选用\",{\"1\":{\"1002\":1}}],[\"在需要执行时\",{\"1\":{\"719\":1}}],[\"在需要时进行数据交换\",{\"1\":{\"157\":1}}],[\"在系统运行时\",{\"1\":{\"718\":1}}],[\"在系统将要发生内存溢出异常前\",{\"1\":{\"235\":1}}],[\"在获取代理对象时\",{\"1\":{\"715\":1,\"725\":1}}],[\"在获取锁的过程中的获取时间比锁过期时间短很多\",{\"1\":{\"672\":1}}],[\"在代码实现时\",{\"1\":{\"1100\":1}}],[\"在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系\",{\"1\":{\"1097\":1}}],[\"在代码中\",{\"1\":{\"1081\":1,\"1096\":1}}],[\"在代码中获取\",{\"1\":{\"736\":1}}],[\"在代码层面实现加锁和释放锁\",{\"1\":{\"94\":1}}],[\"在代理模式中\",{\"1\":{\"715\":1}}],[\"在我们的系统中\",{\"1\":{\"713\":1}}],[\"在经历过一段时间的调试后\",{\"1\":{\"694\":1}}],[\"在部门遇到客户端信创问题时\",{\"1\":{\"694\":1}}],[\"在开发过程中我积极教新人业务方面的内容\",{\"1\":{\"690\":1}}],[\"在新人引进的过程中我积极承担交接工作\",{\"1\":{\"690\":1}}],[\"在职期间我主要负责新一代资金系统银行间同业存款交易的对话报价平台开发\",{\"1\":{\"687\":1}}],[\"在缓存使用\",{\"1\":{\"674\":1}}],[\"在缓存失效后\",{\"1\":{\"642\":1}}],[\"在订阅者和发布者之间起到了消息路由的功能\",{\"1\":{\"673\":1}}],[\"在后台生成一个\",{\"1\":{\"662\":1}}],[\"在后台维护一个优先列表\",{\"1\":{\"260\":1}}],[\"在扩缩容的时候\",{\"1\":{\"660\":1}}],[\"在扩容时\",{\"1\":{\"410\":1}}],[\"在集群中大多数服务器响应\",{\"1\":{\"873\":1}}],[\"在集群中一部分节点故障后\",{\"1\":{\"870\":1}}],[\"在集群中启动\",{\"1\":{\"820\":1}}],[\"在集群中充当\",{\"1\":{\"678\":1}}],[\"在集群节点数量过多的时候\",{\"1\":{\"660\":1}}],[\"在集群容量达到上限时在线扩容会变得很复杂\",{\"1\":{\"656\":1,\"658\":1}}],[\"在三个\",{\"1\":{\"659\":1}}],[\"在持久化时会fork一个子进程\",{\"1\":{\"647\":1}}],[\"在生成\",{\"1\":{\"647\":1}}],[\"在应用层做好判断\",{\"1\":{\"641\":1}}],[\"在应用和数据中间加了一个代理层\",{\"1\":{\"586\":1}}],[\"在完整描述业务情况下\",{\"1\":{\"637\":1}}],[\"在完成double\",{\"1\":{\"496\":1}}],[\"在设置了过期时间的键空间中\",{\"1\":{\"636\":3}}],[\"在键空间中\",{\"1\":{\"636\":2}}],[\"在复杂度与红黑树相同\",{\"1\":{\"630\":1}}],[\"在复制的过程中\",{\"1\":{\"469\":1,\"580\":1}}],[\"在复制的时候只是复制容器里的引用\",{\"1\":{\"411\":1}}],[\"在压缩列表中\",{\"1\":{\"627\":1}}],[\"在内核里使用红黑树来跟踪进程所有待检测的文件描述字\",{\"1\":{\"612\":1}}],[\"在内存中只有一个对象\",{\"1\":{\"1071\":1}}],[\"在内存中维护了这个树状的目录结构\",{\"1\":{\"818\":1}}],[\"在内存中累计调用次数和调用时间\",{\"1\":{\"811\":1}}],[\"在内存中生成一个代表这个类的java\",{\"1\":{\"168\":1}}],[\"在内存中以帧为单位放置页面\",{\"1\":{\"160\":1}}],[\"在通信两端分别有文件描述符来描述接收和发送缓冲区管道\",{\"1\":{\"612\":1}}],[\"在服务器生成并发送\",{\"1\":{\"1039\":1}}],[\"在服务器启动时\",{\"1\":{\"736\":1}}],[\"在服务器内存使用完之后\",{\"1\":{\"610\":2}}],[\"在服务端模式下\",{\"1\":{\"256\":1}}],[\"在各个方面比如性能要更加优秀\",{\"1\":{\"607\":1}}],[\"在考虑了这些问题之后\",{\"1\":{\"606\":1}}],[\"在日常的\",{\"1\":{\"606\":1}}],[\"在日常生活或编程中\",{\"1\":{\"354\":1}}],[\"在交给\",{\"1\":{\"604\":1}}],[\"在分布式系统\",{\"1\":{\"1075\":1}}],[\"在分布式系统环境下\",{\"1\":{\"667\":1}}],[\"在分布式场景下\",{\"1\":{\"603\":1}}],[\"在分配的时候从列表中找到一块足够大的空间划分给对象实例\",{\"1\":{\"217\":1}}],[\"在刷脏页时\",{\"1\":{\"593\":1}}],[\"在从服务器上执行的时间稍长或者由于某个\",{\"1\":{\"582\":1}}],[\"在出现\",{\"1\":{\"571\":1}}],[\"在数据不变的情况下\",{\"1\":{\"807\":1}}],[\"在数据修改时\",{\"1\":{\"570\":1}}],[\"在数据库表中加个字段\",{\"1\":{\"668\":1}}],[\"在数据库正常关闭的过程中\",{\"1\":{\"574\":1}}],[\"在数据库里面\",{\"1\":{\"536\":1}}],[\"在数据库设计时尽量不要让字段的默认值为\",{\"1\":{\"535\":1}}],[\"在查找时\",{\"1\":{\"922\":1}}],[\"在查找一个key时\",{\"1\":{\"884\":1}}],[\"在查找数据时一次页的查找代表一次\",{\"1\":{\"539\":1}}],[\"在查询大小区间的数据时候更方便\",{\"1\":{\"541\":1}}],[\"在查询大小区间的数据时更方便\",{\"1\":{\"541\":1}}],[\"在原来\",{\"1\":{\"538\":1}}],[\"在索引中查找\",{\"1\":{\"537\":1}}],[\"在有些场景下\",{\"1\":{\"536\":1}}],[\"在随后的查询中\",{\"1\":{\"521\":1}}],[\"在活动状态或部分提交状态发生一些错误\",{\"1\":{\"520\":1}}],[\"在为数据行加\",{\"1\":{\"514\":1}}],[\"在访问一个表的时候会被自动加上\",{\"1\":{\"511\":1}}],[\"在gap上的gap锁\",{\"1\":{\"501\":1}}],[\"在repeatable\",{\"1\":{\"501\":1}}],[\"在rr隔离级别下\",{\"1\":{\"501\":1}}],[\"在rc的隔离级别下\",{\"1\":{\"501\":1}}],[\"在icmp时间戳回答报文中有一个32位的字段\",{\"1\":{\"993\":1}}],[\"在innodb下主键索引是聚集索引\",{\"1\":{\"547\":1}}],[\"在innodb存储引擎中\",{\"1\":{\"498\":1}}],[\"在id索引上满足条件的列\",{\"1\":{\"501\":1}}],[\"在默认情况下\",{\"1\":{\"498\":1}}],[\"在对数据库进行处理的时候\",{\"1\":{\"513\":1}}],[\"在对任意记录进行修改前\",{\"1\":{\"513\":1}}],[\"在对缓冲池的脏页进行刷新时\",{\"1\":{\"496\":1}}],[\"在对象被移动\",{\"1\":{\"230\":1}}],[\"在异常崩溃后\",{\"1\":{\"493\":1}}],[\"在每次新增键值对时都会检查负载因子\",{\"1\":{\"623\":1}}],[\"在每次修改执行完成时\",{\"1\":{\"492\":1}}],[\"在每次插入\",{\"1\":{\"414\":1}}],[\"在使用单例模式的时候\",{\"1\":{\"1075\":1}}],[\"在使用cidr时\",{\"1\":{\"991\":1}}],[\"在使用之前一定要尽可能的精确估计元素数量\",{\"1\":{\"645\":1}}],[\"在使用分组和排序子句进行数据检索时\",{\"1\":{\"528\":1}}],[\"在使用磁盘进行排序时\",{\"1\":{\"478\":1}}],[\"在使用迭代器遍历时效率最高\",{\"1\":{\"391\":1}}],[\"在达到上限后\",{\"1\":{\"468\":1}}],[\"在当前读的情况下\",{\"1\":{\"500\":1}}],[\"在当前目录新建一个git代码库\",{\"1\":{\"445\":1}}],[\"在当前会话周期内有效\",{\"1\":{\"39\":1,\"44\":1}}],[\"在环境变量\",{\"1\":{\"434\":1}}],[\"在符号连接中\",{\"1\":{\"427\":1}}],[\"在删除前会询问使用者\",{\"1\":{\"424\":1}}],[\"在覆盖时会先询问动作的进行\",{\"1\":{\"423\":1}}],[\"在写完缓冲区后就可以继续执行后续的命令\",{\"1\":{\"650\":1}}],[\"在写锁被获取后\",{\"1\":{\"411\":1}}],[\"在写线程访问时\",{\"1\":{\"125\":1}}],[\"在处理节点时就可能出现环形链\",{\"1\":{\"406\":1}}],[\"在构造方法中创建了一个长度为\",{\"1\":{\"399\":1}}],[\"在根据\",{\"1\":{\"396\":1}}],[\"在硬盘中的存储是不连续的\",{\"1\":{\"392\":1}}],[\"在比较\",{\"1\":{\"368\":1}}],[\"在不改变原有对象的情况下\",{\"1\":{\"1085\":1}}],[\"在不修改源码的基础上\",{\"1\":{\"719\":1}}],[\"在不影响数据一致性的前提下\",{\"1\":{\"574\":1}}],[\"在不创建对象的情况下就可以用来直接调用方法或使用类的属性\",{\"1\":{\"352\":1}}],[\"在不同的条件下被触发\",{\"1\":{\"263\":1}}],[\"在泛型类被类型擦除的时候\",{\"1\":{\"345\":1}}],[\"在进行降级之前要对系统进行梳理\",{\"1\":{\"644\":1}}],[\"在进行\",{\"1\":{\"380\":1}}],[\"在进行gc的前后打印出堆的信息\",{\"1\":{\"270\":1}}],[\"在进入\",{\"1\":{\"345\":1}}],[\"在运行期间就不会出现\",{\"1\":{\"345\":1}}],[\"在运行期根据实际类型确定方法执行版本的分派过程称为动态分派\",{\"1\":{\"278\":1}}],[\"在遍历过程中还会对非空的\",{\"1\":{\"301\":1}}],[\"在调用getbean方法时创建多实例对象\",{\"1\":{\"713\":1,\"734\":1}}],[\"在调用\",{\"1\":{\"300\":1,\"377\":1}}],[\"在多数情况下不可缓存的\",{\"1\":{\"1041\":1}}],[\"在多处理器环境中\",{\"1\":{\"296\":1}}],[\"在多线程环境下\",{\"1\":{\"409\":1}}],[\"在多线程的情况下\",{\"1\":{\"189\":1}}],[\"在多线程程序中\",{\"1\":{\"76\":1}}],[\"在一串比特流尚未加上帧头帧尾时\",{\"1\":{\"973\":1}}],[\"在一串比特流尚未加上soh\",{\"1\":{\"973\":1}}],[\"在一趟排序中\",{\"1\":{\"930\":1}}],[\"在一致哈希算法中\",{\"1\":{\"880\":1}}],[\"在一些特殊的场景下\",{\"1\":{\"785\":1}}],[\"在一定程度上降低了系统的耦合度\",{\"1\":{\"715\":1}}],[\"在一定时间之后会被系统自动唤醒\",{\"1\":{\"38\":1}}],[\"在一般情况下\",{\"1\":{\"657\":1}}],[\"在一条线路上传输数据时\",{\"1\":{\"971\":1}}],[\"在一条\",{\"1\":{\"560\":1}}],[\"在一步一步的具体步骤中再按顺序调用函数\",{\"1\":{\"354\":1}}],[\"在一个\",{\"1\":{\"1075\":1}}],[\"在一个连接里\",{\"1\":{\"1042\":1}}],[\"在一个tcp连接中传送的字节流中的每一个字节都是按顺序编号\",{\"1\":{\"1007\":1}}],[\"在一个任期内收到了来自集群内的多数选票\",{\"1\":{\"877\":1}}],[\"在一个周期内没有收到心跳信息\",{\"1\":{\"877\":1}}],[\"在一个类中\",{\"1\":{\"359\":1}}],[\"在一个平台上序列化的对象可以在不同的平台上反序列化\",{\"1\":{\"344\":1}}],[\"在一个线程观察另一个线程\",{\"1\":{\"295\":1}}],[\"在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的\",{\"1\":{\"295\":1}}],[\"在常量池结束之后\",{\"1\":{\"287\":1}}],[\"在父类中添加虚函数\",{\"1\":{\"275\":1}}],[\"在动态分派里面有个注意点\",{\"1\":{\"275\":1}}],[\"在小内存应用上cms的表现大概率会优于g1\",{\"1\":{\"262\":1}}],[\"在下一行将一串整型数字存入二维数组中\",{\"1\":{\"954\":1}}],[\"在下一次\",{\"1\":{\"46\":1}}],[\"在下游对数据的重复进行去重操作\",{\"1\":{\"856\":1}}],[\"在下次重启时可以利用之前持久化的文件进行数据恢复\",{\"1\":{\"646\":1}}],[\"在下次查询需要访问这个数据页的时候\",{\"1\":{\"574\":1}}],[\"在下列情况下\",{\"1\":{\"261\":1}}],[\"在注重吞吐量或者处理器资源较为稀缺的场合\",{\"1\":{\"258\":1}}],[\"在并发读写数据库时\",{\"1\":{\"499\":1}}],[\"在并发收集发生concurrent\",{\"1\":{\"256\":1}}],[\"在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题\",{\"1\":{\"50\":1}}],[\"在实例化bean时spring会帮我们调用接口中的方法\",{\"1\":{\"737\":2}}],[\"在实例化bean时spring会帮我们注入对应的beanfactory实例\",{\"1\":{\"737\":1}}],[\"在实例恢复的时候也可以从共享表空间中找到doublewrite\",{\"1\":{\"593\":1}}],[\"在实践中\",{\"1\":{\"668\":1}}],[\"在实际的业务场景中\",{\"1\":{\"571\":1}}],[\"在实际去修改的时候才去判断能否修改成功\",{\"1\":{\"104\":1}}],[\"在实现上\",{\"1\":{\"524\":1}}],[\"在实现上这两种收集器也共用了相当多的代码\",{\"1\":{\"255\":1}}],[\"在赋值后的则叫作写后屏障\",{\"1\":{\"250\":1}}],[\"在赋值前的部分的写屏障叫作写前屏障\",{\"1\":{\"250\":1}}],[\"在引用对象赋值时会产生一个环形通知\",{\"1\":{\"250\":1}}],[\"在hotspot虚拟机中通过写屏障\",{\"1\":{\"250\":1}}],[\"在垃圾回收的时候会\",{\"1\":{\"300\":1}}],[\"在垃圾回收器线程扫描它所管辖的内存区域的过程中\",{\"1\":{\"235\":1}}],[\"在垃圾收集发生时\",{\"1\":{\"249\":1}}],[\"在标记完成后\",{\"1\":{\"244\":1}}],[\"在堆内存上都会物理或逻辑上进行分代\",{\"1\":{\"240\":1}}],[\"在堆中new的对象几乎都在eden区\",{\"1\":{\"199\":1}}],[\"在任意的时间\",{\"1\":{\"874\":1}}],[\"在任意一个线程没有完成\",{\"1\":{\"121\":1}}],[\"在任何时候都可以发起全量同步\",{\"1\":{\"655\":1}}],[\"在任何时候都可能被垃圾回收\",{\"1\":{\"235\":1}}],[\"在任何情况下每个区的大小都为1mb\",{\"1\":{\"498\":1}}],[\"在给线程中的对象分配内存时\",{\"1\":{\"219\":1}}],[\"在类加载的连接阶段的准备过程中对其进行初始化也就是分配内存空间\",{\"1\":{\"352\":1}}],[\"在类加载的解析阶段\",{\"1\":{\"274\":1}}],[\"在类加载检查通过后\",{\"1\":{\"215\":1}}],[\"在类校验阶段的数据流分析中还要再次验证这一点\",{\"1\":{\"193\":1}}],[\"在加载类型到jvm后\",{\"1\":{\"208\":1}}],[\"在加载阶段\",{\"1\":{\"168\":1}}],[\"在execution\",{\"1\":{\"197\":1}}],[\"在native\",{\"1\":{\"197\":1}}],[\"在方法退出之后\",{\"1\":{\"195\":1}}],[\"在方法执行时\",{\"1\":{\"96\":1}}],[\"在编译\",{\"1\":{\"368\":1}}],[\"在编译期间没有警告\",{\"1\":{\"345\":1}}],[\"在编译程序代码的时候\",{\"1\":{\"193\":1}}],[\"在编译java程序源码的时候\",{\"1\":{\"191\":1}}],[\"在模块化设计中这个机制尤其重要\",{\"1\":{\"185\":1}}],[\"在委派给父加载器之前\",{\"1\":{\"181\":1}}],[\"在某个时间点的全部数据快照\",{\"1\":{\"648\":1}}],[\"在某个应用中需要使用中间件\",{\"1\":{\"180\":1}}],[\"在某些业务场景中出现误判的情况对用户无感知的时候\",{\"1\":{\"645\":1}}],[\"在某些特定情况下才会发生\",{\"1\":{\"303\":1}}],[\"在某些框架内进行中间件与应用的模块隔离\",{\"1\":{\"180\":1}}],[\"在某事件阻塞等队列\",{\"1\":{\"147\":1}}],[\"在程序运行之前就已经编译完成\",{\"1\":{\"723\":1}}],[\"在程序运行期间\",{\"1\":{\"339\":1}}],[\"在程序运行或加载时将这些信息传递给操作系统\",{\"1\":{\"161\":1}}],[\"在程序设计中一般很少使用弱引用与虚引用\",{\"1\":{\"235\":1}}],[\"在程序执行方法时\",{\"1\":{\"172\":1}}],[\"在程序执行过程中\",{\"1\":{\"159\":1}}],[\"在程序实际运行时\",{\"1\":{\"172\":1}}],[\"在其等待的事件已经发生\",{\"1\":{\"148\":1}}],[\"在单线程里实现多任务的调度\",{\"1\":{\"144\":1}}],[\"在单线程程序中\",{\"1\":{\"76\":1}}],[\"在用户态下执行\",{\"1\":{\"135\":1}}],[\"在用户态下调用\",{\"1\":{\"135\":1}}],[\"在核心态执行\",{\"1\":{\"135\":1}}],[\"在统计结果累加的过程中\",{\"1\":{\"129\":1}}],[\"在操作的时候给\",{\"1\":{\"128\":1}}],[\"在释放写锁之前可以获取读锁来达到锁的降级\",{\"1\":{\"125\":1}}],[\"在共享模式中\",{\"1\":{\"111\":1}}],[\"在同一节点上的事务操作\",{\"1\":{\"678\":1}}],[\"在同一台服务器上启动多个实例\",{\"1\":{\"671\":1}}],[\"在同一个跳跃表中\",{\"1\":{\"630\":1}}],[\"在同一个事务中\",{\"1\":{\"516\":1}}],[\"在同一个工程里面\",{\"1\":{\"180\":1}}],[\"在同步数据时\",{\"1\":{\"661\":1}}],[\"在同步期间\",{\"1\":{\"656\":1}}],[\"在同步队列中等待的线程等待超时或被中断\",{\"1\":{\"111\":1}}],[\"在同时读取\",{\"1\":{\"72\":1}}],[\"在读多写少的场合性能非常好\",{\"1\":{\"108\":1}}],[\"在很多游戏软件中\",{\"1\":{\"1086\":1}}],[\"在很多情况下会比\",{\"1\":{\"104\":1}}],[\"在很短的时间内就释放了锁\",{\"1\":{\"81\":1}}],[\"在哲学家就餐问题中\",{\"1\":{\"100\":1}}],[\"在线程代码执行完或出现异常时自动释放锁\",{\"1\":{\"94\":1}}],[\"在java程序被编译为class文件时\",{\"1\":{\"192\":1}}],[\"在java\",{\"1\":{\"184\":1}}],[\"在java语言中字段是无法重载的\",{\"1\":{\"289\":1}}],[\"在java语言中\",{\"1\":{\"165\":1,\"290\":1}}],[\"在jvm中\",{\"1\":{\"166\":1}}],[\"在jvm\",{\"1\":{\"94\":1}}],[\"在jdk动态代理中\",{\"1\":{\"725\":1}}],[\"在jdk8时新加入到class文件格式中的\",{\"1\":{\"292\":1}}],[\"在jdk9已经过时\",{\"1\":{\"212\":1}}],[\"在jdk\",{\"1\":{\"91\":1,\"185\":2,\"209\":1,\"256\":1}}],[\"在执行时需要使用\",{\"1\":{\"797\":1}}],[\"在执行某个语句之前\",{\"1\":{\"556\":1}}],[\"在执行一条指令时\",{\"1\":{\"159\":1}}],[\"在执行\",{\"1\":{\"82\":1,\"665\":1}}],[\"在执行monitorenter时\",{\"1\":{\"82\":1}}],[\"在屏障指令之前的操作均已被处理\",{\"1\":{\"72\":1}}],[\"在第一个\",{\"1\":{\"71\":1}}],[\"在学习一些设计模式的过程中\",{\"1\":{\"50\":1}}],[\"在没有手动删除这个\",{\"1\":{\"45\":1}}],[\"在\",{\"0\":{\"43\":1},\"1\":{\"62\":1,\"72\":1,\"75\":1,\"78\":1,\"85\":2,\"103\":1,\"114\":1,\"129\":1,\"131\":1,\"142\":1,\"224\":1,\"295\":1,\"381\":1,\"409\":2,\"410\":1,\"413\":1,\"416\":3,\"427\":2,\"429\":1,\"430\":1,\"511\":1,\"516\":1,\"523\":1,\"525\":1,\"604\":1,\"623\":3,\"624\":1,\"653\":1,\"659\":1,\"663\":1,\"668\":1,\"695\":1,\"708\":1,\"721\":1,\"725\":1,\"740\":1,\"759\":1,\"790\":1,\"804\":2,\"807\":1,\"822\":2,\"856\":1,\"861\":2,\"921\":1,\"986\":1,\"1027\":1,\"1067\":1,\"1087\":2,\"1097\":1,\"1098\":1,\"1099\":1,\"1100\":1,\"1101\":1,\"1117\":2,\"1199\":1,\"1200\":1,\"1249\":1}}],[\"在国产操作系统上安装了\",{\"1\":{\"18\":1}}],[\"无业务逻辑\",{\"1\":{\"1238\":1}}],[\"无须知道产品的具体创建过程\",{\"1\":{\"1078\":1}}],[\"无须等到maxtenuringthreshold中要求的年龄\",{\"1\":{\"220\":1}}],[\"无差错情况\",{\"1\":{\"1010\":1}}],[\"无差别轮询\",{\"1\":{\"381\":1}}],[\"无分类编址cidr\",{\"0\":{\"991\":1}}],[\"无连接的\",{\"1\":{\"982\":1}}],[\"无符号右移\",{\"1\":{\"943\":1}}],[\"无符号数\",{\"1\":{\"284\":2}}],[\"无序表中包含有\",{\"1\":{\"932\":1}}],[\"无非就是\",{\"1\":{\"881\":1}}],[\"无代码生成和xml配置\",{\"1\":{\"768\":1}}],[\"无状态的\",{\"1\":{\"735\":1}}],[\"无中心架构\",{\"1\":{\"678\":1}}],[\"无环\",{\"1\":{\"626\":1}}],[\"无环链表\",{\"1\":{\"626\":1}}],[\"无歧义的格式显示\",{\"1\":{\"475\":1}}],[\"无\",{\"1\":{\"357\":1}}],[\"无效连接监视释放\",{\"1\":{\"1060\":1}}],[\"无效\",{\"1\":{\"296\":1}}],[\"无永久代\",{\"1\":{\"204\":1}}],[\"无论谁访问都必须携带自己通行证\",{\"1\":{\"1051\":1}}],[\"无论访问哪个节点\",{\"1\":{\"870\":1}}],[\"无论方法执行是否成功\",{\"1\":{\"722\":1}}],[\"无论如何\",{\"1\":{\"655\":1}}],[\"无论事务是否成功\",{\"1\":{\"519\":1}}],[\"无论\",{\"1\":{\"381\":1}}],[\"无论是更新还是插入删除\",{\"1\":{\"523\":1}}],[\"无论是否有\",{\"1\":{\"659\":1}}],[\"无论是否满足条件\",{\"1\":{\"501\":1}}],[\"无论是否出现异常\",{\"1\":{\"346\":1}}],[\"无论是普通变量还是volatile变量都是如此\",{\"1\":{\"295\":1}}],[\"无论是无符号数还是表\",{\"1\":{\"284\":1}}],[\"无论是从父类继承下来的\",{\"1\":{\"226\":1}}],[\"无论引用关系删除与否\",{\"1\":{\"251\":1}}],[\"无论更新的是不是老年代对新生代对象的引用\",{\"1\":{\"250\":1}}],[\"无论任何情况下\",{\"1\":{\"235\":1}}],[\"无论哪种退出方式\",{\"1\":{\"195\":1}}],[\"无论读写两个连续的变量槽是否为原子操作\",{\"1\":{\"192\":1}}],[\"无论共享的数据是否真的会出现竞争\",{\"1\":{\"142\":1}}],[\"无需手动操作\",{\"1\":{\"1177\":1}}],[\"无需客户端发送请求到服务器获取\",{\"1\":{\"1042\":1}}],[\"无需再依赖spring\",{\"1\":{\"772\":1}}],[\"无需做过多的配置和依赖\",{\"1\":{\"772\":1}}],[\"无需部署war文件\",{\"1\":{\"767\":1,\"768\":1}}],[\"无需对其他分片的数据进行迁移\",{\"1\":{\"587\":1}}],[\"无需重启\",{\"1\":{\"313\":1}}],[\"无需保留ext目录了\",{\"1\":{\"181\":1}}],[\"无需等待其它线程显式地唤醒\",{\"1\":{\"38\":1}}],[\"无名管道\",{\"1\":{\"149\":1}}],[\"无锁并发编程\",{\"1\":{\"144\":1}}],[\"无锁操作\",{\"1\":{\"105\":1}}],[\"无阻塞并发\",{\"1\":{\"105\":1}}],[\"无法映射到报盘枚举\",{\"1\":{\"1261\":1}}],[\"无法映射到系统内枚举\",{\"1\":{\"1261\":1}}],[\"无法正常在\",{\"1\":{\"1206\":1}}],[\"无法打开包括文件\",{\"1\":{\"1144\":1}}],[\"无法在\",{\"0\":{\"1206\":1}}],[\"无法在任何地方通过反射访问该类的方法\",{\"1\":{\"1075\":1}}],[\"无法在国产操作系统\",{\"1\":{\"18\":1}}],[\"无法进行差错控制\",{\"1\":{\"992\":1}}],[\"无法进行重排序\",{\"1\":{\"78\":1}}],[\"无法保证数据的高可用\",{\"1\":{\"866\":1}}],[\"无法保证全局有序\",{\"1\":{\"865\":1}}],[\"无法保证全局唯一\",{\"1\":{\"589\":1}}],[\"无法做到数据库无关性\",{\"1\":{\"749\":1}}],[\"无法命中\",{\"1\":{\"679\":1}}],[\"无法使用单机环境下的锁来对多个节点上的进程进行同步\",{\"1\":{\"603\":1}}],[\"无法使用第一个范围列后面的其他索引列\",{\"1\":{\"534\":1}}],[\"无法解决集中写入瓶颈的问题\",{\"1\":{\"588\":1}}],[\"无法解决慢\",{\"1\":{\"558\":1}}],[\"无法用于模糊查找和范围查找\",{\"1\":{\"537\":1}}],[\"无法从此状态回滚\",{\"1\":{\"520\":1}}],[\"无法按顺序添加\",{\"1\":{\"466\":1}}],[\"无法直接取到对应的下标\",{\"1\":{\"391\":1}}],[\"无法处理\",{\"1\":{\"384\":1}}],[\"无法处理浮动垃圾\",{\"1\":{\"259\":1}}],[\"无法以返回值类型作为判断重载函数的区分标准\",{\"1\":{\"359\":1}}],[\"无法对这些代码进行优化\",{\"1\":{\"348\":1}}],[\"无法被继承\",{\"1\":{\"346\":1}}],[\"无法被重写\",{\"1\":{\"346\":1}}],[\"无法被父类加载器加载的类最终会通过这个方法被加载\",{\"1\":{\"185\":1}}],[\"无法阻止指令重排\",{\"1\":{\"71\":1}}],[\"无法响应中断的任务可能永远无法终止\",{\"1\":{\"59\":1}}],[\"无法独立存在\",{\"1\":{\"26\":1}}],[\"uml\",{\"0\":{\"1267\":1},\"1\":{\"1095\":2,\"1097\":1,\"1098\":1,\"1099\":1,\"1100\":1,\"1101\":1}}],[\"uml1\",{\"1\":{\"1094\":1}}],[\"uml2\",{\"1\":{\"1094\":2}}],[\"udt\",{\"1\":{\"1004\":2}}],[\"udp可以建立连接么\",{\"0\":{\"1003\":1}}],[\"udp计算检验和与计算ip数据报首部检验和的方法相似\",{\"1\":{\"1002\":1}}],[\"udp在计算检验和时\",{\"1\":{\"1002\":1}}],[\"udp用户数据报的长度\",{\"1\":{\"1002\":1}}],[\"udp首部格式\",{\"1\":{\"1002\":1}}],[\"udp8个字节\",{\"1\":{\"1002\":1}}],[\"udp的首部开销小\",{\"1\":{\"1002\":1}}],[\"udp支持一对一\",{\"1\":{\"1002\":1}}],[\"udp是面向报文的\",{\"1\":{\"1002\":1,\"1006\":1}}],[\"udp是无连接的\",{\"1\":{\"1002\":1}}],[\"udp使用尽最大努力交付\",{\"1\":{\"1002\":1}}],[\"udp没有拥塞控制\",{\"1\":{\"1002\":1}}],[\"udp没有\",{\"1\":{\"1001\":1}}],[\"udp保留数据边界\",{\"1\":{\"1001\":1}}],[\"udp\",{\"0\":{\"1001\":1,\"1002\":1,\"1004\":1},\"1\":{\"612\":1,\"962\":1,\"993\":1,\"994\":2,\"1001\":8,\"1003\":6,\"1004\":4,\"1006\":1,\"1033\":3,\"1042\":5}}],[\"ui\",{\"1\":{\"687\":1,\"696\":1}}],[\"uid=2时\",{\"1\":{\"587\":1}}],[\"uid\",{\"1\":{\"136\":1}}],[\"uuid\",{\"1\":{\"467\":1}}],[\"uri\",{\"1\":{\"755\":2}}],[\"uroot\",{\"1\":{\"459\":2}}],[\"urls\",{\"1\":{\"1143\":1}}],[\"url级别的权限访问控制\",{\"1\":{\"759\":1}}],[\"url显得冗长\",{\"1\":{\"467\":1}}],[\"url\",{\"0\":{\"959\":1,\"1029\":1},\"1\":{\"369\":1,\"445\":1,\"452\":1,\"755\":1,\"759\":1,\"882\":1,\"896\":10,\"1041\":1,\"1143\":1,\"1202\":1,\"1266\":1}}],[\"urlclassloader\",{\"1\":{\"181\":1}}],[\"upgrade\",{\"1\":{\"1144\":1}}],[\"up\",{\"1\":{\"499\":1}}],[\"upstream\",{\"1\":{\"451\":1}}],[\"update执行更新\",{\"1\":{\"1139\":1}}],[\"update\",{\"1\":{\"110\":2,\"425\":1,\"469\":1,\"489\":1,\"500\":1,\"501\":2,\"509\":1,\"514\":1,\"516\":1,\"559\":1,\"580\":1,\"1119\":1}}],[\"u=rwx\",{\"1\":{\"433\":1}}],[\"using\",{\"1\":{\"556\":2,\"702\":2,\"1178\":1}}],[\"usingrandom\",{\"1\":{\"304\":1}}],[\"usage\",{\"1\":{\"442\":1}}],[\"usr\",{\"1\":{\"416\":4,\"418\":3}}],[\"used+1\",{\"1\":{\"623\":1}}],[\"used\",{\"1\":{\"441\":1,\"623\":1,\"633\":2}}],[\"usetlab参数来设定\",{\"1\":{\"219\":1}}],[\"user=new\",{\"1\":{\"1070\":1}}],[\"username=dabin\",{\"1\":{\"1038\":1}}],[\"userid=\",{\"1\":{\"745\":1}}],[\"userid=10000\",{\"1\":{\"745\":1}}],[\"userid=b\",{\"1\":{\"601\":1}}],[\"userid\",{\"1\":{\"601\":5}}],[\"user2\",{\"1\":{\"587\":1}}],[\"user1\",{\"1\":{\"587\":1}}],[\"userserviceimpl\",{\"1\":{\"736\":1}}],[\"userservice\",{\"1\":{\"713\":2,\"734\":2,\"736\":2}}],[\"users\",{\"1\":{\"559\":1,\"601\":3,\"1143\":1,\"1144\":2}}],[\"user权限表\",{\"1\":{\"458\":1}}],[\"user\",{\"1\":{\"175\":1,\"331\":1,\"433\":1,\"446\":2,\"517\":2,\"554\":2,\"556\":1,\"641\":3,\"1038\":2,\"1039\":1,\"1070\":8,\"1148\":1,\"1178\":1,\"1202\":3}}],[\"use\",{\"1\":{\"73\":3,\"74\":1,\"294\":1,\"295\":1,\"459\":1,\"708\":1,\"1271\":1}}],[\"utcodeof\",{\"1\":{\"1261\":1}}],[\"ut2enunm\",{\"1\":{\"1261\":1}}],[\"ut2enum\",{\"1\":{\"1261\":5}}],[\"ut2b\",{\"1\":{\"1261\":2}}],[\"ut2a\",{\"1\":{\"1261\":2}}],[\"ut2\",{\"0\":{\"1259\":1},\"1\":{\"1249\":1,\"1259\":2,\"1261\":10}}],[\"utenumeration<string>\",{\"1\":{\"1261\":1}}],[\"utenumeration<t>\",{\"1\":{\"1247\":1,\"1260\":3}}],[\"utenumerationfactory\",{\"1\":{\"1247\":1}}],[\"utenumeration\",{\"1\":{\"1247\":1,\"1260\":1,\"1261\":1}}],[\"utf8mb4\",{\"1\":{\"601\":1,\"1177\":2}}],[\"utf8\",{\"1\":{\"288\":1,\"291\":1}}],[\"utils\",{\"1\":{\"736\":1}}],[\"util\",{\"1\":{\"103\":1,\"108\":1,\"185\":1,\"390\":1,\"951\":2,\"952\":1,\"953\":2,\"955\":2,\"956\":1}}],[\"u8来分别代表1\",{\"1\":{\"284\":1}}],[\"u4\",{\"1\":{\"284\":1}}],[\"u2\",{\"1\":{\"284\":1}}],[\"u\",{\"1\":{\"81\":1,\"425\":1,\"426\":1,\"433\":2,\"452\":1,\"1177\":1,\"1178\":1,\"1190\":1}}],[\"unchecked\",{\"1\":{\"717\":1}}],[\"uncommitted\",{\"1\":{\"522\":2,\"741\":1}}],[\"unrepeatableread\",{\"1\":{\"521\":1}}],[\"undolog\",{\"1\":{\"559\":1}}],[\"undo\",{\"0\":{\"570\":1},\"1\":{\"499\":1,\"519\":1,\"559\":1,\"567\":2,\"570\":3}}],[\"unsubscribe\",{\"1\":{\"673\":1}}],[\"unsigned\",{\"1\":{\"468\":1,\"476\":1,\"997\":1}}],[\"unsafe\",{\"1\":{\"110\":1}}],[\"unicode\",{\"1\":{\"1177\":1,\"1190\":3}}],[\"uninstall\",{\"1\":{\"1144\":1}}],[\"union语句注意事项\",{\"1\":{\"485\":1}}],[\"union\",{\"0\":{\"480\":2},\"1\":{\"480\":3,\"485\":4,\"560\":1}}],[\"uniqueinstance\",{\"1\":{\"1066\":5,\"1067\":14,\"1068\":5}}],[\"unique\",{\"1\":{\"462\":1,\"527\":1}}],[\"unixtime\",{\"1\":{\"475\":1,\"533\":1}}],[\"unix\",{\"1\":{\"150\":1,\"354\":1,\"475\":3,\"533\":1}}],[\"unit\",{\"1\":{\"58\":3,\"61\":1,\"972\":1,\"982\":1}}],[\"unlock\",{\"1\":{\"73\":2,\"74\":1,\"75\":1,\"102\":1,\"126\":2,\"294\":1,\"295\":2,\"510\":1}}],[\"unpark\",{\"1\":{\"38\":3}}],[\"uos\",{\"1\":{\"18\":1}}],[\"也表示类之间的整体与部分的关系\",{\"1\":{\"1099\":1}}],[\"也违背了\",{\"1\":{\"1090\":1}}],[\"也好像如同上图虚线一样传递给了对方\",{\"1\":{\"963\":1}}],[\"也具有不同的主键\",{\"1\":{\"856\":1}}],[\"也即点对点的通信\",{\"1\":{\"844\":1}}],[\"也即是跳跃表目前包含节点的数量\",{\"1\":{\"630\":1}}],[\"也即虚拟文件系统\",{\"1\":{\"416\":1}}],[\"也变成了\",{\"1\":{\"628\":1}}],[\"也依然只苏醒⼀次\",{\"1\":{\"613\":1}}],[\"也要关注异常的业务流程\",{\"1\":{\"1216\":1}}],[\"也要消耗掉一个序号\",{\"1\":{\"1026\":1}}],[\"也要提一下使用缓存的考虑\",{\"1\":{\"606\":1}}],[\"也要确保一次性写入\",{\"1\":{\"571\":1}}],[\"也能保证数据不被伪造\",{\"1\":{\"1057\":1}}],[\"也能收到这条消息\",{\"1\":{\"986\":1}}],[\"也能对不同的业务的数据进行分级管理\",{\"1\":{\"585\":1}}],[\"也能做到不加锁\",{\"1\":{\"499\":1}}],[\"也\",{\"1\":{\"582\":1}}],[\"也已经写完了\",{\"1\":{\"578\":1}}],[\"也差不多\",{\"1\":{\"568\":1}}],[\"也有其他级别缓存兜底\",{\"1\":{\"642\":1}}],[\"也有可能是每个\",{\"1\":{\"562\":1}}],[\"也有抢占式的\",{\"1\":{\"150\":1}}],[\"也执行这么慢\",{\"1\":{\"559\":1}}],[\"也将聚集索引的叶子节点称为数据页\",{\"1\":{\"547\":1}}],[\"也限定了本线程接下来的操作对象\",{\"1\":{\"510\":1}}],[\"也从服务器仓库中拉取别人的提交\",{\"1\":{\"452\":1}}],[\"也叫本地缓存\",{\"1\":{\"752\":1}}],[\"也叫软连接\",{\"1\":{\"427\":1}}],[\"也叫内存泄漏\",{\"1\":{\"302\":1}}],[\"也叫内中断\",{\"1\":{\"134\":1}}],[\"也就根本不可能从数字签名确定对方的合法性了\",{\"1\":{\"1057\":1}}],[\"也就不知道\",{\"1\":{\"1061\":1}}],[\"也就不存在\",{\"1\":{\"870\":1}}],[\"也就不会出现不可重复读\",{\"1\":{\"523\":1}}],[\"也就要尽量把数据分配均匀\",{\"1\":{\"404\":1}}],[\"也就是只存在一个产品等级结构时\",{\"1\":{\"1080\":1}}],[\"也就是伪造第一次握手数据包\",{\"1\":{\"1060\":1}}],[\"也就是第三次手不握了\",{\"1\":{\"1054\":1}}],[\"也就是第三条中的\",{\"1\":{\"919\":1}}],[\"也就是a已经没数据要发给b了\",{\"1\":{\"1026\":1}}],[\"也就是acquire\",{\"1\":{\"124\":1}}],[\"也就是传输层能够区分不同的进程的数据并且加以区分处理\",{\"1\":{\"999\":1}}],[\"也就是最多有\",{\"1\":{\"996\":1}}],[\"也就是地址掩码中1的个数\",{\"1\":{\"991\":1}}],[\"也就是每一个网卡就有一个mac地址\",{\"1\":{\"979\":1}}],[\"也就是每个表必须有主键\",{\"1\":{\"455\":1}}],[\"也就是把数据\",{\"1\":{\"960\":1}}],[\"也就是取关键字的某个线性值作为地址\",{\"1\":{\"923\":1}}],[\"也就是一个结点能够存放\",{\"1\":{\"919\":1}}],[\"也就是一个线程何时可以看到由其他线程修改的变量\",{\"1\":{\"65\":1}}],[\"也就是nums\",{\"1\":{\"912\":1,\"913\":1}}],[\"也就是new一个对象\",{\"1\":{\"733\":1}}],[\"也就是越热门\",{\"1\":{\"893\":1}}],[\"也就是对实体\",{\"1\":{\"1218\":1}}],[\"也就是对一个真实节点做多个副本\",{\"1\":{\"880\":1}}],[\"也就是对存储节点做哈希映射\",{\"1\":{\"880\":1}}],[\"也就是在对系统做扩容或者缩容时\",{\"1\":{\"880\":1}}],[\"也就是在statement和row之间选择一种\",{\"1\":{\"572\":1}}],[\"也就是上文中提到的简易版拜占庭\",{\"1\":{\"873\":1}}],[\"也就是牺牲数据的一致性来满足系统的高可用性\",{\"1\":{\"871\":1}}],[\"也就是blocking\",{\"1\":{\"829\":1}}],[\"也就是bind方法中返回的对象\",{\"1\":{\"725\":1}}],[\"也就是t2线程拿到了一个未初始化完毕的单例\",{\"1\":{\"714\":1}}],[\"也就是被缓存的对象大部分集中缓存在某一台服务器上\",{\"1\":{\"681\":1}}],[\"也就是读取数据库中的所有键值对\",{\"1\":{\"651\":1}}],[\"也就是读写锁允许多个线程同时对某一资源进行读\",{\"1\":{\"115\":1}}],[\"也就是真正的对象存储的空间\",{\"1\":{\"631\":1}}],[\"也就是双向链表\",{\"1\":{\"618\":1}}],[\"也就是大表拆小表\",{\"1\":{\"585\":1}}],[\"也就是主从延迟\",{\"1\":{\"582\":1}}],[\"也就是图中的绿色部分\",{\"1\":{\"568\":1}}],[\"也就是图中的黄色部分\",{\"1\":{\"568\":1}}],[\"也就是执行计划\",{\"1\":{\"556\":1}}],[\"也就是我们说的充血模型\",{\"1\":{\"1230\":1}}],[\"也就是我们的\",{\"1\":{\"550\":1}}],[\"也就是我们读取一页内的数据时候\",{\"1\":{\"543\":1}}],[\"也就是回表查询\",{\"1\":{\"549\":1}}],[\"也就是mvcc也不存在\",{\"1\":{\"501\":1}}],[\"也就是关联一个远程库\",{\"1\":{\"452\":1}}],[\"也就是它只会通知你一次\",{\"1\":{\"381\":1}}],[\"也就是具有该对象的锁\",{\"1\":{\"350\":1}}],[\"也就是要先分清楚到底是出现了内存泄漏还是内存溢出\",{\"1\":{\"298\":1}}],[\"也就是方法描述时在throws关键字后面列举的异常\",{\"1\":{\"292\":1}}],[\"也就是未逃逸出去\",{\"1\":{\"199\":1}}],[\"也就是字节码\",{\"1\":{\"197\":1}}],[\"也就是得到类或者字段\",{\"1\":{\"172\":1}}],[\"也就是不再需要带着库一块发布\",{\"1\":{\"161\":1}}],[\"也就是个服务线程\",{\"1\":{\"143\":1}}],[\"也就是乐观锁\",{\"1\":{\"142\":1}}],[\"也就是\",{\"1\":{\"101\":1,\"144\":1,\"518\":1,\"577\":1,\"620\":1,\"886\":1,\"1075\":1}}],[\"也就是先将引用了指向了对象\",{\"1\":{\"101\":1,\"714\":1}}],[\"也就是完成了第一个步骤\",{\"1\":{\"101\":1,\"714\":1}}],[\"也就是没有线程产生实际竞争\",{\"1\":{\"87\":1}}],[\"也就是cpu\",{\"1\":{\"71\":1}}],[\"也就是说你的仓库地址是\",{\"1\":{\"1197\":1}}],[\"也就是说它只是可读的\",{\"1\":{\"1041\":1}}],[\"也就是说同一个客户第二次访问同一个服务器上的页面时\",{\"1\":{\"1037\":1}}],[\"也就是说双方在交换http报文之前\",{\"1\":{\"1037\":1}}],[\"也就是说数据发送出来它已经是粘包的状态了\",{\"1\":{\"1006\":1}}],[\"也就是说当n\",{\"1\":{\"948\":1}}],[\"也就是说i我们内存没办法直接装下\",{\"1\":{\"904\":1}}],[\"也就是说文档指向了它包含的那些单词\",{\"1\":{\"888\":1}}],[\"也就是说只要有足够的磁盘空间\",{\"1\":{\"886\":1}}],[\"也就是说只要锁住这个链表的头结点\",{\"1\":{\"130\":1}}],[\"也就是说两台服务器\",{\"1\":{\"801\":1}}],[\"也就是说控制对象生存周期的不再是引用它的对象\",{\"1\":{\"718\":1}}],[\"也就是说每台\",{\"1\":{\"659\":1}}],[\"也就是说change\",{\"1\":{\"574\":1}}],[\"也就是说1秒钟能转120次\",{\"1\":{\"543\":1}}],[\"也就是说一个时间戳在不同的时区所代表的具体时间是不同的\",{\"1\":{\"475\":1}}],[\"也就是说一直读到\",{\"1\":{\"381\":1}}],[\"也就是说如果web服务器做了负载均衡\",{\"1\":{\"1052\":1}}],[\"也就是说如果使用读写锁依然会出现读线程阻塞等待的情况\",{\"1\":{\"411\":1}}],[\"也就是说如果父类访问修饰符是\",{\"1\":{\"359\":1}}],[\"也就是说赋值的前后都在写屏障的覆盖范畴内\",{\"1\":{\"250\":1}}],[\"也就是说在某个较短的时间段内\",{\"1\":{\"158\":1}}],[\"也就是说我们的用户程序\",{\"1\":{\"135\":1}}],[\"也就是说\",{\"1\":{\"36\":1,\"118\":1,\"134\":1,\"166\":1,\"290\":1,\"406\":1,\"427\":1,\"490\":1,\"522\":1,\"554\":1,\"568\":1,\"716\":1,\"745\":1,\"804\":1,\"882\":1,\"978\":1,\"1042\":1,\"1079\":1}}],[\"也一定为\",{\"0\":{\"341\":1}}],[\"也正是因为继承了这个依赖\",{\"1\":{\"779\":1}}],[\"也正是因为返回值不会包含在特征签名之中\",{\"1\":{\"290\":1}}],[\"也正是因为堆与栈分离的思想才使得jvm的垃圾回收成为可能\",{\"1\":{\"198\":1}}],[\"也没有包的拆分合并\",{\"1\":{\"1006\":1}}],[\"也没有必要使用缓存\",{\"1\":{\"606\":1}}],[\"也没有特别的含义\",{\"1\":{\"227\":1}}],[\"也没有对变量的赋值操作\",{\"1\":{\"173\":1}}],[\"也不发送数据\",{\"1\":{\"1023\":1}}],[\"也不拆分\",{\"1\":{\"1006\":1}}],[\"也不关心\",{\"1\":{\"982\":1}}],[\"也不需要使用字节插入来保证透明传输\",{\"1\":{\"980\":1}}],[\"也不需要进行流量控制\",{\"1\":{\"975\":1}}],[\"也不需要加锁\",{\"1\":{\"831\":1}}],[\"也不需要并发控制\",{\"1\":{\"499\":1}}],[\"也不会一直等\",{\"1\":{\"1022\":1}}],[\"也不会向服务器端发送数据\",{\"1\":{\"1022\":1}}],[\"也不会出现线程安全问题\",{\"1\":{\"735\":1}}],[\"也不会靠随意回收具有强引用的对象来解决内存不足问题\",{\"1\":{\"235\":1}}],[\"也不会被回收\",{\"1\":{\"192\":1,\"304\":1}}],[\"也不是我们定义的那组接口的类型\",{\"1\":{\"349\":1}}],[\"也不是\",{\"1\":{\"209\":1}}],[\"也包括运行期解析之后才能获得的方法或者字段引用\",{\"1\":{\"208\":1}}],[\"也包括了使用instanceof关键字做对象所属关系判定等各种情况\",{\"1\":{\"166\":1}}],[\"也成锁消除\",{\"1\":{\"202\":1}}],[\"也编写了处理数据的逻辑\",{\"1\":{\"198\":1}}],[\"也保证了\",{\"1\":{\"184\":1}}],[\"也称开地址法\",{\"1\":{\"884\":1}}],[\"也称为码分多址cdma\",{\"1\":{\"967\":1}}],[\"也称为拉链法\",{\"1\":{\"884\":1}}],[\"也称为修饰的标识为常量\",{\"1\":{\"370\":1}}],[\"也称快照\",{\"1\":{\"647\":1}}],[\"也称\",{\"1\":{\"178\":1}}],[\"也是圆梦了\",{\"1\":{\"1167\":1}}],[\"也是拒绝服务攻击的一种\",{\"1\":{\"1054\":1}}],[\"也是为了实现可靠传输的\",{\"1\":{\"1009\":1}}],[\"也是目前业界热点技术\",{\"1\":{\"748\":1}}],[\"也是持久化要做的工作\",{\"1\":{\"748\":1}}],[\"也是利用了\",{\"1\":{\"603\":1}}],[\"也是类似的实践\",{\"1\":{\"587\":1}}],[\"也是可能已经持久化到磁盘的\",{\"1\":{\"568\":1}}],[\"也是直接写在\",{\"1\":{\"568\":1}}],[\"也是一样\",{\"1\":{\"478\":1}}],[\"也是一直阻塞到有客户端连接才会返回\",{\"1\":{\"377\":1}}],[\"也是通过数组实现的\",{\"1\":{\"393\":1}}],[\"也是使用基于region的堆内存布局\",{\"1\":{\"267\":1}}],[\"也是采用了与\",{\"1\":{\"128\":1}}],[\"也是独立实现的\",{\"1\":{\"42\":1}}],[\"也可采用与第1题类似的方法\",{\"1\":{\"900\":1}}],[\"也可修改默认值\",{\"1\":{\"768\":1}}],[\"也可能不在其中\",{\"1\":{\"901\":1}}],[\"也可能开启一个新事务\",{\"1\":{\"740\":1}}],[\"也可能会出现问题\",{\"1\":{\"657\":1}}],[\"也可能会存在死锁和线程池阻塞的风险\",{\"1\":{\"643\":1}}],[\"也可能会导致内存耗尽\",{\"1\":{\"303\":1}}],[\"也可能拖垮整个库\",{\"1\":{\"525\":1}}],[\"也可能等待资源调度\",{\"1\":{\"38\":1}}],[\"也可以在关联线的两端标注角色名\",{\"1\":{\"1097\":1}}],[\"也可以用黑色节点表示较大的那个元素\",{\"1\":{\"921\":1}}],[\"也可以关闭某个自动配置的选项\",{\"1\":{\"777\":1}}],[\"也可以说是为了集成测试\",{\"1\":{\"774\":1}}],[\"也可以将数据库表中的行转化为\",{\"1\":{\"747\":1}}],[\"也可以使用\",{\"1\":{\"727\":1}}],[\"也可以使用class\",{\"1\":{\"348\":1}}],[\"也可以牺牲一个备用节点\",{\"1\":{\"674\":1}}],[\"也可以向多个\",{\"1\":{\"673\":1}}],[\"也可以配合expire\",{\"1\":{\"669\":1}}],[\"也可以配置开关实现人工降级\",{\"1\":{\"644\":1}}],[\"也可以部署在其他的机器上\",{\"1\":{\"657\":1}}],[\"也可以节省大量内存\",{\"1\":{\"637\":1}}],[\"也可以是一对多的关系\",{\"1\":{\"1232\":1}}],[\"也可以是一周一备\",{\"1\":{\"576\":1}}],[\"也可以是单向的\",{\"1\":{\"1097\":1}}],[\"也可以是可扩展的\",{\"1\":{\"199\":1}}],[\"也可以通过\",{\"1\":{\"614\":1}}],[\"也可以通过触发semi\",{\"1\":{\"501\":1}}],[\"也可以通过指定\",{\"1\":{\"125\":1}}],[\"也可以往表中插入新的记录\",{\"1\":{\"492\":1}}],[\"也可以序列化\",{\"1\":{\"343\":1}}],[\"也可以理解为\",{\"1\":{\"251\":1}}],[\"也可以反过来\",{\"1\":{\"244\":1}}],[\"也可以按消息的类型读取\",{\"1\":{\"149\":1}}],[\"也可以等待\",{\"1\":{\"121\":1}}],[\"也可以叫同步点\",{\"1\":{\"120\":1}}],[\"也属于\",{\"1\":{\"120\":1}}],[\"也提供了实现共享锁的模版方法\",{\"1\":{\"81\":1}}],[\"也会先经反序列化解压\",{\"1\":{\"804\":1}}],[\"也会有自己觉得用起来不错的开发方式\",{\"1\":{\"692\":1}}],[\"也会对负载因子做检查\",{\"1\":{\"623\":1}}],[\"也会越来越大\",{\"1\":{\"583\":1}}],[\"也会执行merge操作\",{\"1\":{\"574\":1}}],[\"也会被写入到磁盘上\",{\"1\":{\"574\":1}}],[\"也会被后台线程一起持久化到磁盘\",{\"1\":{\"568\":1}}],[\"也会耗费一定空间\",{\"1\":{\"528\":1}}],[\"也会进入新生代\",{\"1\":{\"495\":1}}],[\"也会拖慢总查询速度\",{\"1\":{\"486\":1}}],[\"也会根据\",{\"1\":{\"396\":1}}],[\"也会导致无法单独删除该对象\",{\"1\":{\"304\":1}}],[\"也会让对比结果继续向g1倾斜\",{\"1\":{\"262\":1}}],[\"也会自动由扩展类加载器加载\",{\"1\":{\"177\":1}}],[\"也会把接收到的消息放入\",{\"1\":{\"72\":1}}],[\"也会增加复杂度\",{\"1\":{\"64\":1}}],[\"也会随之销毁\",{\"1\":{\"42\":1}}],[\"也支持公平策略\",{\"1\":{\"62\":1}}],[\"也随之结束\",{\"1\":{\"45\":1}}],[\"正则表达式修饰符\",{\"0\":{\"1190\":1},\"1\":{\"1188\":1}}],[\"正则表达式\",{\"0\":{\"1187\":1}}],[\"正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询\",{\"1\":{\"888\":1}}],[\"正向索引开发出来用来存储每个文档的单词的列表\",{\"1\":{\"888\":1}}],[\"正向代理主要是为了突破网络访问限制\",{\"1\":{\"826\":1}}],[\"正向代理相对于目标服务器而言隐藏了客户端的真实ip地址\",{\"1\":{\"826\":1}}],[\"正向代理\",{\"0\":{\"826\":1},\"1\":{\"826\":1}}],[\"正因为\",{\"1\":{\"1001\":1}}],[\"正因为联合索引的b值可能没有顺序\",{\"1\":{\"551\":1}}],[\"正因为有切换才导致了\",{\"1\":{\"380\":1}}],[\"正常客户发送\",{\"1\":{\"1060\":1}}],[\"正常情况下\",{\"1\":{\"623\":1}}],[\"正常情况下为快照读\",{\"1\":{\"501\":1}}],[\"正常调用完成\",{\"1\":{\"195\":1}}],[\"正确的注入就直接在变量定义之后\",{\"1\":{\"1159\":1}}],[\"正确\",{\"1\":{\"481\":1}}],[\"正确写法\",{\"1\":{\"26\":1}}],[\"正好相当于一个\",{\"1\":{\"405\":1}}],[\"正好是\",{\"1\":{\"156\":1}}],[\"正是因为程序运行具有局部性原理\",{\"1\":{\"158\":1}}],[\"正在做\",{\"1\":{\"623\":1}}],[\"正在活跃的事务id列表\",{\"1\":{\"499\":1}}],[\"正在执行的进程\",{\"1\":{\"148\":1}}],[\"正在执行的进程因发生某等待事件而无法执行\",{\"1\":{\"148\":1}}],[\"正在执行用户态程序时\",{\"1\":{\"134\":1}}],[\"正在使用哪些文件\",{\"1\":{\"136\":1}}],[\"正在使用哪些\",{\"1\":{\"136\":1}}],[\"正在创建实例\",{\"1\":{\"101\":1}}],[\"正在修改该变量的值\",{\"1\":{\"72\":1}}],[\"正在\",{\"1\":{\"38\":1}}],[\"6379\",{\"1\":{\"1192\":1}}],[\"610798187\",{\"1\":{\"1202\":2}}],[\"61\",{\"1\":{\"1139\":2}}],[\"6oct2003\",{\"1\":{\"1038\":1}}],[\"65535\",{\"1\":{\"1000\":1}}],[\"62\",{\"1\":{\"935\":1}}],[\"60\",{\"1\":{\"708\":1}}],[\"6版本之前\",{\"1\":{\"553\":1}}],[\"64m\",{\"1\":{\"1177\":1}}],[\"64\",{\"1\":{\"315\":1,\"398\":1,\"401\":1,\"472\":1,\"618\":1,\"622\":1,\"671\":1,\"1042\":1}}],[\"64位数据类型所占的栈容量为2\",{\"1\":{\"193\":1}}],[\"6及之前\",{\"1\":{\"204\":1}}],[\"6时\",{\"1\":{\"185\":1}}],[\"6\",{\"0\":{\"394\":1,\"897\":1,\"1101\":1,\"1233\":1},\"1\":{\"38\":1,\"91\":1,\"131\":1,\"304\":1,\"350\":1,\"398\":1,\"401\":1,\"409\":1,\"468\":1,\"539\":1,\"547\":1,\"553\":1,\"554\":1,\"610\":1,\"636\":1,\"678\":1,\"687\":1,\"938\":1,\"952\":1,\"956\":2,\"1095\":1,\"1144\":2,\"1162\":1}}],[\"它一般包含主食\",{\"1\":{\"1086\":1}}],[\"它属于对象结构型模式\",{\"1\":{\"1085\":1}}],[\"它属于面向通信部分的最高层\",{\"1\":{\"997\":1}}],[\"它同具体工厂之间是多对一的关系\",{\"1\":{\"1079\":1}}],[\"它同样是一个单线程收集器\",{\"1\":{\"256\":1}}],[\"它包含多个创建产品的方法\",{\"1\":{\"1079\":1}}],[\"它用于格式化一个本地日期或者时间\",{\"1\":{\"1077\":1}}],[\"它被所有需要进行实例化的客户类调用\",{\"1\":{\"1077\":1}}],[\"它被分为三个核心部件\",{\"1\":{\"754\":1}}],[\"它降低了客户与实现模块之间的耦合\",{\"1\":{\"1064\":1}}],[\"它非常的慢\",{\"1\":{\"1056\":1}}],[\"它记录一个报文段发出的时间\",{\"1\":{\"1012\":1}}],[\"它记录了数据库上的所有改变\",{\"1\":{\"571\":1}}],[\"它启动一个定时器\",{\"1\":{\"1009\":1}}],[\"它指出tcp报文段的数据起始处距离tcp报文段的起始处有多远\",{\"1\":{\"1007\":1}}],[\"它指向了对应的行数据\",{\"1\":{\"546\":1}}],[\"它无法满足我们的需求\",{\"1\":{\"996\":1}}],[\"它地址长度为\",{\"1\":{\"996\":1}}],[\"它至少有一个有效的外部全球ip地址\",{\"1\":{\"995\":1}}],[\"它负责对数据加上ip地址和其他数据以及确定传输的目标\",{\"1\":{\"964\":1}}],[\"它负责加载<java\",{\"1\":{\"177\":1}}],[\"它主要为⽹络层提供链路级别传输的服务\",{\"1\":{\"961\":1}}],[\"它或者是一颗空树\",{\"1\":{\"915\":1}}],[\"它大大降低了我们对系统的要求\",{\"1\":{\"871\":1}}],[\"它唯一确定了partition中的一条message\",{\"1\":{\"847\":1}}],[\"它监听的端口号\",{\"1\":{\"824\":1}}],[\"它就是⽤来唯⼀标识设备的\",{\"1\":{\"961\":1}}],[\"它就开始接受客户端的请求\",{\"1\":{\"878\":1}}],[\"它就会在该任期内担任\",{\"1\":{\"876\":1}}],[\"它就查一下这个表\",{\"1\":{\"804\":1}}],[\"它就进入了一个全新的并且不再受虚拟机限制的世界\",{\"1\":{\"197\":1}}],[\"它也是\",{\"1\":{\"777\":1}}],[\"它也可以实现线程间的技术等待\",{\"1\":{\"120\":1}}],[\"它整合了这个模块需要的依赖库\",{\"1\":{\"772\":1}}],[\"它能将模块所需的依赖整合起来并对模块内的bean根据环境\",{\"1\":{\"772\":1}}],[\"它能够用来遍历集合中的元素\",{\"1\":{\"389\":1}}],[\"它还有一个子接口\",{\"1\":{\"1090\":1}}],[\"它还提供h2数据库控制台以更好地测试应用程序\",{\"1\":{\"769\":1}}],[\"它还是在class文件中第一个出现的表类型数据项目\",{\"1\":{\"286\":1}}],[\"它有助于提高开发人员的生产力\",{\"1\":{\"769\":1}}],[\"它有两种用途\",{\"1\":{\"256\":1}}],[\"它分离了表现与交互\",{\"1\":{\"754\":1}}],[\"它比spring\",{\"1\":{\"720\":1}}],[\"它并不局限于\",{\"1\":{\"685\":1}}],[\"它并不是我们的\",{\"1\":{\"349\":1}}],[\"它周期性的随机选择一些节点\",{\"1\":{\"684\":1}}],[\"它会一直等待客户端发送数据\",{\"1\":{\"1022\":1}}],[\"它会在其他服务器超时之前赢得选举\",{\"1\":{\"877\":1}}],[\"它会对服务提供者\",{\"1\":{\"802\":1}}],[\"它会独立运行\",{\"1\":{\"657\":1}}],[\"它会自行处理这些\",{\"1\":{\"379\":1}}],[\"它给父进程发送一个信号\",{\"1\":{\"651\":1}}],[\"它在每一个写命令后都有一个慢速的落盘操作\",{\"1\":{\"650\":1}}],[\"它为没有实现接口的类提供代理\",{\"1\":{\"1084\":1}}],[\"它为我们提供多种数据结构\",{\"1\":{\"637\":1}}],[\"它为事务分配单向增长的时间戳\",{\"1\":{\"499\":1}}],[\"它采用\",{\"1\":{\"611\":1}}],[\"它对安全性的要求比从服务器高\",{\"1\":{\"582\":1}}],[\"它对数据库中数据的改变是持久的\",{\"1\":{\"519\":1}}],[\"它发生在一个事务\",{\"1\":{\"521\":1}}],[\"它允许程序在运行的时候动态生成对象\",{\"1\":{\"718\":1}}],[\"它允许行级锁与表级锁共存\",{\"1\":{\"514\":1}}],[\"它允许同一时刻多个线程访问同一资源\",{\"1\":{\"142\":1}}],[\"它从\",{\"1\":{\"488\":1}}],[\"它表示返回最大的记录行数目\",{\"1\":{\"486\":1}}],[\"它与时区无关\",{\"1\":{\"475\":1}}],[\"它跟某个\",{\"1\":{\"450\":1}}],[\"它需要程序员自己编写\",{\"1\":{\"749\":1}}],[\"它需要占用一个数据块来存储这个文件\",{\"1\":{\"442\":1}}],[\"它需要调用由其他厂商实现并部署在应用程序的classpath下的jndi服务提供者接口\",{\"1\":{\"185\":1}}],[\"它实际上是一个特殊的文件\",{\"1\":{\"427\":1}}],[\"它实现的接口\",{\"1\":{\"392\":2}}],[\"它支持高并发的访问和更新\",{\"1\":{\"410\":1}}],[\"它持有指向下一个元素的引用\",{\"1\":{\"396\":1}}],[\"它首先需要支持开发语言的\",{\"1\":{\"825\":1}}],[\"它首先检查索引值合法性\",{\"1\":{\"392\":1}}],[\"它首先不会自己去尝试加载这个类\",{\"1\":{\"184\":1}}],[\"它增删速度比较快\",{\"1\":{\"392\":1}}],[\"它只允许在一端进行插入数据操作\",{\"1\":{\"941\":1}}],[\"它只需要很少的代码\",{\"1\":{\"789\":1}}],[\"它只要知道反正有一行被锁了就行了\",{\"1\":{\"514\":1}}],[\"它只比迭代器遍历多了生成中间变量这一步\",{\"1\":{\"391\":1}}],[\"它只会提示一次\",{\"1\":{\"381\":1}}],[\"它将变与不变相分离\",{\"1\":{\"1086\":1}}],[\"它将用户传入的数据拷贝到内核空间\",{\"1\":{\"381\":1}}],[\"它将会从父线程中继承一个\",{\"1\":{\"179\":1}}],[\"它仅仅知道有\",{\"1\":{\"381\":1}}],[\"它仅仅起着占位符的作用\",{\"1\":{\"227\":1}}],[\"它具有独立处理\",{\"1\":{\"379\":1}}],[\"它提供三大核心能力\",{\"1\":{\"809\":1}}],[\"它提供了一个创建代理对象的静态方法\",{\"1\":{\"1083\":1}}],[\"它提供了一种机制\",{\"1\":{\"1049\":1}}],[\"它提供了\",{\"1\":{\"607\":1}}],[\"它提供了许多的方法\",{\"1\":{\"349\":1}}],[\"它提供一个同步点\",{\"1\":{\"127\":1}}],[\"它把store操作从工作内存中得到的变量的值放入主内存的变量中\",{\"1\":{\"294\":1}}],[\"它把工作内存中一个变量的值传送到主内存中\",{\"1\":{\"294\":1}}],[\"它把工作内存中一个变量的值传递给执行引擎\",{\"1\":{\"294\":1}}],[\"它把read操作从主内存中得到的变量值放入工作内存的变量副本中\",{\"1\":{\"294\":1}}],[\"它把一个从执行引擎接收的值赋给工作内存的变量\",{\"1\":{\"294\":1}}],[\"它把一个变量的值从主内存传输到线程的工作内存中\",{\"1\":{\"294\":1}}],[\"它把一个变量标识为一条线程独占的状态\",{\"1\":{\"294\":1}}],[\"它把一个处于锁定状态的变量释放出来\",{\"1\":{\"294\":1}}],[\"它把堆内存分割为很多不相关的region\",{\"1\":{\"260\":1}}],[\"它定义了记忆集的记录精度\",{\"1\":{\"249\":1}}],[\"它节省了一次指针定位的时间开销\",{\"1\":{\"230\":1}}],[\"它可以是抽象类或接口\",{\"1\":{\"1092\":1}}],[\"它可以自动分配\",{\"1\":{\"981\":1}}],[\"它可以监听客户端的请求\",{\"1\":{\"759\":1}}],[\"它可以保证以下特性\",{\"1\":{\"672\":1}}],[\"它可以将数据分布到集群的不同节点上\",{\"1\":{\"585\":1}}],[\"它可以用来查看数据库的变更历史\",{\"1\":{\"571\":1}}],[\"它可以使用native函数库直接分配堆外内存\",{\"1\":{\"209\":1}}],[\"它可能被外部方法所引用\",{\"1\":{\"202\":1}}],[\"它可能处于运行状态\",{\"1\":{\"38\":1}}],[\"它和时区有关\",{\"1\":{\"475\":1}}],[\"它和虚拟机拥有相同的权限\",{\"1\":{\"197\":1}}],[\"它和独占式的区别在于\",{\"1\":{\"123\":1}}],[\"它通过对算法进行封装\",{\"1\":{\"1088\":1}}],[\"它通过反射调用类中\",{\"1\":{\"729\":1}}],[\"它通过在classpath路径下的meta\",{\"1\":{\"185\":1}}],[\"它通常是被分隔成多个页\",{\"1\":{\"157\":1}}],[\"它由一个模板方法和若干个基本方法构成\",{\"1\":{\"1087\":1}}],[\"它由\",{\"1\":{\"168\":1,\"381\":1}}],[\"它使得应用程序认为它拥有连续的可用的内存\",{\"1\":{\"157\":1}}],[\"它使得线程能够从中断点恢复执行\",{\"1\":{\"144\":1}}],[\"它的典型应用就是spring\",{\"1\":{\"1083\":1}}],[\"它的过程\",{\"1\":{\"1060\":1}}],[\"它的基本原理就是每发完一个分组就停止发送\",{\"1\":{\"1009\":1,\"1010\":1}}],[\"它的基本思想\",{\"1\":{\"684\":1}}],[\"它的左右子树也均是二叉排序树\",{\"1\":{\"915\":1}}],[\"它的目标是尽可能以最快的速度传递消息\",{\"1\":{\"858\":1}}],[\"它的实现类支持不同的视图类型如jsp\",{\"1\":{\"755\":1}}],[\"它的实现原理主要是版本链\",{\"1\":{\"499\":1}}],[\"它的主要目的是借助于\",{\"1\":{\"718\":1}}],[\"它的原理是哨兵通过发送命令\",{\"1\":{\"676\":1}}],[\"它的的取值范围是\",{\"1\":{\"659\":1}}],[\"它的内部实现也比较干净\",{\"1\":{\"607\":1}}],[\"它的数据无序的放置在磁盘的存储器上\",{\"1\":{\"548\":1}}],[\"它的关键点就是先写日志\",{\"1\":{\"489\":1,\"569\":1}}],[\"它的作用\",{\"1\":{\"464\":1}}],[\"它的作用是记住下一条\",{\"1\":{\"144\":1}}],[\"它的方法上加了\",{\"1\":{\"393\":1}}],[\"它的取值在程序的整个执行过程中将不会改变\",{\"1\":{\"370\":1}}],[\"它的名称都要从常量池中引用一个constant\",{\"1\":{\"291\":1}}],[\"它的每个region都维护有自己的记忆集\",{\"1\":{\"265\":1}}],[\"它的生命周期很长\",{\"1\":{\"210\":1}}],[\"它的代码由启动类加载器来完成加载\",{\"1\":{\"185\":1}}],[\"它的搜索范围中没有找到所需的类\",{\"1\":{\"184\":1}}],[\"它的自定义同步器需要在同步状态\",{\"1\":{\"125\":1}}],[\"它都会进行加锁\",{\"1\":{\"142\":1}}],[\"它要做的事情是\",{\"1\":{\"120\":1}}],[\"它不断监听tcp的端口80\",{\"1\":{\"1037\":1}}],[\"它不是什么技术\",{\"1\":{\"718\":1}}],[\"它不会通知你\",{\"1\":{\"381\":1}}],[\"它不仅提供了公共方法的实现\",{\"1\":{\"362\":1}}],[\"它不需要显式地调用父类构造器\",{\"1\":{\"173\":1}}],[\"它不能再次被使用\",{\"1\":{\"119\":1}}],[\"它不保证程序中各语句执行先后顺序同代码中顺序一致\",{\"1\":{\"70\":1}}],[\"它默认构造\",{\"1\":{\"118\":1}}],[\"它假设所有线程访问共享资源时不会出现冲突\",{\"1\":{\"105\":1}}],[\"它们是什么意思\",{\"1\":{\"1140\":1}}],[\"它们是最强的\",{\"1\":{\"1095\":1}}],[\"它们是一个顶级逻辑的一个组成步骤\",{\"1\":{\"1087\":1}}],[\"它们两者都要定义一个适配器类来实现当前系统的业务接口\",{\"1\":{\"1092\":1}}],[\"它们不会发送任何请求\",{\"1\":{\"874\":1}}],[\"它们的编号是\",{\"1\":{\"820\":1}}],[\"它们的区别是什么\",{\"0\":{\"783\":1}}],[\"它们之间的区别\",{\"1\":{\"745\":1}}],[\"它们就使用到了模板模式\",{\"1\":{\"742\":1}}],[\"它们经常发生在核心关注点的多处\",{\"1\":{\"719\":1}}],[\"它们占的空间还是\",{\"1\":{\"477\":1}}],[\"它们每次调用epoll\",{\"1\":{\"381\":1}}],[\"它们都会自定义类的加载器\",{\"1\":{\"180\":1}}],[\"它们都可以被\",{\"1\":{\"37\":1}}],[\"它们作为lock接口功能的基本实现\",{\"1\":{\"95\":1}}],[\"它是对象之间耦合度最弱的一种关联方式\",{\"1\":{\"1096\":1}}],[\"它是被访问和适配的现存组件库中的组件接口\",{\"1\":{\"1092\":1}}],[\"它是包含多个组成部件的复杂对象\",{\"1\":{\"1086\":1}}],[\"它是将一个复杂的对象分解为多个简单的对象\",{\"1\":{\"1086\":1}}],[\"它是以太网单程端到端时延τ与帧的发送时间to之比\",{\"1\":{\"978\":1}}],[\"它是自动执行的\",{\"1\":{\"759\":1}}],[\"它是整个流程的控制中心\",{\"1\":{\"756\":1}}],[\"它是一种类行为型模式\",{\"1\":{\"1087\":1}}],[\"它是一种高度平衡的二叉平衡树\",{\"1\":{\"916\":1}}],[\"它是一种设计模式\",{\"1\":{\"754\":1}}],[\"它是一个转换器\",{\"1\":{\"1092\":1}}],[\"它是一个新的一致状态\",{\"1\":{\"520\":1}}],[\"它是一个用在方法表中的变长属性\",{\"1\":{\"292\":1}}],[\"它是针对\",{\"1\":{\"753\":1}}],[\"它是单边增长结构\",{\"1\":{\"541\":1}}],[\"它是使用固定大小的内存块来保存值\",{\"1\":{\"478\":1}}],[\"它是系统内存的映射\",{\"1\":{\"416\":1}}],[\"它是class文件结构中与其他项目关联最多的数据\",{\"1\":{\"286\":1}}],[\"它是许多运行在\",{\"1\":{\"255\":1}}],[\"它是所有收集器里额外内存消耗最小的\",{\"1\":{\"254\":1}}],[\"它是最基础的收集算法\",{\"1\":{\"244\":1}}],[\"它是根据用户的需要划分的\",{\"1\":{\"155\":1}}],[\"它是判断数据是否存在竞争\",{\"1\":{\"75\":1}}],[\"它是在等待获取\",{\"1\":{\"38\":1}}],[\"它做的事情只是纯粹地去执行\",{\"1\":{\"33\":1}}],[\"调节转发服务器的请求数目\",{\"1\":{\"869\":1}}],[\"调通\",{\"1\":{\"691\":1}}],[\"调整资源访问顺序\",{\"1\":{\"700\":1}}],[\"调整业务逻辑\",{\"1\":{\"516\":1}}],[\"调整为对每个数组元素加锁\",{\"1\":{\"130\":1}}],[\"调换光标所在处与其之前字符位置\",{\"1\":{\"417\":1}}],[\"调度实现类中的方法\",{\"1\":{\"725\":1}}],[\"调度算法中磁臂移动过大的问题\",{\"1\":{\"163\":1}}],[\"调度时选择优先级最高的进程\",{\"1\":{\"150\":1}}],[\"调度时选择响应比最高的进程服务\",{\"1\":{\"150\":1}}],[\"调度和管理线程的函数来控制用户线程\",{\"1\":{\"143\":1}}],[\"调度和分派的基本单位\",{\"1\":{\"28\":1,\"139\":1}}],[\"调优和监控\",{\"1\":{\"53\":1}}],[\"调用建造者对象中的部件构造与装配方法完成复杂对象的创建\",{\"1\":{\"1086\":1}}],[\"调用解析程序\",{\"1\":{\"1031\":1}}],[\"调用init\",{\"1\":{\"959\":1,\"1029\":1}}],[\"调用新的不阻塞的协程\",{\"1\":{\"831\":1}}],[\"调用线程将会阻塞\",{\"1\":{\"814\":1}}],[\"调用服务器之前询问上次处理请求花费时间\",{\"1\":{\"812\":1}}],[\"调用远程服务的服务消费方\",{\"1\":{\"810\":1}}],[\"调用接口时会传入该\",{\"1\":{\"807\":2}}],[\"调用接口即可完成所需要的逻辑单元应用\",{\"1\":{\"766\":1}}],[\"调用别的机器\",{\"1\":{\"802\":1}}],[\"调用适配器对象实例的handle方法真正执行代码逻辑处理\",{\"1\":{\"755\":1}}],[\"调用getwebapplicationcontext\",{\"1\":{\"736\":1}}],[\"调用getbean\",{\"1\":{\"712\":1}}],[\"调用postprocessafterinitialization\",{\"1\":{\"733\":1}}],[\"调用applicationcontextaware\",{\"1\":{\"733\":1}}],[\"调用beanfactoryaware\",{\"1\":{\"733\":1}}],[\"调用该\",{\"1\":{\"730\":1}}],[\"调用该方法后当前线程进入睡眠状态\",{\"1\":{\"350\":1}}],[\"调用service层提供的接口来控制业务流程\",{\"1\":{\"764\":1}}],[\"调用setbeanname\",{\"1\":{\"733\":1}}],[\"调用set\",{\"1\":{\"46\":1}}],[\"调用singleton的构造函数来初始化成员变量\",{\"1\":{\"714\":1}}],[\"调用这些\",{\"1\":{\"379\":1}}],[\"调用的是\",{\"1\":{\"340\":1}}],[\"调用不同类型的方法\",{\"1\":{\"274\":1}}],[\"调用尚未构造完成的对象的方法可能引起奇怪的问题\",{\"1\":{\"202\":1}}],[\"调用对象的\",{\"1\":{\"88\":1}}],[\"调用\",{\"1\":{\"46\":1,\"88\":2,\"101\":1,\"117\":1,\"123\":2,\"126\":1,\"377\":1,\"568\":1,\"755\":1,\"1068\":1,\"1083\":1}}],[\"调用会放弃对象锁\",{\"1\":{\"37\":1}}],[\"调用会暂停此线程\",{\"1\":{\"37\":1}}],[\"等字符类别匹配整个\",{\"1\":{\"1190\":1}}],[\"等字符类别匹配对应的\",{\"1\":{\"1190\":1}}],[\"等组件的\",{\"1\":{\"1157\":1}}],[\"等组成部分\",{\"1\":{\"1086\":1}}],[\"等文件的格式化方式同样可在此设置\",{\"1\":{\"1151\":1}}],[\"等制品库\",{\"1\":{\"1108\":2}}],[\"等服务器发完数据后\",{\"1\":{\"1026\":1}}],[\"等我们读取数据时就是一个粘包\",{\"1\":{\"1006\":1}}],[\"等我重启成功后在放流量进来\",{\"1\":{\"802\":1}}],[\"等于\",{\"1\":{\"948\":1}}],[\"等于sds所保存字符串的长度\",{\"1\":{\"624\":1}}],[\"等对象类型\",{\"1\":{\"938\":1}}],[\"等直接来统计每个\",{\"1\":{\"895\":1}}],[\"等其他语言开发的应用也无法直接运行在\",{\"1\":{\"825\":1}}],[\"等容器\",{\"1\":{\"780\":1}}],[\"等容器中\",{\"1\":{\"369\":1}}],[\"等一些简单的概念\",{\"1\":{\"770\":1}}],[\"等一般采用面向过程开发\",{\"1\":{\"354\":1}}],[\"等属性设置需要拦截或需要排除的\",{\"1\":{\"759\":1}}],[\"等数据\",{\"1\":{\"755\":1}}],[\"等数据结构的存储\",{\"1\":{\"610\":1}}],[\"等繁杂的过程\",{\"1\":{\"746\":1}}],[\"等以\",{\"1\":{\"742\":1}}],[\"等不一样的地方在于\",{\"1\":{\"685\":1}}],[\"等类型\",{\"1\":{\"637\":1}}],[\"等结构\",{\"1\":{\"637\":1}}],[\"等后台程序\",{\"1\":{\"623\":1}}],[\"等处理下一个请求时\",{\"1\":{\"615\":1}}],[\"等copy完成后\",{\"1\":{\"593\":1}}],[\"等行锁\",{\"1\":{\"559\":1}}],[\"等刷脏页\",{\"1\":{\"559\":1}}],[\"等操作支持不友好\",{\"1\":{\"678\":1}}],[\"等操作\",{\"1\":{\"556\":1}}],[\"等手段来保证事务的隔离性\",{\"1\":{\"519\":1}}],[\"等多个存储引擎\",{\"1\":{\"488\":1}}],[\"等格式自行显示\",{\"1\":{\"441\":1}}],[\"等问题\",{\"1\":{\"411\":1}}],[\"等问题的产生\",{\"1\":{\"235\":1}}],[\"等同于clear\",{\"1\":{\"417\":1}}],[\"等同于\",{\"1\":{\"325\":1}}],[\"等价于通过\",{\"1\":{\"340\":1}}],[\"等价于\",{\"1\":{\"321\":1}}],[\"等并发扫描结束后\",{\"1\":{\"251\":2}}],[\"等信息\",{\"1\":{\"203\":2}}],[\"等等\",{\"1\":{\"174\":1}}],[\"等单独预编译好的目标文件进行合并\",{\"1\":{\"162\":1}}],[\"等函数\",{\"1\":{\"149\":1,\"1006\":1}}],[\"等方法都是幂等的\",{\"1\":{\"1041\":1}}],[\"等方法时\",{\"1\":{\"377\":1}}],[\"等方法\",{\"1\":{\"144\":1}}],[\"等方法进入\",{\"1\":{\"38\":1}}],[\"等\",{\"1\":{\"109\":1,\"135\":1,\"234\":1,\"338\":1,\"342\":1,\"416\":1,\"501\":1,\"583\":1,\"748\":1,\"755\":1,\"825\":1,\"1001\":1}}],[\"等到缺失的字节收到后\",{\"1\":{\"1015\":1}}],[\"等到操作共享变量的时候才加锁\",{\"1\":{\"98\":1}}],[\"等到其他\",{\"1\":{\"72\":1}}],[\"等到\",{\"1\":{\"51\":1}}],[\"等到线程\",{\"1\":{\"35\":1}}],[\"等待客户端的确认\",{\"1\":{\"1060\":1}}],[\"等待连接\",{\"1\":{\"1022\":1}}],[\"等待目的端确认收到这个报文段\",{\"1\":{\"1009\":1}}],[\"等待对方确认\",{\"1\":{\"1009\":1,\"1010\":1}}],[\"等待该follower的leo大于等于该partition的hw\",{\"1\":{\"855\":1}}],[\"等待该follower恢复后\",{\"1\":{\"855\":1}}],[\"等待将来使用\",{\"1\":{\"624\":1}}],[\"等待所有io操作的完成\",{\"1\":{\"496\":1}}],[\"等待时间+运行时间\",{\"1\":{\"150\":1}}],[\"等待获取同步锁\",{\"1\":{\"111\":1}}],[\"等待它结束\",{\"1\":{\"102\":1}}],[\"等待的资源被\",{\"1\":{\"98\":4}}],[\"等待可中断\",{\"1\":{\"94\":1}}],[\"等待锁的释放\",{\"1\":{\"81\":1}}],[\"等待锁的释放以及被唤醒\",{\"1\":{\"81\":1}}],[\"等待上\",{\"1\":{\"64\":1}}],[\"等待其它线程显式地唤醒\",{\"1\":{\"38\":1}}],[\"等待\",{\"1\":{\"38\":1,\"121\":1,\"657\":1,\"676\":1}}],[\"等待队列\",{\"1\":{\"37\":1}}],[\"等待和唤醒必须是同一个锁\",{\"1\":{\"36\":1}}],[\"唤醒出队等\",{\"1\":{\"115\":1}}],[\"唤醒机制\",{\"1\":{\"109\":1}}],[\"唤醒指定的线程或者所有线程\",{\"1\":{\"37\":1}}],[\"唤醒\",{\"1\":{\"36\":1,\"89\":1}}],[\"中最重要的就是规范\",{\"1\":{\"1242\":1}}],[\"中文文档地址\",{\"1\":{\"1208\":1}}],[\"中即可\",{\"1\":{\"1202\":1}}],[\"中配置\",{\"1\":{\"1199\":1,\"1200\":1}}],[\"中直接使用\",{\"1\":{\"1134\":1}}],[\"中大量使用了\",{\"1\":{\"1089\":1}}],[\"中实现了\",{\"1\":{\"1087\":1}}],[\"中实例对象的传递是引用传递\",{\"1\":{\"351\":1}}],[\"中会出现多个单例吗\",{\"1\":{\"1075\":1}}],[\"中会包含着一些\",{\"1\":{\"721\":1}}],[\"中设置了\",{\"1\":{\"1061\":1}}],[\"中采用滑动窗口来进行传输控制\",{\"1\":{\"1015\":1}}],[\"中调用\",{\"1\":{\"1003\":2}}],[\"中规定\",{\"1\":{\"996\":1}}],[\"中装了黑客软件\",{\"1\":{\"986\":1}}],[\"中继代理\",{\"1\":{\"1049\":1}}],[\"中继器\",{\"1\":{\"962\":1}}],[\"中继日志\",{\"1\":{\"566\":1}}],[\"中选取最小值\",{\"1\":{\"931\":5}}],[\"中再次列出\",{\"1\":{\"920\":1}}],[\"中序遍历\",{\"1\":{\"908\":1}}],[\"中bitmap\",{\"1\":{\"900\":1}}],[\"中较大的哪一个\",{\"1\":{\"899\":1}}],[\"中位数\",{\"1\":{\"886\":1}}],[\"中拿数据进行消费\",{\"1\":{\"840\":1}}],[\"中国大陆使用nginx网站用户有\",{\"1\":{\"824\":1}}],[\"中查询这个\",{\"1\":{\"807\":1}}],[\"中将返回结果写入\",{\"1\":{\"804\":1}}],[\"中将消息读出来之前\",{\"1\":{\"804\":1}}],[\"中获取连接\",{\"1\":{\"804\":1}}],[\"中获取缓存时\",{\"1\":{\"608\":1}}],[\"中央仓库\",{\"1\":{\"794\":2}}],[\"中缓存分为一级缓存\",{\"1\":{\"752\":1}}],[\"中缓存一致性\",{\"0\":{\"72\":1}}],[\"中取出\",{\"1\":{\"745\":1}}],[\"中事务有两种实现方式\",{\"1\":{\"739\":1}}],[\"中非线程安全状态采用\",{\"1\":{\"735\":1}}],[\"中当作缓存\",{\"1\":{\"645\":1}}],[\"中同时使用了惰性过期和定期过期两种过期策略\",{\"1\":{\"632\":1}}],[\"中已经过期的\",{\"1\":{\"632\":1}}],[\"中用在了两个地方\",{\"1\":{\"630\":1}}],[\"中用到\",{\"1\":{\"350\":1}}],[\"中需要一个可变的字符串值时\",{\"1\":{\"624\":1}}],[\"中需要监控的资源主要有\",{\"1\":{\"440\":1}}],[\"中都有的情况\",{\"1\":{\"623\":1}}],[\"中一致性\",{\"1\":{\"871\":1}}],[\"中一个\",{\"1\":{\"859\":1}}],[\"中一个事务的所有快照读\",{\"1\":{\"523\":1}}],[\"中一般采用\",{\"1\":{\"725\":1}}],[\"中一次查找并执行\",{\"1\":{\"623\":1}}],[\"中下一个索引位置的键值对\",{\"1\":{\"615\":1}}],[\"中苏醒\",{\"1\":{\"613\":1}}],[\"中苏醒⼀次\",{\"1\":{\"613\":1}}],[\"中主键所建立的是聚簇索引\",{\"1\":{\"549\":1}}],[\"中存储对应全量数值在磁盘上的地址\",{\"1\":{\"546\":1}}],[\"中存储的直接就是对象的地址\",{\"1\":{\"230\":1}}],[\"中存储的就是对象的句柄地址\",{\"1\":{\"229\":1}}],[\"中止状态\",{\"1\":{\"520\":1}}],[\"中提供了两个函数来实现分布式锁\",{\"1\":{\"517\":1}}],[\"中提供了哪些并发容器\",{\"0\":{\"108\":1}}],[\"中锁定粒度最细的一种锁\",{\"1\":{\"509\":1}}],[\"中秋节时购买月饼礼盒\",{\"1\":{\"442\":1}}],[\"中第一个字符代表这个文件是目录\",{\"1\":{\"430\":1}}],[\"中访问设备的方式和访问文件的方式是相同的\",{\"1\":{\"416\":1}}],[\"中怎样判断一个元素是否相同\",{\"0\":{\"400\":1}}],[\"中对要返回数据操作无影响\",{\"1\":{\"383\":1}}],[\"中对应的概念就是程序计数器\",{\"1\":{\"144\":1}}],[\"中要\",{\"1\":{\"383\":1}}],[\"中没有\",{\"1\":{\"383\":2}}],[\"中有三种集群方式用来保证高并发和高可用\",{\"1\":{\"654\":1}}],[\"中有对\",{\"1\":{\"383\":1}}],[\"中有\",{\"1\":{\"383\":3}}],[\"中有一个指向一级分页表的指针\",{\"1\":{\"156\":1}}],[\"中强制退出\",{\"1\":{\"383\":1}}],[\"中强制线程池不允许使用\",{\"1\":{\"59\":1}}],[\"中是否还有数据可读\",{\"1\":{\"381\":1}}],[\"中内核会把哪个流发生了怎样的\",{\"1\":{\"381\":1}}],[\"中内核线程会负责把数据从内核空间拷贝到用户空间\",{\"1\":{\"381\":1}}],[\"中也是用到了适配器模式适配\",{\"1\":{\"742\":1}}],[\"中也有\",{\"1\":{\"383\":1}}],[\"中也不可以覆盖\",{\"1\":{\"358\":1}}],[\"中也出现了\",{\"1\":{\"71\":1}}],[\"中创建对象的方式\",{\"0\":{\"356\":1}}],[\"中基础类型数据传递都是值传递\",{\"1\":{\"351\":1}}],[\"中断该线程\",{\"1\":{\"350\":1}}],[\"中两者是一样的\",{\"1\":{\"350\":1}}],[\"中就会出现key为null的entry\",{\"1\":{\"300\":1}}],[\"中使用\",{\"1\":{\"1003\":1}}],[\"中使用的\",{\"1\":{\"300\":1}}],[\"中使用wait\",{\"1\":{\"141\":1}}],[\"中可以使用\",{\"1\":{\"297\":1,\"1003\":1}}],[\"中曾试图定义一种\",{\"1\":{\"293\":1}}],[\"中间人\",{\"1\":{\"1046\":1}}],[\"中间还缺少一些序号的数据\",{\"1\":{\"1013\":1}}],[\"中间有各种各样的线路和分叉路⼝\",{\"1\":{\"961\":1}}],[\"中间件代理\",{\"1\":{\"586\":1}}],[\"中间没有添加任何分隔符\",{\"1\":{\"284\":1}}],[\"中间放着一个指针作为分界点的指示器\",{\"1\":{\"216\":1}}],[\"中成功拯救自己\",{\"1\":{\"236\":1}}],[\"中引用的对象\",{\"1\":{\"234\":2}}],[\"中定义的内存区域\",{\"1\":{\"209\":1}}],[\"中把方法区描述为堆的一个逻辑部分\",{\"1\":{\"203\":1}}],[\"中把变量值存储到内存和从内存中取出变量值这样的细节\",{\"1\":{\"74\":1}}],[\"中保存的少\",{\"1\":{\"136\":1}}],[\"中为什么使用内置锁\",{\"1\":{\"131\":1}}],[\"中所有等待线程来同时竞争锁\",{\"1\":{\"85\":1}}],[\"中所有的有序性\",{\"1\":{\"75\":1}}],[\"中看不到它的存在\",{\"1\":{\"85\":1}}],[\"中我们最常用的锁应该就是\",{\"1\":{\"81\":1}}],[\"中包含了\",{\"1\":{\"45\":1}}],[\"中\",{\"0\":{\"476\":1,\"908\":1},\"1\":{\"42\":1,\"71\":1,\"72\":2,\"75\":1,\"84\":1,\"103\":1,\"128\":3,\"131\":1,\"136\":2,\"294\":1,\"299\":1,\"337\":1,\"348\":1,\"358\":1,\"369\":1,\"381\":1,\"383\":2,\"406\":1,\"407\":1,\"409\":1,\"416\":1,\"427\":1,\"461\":2,\"470\":1,\"478\":1,\"484\":3,\"568\":2,\"571\":1,\"581\":1,\"593\":1,\"596\":2,\"603\":1,\"615\":2,\"623\":1,\"624\":1,\"625\":1,\"641\":1,\"665\":1,\"718\":1,\"735\":1,\"742\":1,\"750\":2,\"755\":1,\"804\":2,\"807\":1,\"861\":1,\"894\":1,\"895\":1,\"896\":4,\"907\":1,\"996\":1,\"1003\":1,\"1041\":1,\"1075\":1}}],[\"中的域是指业务进行上下文拆分之后形成的\",{\"1\":{\"1221\":1}}],[\"中的函数使用以下标志位作为可选入参\",{\"1\":{\"1190\":1}}],[\"中的版本号后运行pnpm\",{\"1\":{\"1139\":1}}],[\"中的某些方法来完成一些职责\",{\"1\":{\"1096\":1}}],[\"中的某个数值\",{\"1\":{\"571\":1}}],[\"中的应用\",{\"0\":{\"1089\":1}}],[\"中的公钥对证书解密\",{\"1\":{\"1057\":1}}],[\"中的df\",{\"1\":{\"987\":1}}],[\"中的幂等性指代producer不论向server发送了多少次重复数据\",{\"1\":{\"856\":1}}],[\"中的模型数据\",{\"1\":{\"755\":1}}],[\"中的一个\",{\"1\":{\"859\":1}}],[\"中的一个关键字\",{\"1\":{\"370\":1}}],[\"中的一级缓存\",{\"1\":{\"752\":1}}],[\"中的类图有以下几种关系\",{\"1\":{\"1095\":1}}],[\"中的类属性注入到类中\",{\"1\":{\"729\":1}}],[\"中的类声明\",{\"1\":{\"721\":1}}],[\"中的aop有两种\",{\"1\":{\"724\":1}}],[\"中的事务简单理解为\",{\"1\":{\"665\":1}}],[\"中的集合\",{\"1\":{\"619\":1}}],[\"中的集合框架继承了\",{\"1\":{\"389\":1}}],[\"中的第一个索引位置开始\",{\"1\":{\"615\":1}}],[\"中的缓存\",{\"1\":{\"608\":1}}],[\"中的操作应用到原数据页\",{\"1\":{\"574\":1}}],[\"中的日志\",{\"1\":{\"568\":1}}],[\"中的数据将会丢失无法恢复\",{\"1\":{\"646\":1}}],[\"中的数据都是热点数据\",{\"0\":{\"635\":1}}],[\"中的数据结构是专门进行设计的\",{\"1\":{\"604\":1}}],[\"中的数据\",{\"1\":{\"523\":1}}],[\"中的数据按照字段\",{\"1\":{\"484\":2}}],[\"中的数字只是规定了交互工具显示字符的个数\",{\"1\":{\"472\":1}}],[\"中的链表顺序和原\",{\"1\":{\"406\":1}}],[\"中的语句合并产生的\",{\"1\":{\"173\":1}}],[\"中的class文件格式中\",{\"1\":{\"172\":1}}],[\"中的值是不确定的\",{\"1\":{\"79\":1}}],[\"中的几点规定\",{\"1\":{\"65\":1}}],[\"中的阻塞队列\",{\"1\":{\"62\":1}}],[\"中的还是有值\",{\"1\":{\"46\":1}}],[\"中的\",{\"1\":{\"43\":1,\"72\":1,\"81\":2,\"85\":1,\"88\":1,\"89\":1,\"130\":1,\"383\":2,\"405\":1,\"413\":2,\"568\":1,\"624\":1,\"718\":1,\"734\":1,\"735\":1,\"742\":1,\"748\":1,\"875\":1,\"1003\":1,\"1240\":1}}],[\"中的使用\",{\"0\":{\"43\":1}}],[\"中的这把锁可以是任意对象\",{\"1\":{\"36\":1}}],[\"中的方法调用之后\",{\"1\":{\"759\":1}}],[\"中的方法\",{\"1\":{\"35\":1}}],[\"中运行\",{\"1\":{\"18\":1}}],[\"补充\",{\"1\":{\"35\":1}}],[\"这违背了\",{\"1\":{\"1090\":1}}],[\"这都是动态代理需要解决的问题\",{\"1\":{\"1083\":1}}],[\"这将导致系统中的类个数急剧增加\",{\"1\":{\"1083\":1}}],[\"这将消除每次手动部署更改的需要\",{\"1\":{\"769\":1}}],[\"这条语句\",{\"1\":{\"1067\":1}}],[\"这条规则获得的\",{\"1\":{\"295\":1}}],[\"这对某些允许网络拥塞时丢失一些数据\",{\"1\":{\"1002\":1}}],[\"这称为最大传送单元mtu\",{\"1\":{\"987\":1}}],[\"这台计算机使用\",{\"1\":{\"986\":1}}],[\"这台机器会通过\",{\"1\":{\"578\":1}}],[\"这块连续存储空间称为散列表\",{\"1\":{\"922\":1}}],[\"这块的设计下章节会做说明\",{\"1\":{\"843\":1}}],[\"这道题可能就没那个多的奇技淫巧了\",{\"1\":{\"904\":1}}],[\"这相当于折半了\",{\"1\":{\"901\":2}}],[\"这题是考虑时间效率\",{\"1\":{\"899\":1}}],[\"这实际上就是reduce过程\",{\"1\":{\"891\":1}}],[\"这只能保证副本之间的数据一致性\",{\"1\":{\"855\":1}}],[\"这与磁盘的机械结构有关\",{\"1\":{\"850\":1}}],[\"这么多服务\",{\"1\":{\"815\":3}}],[\"这么多服务器合起来组成一个完整系统来提供服务\",{\"1\":{\"809\":1}}],[\"这么做的原因是集合中比较两个对象时\",{\"1\":{\"342\":1}}],[\"这可以参考数据库的存储方法\",{\"1\":{\"891\":1}}],[\"这可以使用dev工具来实现\",{\"1\":{\"769\":1}}],[\"这可能导致代码功能失调并破坏可移植性\",{\"1\":{\"348\":1}}],[\"这可能会释放一个阻塞的\",{\"1\":{\"117\":1}}],[\"这正是spring倡导的非侵入式的编程方式\",{\"1\":{\"739\":1}}],[\"这点和设计模式中观察者模式比较相似\",{\"1\":{\"673\":1}}],[\"这点在你想切分数据库的时候尤为重要\",{\"1\":{\"467\":1}}],[\"这把锁是非重入的\",{\"1\":{\"668\":1}}],[\"这把锁只能是非阻塞的\",{\"1\":{\"668\":1}}],[\"这把锁没有失效时间\",{\"1\":{\"668\":1}}],[\"这把锁强依赖数据库的可用性\",{\"1\":{\"668\":1}}],[\"这又会导致后面一系列的更新\",{\"1\":{\"628\":1}}],[\"这使得磁盘\",{\"1\":{\"916\":1}}],[\"这使得单库的处理能力成为瓶颈\",{\"1\":{\"585\":1}}],[\"这使得它能像一些普通的c一样与外部交互\",{\"1\":{\"197\":1}}],[\"这不是永久开启\",{\"1\":{\"557\":1}}],[\"这有利于数据库做全表扫描\",{\"1\":{\"541\":1}}],[\"这保证了其他事务在t释放a上的锁之前不能再读取和修改a\",{\"1\":{\"509\":1}}],[\"这保证了其他事务可以读a\",{\"1\":{\"509\":1}}],[\"这⾥就不赘述了\",{\"1\":{\"508\":1}}],[\"这被称为并发插入\",{\"1\":{\"492\":1}}],[\"这三个字段\",{\"1\":{\"484\":1,\"550\":1}}],[\"这三个权限的位置不会改变\",{\"1\":{\"430\":1}}],[\"这三个函数分别是\",{\"1\":{\"414\":1}}],[\"这三个函数都统称为\",{\"1\":{\"414\":1}}],[\"这意味着数组最多只能放\",{\"1\":{\"399\":1}}],[\"这主要是防止任何继承类改变它的本来含义\",{\"1\":{\"355\":1}}],[\"这导致volatile变量的运算在并发下一样是不安全的\",{\"1\":{\"296\":1}}],[\"这导致g1的记忆集\",{\"1\":{\"262\":1}}],[\"这两个时间之差就是报文段的往返时间rtt\",{\"1\":{\"1012\":1}}],[\"这两个字段\",{\"1\":{\"484\":1}}],[\"这两个字节码指令反映到java代码中就是同步块\",{\"1\":{\"295\":1}}],[\"这两种情况系统的压力都没有\",{\"1\":{\"594\":1}}],[\"这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本\",{\"1\":{\"274\":1}}],[\"这两种对象访问方式各有优势\",{\"1\":{\"230\":1}}],[\"这两种语义的目的都是为了在不改变程序执行结果的前提下尽可能提高程序执行并行度\",{\"1\":{\"77\":1}}],[\"这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用\",{\"1\":{\"275\":1}}],[\"这类元框架其实并不适合进行频繁的写更新\",{\"1\":{\"860\":1}}],[\"这类方法的调用被称为\",{\"1\":{\"274\":1}}],[\"这类应用通常都会较为关注服务的响应速度\",{\"1\":{\"259\":1}}],[\"这阶段耗时较长\",{\"1\":{\"264\":1}}],[\"这会导致程序的错误\",{\"1\":{\"251\":1}}],[\"这也导致了大量的随机\",{\"1\":{\"466\":1}}],[\"这也正好解释了为什么\",{\"1\":{\"405\":1}}],[\"这也是\",{\"1\":{\"604\":1}}],[\"这也是创建索引的最主要的原因\",{\"1\":{\"528\":1}}],[\"这也是一种性能优化手段\",{\"1\":{\"369\":1}}],[\"这也是threadlocal变量名的由来\",{\"1\":{\"299\":1}}],[\"这也是目前最常用的一种记忆集实现形式\",{\"1\":{\"249\":1}}],[\"这也就体现了\",{\"1\":{\"484\":1}}],[\"这也就解释了threadlocal声明的变量为什么在每一个线程都有自己的专属本地变量\",{\"1\":{\"299\":1}}],[\"这也就是\",{\"1\":{\"260\":1}}],[\"这也就意味着所有操作需要在同一个数据库连接上\",{\"1\":{\"43\":1}}],[\"这是开发人员最需要的功能\",{\"1\":{\"769\":1}}],[\"这是为了不要过长时间等待已经关闭的\",{\"1\":{\"672\":1}}],[\"这是为了避免一次性执行过多的\",{\"1\":{\"623\":1}}],[\"这是从数据库初始化完成后的操作\",{\"1\":{\"655\":1}}],[\"这是由于consumer可以通过offset访问任意信息\",{\"1\":{\"864\":1}}],[\"这是由于\",{\"1\":{\"649\":1}}],[\"这是提升性能最简单也是最普遍的做法\",{\"1\":{\"645\":1}}],[\"这是我们数据库设计的最基本要求\",{\"1\":{\"455\":1}}],[\"这是给主机额外安装软件所摆放的目录\",{\"1\":{\"416\":1}}],[\"这是执行此进程所使用的实际cpu时间\",{\"1\":{\"331\":1}}],[\"这是\",{\"1\":{\"261\":1,\"475\":1}}],[\"这是jdk1\",{\"1\":{\"257\":1}}],[\"这是因为软引用可以加速\",{\"1\":{\"235\":1}}],[\"这是使用最普遍的引用\",{\"1\":{\"235\":1}}],[\"这是一种错误的实现\",{\"1\":{\"1077\":1}}],[\"这是一种解决分布式系统一致性的经典算法\",{\"1\":{\"872\":1}}],[\"这是一种可以有效减少java\",{\"1\":{\"202\":1}}],[\"这是一种父类加载器去请求子类加载器完成类加载的行为\",{\"1\":{\"185\":1}}],[\"这是一个收敛的过程\",{\"1\":{\"1217\":1}}],[\"这是一个端到端的检验和\",{\"1\":{\"1009\":1}}],[\"这是一个ppp帧\",{\"1\":{\"975\":1}}],[\"这是一个隐藏条件\",{\"1\":{\"902\":1}}],[\"这是一个相对较慢的过程\",{\"1\":{\"606\":1}}],[\"这是一个字符串\",{\"1\":{\"517\":1}}],[\"这是一个泛型类\",{\"1\":{\"339\":1}}],[\"这是一个实例方法\",{\"1\":{\"183\":1}}],[\"这是一个\",{\"1\":{\"108\":1}}],[\"这是一个接口\",{\"1\":{\"108\":1}}],[\"这是一个非阻塞队列\",{\"1\":{\"108\":1}}],[\"这并不是必然存在的\",{\"1\":{\"227\":1}}],[\"这一点很重要\",{\"1\":{\"1242\":1}}],[\"这一点是无庸置疑的\",{\"1\":{\"1075\":1}}],[\"这一点是通过di\",{\"1\":{\"718\":1}}],[\"这一类题他虽然样子很吓人\",{\"1\":{\"902\":1}}],[\"这一类对象只能有一个实例\",{\"1\":{\"713\":1}}],[\"这一操作提供了最低的延迟\",{\"1\":{\"854\":1}}],[\"这一操作被称为缓存锁定\",{\"1\":{\"296\":1}}],[\"这一过程\",{\"1\":{\"660\":1}}],[\"这一行的\",{\"1\":{\"573\":1}}],[\"这一行所在的数据页本来就在内存中\",{\"1\":{\"489\":1}}],[\"这一行\",{\"1\":{\"489\":1}}],[\"这一项工作也可以提前至tlab分配时顺便进行\",{\"1\":{\"221\":1}}],[\"这一步操作保证了对象的实例字段在\",{\"1\":{\"221\":1}}],[\"这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式\",{\"1\":{\"168\":1}}],[\"这部分数据可能是乱序到达的\",{\"1\":{\"1042\":1}}],[\"这部分是用户直接使用的\",{\"1\":{\"960\":1}}],[\"这部分的实际时间很少\",{\"1\":{\"268\":1}}],[\"这部分内容将在类加载后存放到方法区的运行时常量池中\",{\"1\":{\"208\":1}}],[\"这部分信息完全取决于具体的虚拟机实现\",{\"1\":{\"196\":1}}],[\"这部分就称为动态连接\",{\"1\":{\"194\":1}}],[\"这仅仅发生一次\",{\"1\":{\"194\":1}}],[\"这同时也就意味着需要更多的指令分派\",{\"1\":{\"193\":1}}],[\"这才算是给spi的加载提供了一种相对合理的解决方案\",{\"1\":{\"185\":1}}],[\"这4条直接码指令时\",{\"1\":{\"174\":1}}],[\"这必然导致用户态到核心态转换\",{\"1\":{\"142\":1}}],[\"这无疑带来了巨大内存浪费\",{\"1\":{\"131\":1}}],[\"这些都是需要在战术设计阶段明确下来\",{\"1\":{\"1225\":1}}],[\"这些伪造的\",{\"1\":{\"1060\":1}}],[\"这些主机不和连接在网络上的路由器定期交换路由信息\",{\"1\":{\"993\":1}}],[\"这些主机又称为端系统\",{\"1\":{\"960\":1}}],[\"这些查询串的重复度比较高\",{\"1\":{\"893\":1}}],[\"这些分区信息及与\",{\"1\":{\"861\":1}}],[\"这些节点都可以设置关联的数据\",{\"1\":{\"818\":1}}],[\"这些策略都是可配置的\",{\"1\":{\"803\":1}}],[\"这些全部都得一一对应\",{\"1\":{\"751\":1}}],[\"这些类里面通常不会含有成员变量\",{\"1\":{\"735\":1}}],[\"这些类\",{\"1\":{\"735\":1}}],[\"这些对象是动态生成的\",{\"1\":{\"731\":1}}],[\"这些收到信息的节点接下来会做同样的事情\",{\"1\":{\"684\":1}}],[\"这些\",{\"1\":{\"568\":1,\"817\":1}}],[\"这些权限表分别为user\",{\"1\":{\"458\":1}}],[\"这些缓冲区是建立在物理内存之中的\",{\"1\":{\"378\":1}}],[\"这些缓冲区是建立在jvm\",{\"1\":{\"378\":1}}],[\"这些标记可以在编译\",{\"1\":{\"338\":1}}],[\"这些被实现的接口将按implements关键字\",{\"1\":{\"288\":1}}],[\"这些方法统称为\",{\"1\":{\"275\":1}}],[\"这些方法与\",{\"1\":{\"126\":1}}],[\"这些记忆集会记录下别的region指向自己的指针\",{\"1\":{\"265\":1}}],[\"这些信息存放在对象头中\",{\"1\":{\"222\":1}}],[\"这些信息都被保存在一个数据结构\",{\"1\":{\"136\":1}}],[\"这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用\",{\"1\":{\"194\":1}}],[\"这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存\",{\"1\":{\"157\":1}}],[\"这些保存下来的上下文\",{\"1\":{\"144\":1}}],[\"这些操作就可能被编译器和处理器重排序\",{\"1\":{\"76\":1}}],[\"这依旧不能说明它没有被其他线程更改过\",{\"1\":{\"106\":1}}],[\"这就找到了\",{\"1\":{\"904\":1}}],[\"这就叫网络分区\",{\"1\":{\"870\":1}}],[\"这就没有保证接口的幂等性\",{\"1\":{\"807\":1}}],[\"这就需要人工干预\",{\"1\":{\"657\":1}}],[\"这就可以实现出上述的去重功能\",{\"1\":{\"645\":1}}],[\"这就可以在加载阶段构建了一个广阔的舞台\",{\"1\":{\"168\":1}}],[\"这就导致了主从不一致\",{\"1\":{\"582\":1}}],[\"这就导致接下来的查询都在事务中\",{\"1\":{\"526\":1}}],[\"这就大大提高了对于非聚集索引插入的性能\",{\"1\":{\"496\":1}}],[\"这就是外观模式的目标\",{\"1\":{\"1090\":1}}],[\"这就是session\",{\"1\":{\"1052\":1}}],[\"这就是cookie的工作原理\",{\"1\":{\"1051\":1}}],[\"这就是所谓对等层之间的通信\",{\"1\":{\"963\":1}}],[\"这就是数据链路层\",{\"1\":{\"961\":1}}],[\"这就是nginx高效率的原因之一\",{\"1\":{\"830\":1}}],[\"这就是控制反转名字的由来\",{\"1\":{\"718\":1}}],[\"这就是使用布隆过滤器\",{\"1\":{\"645\":1}}],[\"这就是aio\",{\"1\":{\"496\":1}}],[\"这就是重写\",{\"1\":{\"359\":1}}],[\"这就是前端编译器\",{\"1\":{\"282\":1}}],[\"这就包括自身的所有\",{\"1\":{\"356\":1}}],[\"这就会产生升内存数据页和磁盘数据页的数据不一致的情况\",{\"1\":{\"559\":1}}],[\"这就会导致大量占用存储空间\",{\"1\":{\"525\":1}}],[\"这就会导致上层应用会不断的进行\",{\"1\":{\"104\":1}}],[\"这就会造成同一个对象前后两次调用\",{\"1\":{\"88\":1}}],[\"这就意味着使用完\",{\"1\":{\"46\":1}}],[\"这几个状态会随着竞争情况逐渐升级\",{\"1\":{\"86\":1}}],[\"这里可以使用\",{\"1\":{\"804\":1}}],[\"这里可以和jdk的获得真实对象的接口类比\",{\"1\":{\"726\":1}}],[\"这里使用的是cglib的加强者enhancer\",{\"1\":{\"726\":1}}],[\"这里我们以\",{\"1\":{\"1198\":1}}],[\"这里我们把40亿个数中的每一个用32位的二进制来表示\",{\"1\":{\"901\":1}}],[\"这里我们简单介绍下两者的区别\",{\"1\":{\"716\":1}}],[\"这里我们先假设\",{\"1\":{\"539\":1}}],[\"这里消息的传递是多对多的\",{\"1\":{\"673\":1}}],[\"这里面最重要的就是\",{\"1\":{\"622\":1}}],[\"这里不妨用反证法来进行解释\",{\"1\":{\"578\":1}}],[\"这里不包含被final修饰的static\",{\"1\":{\"171\":1}}],[\"这里假设一行记录的数据大小为\",{\"1\":{\"539\":1}}],[\"这里的指明是指第几个分区\",{\"1\":{\"852\":1}}],[\"这里的什么类型就是把真实对象转换为代理的这个代理的类型\",{\"1\":{\"726\":1}}],[\"这里的方法计时\",{\"1\":{\"724\":1}}],[\"这里的水平分表指的是在一个数据库进行的库内分表\",{\"1\":{\"585\":1}}],[\"这里的\",{\"1\":{\"576\":1,\"653\":1}}],[\"这里的操作涉及存活对象的移动\",{\"1\":{\"264\":1}}],[\"这里的变量与\",{\"1\":{\"74\":1}}],[\"这里类加载器之间的父子关系一般不是以继承\",{\"1\":{\"184\":1}}],[\"这里所指的\",{\"1\":{\"166\":1}}],[\"这里就不多介绍了\",{\"1\":{\"23\":1}}],[\"这种自动重传方式常称为自动重传请求\",{\"1\":{\"1011\":1}}],[\"这种现象即为粘包\",{\"1\":{\"1006\":1}}],[\"这种简单的处理方式\",{\"1\":{\"1001\":1}}],[\"这种在协议栈层间的抽象的协议端口是软件端口\",{\"1\":{\"1000\":1}}],[\"这种主机称为多归属主机\",{\"1\":{\"984\":1}}],[\"这种冗余码成为帧检验序列fcs\",{\"1\":{\"974\":1}}],[\"这种数据结构是高效且性能很好的\",{\"1\":{\"882\":1}}],[\"这种数据不一致的数据页称为脏页\",{\"1\":{\"559\":1}}],[\"这种机制允许一台计算机加入新的网络获取ip地址而不用手工参与\",{\"1\":{\"1049\":1}}],[\"这种机制使得各个follower能够分散开来\",{\"1\":{\"877\":1}}],[\"这种机制的好处在于\",{\"1\":{\"684\":1}}],[\"这种大吞吐量的写操作会极大地拖慢\",{\"1\":{\"860\":1}}],[\"这种父子关系的好处就是\",{\"1\":{\"830\":1}}],[\"这种特性使得\",{\"1\":{\"818\":1}}],[\"这种操作就是不幂等的\",{\"1\":{\"807\":1}}],[\"这种jar不可以作为普通的jar被其他项目依赖\",{\"1\":{\"790\":1}}],[\"这种jar可以直接通过\",{\"1\":{\"790\":1}}],[\"这种的都不能映射\",{\"1\":{\"751\":1}}],[\"这种模式也称为发布\",{\"1\":{\"844\":1}}],[\"这种模式让我们可以根据客户的需求能够动态切换不同的数据源\",{\"1\":{\"742\":1}}],[\"这种模式下\",{\"1\":{\"657\":1,\"675\":1}}],[\"这种模式比水平触发效率高\",{\"1\":{\"381\":1}}],[\"这种方案思路比较简单\",{\"1\":{\"643\":1}}],[\"这种方式不仅具有延迟初始化的好处\",{\"1\":{\"1069\":1}}],[\"这种方式存在的最大问题就是密钥发送问题\",{\"1\":{\"1056\":1}}],[\"这种方式会导致在前面的consumer得到更多的分区\",{\"1\":{\"859\":1}}],[\"这种方式适合于采用\",{\"1\":{\"736\":1}}],[\"这种方式适用于采用\",{\"1\":{\"736\":1}}],[\"这种方式适用于\",{\"1\":{\"486\":1}}],[\"这种方式下\",{\"1\":{\"728\":1}}],[\"这种方式并不推荐\",{\"1\":{\"657\":1,\"675\":1}}],[\"这种方式可以极大的提升写入性能\",{\"1\":{\"492\":1}}],[\"这种方式假设数据表的id是连续递增的\",{\"1\":{\"486\":1}}],[\"这种方式来控制类的加载\",{\"1\":{\"348\":1}}],[\"这种\",{\"1\":{\"641\":1}}],[\"这种连续多次空间扩展操作称之为连锁更新\",{\"1\":{\"628\":1}}],[\"这种环境中\",{\"1\":{\"513\":1}}],[\"这种就是⾏锁\",{\"1\":{\"508\":1}}],[\"这种分页查询方式会从数据库第一条记录开始扫描\",{\"1\":{\"486\":1}}],[\"这种分配方式称为空闲列表\",{\"1\":{\"217\":1}}],[\"这种分配方式就叫做指针碰撞\",{\"1\":{\"216\":1}}],[\"这种边沿触发模式的话\",{\"1\":{\"381\":1}}],[\"这种伪结构中只有两种数据类型\",{\"1\":{\"284\":1}}],[\"这种解析能够成立的前提\",{\"1\":{\"274\":1}}],[\"这种垃圾收集算法会带来两个明显的问题\",{\"1\":{\"244\":1}}],[\"这种共享有很多好处\",{\"1\":{\"198\":1}}],[\"这种隔离\",{\"1\":{\"198\":1}}],[\"这种转化被称为静态解析\",{\"1\":{\"194\":1}}],[\"这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器\",{\"1\":{\"185\":1}}],[\"这种算法性能低\",{\"1\":{\"163\":1}}],[\"这种通信方式主要用于解决与同步相关的问题\",{\"1\":{\"149\":1}}],[\"这种情况我们可以适当增加位数组大小或者调整我们的哈希函数\",{\"1\":{\"882\":1}}],[\"这种情况下\",{\"1\":{\"866\":1}}],[\"这种情况是直接将静态资源放在了\",{\"1\":{\"836\":1}}],[\"这种情况就称为\",{\"1\":{\"681\":1}}],[\"这种情况就需要跟应用一起分析为何连接数会激增\",{\"1\":{\"562\":1}}],[\"这种情况其实是常态\",{\"1\":{\"594\":1}}],[\"这种情况使得\",{\"1\":{\"442\":1}}],[\"这种情况一般发生的原因是这个线程优先级低\",{\"1\":{\"100\":1}}],[\"这种情况称为\",{\"1\":{\"98\":1}}],[\"这种异步很可能会导致指令重排\",{\"1\":{\"71\":1}}],[\"这种变量在多线程环境下访问时能保证各个线程的变量相对独立于其它线程内的变量\",{\"1\":{\"39\":1}}],[\"这时如果系统内部发生改变\",{\"1\":{\"1090\":1}}],[\"这时如果线程2走到第一个if\",{\"1\":{\"714\":1}}],[\"这时如果线程\",{\"1\":{\"101\":1}}],[\"这时要是有一个综合部门能解决一切手续问题就好了\",{\"1\":{\"1090\":1}}],[\"这时必须创建新的\",{\"1\":{\"1042\":1}}],[\"这时会出现一个问题\",{\"1\":{\"1006\":1}}],[\"这时需要检查t1中的h1\",{\"1\":{\"884\":1}}],[\"这时需要使用分页查询\",{\"1\":{\"486\":1}}],[\"这时它会与服务器\",{\"1\":{\"820\":1}}],[\"这时我们就可以热插拨chinese对象\",{\"1\":{\"731\":1}}],[\"这时由于并发用户特别多\",{\"1\":{\"643\":1}}],[\"这时事务\",{\"1\":{\"514\":1}}],[\"这时就会创建\",{\"1\":{\"822\":1}}],[\"这时就遇到了问题\",{\"1\":{\"513\":1}}],[\"这时就要用到\",{\"1\":{\"35\":1}}],[\"这时通常将多个插入合并到一个操作中\",{\"1\":{\"496\":1}}],[\"这时\",{\"1\":{\"89\":1}}],[\"这时候\",{\"1\":{\"986\":1}}],[\"这时候归并就要登场了\",{\"1\":{\"904\":1}}],[\"这时候我们把文件分成了5000份的小文件\",{\"1\":{\"904\":1}}],[\"这时候只能把最久不使用的数据页从内存中淘汰掉\",{\"1\":{\"594\":1}}],[\"这时候系统会停止所有更新操作\",{\"1\":{\"594\":1}}],[\"这时候问题就来了\",{\"1\":{\"405\":1}}],[\"这时候进行内存分配的仅包括类变量\",{\"1\":{\"171\":1}}],[\"这时候偏向了线程\",{\"1\":{\"88\":1}}],[\"这时候有可能任务没有执行完\",{\"1\":{\"61\":1}}],[\"这时重置锁记录\",{\"1\":{\"87\":1}}],[\"这个很简单\",{\"1\":{\"1273\":1}}],[\"这个聚合根要存库\",{\"1\":{\"1245\":1}}],[\"这个已经讲的很清楚了\",{\"1\":{\"1242\":1}}],[\"这个后面结合\",{\"1\":{\"1226\":1}}],[\"这个后续再看解释\",{\"1\":{\"1219\":1}}],[\"这个边界可以是一个领域或者多个领域的集合\",{\"1\":{\"1221\":1}}],[\"这个问题是因为使用\",{\"1\":{\"1124\":1}}],[\"这个问题应该是有个前提\",{\"1\":{\"342\":1}}],[\"这个策略模式使用了函数式编程接口\",{\"1\":{\"1089\":1}}],[\"这个策略接口\",{\"1\":{\"1089\":1}}],[\"这个内容可能是用户上传的表单数据\",{\"1\":{\"1041\":1}}],[\"这个内存块被称作\",{\"1\":{\"249\":1}}],[\"这个请求才会带上这个\",{\"1\":{\"1039\":1}}],[\"这个合并过程就是在发送缓冲区中进行的\",{\"1\":{\"1006\":1}}],[\"这个伪首部也仅用来计算检验和\",{\"1\":{\"1002\":1}}],[\"这个没有多余的话\",{\"1\":{\"904\":1}}],[\"这个没用过\",{\"1\":{\"557\":1}}],[\"这个词不知道你注意到了没\",{\"1\":{\"902\":1}}],[\"这个数据具有很明显的特点\",{\"1\":{\"889\":1}}],[\"这个数据会同步给这个\",{\"1\":{\"659\":1}}],[\"这个圆环被称为哈希环\",{\"1\":{\"880\":1}}],[\"这个是nginx可以平滑重启的原理\",{\"1\":{\"830\":1}}],[\"这个是主动下线\",{\"1\":{\"802\":1}}],[\"这个是最常用的\",{\"1\":{\"636\":1}}],[\"这个里面定义了依赖的版本\",{\"1\":{\"779\":1}}],[\"这个参数是方法代理\",{\"1\":{\"726\":1}}],[\"这个参数默认为\",{\"1\":{\"565\":1}}],[\"这个现象成为主观下线\",{\"1\":{\"657\":1}}],[\"这个限制可以在配置文件中指定\",{\"1\":{\"622\":1}}],[\"这个文件事件处理器是单线程的\",{\"1\":{\"611\":1}}],[\"这个目的还是分散读的压力\",{\"1\":{\"582\":1}}],[\"这个目录\",{\"1\":{\"418\":1,\"420\":1}}],[\"这个目录的内容不在硬盘上而是在内存里\",{\"1\":{\"416\":1}}],[\"这个目录是一个虚拟的目录\",{\"1\":{\"416\":1}}],[\"这个就要依赖于\",{\"1\":{\"578\":1}}],[\"这个记录要更新的目标页不在内存中\",{\"1\":{\"574\":1}}],[\"这个记录要更新的目标页就在内存中\",{\"1\":{\"574\":1}}],[\"这个记录时要加读锁\",{\"1\":{\"559\":1}}],[\"这个能力成为crash\",{\"1\":{\"568\":1}}],[\"这个insert\",{\"1\":{\"565\":1}}],[\"这个结果\",{\"1\":{\"559\":1}}],[\"这个操作称为flush\",{\"1\":{\"559\":1}}],[\"这个不同带来的性能差距会有多少呢\",{\"1\":{\"555\":1}}],[\"这个不算工作区\",{\"1\":{\"444\":1}}],[\"这个查询语句在索引树上查找的过程\",{\"1\":{\"555\":1}}],[\"这个理论对于索引的数据结构设计非常有帮助\",{\"1\":{\"543\":1}}],[\"这个语句也得改\",{\"1\":{\"536\":1}}],[\"这个基数越大\",{\"1\":{\"536\":1}}],[\"这个统计信息就是索引的\",{\"1\":{\"536\":1}}],[\"这个命令会将这个线程的自动提交关掉\",{\"1\":{\"526\":1}}],[\"这个视图是在事务启动时创建的\",{\"1\":{\"524\":1}}],[\"这个视图是在每个\",{\"1\":{\"524\":1}}],[\"这个超时时间可以通过参数\",{\"1\":{\"516\":1}}],[\"这个恢复的过程依赖于\",{\"1\":{\"493\":1}}],[\"这个表上的所有的查询缓存都会被清空\",{\"1\":{\"490\":1}}],[\"这个阶段主要包括解析\",{\"1\":{\"489\":1}}],[\"这个阶段需要停顿线程\",{\"1\":{\"264\":1}}],[\"这个日志模块所有执行引擎都可以共用\",{\"1\":{\"488\":1}}],[\"这个权限表不受grant和revoke语句的影响\",{\"1\":{\"458\":1}}],[\"这个用的少\",{\"1\":{\"455\":1}}],[\"这个程序\",{\"1\":{\"429\":1}}],[\"这个程序的运行过程中\",{\"1\":{\"429\":1}}],[\"这个关键字\",{\"1\":{\"429\":1}}],[\"这个题目的示例就是告诉我们要按照读取的顺序进行排序\",{\"1\":{\"414\":1}}],[\"这个变量只作为放入\",{\"1\":{\"413\":1}}],[\"这个变量是共享且不稳定的\",{\"1\":{\"78\":1}}],[\"这个读写过程是阻塞的\",{\"1\":{\"381\":1}}],[\"这个接口的类支持快速随机访问\",{\"1\":{\"392\":1}}],[\"这个接口的唯一一个方法\",{\"1\":{\"349\":1}}],[\"这个接口的\",{\"1\":{\"349\":1}}],[\"这个接口\",{\"1\":{\"349\":1}}],[\"这个代理类并不是定义好的\",{\"1\":{\"349\":1}}],[\"这个类就称为简单工厂类\",{\"1\":{\"1077\":1}}],[\"这个类不仅包含原来类方法的功能\",{\"1\":{\"349\":1}}],[\"这个类加载器可以通过java\",{\"1\":{\"179\":1}}],[\"这个类加载器由sun\",{\"1\":{\"178\":1}}],[\"这个类加载器是在类sun\",{\"1\":{\"177\":1}}],[\"这个类加载器使用c++语言实现\",{\"1\":{\"176\":1}}],[\"这个信息会跟踪每个对象所属的类\",{\"1\":{\"339\":1}}],[\"这个写回内存的操作会使在其他\",{\"1\":{\"296\":1}}],[\"这个规则决定了持有同一个锁的两个同步块只能串行地进入\",{\"1\":{\"295\":1}}],[\"这个class是类还是接口\",{\"1\":{\"287\":1}}],[\"这个收集器的主要意义是供客户端模式下的hotspot虚拟机使用\",{\"1\":{\"256\":1}}],[\"这个动作的aop切面\",{\"1\":{\"250\":1}}],[\"这个精度决定了机器访问物理内存地址的指针长度\",{\"1\":{\"249\":1}}],[\"这个算法的基本思想\",{\"1\":{\"234\":1}}],[\"这个方法将在请求处理之前进行调用\",{\"1\":{\"759\":1}}],[\"这个方法是基于\",{\"1\":{\"563\":1}}],[\"这个方法是一个延迟调用方法\",{\"1\":{\"39\":1}}],[\"这个方法在一些具有哈希功能的\",{\"1\":{\"350\":1}}],[\"这个方法\",{\"1\":{\"349\":1}}],[\"这个方法的调用就会被转发为由\",{\"1\":{\"349\":1}}],[\"这个方法允许在子类中被重写\",{\"1\":{\"346\":1}}],[\"这个方法实现简单\",{\"1\":{\"233\":1}}],[\"这个中间件有自己的依赖的jar包\",{\"1\":{\"180\":1}}],[\"这个转化动作将在连接的第三个阶段\",{\"1\":{\"170\":1}}],[\"这个在我们平时使用电脑特别是\",{\"1\":{\"157\":1}}],[\"这个时间差要小于\",{\"1\":{\"672\":1}}],[\"这个时间开销甚至大于用户代码执行的时间\",{\"1\":{\"81\":1}}],[\"这个时候如果注册中心不知道该服务已经掉线\",{\"1\":{\"802\":1}}],[\"这个时候\",{\"1\":{\"718\":1,\"870\":1}}],[\"这个时候发生了异常重启会怎么样呢\",{\"1\":{\"578\":1}}],[\"这个时候更新就算完成了\",{\"1\":{\"489\":1,\"569\":1}}],[\"这个时候就可以用到它了\",{\"1\":{\"726\":1}}],[\"这个时候就可能会产生内存泄露\",{\"1\":{\"300\":1}}],[\"这个时候就会\",{\"1\":{\"623\":1}}],[\"这个时候就会去判断\",{\"1\":{\"578\":1}}],[\"这个时候就会触发从用户态执行的进程转向内核态执行相关的异常事件\",{\"1\":{\"134\":1}}],[\"这个时候就需要优化器上场了\",{\"1\":{\"490\":1}}],[\"这个时候就需要做一个类的仲裁\",{\"1\":{\"180\":1}}],[\"这个机制\",{\"1\":{\"110\":1}}],[\"这个漏洞称为\",{\"1\":{\"106\":1}}],[\"这个过程称为客观下线\",{\"1\":{\"657\":1}}],[\"这个过程叫rehash\",{\"1\":{\"623\":1}}],[\"这个过程会比较慢\",{\"1\":{\"606\":1}}],[\"这个过程耗时较长但是不需要停顿用户线程\",{\"1\":{\"259\":1}}],[\"这个过程中经过下面这些变化\",{\"1\":{\"147\":1}}],[\"这个过程是原子性的\",{\"1\":{\"105\":1}}],[\"这个过程需要\",{\"1\":{\"81\":1}}],[\"这个对象还能被设置偏向锁么\",{\"1\":{\"88\":1}}],[\"这个对象锁就归该线程所有\",{\"1\":{\"88\":1}}],[\"这个阻塞队列就是用来给生产者和消费者解耦的\",{\"1\":{\"50\":1}}],[\"这样恶意用户抓到的报文已经是密文了\",{\"1\":{\"1061\":1}}],[\"这样还得把这个机器搞成集群\",{\"1\":{\"1052\":1}}],[\"这样服务器就能从通行证上确认客户身份了\",{\"1\":{\"1051\":1}}],[\"这样进行下去\",{\"1\":{\"1018\":1}}],[\"这样处理后\",{\"1\":{\"896\":1}}],[\"这样得到了10个排好序的文件\",{\"1\":{\"895\":1}}],[\"这样新生成的文件每个的大小大约也1g\",{\"1\":{\"895\":1}}],[\"这样又得到了5000个文件\",{\"1\":{\"894\":1}}],[\"这样本来具有1万个的这个就会被淘汰\",{\"1\":{\"891\":1}}],[\"这样是无法得到正确的解的\",{\"1\":{\"891\":1}}],[\"这样不同的机子负责处理各种的数值范围\",{\"1\":{\"891\":1}}],[\"这样最后得到的n个元素就是最小的n个\",{\"1\":{\"885\":1}}],[\"这样数据的迁移成本太高了\",{\"1\":{\"880\":1}}],[\"这样才可以使日志条目只有一个流向\",{\"1\":{\"878\":1}}],[\"这样来自同一个ip地址的请求总在同一个服务器上处理\",{\"1\":{\"869\":1}}],[\"这样即使整个服务重启\",{\"1\":{\"863\":1}}],[\"这样当producer重启之后就可以通过正在进行的transaction\",{\"1\":{\"863\":1}}],[\"这样当然会出现幻读了\",{\"1\":{\"523\":1}}],[\"这样便能提供比较好的并发能力\",{\"1\":{\"861\":1}}],[\"这样避免了索引文件占用过多的空间\",{\"1\":{\"848\":1}}],[\"这样每个元素记录32个整数\",{\"1\":{\"903\":1}}],[\"这样每个元素对应32位二进制位\",{\"1\":{\"903\":1}}],[\"这样每个小文件的大约为\",{\"1\":{\"896\":1}}],[\"这样每个文件大概是200k左右\",{\"1\":{\"894\":1}}],[\"这样每个访客固定访问一个后端服务器\",{\"1\":{\"832\":1}}],[\"这样每个\",{\"1\":{\"659\":1}}],[\"这样对于客户端而言\",{\"1\":{\"657\":1}}],[\"这样样即使在重写的中途发生停机\",{\"1\":{\"651\":1}}],[\"这样目的是为了解决\",{\"1\":{\"622\":1}}],[\"这样巧妙地把一次性大量的拷贝开销\",{\"1\":{\"615\":1}}],[\"这样也没有必要\",{\"1\":{\"606\":1}}],[\"这样用户的一部分请求就会到缓存这里而不用经过数据库\",{\"1\":{\"606\":1}}],[\"这样用户就可以建立硬连接到重要文件\",{\"1\":{\"427\":1}}],[\"这样下一次再访问这些数据的时候就可以直接从缓存中获取了\",{\"1\":{\"606\":1}}],[\"这样dbms执行sql时\",{\"1\":{\"597\":1}}],[\"这样同一个用户的数据会分散到同一个库中\",{\"1\":{\"587\":1}}],[\"这样表中字段长度较短且访问频率较高\",{\"1\":{\"585\":1}}],[\"这样虽然会减少单库的压力\",{\"1\":{\"585\":1}}],[\"这样有会有大并发的更新操作\",{\"1\":{\"582\":1}}],[\"这样有利于对数据的快速处理\",{\"1\":{\"494\":1}}],[\"这样随机io的次数不会减少\",{\"1\":{\"574\":1}}],[\"这样可能会产生大量的日志内容\",{\"1\":{\"572\":1}}],[\"这样可以减少冗余数据\",{\"1\":{\"1042\":1}}],[\"这样可以减少连续执行字符串增长操作所需的内存重分配次数\",{\"1\":{\"624\":1}}],[\"这样可以使网络中的路由器或链路不致过载\",{\"1\":{\"1019\":1}}],[\"这样可以使得\",{\"1\":{\"51\":1}}],[\"这样可以不用查找该地址的类别就能知道这是哪一类的ip地址\",{\"1\":{\"989\":1}}],[\"这样可以扫描一遍即可得到所有的前n元素\",{\"1\":{\"885\":1}}],[\"这样可以有效地分载\",{\"1\":{\"656\":1}}],[\"这样可以有效防止幻读的发生\",{\"1\":{\"505\":1}}],[\"这样可以防止攻击用户反复用同一个\",{\"1\":{\"641\":1}}],[\"这样可以确保\",{\"1\":{\"623\":1}}],[\"这样可以在运行时\",{\"1\":{\"185\":1}}],[\"这样可以省去了锁的开销\",{\"1\":{\"104\":1}}],[\"这样可以提高吞吐量\",{\"1\":{\"103\":1}}],[\"这样在每台上只有1千个\",{\"1\":{\"891\":1}}],[\"这样在发生错误时\",{\"1\":{\"570\":1}}],[\"这样在函数中如果对参数进行修改\",{\"1\":{\"351\":1}}],[\"这样使得数据库更加合理\",{\"1\":{\"561\":1}}],[\"这样能将多个插入合并到一个操作中\",{\"1\":{\"574\":1}}],[\"这样能够节省大量磁盘空间和\",{\"1\":{\"535\":1}}],[\"这样能在一些场景中显著提高性能\",{\"1\":{\"209\":1}}],[\"这样事务之间就完全不可能产生干扰\",{\"1\":{\"522\":1,\"741\":1}}],[\"这样排序后就会直接从内存里面返回查询结果了\",{\"1\":{\"484\":1}}],[\"这样排序过程中一次可以排序更多行\",{\"1\":{\"484\":1}}],[\"这样会大大降低应用程序的复杂度\",{\"1\":{\"1090\":1}}],[\"这样会大大降低处理程序检索自己关心的就绪文件描述符的效率\",{\"1\":{\"381\":1}}],[\"这样会造成大量线程都处于等待状态\",{\"1\":{\"144\":1}}],[\"这样我就能调用这组接口中的方法了\",{\"1\":{\"349\":1}}],[\"这样做能把客户类和具体子类的实现解耦\",{\"1\":{\"1077\":1}}],[\"这样做\",{\"1\":{\"1017\":1}}],[\"这样做的风险是\",{\"1\":{\"563\":2}}],[\"这样做的好处是通过aio可以将多个io写入操作合并为一个io操作\",{\"1\":{\"496\":1}}],[\"这样做的目的是让缓存中存储的是最新的信息\",{\"1\":{\"752\":1}}],[\"这样做的目的\",{\"1\":{\"345\":1}}],[\"这样做对集合的效率是有利的\",{\"1\":{\"342\":1}}],[\"这样集合中取出的元素是泛型指定的类型\",{\"1\":{\"345\":1}}],[\"这样一共\",{\"1\":{\"539\":1}}],[\"这样一个真正可用的对象才算完全产生出来\",{\"1\":{\"223\":1}}],[\"这样一来\",{\"1\":{\"156\":1,\"300\":1,\"404\":1,\"614\":1}}],[\"这样它的作用域就不只是在方法内部\",{\"1\":{\"202\":1}}],[\"这样这个stringbuffer有可能被其他方法所改变\",{\"1\":{\"202\":1}}],[\"这样分离使得处理逻辑更为清晰\",{\"1\":{\"198\":1}}],[\"这样的专用网称为虚拟专用网vpn\",{\"1\":{\"995\":1}}],[\"这样的传输就是透明传输\",{\"1\":{\"973\":1}}],[\"这样的一种模式在开发大项目的过程中尤其有优势\",{\"1\":{\"766\":1}}],[\"这样的情况\",{\"1\":{\"642\":1}}],[\"这样的\",{\"1\":{\"637\":1}}],[\"这样的树形结构\",{\"1\":{\"630\":1}}],[\"这样的查询叫\",{\"1\":{\"549\":1}}],[\"这样的二叉树查找无异于全表扫描\",{\"1\":{\"532\":1}}],[\"这样的话还是有可能丢失部分修改\",{\"1\":{\"649\":1}}],[\"这样的话\",{\"1\":{\"380\":1,\"671\":1}}],[\"这样的数据\",{\"1\":{\"335\":1}}],[\"这样的方法称为非虚方法\",{\"1\":{\"194\":1}}],[\"这样的处理方式让写的同学更加明确线程池的运行规则\",{\"1\":{\"59\":1}}],[\"这样就实现了\",{\"1\":{\"1091\":1}}],[\"这样就大量省略策略类了\",{\"1\":{\"1089\":1}}],[\"这样就能有效的防止\",{\"1\":{\"1061\":1}}],[\"这样就能够找到泄漏的对象是通过怎么样的路径与gc\",{\"1\":{\"298\":1}}],[\"这样就进一步改进了http协议的效率\",{\"1\":{\"1042\":1}}],[\"这样就提醒了发送方放慢发送的速率\",{\"1\":{\"1021\":1}}],[\"这样就构成了一个帧\",{\"1\":{\"972\":1}}],[\"这样就可以避免上一次\",{\"1\":{\"1027\":1}}],[\"这样就可以让数据链路层只需要考虑如何完成本层的协议和服务\",{\"1\":{\"966\":1}}],[\"这样就可以在应用中调用service接口来进行业务处理\",{\"1\":{\"763\":1}}],[\"这样就知道这个\",{\"1\":{\"961\":1}}],[\"这样就得到了16个文件中各自出现次数最多的数\",{\"1\":{\"897\":1}}],[\"这样就完成了对各个对象之间关系的控制\",{\"1\":{\"718\":1}}],[\"这样就形成了多哨兵模式\",{\"1\":{\"657\":1}}],[\"这样就不需要从磁盘中读入这个数据页了\",{\"1\":{\"574\":1}}],[\"这样就让\",{\"1\":{\"537\":1}}],[\"这样就算我的散列值分布再松散\",{\"1\":{\"405\":1}}],[\"这样就会带来一个问题\",{\"1\":{\"880\":1}}],[\"这样就会找不到对象\",{\"1\":{\"304\":1}}],[\"这样就会出现类的冲突了\",{\"1\":{\"180\":1}}],[\"这样就使接收缓存空间仅腾出1个字节\",{\"1\":{\"1018\":1}}],[\"这样就使每次的内存回收都是对内存区间的一半进行回收\",{\"1\":{\"245\":1}}],[\"这样就使节点的释放规则符合\",{\"1\":{\"122\":1}}],[\"这样就通过协程实现了即轻量又灵活的\",{\"1\":{\"139\":1}}],[\"这样直接从内存中读写文件\",{\"1\":{\"138\":1}}],[\"这样反倒是降低了性能\",{\"1\":{\"104\":1}}],[\"这样设计的原因是大部分情况下我们占用锁的线程很快就执行完了\",{\"1\":{\"81\":1}}],[\"这样\",{\"1\":{\"39\":1,\"450\":1,\"655\":1,\"712\":1,\"766\":1,\"892\":1,\"895\":1,\"903\":1,\"1049\":1,\"1157\":1}}],[\"主页对应的代码分支\",{\"1\":{\"1200\":1}}],[\"主域名服务器向辅助域名服务器传送变化的那部分数据\",{\"1\":{\"1033\":1}}],[\"主体将\",{\"1\":{\"1004\":1}}],[\"主题\",{\"1\":{\"845\":1}}],[\"主\",{\"1\":{\"678\":1}}],[\"主库执行全量备份的同时\",{\"1\":{\"675\":1}}],[\"主库的存储能力受到单机的限制\",{\"1\":{\"675\":1}}],[\"主库的写能力受到单机的限制\",{\"1\":{\"675\":1}}],[\"主库同步数据到从库阶段\",{\"1\":{\"662\":1}}],[\"主节点\",{\"1\":{\"659\":1}}],[\"主节点自动执行\",{\"1\":{\"647\":1}}],[\"主观的认为\",{\"1\":{\"657\":1}}],[\"主服务器重新向\",{\"1\":{\"657\":1}}],[\"主服务器下线\",{\"1\":{\"657\":1}}],[\"主服务器被\",{\"1\":{\"657\":1}}],[\"主服务器被标记为主观下线\",{\"1\":{\"657\":1}}],[\"主服务器会被标记为客观下线\",{\"1\":{\"657\":1}}],[\"主服务器进入了主观下线状态\",{\"1\":{\"657\":1}}],[\"主服务器的主观下线状态就会被移除\",{\"1\":{\"657\":1}}],[\"主服务器的客观下线状态就会被移除\",{\"1\":{\"657\":1}}],[\"主服务器的确进入了主观下线状态\",{\"1\":{\"657\":1}}],[\"主服务器的所有\",{\"1\":{\"657\":2}}],[\"主服务器\",{\"1\":{\"657\":2,\"672\":1}}],[\"主机也因此可能收到多个offer报文\",{\"1\":{\"1049\":1}}],[\"主机号全为0\",{\"1\":{\"989\":1}}],[\"主机号也因此减少位数\",{\"1\":{\"989\":1}}],[\"主机a收到响应分组后\",{\"1\":{\"986\":1}}],[\"主机宕机\",{\"1\":{\"656\":1}}],[\"主机从机的宕机都会导致前端部分读写请求失败\",{\"1\":{\"656\":1}}],[\"主机会自动将数据同步到从机\",{\"1\":{\"656\":1}}],[\"主机掉电的时候会丢数据\",{\"1\":{\"563\":1}}],[\"主机掉电时会丢\",{\"1\":{\"563\":1}}],[\"主索引\",{\"1\":{\"545\":1}}],[\"主索引和辅助索引没啥区别\",{\"1\":{\"547\":1}}],[\"主索引和辅助索引\",{\"0\":{\"545\":1}}],[\"主流磁盘一般在5ms以下\",{\"1\":{\"543\":1}}],[\"主流的访问方式主要有使用句柄和直接指针两种\",{\"1\":{\"228\":1}}],[\"主动攻击\",{\"1\":{\"1054\":1}}],[\"主动关闭tcp连接\",{\"1\":{\"1026\":1}}],[\"主动关闭端接到重发的\",{\"1\":{\"1026\":1}}],[\"主动队列管理就是不要等到路由器丢弃队尾分组\",{\"1\":{\"1021\":1}}],[\"主动队列管理aqm\",{\"0\":{\"1021\":1}}],[\"主动队列管理\",{\"1\":{\"1019\":1}}],[\"主动回滚某一个事务\",{\"1\":{\"516\":1}}],[\"主动初始化\",{\"0\":{\"174\":1}}],[\"主表修改主键值\",{\"1\":{\"463\":2}}],[\"主表删除行\",{\"1\":{\"463\":2}}],[\"主键的作用就是把表的数据格式转换为\",{\"1\":{\"548\":1}}],[\"主键索引会自动创建\",{\"1\":{\"548\":1}}],[\"主键索引\",{\"1\":{\"548\":2}}],[\"主键索引是唯一的\",{\"1\":{\"547\":1}}],[\"主键整型最好\",{\"1\":{\"535\":1}}],[\"主键字段名\",{\"1\":{\"462\":1}}],[\"主键\",{\"0\":{\"462\":1},\"1\":{\"462\":1,\"531\":1,\"702\":1}}],[\"主键约束\",{\"1\":{\"460\":1}}],[\"主键共享\",{\"1\":{\"455\":1}}],[\"主分支\",{\"1\":{\"444\":1}}],[\"主从模式要复杂一些\",{\"1\":{\"676\":1}}],[\"主从模式下的高可用切换问题\",{\"1\":{\"676\":1}}],[\"主从模式下\",{\"1\":{\"657\":1}}],[\"主从实例部署在不同的物理服务器上\",{\"1\":{\"675\":1}}],[\"主从库会采用增量复制的方式继续同步\",{\"1\":{\"663\":1}}],[\"主从服务器两者数据库达到一致状态\",{\"1\":{\"662\":1}}],[\"主从可以自动切换\",{\"1\":{\"658\":1}}],[\"主从刚刚连接的时候\",{\"1\":{\"655\":1}}],[\"主从+哨兵+集群\",{\"0\":{\"654\":1}}],[\"主从架构\",{\"1\":{\"642\":1}}],[\"主从同步延迟的解决办法\",{\"1\":{\"582\":1}}],[\"主从同步的延迟原因\",{\"0\":{\"582\":1}}],[\"主从数据库的复制\",{\"1\":{\"571\":1}}],[\"主从复制作用\",{\"1\":{\"661\":1}}],[\"主从复制不会阻塞\",{\"1\":{\"661\":1}}],[\"主从复制的优缺点\",{\"0\":{\"656\":1}}],[\"主从复制的原理\",{\"0\":{\"580\":1}}],[\"主从复制的原理⭐\",{\"0\":{\"469\":1}}],[\"主从复制时使用的日志\",{\"1\":{\"566\":1}}],[\"主从复制\",{\"0\":{\"579\":1,\"655\":1},\"1\":{\"561\":1,\"579\":1,\"654\":1,\"661\":1}}],[\"主从复制涉及的线程\",{\"0\":{\"470\":1}}],[\"主从复制并不是复制磁盘上的数据库文件\",{\"1\":{\"469\":1,\"580\":1}}],[\"主从\",{\"0\":{\"675\":1},\"1\":{\"427\":1}}],[\"主版本号+1\",{\"1\":{\"285\":1}}],[\"主调方法的pc计数器的值就可以作为返回地址\",{\"1\":{\"195\":1}}],[\"主存空间或外部设备\",{\"1\":{\"148\":1}}],[\"主存与工作内存\",{\"0\":{\"66\":1}}],[\"主内存与工作内存\",{\"0\":{\"294\":1}}],[\"主内存是虚拟机内存的部分\",{\"1\":{\"66\":1}}],[\"主内存\",{\"1\":{\"66\":1,\"74\":4}}],[\"主要的过程大致包括业务场景分析\",{\"1\":{\"1215\":1}}],[\"主要的关注点在于局部性的优化\",{\"1\":{\"283\":1}}],[\"主要缺点\",{\"1\":{\"1085\":1}}],[\"主要特点\",{\"1\":{\"1002\":1}}],[\"主要可用\",{\"1\":{\"871\":1}}],[\"主要采用轮询的方式分配所有的分区\",{\"1\":{\"859\":1}}],[\"主要为了解决消息重复\",{\"1\":{\"856\":1}}],[\"主要在于消费者的性能\",{\"1\":{\"843\":1}}],[\"主要还是它和普通jar的结构不同\",{\"1\":{\"790\":1}}],[\"主要组合包含了以下\",{\"1\":{\"777\":1}}],[\"主要和控制层紧密结合\",{\"1\":{\"765\":1}}],[\"主要使用的技术栈有\",{\"1\":{\"687\":2}}],[\"主要交换故障信息\",{\"1\":{\"684\":1}}],[\"主要从\",{\"1\":{\"606\":1}}],[\"主要用来测试目的站是否可以到达以及了解其有关状态\",{\"1\":{\"993\":1}}],[\"主要用到的技术有html\",{\"1\":{\"754\":1}}],[\"主要用于时钟同步和时间测量\",{\"1\":{\"993\":1}}],[\"主要用于补充\",{\"1\":{\"992\":1}}],[\"主要用于公司内部的服务调用\",{\"1\":{\"806\":1}}],[\"主要用于\",{\"1\":{\"783\":1}}],[\"主要用于区别普通查询\",{\"1\":{\"556\":1}}],[\"主要用于数据争用激烈的环境\",{\"1\":{\"513\":1}}],[\"主要用在myisam存储引擎中\",{\"1\":{\"547\":1}}],[\"主要是写\",{\"1\":{\"1274\":1}}],[\"主要是配置\",{\"1\":{\"1270\":1}}],[\"主要是实现抽象工厂中的多个抽象方法\",{\"1\":{\"1079\":1}}],[\"主要是增加判断\",{\"1\":{\"936\":1}}],[\"主要是通过相应的log与index等文件保存具体的消息文件\",{\"1\":{\"846\":1}}],[\"主要是做数据持久层工作\",{\"1\":{\"762\":1}}],[\"主要是针对\",{\"1\":{\"676\":1}}],[\"主要是针对不满足最左前缀的部分\",{\"1\":{\"553\":1}}],[\"主要是根据索引加锁\",{\"1\":{\"506\":1}}],[\"主要是为了解决幻读问题\",{\"1\":{\"504\":1}}],[\"主要是替换掉项目名对于\",{\"1\":{\"18\":1}}],[\"主要就是判断你输入的\",{\"1\":{\"490\":1}}],[\"主要负责使用对称密码对消息进行加密\",{\"1\":{\"1062\":1}}],[\"主要负责前台jsp页面的表示\",{\"1\":{\"765\":1}}],[\"主要负责用户登录数据库\",{\"1\":{\"490\":1}}],[\"主要负责数据的存储和读取\",{\"1\":{\"488\":1}}],[\"主要分为握手协议\",{\"1\":{\"1062\":1}}],[\"主要分为\",{\"1\":{\"488\":1}}],[\"主要通常采用数值型或定长字符串表示\",{\"1\":{\"455\":1}}],[\"主要通过\",{\"1\":{\"62\":1}}],[\"主要体现在以下两个方面\",{\"1\":{\"463\":1}}],[\"主要体现\",{\"1\":{\"409\":1}}],[\"主要区别如下\",{\"1\":{\"384\":1}}],[\"主要目的是解耦消息发布者和消息订阅者之间的耦合\",{\"1\":{\"673\":1}}],[\"主要目的\",{\"1\":{\"293\":1}}],[\"主要包括\",{\"1\":{\"1216\":1}}],[\"主要包括以下几种情况\",{\"1\":{\"1010\":1}}],[\"主要包括连接器\",{\"1\":{\"488\":1}}],[\"主要包括下面几类常量\",{\"1\":{\"286\":1}}],[\"主要包括wait\",{\"1\":{\"126\":1}}],[\"主要有cookie\",{\"1\":{\"1038\":1}}],[\"主要有两种方式\",{\"1\":{\"715\":1,\"782\":1}}],[\"主要有\",{\"1\":{\"616\":1}}],[\"主要有3个关键字能够实现可见性\",{\"1\":{\"295\":1}}],[\"主要有javac与ecj\",{\"1\":{\"282\":1}}],[\"主要有静态方法和私有方法两大类\",{\"1\":{\"274\":1}}],[\"主要针对配备多核cpu及大容量内存的机器\",{\"1\":{\"261\":1}}],[\"主要应用在分布式开发中\",{\"1\":{\"149\":1}}],[\"主要应用场景和\",{\"1\":{\"120\":1}}],[\"主要对\",{\"1\":{\"130\":1}}],[\"主要增加了三个高级功能\",{\"1\":{\"94\":1}}],[\"主要\",{\"1\":{\"45\":1}}],[\"主线程创建并启动了子线程\",{\"1\":{\"35\":1}}],[\"执行io操作\",{\"1\":{\"829\":1}}],[\"执行init\",{\"0\":{\"223\":1}}],[\"执行应用\",{\"1\":{\"825\":1}}],[\"执行test目录下的测试用例\",{\"1\":{\"793\":1}}],[\"执行top\",{\"1\":{\"201\":1}}],[\"执行打包操作的配置\",{\"1\":{\"779\":1}}],[\"执行放行后的资源\",{\"1\":{\"759\":1}}],[\"执行过滤器\",{\"1\":{\"759\":1}}],[\"执行过程中系统锁及表锁的花费时间等信息\",{\"1\":{\"558\":1}}],[\"执行多次\",{\"1\":{\"759\":1}}],[\"执行插入\",{\"1\":{\"752\":1}}],[\"执行性能\",{\"1\":{\"746\":1,\"749\":1}}],[\"执行时必须指定一个事先准备好的\",{\"1\":{\"745\":1}}],[\"执行时数据库生成的锁模式\",{\"1\":{\"499\":1}}],[\"执行对象的方法\",{\"1\":{\"718\":1}}],[\"执行主体是代理类\",{\"1\":{\"716\":1}}],[\"执行取模\",{\"1\":{\"680\":1}}],[\"执行批量操作\",{\"1\":{\"678\":1}}],[\"执行迁移时\",{\"1\":{\"660\":1}}],[\"执行了100000次之后才将\",{\"1\":{\"559\":1}}],[\"执行100000次\",{\"1\":{\"559\":1}}],[\"执行情况\",{\"1\":{\"557\":1}}],[\"执行查询的语句是\",{\"1\":{\"555\":1}}],[\"执行查询语句的时候\",{\"1\":{\"490\":1}}],[\"执行效率低\",{\"1\":{\"559\":1}}],[\"执行效率\",{\"1\":{\"528\":1}}],[\"执行效率不稳定\",{\"1\":{\"244\":1}}],[\"执行上次操作后\",{\"1\":{\"520\":1}}],[\"执行事务前后\",{\"1\":{\"519\":1}}],[\"执行顺序\",{\"1\":{\"516\":1}}],[\"执行器把\",{\"1\":{\"571\":1}}],[\"执行器调用引擎的提交事务接口\",{\"1\":{\"489\":1}}],[\"执行器生成这个操作的\",{\"1\":{\"489\":1}}],[\"执行器拿到引擎给的行数据\",{\"1\":{\"489\":1}}],[\"执行器先找引擎取\",{\"1\":{\"489\":1}}],[\"执行器\",{\"1\":{\"489\":2,\"490\":1}}],[\"执行器等\",{\"1\":{\"488\":1}}],[\"执行计划\",{\"1\":{\"489\":1,\"559\":1}}],[\"执行select操作\",{\"1\":{\"487\":1}}],[\"执行store\",{\"1\":{\"295\":1}}],[\"执行引擎遇到任何一个方法返回的字节码指令\",{\"1\":{\"195\":1}}],[\"执行引擎运行的所有字节码指令只针对当前栈帧进行操作\",{\"1\":{\"191\":1}}],[\"执行系统调用相应服务程序\",{\"1\":{\"135\":1}}],[\"执行陷入指令\",{\"1\":{\"135\":1}}],[\"执行线程在获取了锁之后仍能连续多次地获得该锁\",{\"1\":{\"96\":1}}],[\"执行原理\",{\"1\":{\"87\":1}}],[\"执行流程\",{\"1\":{\"85\":1}}],[\"执行同步代码块时首先要执行\",{\"1\":{\"82\":1}}],[\"执行函数\",{\"1\":{\"63\":1}}],[\"执行\",{\"1\":{\"45\":1,\"85\":1,\"117\":1,\"223\":1,\"383\":1,\"647\":2,\"651\":1,\"662\":1,\"744\":1}}],[\"执行完成后\",{\"1\":{\"755\":1}}],[\"执行完同步代码块的内容后\",{\"1\":{\"85\":1}}],[\"执行完之后再继续调用其他线程\",{\"1\":{\"51\":1}}],[\"执行完\",{\"1\":{\"35\":1,\"75\":1,\"102\":1,\"655\":1}}],[\"执行的功能并非声称的功能\",{\"1\":{\"1054\":1}}],[\"执行的命令\",{\"1\":{\"878\":1}}],[\"执行的结果看到这\",{\"1\":{\"659\":1}}],[\"执行的\",{\"1\":{\"32\":1}}],[\"可反复测试\",{\"1\":{\"1242\":1}}],[\"可选标志\",{\"0\":{\"1190\":1},\"1\":{\"1188\":1}}],[\"可选\",{\"1\":{\"1144\":1,\"1177\":1}}],[\"可乐等\",{\"1\":{\"1086\":1}}],[\"可把协议软件参数化\",{\"1\":{\"1049\":1}}],[\"可缓存\",{\"1\":{\"1041\":1}}],[\"可读的\",{\"1\":{\"1035\":1}}],[\"可提高信道利用率\",{\"1\":{\"1011\":1}}],[\"可通过更好的路由\",{\"1\":{\"993\":1}}],[\"可靠性传输\",{\"1\":{\"1004\":1}}],[\"可靠性传送\",{\"1\":{\"998\":1}}],[\"可靠性由上层应用实现\",{\"1\":{\"1004\":1}}],[\"可靠传输\",{\"1\":{\"1001\":1}}],[\"可靠传输由运输层的tcp协议负责\",{\"1\":{\"975\":1}}],[\"可靠的数据传输服务\",{\"1\":{\"961\":1}}],[\"可一次读入内存\",{\"1\":{\"891\":1}}],[\"可进行数据的快速查找\",{\"1\":{\"883\":1}}],[\"可进一步通过工具查看泄漏对象到gc\",{\"1\":{\"298\":1}}],[\"可应用到秒杀场景\",{\"1\":{\"840\":1}}],[\"可伸缩和最终一致性架构\",{\"1\":{\"840\":1}}],[\"可直接从\",{\"1\":{\"745\":1}}],[\"可设置\",{\"1\":{\"708\":1}}],[\"可落地的ai提效工具\",{\"1\":{\"697\":1}}],[\"可极大满足\",{\"1\":{\"676\":1}}],[\"可线性扩展到\",{\"1\":{\"660\":1,\"678\":1}}],[\"可扩展性和可维护性\",{\"1\":{\"1064\":1}}],[\"可扩展性\",{\"1\":{\"660\":1,\"678\":1}}],[\"可动态调整数据分布\",{\"1\":{\"660\":1,\"678\":1}}],[\"可忽略\",{\"1\":{\"607\":1}}],[\"可基于内存亦可持久化的日志型\",{\"1\":{\"603\":1}}],[\"可用思路\",{\"1\":{\"891\":1}}],[\"可用数据库连接少甚至无连接可用\",{\"1\":{\"584\":1}}],[\"可用性更高\",{\"1\":{\"658\":1}}],[\"可用性\",{\"1\":{\"583\":1,\"870\":1}}],[\"可用于对表增加普通索引或唯一索引\",{\"1\":{\"527\":1}}],[\"可用于写锁\",{\"1\":{\"500\":1}}],[\"可用于读锁\",{\"1\":{\"500\":1}}],[\"可串行化\",{\"1\":{\"522\":2}}],[\"可重复读\",{\"1\":{\"522\":2,\"524\":1}}],[\"可重复读隔离级别才有\",{\"1\":{\"504\":1}}],[\"可重入锁\",{\"1\":{\"131\":1}}],[\"可重入指的是\",{\"1\":{\"96\":1}}],[\"可重入实现\",{\"0\":{\"96\":1}}],[\"可重入\",{\"1\":{\"94\":2}}],[\"可重入性\",{\"1\":{\"94\":1}}],[\"可回滚\",{\"1\":{\"483\":1}}],[\"可变长度\",{\"1\":{\"477\":1}}],[\"可简单理解为一个占位符\",{\"1\":{\"461\":1,\"596\":1,\"750\":1}}],[\"可执行权限\",{\"1\":{\"430\":1}}],[\"可视化更好\",{\"1\":{\"281\":1}}],[\"可预测的停顿时间模型\",{\"1\":{\"261\":1}}],[\"可预测停顿时间模型的基础\",{\"1\":{\"260\":1}}],[\"可作为\",{\"1\":{\"234\":1}}],[\"可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能进行分析\",{\"1\":{\"251\":1}}],[\"可达性分析算法\",{\"0\":{\"234\":1}}],[\"可达性分析法\",{\"1\":{\"232\":1}}],[\"可关联多个条件队列\",{\"1\":{\"94\":1}}],[\"可实现公平锁及锁可以绑定多个条件\",{\"1\":{\"94\":1}}],[\"可实现选择性通知\",{\"1\":{\"94\":1}}],[\"可能主机b新入网\",{\"1\":{\"986\":1}}],[\"可能需要树的度和高度都非常大\",{\"1\":{\"916\":1}}],[\"可能有的小伙伴已经反应过来了\",{\"1\":{\"902\":1}}],[\"可能有一个\",{\"1\":{\"381\":1}}],[\"可能对于所有的\",{\"1\":{\"895\":1}}],[\"可能订单系统也会出现问题\",{\"1\":{\"840\":1}}],[\"可能被其它线程抢先插入指令\",{\"1\":{\"665\":1}}],[\"可能造成数据库短期内承受大量请求而崩掉\",{\"1\":{\"641\":1}}],[\"可能就是在刷页\",{\"1\":{\"592\":1}}],[\"可能就是昨天晚上的一个备份\",{\"1\":{\"576\":1}}],[\"可能存在的三种状态\",{\"1\":{\"568\":1}}],[\"可能是存款\",{\"1\":{\"1087\":1}}],[\"可能是一个不错的解决方案\",{\"1\":{\"645\":1}}],[\"可能是一个复杂计算\",{\"1\":{\"643\":1}}],[\"可能是加载了许多结果中并不需要的列\",{\"1\":{\"559\":1}}],[\"可能是查询了多余的行并且抛弃掉了\",{\"1\":{\"559\":1}}],[\"可能是历史数据\",{\"1\":{\"523\":1}}],[\"可能是进程正常结束或其他原因中断退出运行\",{\"1\":{\"148\":1}}],[\"可能遇到脏读\",{\"1\":{\"499\":1}}],[\"可能导致mq中消息积压\",{\"1\":{\"843\":1}}],[\"可能导致集群的一些操作会有一些滞后\",{\"1\":{\"684\":1}}],[\"可能导致一些数据丢失\",{\"1\":{\"492\":1}}],[\"可能导致饥饿\",{\"1\":{\"163\":1}}],[\"可能产生大量的页分裂\",{\"1\":{\"466\":1}}],[\"可能产生多次缺页中断\",{\"1\":{\"159\":1}}],[\"可能分配内存并修改指针后未初始化\",{\"1\":{\"101\":1,\"1068\":1}}],[\"可能会存在安全风险\",{\"1\":{\"1057\":1}}],[\"可能会存在更新丢失问题\",{\"1\":{\"499\":1}}],[\"可能会被频繁的读写\",{\"1\":{\"587\":1}}],[\"可能会额外增加记录扫描的次数\",{\"1\":{\"554\":1}}],[\"可能会造成请求的处理速度变慢\",{\"1\":{\"715\":1}}],[\"可能会造成毫秒或秒级的卡顿\",{\"1\":{\"675\":1}}],[\"可能会造成事务隔离性问题\",{\"1\":{\"499\":1}}],[\"可能会造成线程的阻塞\",{\"1\":{\"79\":1}}],[\"可能会超出int的取值范围\",{\"1\":{\"467\":1}}],[\"可能会导致压力过载\",{\"1\":{\"843\":1}}],[\"可能会导致\",{\"1\":{\"656\":1}}],[\"可能会导致索引失效\",{\"1\":{\"560\":1}}],[\"可能会导致脏读\",{\"1\":{\"522\":1,\"741\":1}}],[\"可能会导致环形链表\",{\"1\":{\"406\":1}}],[\"可能会导致在阻塞队列中的线程长期处于饥饿状态\",{\"1\":{\"114\":1}}],[\"可能会占整个堆容量的20\",{\"1\":{\"262\":1}}],[\"可能会影响程序的前期执行性能\",{\"1\":{\"161\":1}}],[\"可能会出现这个问题\",{\"1\":{\"101\":1,\"1068\":1}}],[\"可能会改变程序的执行结果\",{\"1\":{\"76\":1}}],[\"可能会对代码进行指令重排\",{\"1\":{\"70\":1}}],[\"可能还没接收到\",{\"1\":{\"72\":1}}],[\"可见性指当一个线程修改了共享变量的值\",{\"1\":{\"295\":1}}],[\"可见性和原子性\",{\"1\":{\"79\":1}}],[\"可见性和有序性这三个特征来建立的\",{\"1\":{\"74\":1}}],[\"可见性但是要保证共享变量都在\",{\"1\":{\"71\":1}}],[\"可见性\",{\"0\":{\"67\":1},\"1\":{\"65\":1,\"67\":1,\"295\":1}}],[\"可从队列的两端插入和移出元素\",{\"1\":{\"62\":1}}],[\"可自定义\",{\"1\":{\"62\":1,\"751\":1}}],[\"可运行\",{\"1\":{\"38\":1}}],[\"可中断\",{\"1\":{\"35\":1}}],[\"可以抛出聚合根异常\",{\"1\":{\"1245\":1}}],[\"可以按照\",{\"1\":{\"1226\":1}}],[\"可以定义方法\",{\"1\":{\"1217\":1}}],[\"可以定义字符串的一部分作为索引\",{\"1\":{\"554\":1}}],[\"可以开启全局代理\",{\"1\":{\"1201\":1}}],[\"可以检查一下是否开启了全局代理\",{\"1\":{\"1201\":1}}],[\"可以包含一些变量和函数\",{\"1\":{\"1161\":1}}],[\"可以写点自己的项目\",{\"1\":{\"1103\":1}}],[\"可以写成\",{\"1\":{\"418\":1}}],[\"可以延迟到子类中实现\",{\"1\":{\"1087\":1}}],[\"可以处理一些其他问题\",{\"1\":{\"1083\":1}}],[\"可以全局访问\",{\"1\":{\"1071\":1}}],[\"可以说是密码学中的集大成者\",{\"1\":{\"1062\":1}}],[\"可以说这个语句具体该如何执行就已经定下来\",{\"1\":{\"490\":1}}],[\"可以节约数百毫秒的时间\",{\"1\":{\"1042\":1}}],[\"可以被多个请求复用\",{\"1\":{\"1042\":1}}],[\"可以被同一个锁上的\",{\"1\":{\"36\":1}}],[\"可以携带数据\",{\"1\":{\"1022\":1}}],[\"可以一直传输数据\",{\"1\":{\"1006\":1}}],[\"可以和用户交互\",{\"1\":{\"961\":1}}],[\"可以这样想\",{\"1\":{\"912\":1}}],[\"可以估计每个文件安的大小为5g×64=320g\",{\"1\":{\"896\":1}}],[\"可以交给多个文件来处理\",{\"1\":{\"895\":1}}],[\"可以得到\",{\"1\":{\"892\":1}}],[\"可以构建一个\",{\"1\":{\"892\":1}}],[\"可以做的改变就是将字典存放到硬盘上\",{\"1\":{\"891\":1}}],[\"可以做到无\",{\"1\":{\"749\":1}}],[\"可以做到在读操作时不用阻塞写操作\",{\"1\":{\"499\":1}}],[\"可以会提高节点的均衡度\",{\"1\":{\"880\":1}}],[\"可以创建多个不同等级的产品\",{\"1\":{\"1079\":1}}],[\"可以创建\",{\"1\":{\"875\":1}}],[\"可以指定\",{\"1\":{\"865\":1}}],[\"可以指定多个线程同时访问某个资源\",{\"1\":{\"117\":1}}],[\"可以分布在不同的\",{\"1\":{\"861\":1}}],[\"可以分为\",{\"1\":{\"500\":1}}],[\"可以提高性能\",{\"1\":{\"1071\":1}}],[\"可以提高发送效率\",{\"1\":{\"1003\":1}}],[\"可以提高并发\",{\"1\":{\"852\":1}}],[\"可以提升性能\",{\"1\":{\"571\":1}}],[\"可以很好的控制自身的压力\",{\"1\":{\"843\":1}}],[\"可以对分布式锁进行控制\",{\"1\":{\"821\":1}}],[\"可以挂掉一个节点\",{\"1\":{\"819\":1}}],[\"可以让接收方等待一段时间\",{\"1\":{\"1018\":1}}],[\"可以让请求报文体积更小\",{\"1\":{\"806\":1}}],[\"可以让用户临时挂载其他文件系统\",{\"1\":{\"416\":1}}],[\"可以兼容\",{\"1\":{\"788\":1}}],[\"可以兼容老\",{\"0\":{\"788\":1}}],[\"可以严格控制\",{\"1\":{\"746\":1,\"749\":1}}],[\"可以传动态的参数\",{\"1\":{\"745\":1}}],[\"可以方便的获取\",{\"1\":{\"736\":1}}],[\"可以控制真实对象的方法\",{\"1\":{\"727\":1}}],[\"可以扩展到上至本地事务下至全局事务\",{\"1\":{\"717\":1}}],[\"可以订阅多个\",{\"1\":{\"673\":1}}],[\"可以继续处理\",{\"1\":{\"661\":1}}],[\"可以继续响应其他命令\",{\"1\":{\"647\":1}}],[\"可以连接同一个\",{\"1\":{\"661\":1}}],[\"可以拥有多个\",{\"1\":{\"661\":1}}],[\"可以从上面\",{\"1\":{\"659\":1}}],[\"可以从一个程序切换到另外一个程序\",{\"1\":{\"134\":1}}],[\"可以关闭持久化\",{\"1\":{\"653\":1}}],[\"可以采用hash\",{\"1\":{\"892\":1}}],[\"可以采用push的方式\",{\"1\":{\"843\":1}}],[\"可以采用线程池的方式\",{\"1\":{\"843\":1}}],[\"可以采用\",{\"1\":{\"649\":1}}],[\"可以同时处理写请求么\",{\"1\":{\"647\":1}}],[\"可以把其中一个小文件的\",{\"1\":{\"896\":1}}],[\"可以把一致哈希算法是对\",{\"1\":{\"880\":1}}],[\"可以把动态页面和静态页面由不同的服务器来解析\",{\"1\":{\"827\":1}}],[\"可以把缓存层设计成高可用的\",{\"1\":{\"642\":1}}],[\"可以把索引值设置为0来表示\",{\"1\":{\"286\":1}}],[\"可以增加一个用户鉴权校验\",{\"1\":{\"641\":1}}],[\"可以存活的时间\",{\"1\":{\"632\":1}}],[\"可以存储\",{\"1\":{\"156\":1}}],[\"可以快速定位到查询的范围\",{\"1\":{\"630\":1}}],[\"可以满足元素唯一\",{\"1\":{\"619\":1}}],[\"可以达到\",{\"1\":{\"610\":1}}],[\"可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性\",{\"1\":{\"966\":1}}],[\"可以将这个文件先分解\",{\"1\":{\"904\":1}}],[\"可以将partition设置为1\",{\"1\":{\"865\":1}}],[\"可以将\",{\"1\":{\"665\":1}}],[\"可以将不用的数据放到磁盘上\",{\"1\":{\"610\":1}}],[\"可以将内存中的数据保持在磁盘中\",{\"1\":{\"610\":1}}],[\"可以将threadlocal类形象的比喻成存放数据的盒子\",{\"1\":{\"299\":1}}],[\"可以借助mysql的事务\",{\"1\":{\"866\":1}}],[\"可以借助\",{\"1\":{\"603\":1}}],[\"可以理解为producer\",{\"1\":{\"863\":1}}],[\"可以理解为一个队列\",{\"1\":{\"845\":1}}],[\"可以理解为是一个集群管理的插件\",{\"1\":{\"659\":1}}],[\"可以理解为磁盘\",{\"1\":{\"593\":1}}],[\"可以理解为只是threadlocalmap的封装\",{\"1\":{\"299\":1}}],[\"可以是单表设计\",{\"1\":{\"601\":1}}],[\"可以是一天一备\",{\"1\":{\"576\":1}}],[\"可以是线程结束任务之后自己结束\",{\"1\":{\"38\":1}}],[\"可以考虑采用\",{\"1\":{\"892\":1}}],[\"可以考虑以下三种方法\",{\"1\":{\"563\":1}}],[\"可以考虑表中的数据量是否太大\",{\"1\":{\"559\":1}}],[\"可以考虑修改语句\",{\"1\":{\"536\":1}}],[\"可以进一步根据\",{\"1\":{\"557\":1}}],[\"可以进行节点的动态扩容缩容\",{\"1\":{\"660\":1}}],[\"可以进行读写分离\",{\"1\":{\"656\":1}}],[\"可以进行读写操作\",{\"1\":{\"380\":1}}],[\"可以进行编译加密\",{\"1\":{\"180\":1}}],[\"可以使监听器在监听的变量初始化时立即执行一次\",{\"1\":{\"1157\":1}}],[\"可以使路由表中的项目数大幅度减少\",{\"1\":{\"985\":1}}],[\"可以使得树更矮\",{\"1\":{\"541\":1}}],[\"可以使用建造者模式对其进行设计\",{\"1\":{\"1086\":1}}],[\"可以使用抽象工厂模式进行设计\",{\"1\":{\"1079\":1}}],[\"可以使用数组\",{\"1\":{\"1035\":1}}],[\"可以使用bloom\",{\"1\":{\"896\":1}}],[\"可以使用外部模块扩展其功能\",{\"1\":{\"882\":1}}],[\"可以使用<string\",{\"1\":{\"624\":2}}],[\"可以使用这个命令\",{\"1\":{\"508\":1}}],[\"可以使用\",{\"1\":{\"348\":2,\"364\":1,\"393\":1,\"834\":1}}],[\"可以使用weakhashmap代表缓存\",{\"1\":{\"304\":1}}],[\"可以使用版本号机制和\",{\"1\":{\"103\":1}}],[\"可以找到指向第三行的指针\",{\"1\":{\"537\":1}}],[\"可以加速表和表之间的连接\",{\"1\":{\"528\":1}}],[\"可以省略创建对象所花费的时间\",{\"1\":{\"713\":1}}],[\"可以省略\",{\"1\":{\"527\":1}}],[\"可以阻止脏读和不可重复读\",{\"1\":{\"522\":1,\"741\":1}}],[\"可以阻止脏读\",{\"1\":{\"522\":1,\"741\":1}}],[\"可以根据当前的\",{\"1\":{\"861\":1}}],[\"可以根据名称注入\",{\"1\":{\"743\":1}}],[\"可以根据类型注入\",{\"1\":{\"743\":1}}],[\"可以根据\",{\"1\":{\"517\":1,\"620\":2,\"817\":1}}],[\"可以根据这个找到\",{\"1\":{\"427\":1}}],[\"可以尝试使用表锁\",{\"1\":{\"516\":1}}],[\"可以大大降低死锁机会\",{\"1\":{\"516\":1}}],[\"可以想象一下\",{\"1\":{\"511\":1}}],[\"可以读\",{\"1\":{\"509\":1}}],[\"可以锁定一个范围\",{\"1\":{\"505\":1}}],[\"可以认为offset是partition中message的\",{\"1\":{\"847\":1}}],[\"可以认为\",{\"1\":{\"499\":1}}],[\"可以手工或者自动执行检查和修复操作\",{\"1\":{\"492\":1}}],[\"可以容忍修复操作\",{\"1\":{\"492\":1}}],[\"可以往前翻页\",{\"1\":{\"428\":1}}],[\"可以并发执行\",{\"1\":{\"410\":1}}],[\"可以作为堆使用\",{\"1\":{\"394\":1}}],[\"可以获得直接缓冲区\",{\"1\":{\"378\":1}}],[\"可以\",{\"1\":{\"371\":1,\"647\":1}}],[\"可以区分出未赋值和值为\",{\"1\":{\"368\":1}}],[\"可以直接发送syn+ack报文\",{\"1\":{\"1024\":1}}],[\"可以直接使用这个缓存的\",{\"1\":{\"597\":1}}],[\"可以直接使用进程的名字而不是进程标识号\",{\"1\":{\"426\":1}}],[\"可以直接通过下标来查询数组\",{\"1\":{\"392\":1}}],[\"可以直接将一个不超过char范围的数字赋值给char\",{\"1\":{\"367\":1}}],[\"可以直接创建实例\",{\"1\":{\"361\":1}}],[\"可以参与表达式运算\",{\"1\":{\"367\":1}}],[\"可以有null\",{\"1\":{\"548\":1}}],[\"可以有重复值\",{\"1\":{\"462\":1}}],[\"可以有多个\",{\"1\":{\"462\":2}}],[\"可以有静态成员变量\",{\"1\":{\"361\":1}}],[\"可以有效地合并多个相邻的加锁代码块\",{\"1\":{\"93\":1}}],[\"可以修饰类么\",{\"0\":{\"360\":1}}],[\"可以相同也可以不同\",{\"1\":{\"359\":1}}],[\"可以设置\",{\"1\":{\"846\":1,\"1061\":1}}],[\"可以设置为\",{\"1\":{\"582\":1,\"879\":1}}],[\"可以设置超时时间\",{\"1\":{\"517\":1}}],[\"可以设置获取锁的超时时间\",{\"1\":{\"94\":1}}],[\"可以设计出低耦合的系统\",{\"1\":{\"354\":1}}],[\"可以推出\",{\"1\":{\"350\":1}}],[\"可以产生代理对象\",{\"1\":{\"349\":1}}],[\"可以给这个类创建一个代理\",{\"1\":{\"349\":1}}],[\"可以给线程命名\",{\"1\":{\"58\":1}}],[\"可以接受任何继承自\",{\"1\":{\"345\":1}}],[\"可以配合\",{\"1\":{\"316\":1}}],[\"可以在创建线程池的时候\",{\"1\":{\"1089\":1}}],[\"可以在父类中实现\",{\"1\":{\"1087\":1}}],[\"可以在类的内部对产品族中相关联的多等级产品共同管理\",{\"1\":{\"1079\":1}}],[\"可以在pom\",{\"1\":{\"790\":1}}],[\"可以在多线程环境下共享\",{\"1\":{\"735\":1}}],[\"可以在运行时动态生成指定类的一个子类对象\",{\"1\":{\"715\":1}}],[\"可以在不同情况下使得\",{\"1\":{\"632\":1}}],[\"可以在不停机的情况下\",{\"1\":{\"313\":1}}],[\"可以在程序运行前打印出用户手动设置或者jvm自动设置的xx选项\",{\"1\":{\"319\":1}}],[\"可以在线排查问题\",{\"1\":{\"313\":1}}],[\"可以在构造方法中指定\",{\"1\":{\"181\":1}}],[\"可以帮我们查找内存泄漏和减少内存消耗\",{\"1\":{\"313\":1}}],[\"可以用一位bit去装\",{\"1\":{\"903\":1}}],[\"可以用一些办法来避免使用锁\",{\"1\":{\"144\":1}}],[\"可以用堆来实现\",{\"1\":{\"899\":1}}],[\"可以用第2题提到的堆机制完成\",{\"1\":{\"898\":1}}],[\"可以用含100个结点的最小堆\",{\"1\":{\"894\":1}}],[\"可以用这个方式来获取其它bean\",{\"1\":{\"733\":1}}],[\"可以用来维护中位数\",{\"1\":{\"885\":1}}],[\"可以用来开发服务器或者客户端\",{\"1\":{\"685\":1}}],[\"可以用来控制分布式系统之间同步访问共享资源\",{\"1\":{\"667\":1}}],[\"可以用来修饰变量\",{\"1\":{\"370\":1}}],[\"可以用来描述数字\",{\"1\":{\"284\":1}}],[\"可以用\",{\"1\":{\"348\":1,\"560\":3}}],[\"可以自由选择任意多个region构成回收集\",{\"1\":{\"264\":1}}],[\"可以与垃圾收集线程一起并发运行\",{\"1\":{\"259\":1}}],[\"可以维护系统的运行安全\",{\"1\":{\"235\":1}}],[\"可以确认是安全的\",{\"1\":{\"220\":1}}],[\"可以调用带参构造器\",{\"1\":{\"212\":1}}],[\"可以不需要\",{\"1\":{\"780\":1}}],[\"可以不需要其他收集器配合就能独立管理整个\",{\"1\":{\"261\":1}}],[\"可以不存储在内存\",{\"1\":{\"202\":1}}],[\"可以不包含\",{\"1\":{\"26\":1}}],[\"可以避免类的重复加载\",{\"1\":{\"184\":1}}],[\"可以证明缺页数最小\",{\"1\":{\"160\":1}}],[\"可以实现不同效果\",{\"1\":{\"1085\":1}}],[\"可以实现更多接口\",{\"1\":{\"733\":1}}],[\"可以实现一套\",{\"1\":{\"676\":1}}],[\"可以实现故障发现\",{\"1\":{\"676\":1}}],[\"可以实现同时对外提供服务和读写分离策略\",{\"1\":{\"675\":1}}],[\"可以实现当一台数据库中的数据更新后\",{\"1\":{\"655\":1}}],[\"可以实现分次提交\",{\"1\":{\"447\":1}}],[\"可以实现按插入的顺序或访问顺序排序\",{\"1\":{\"412\":1}}],[\"可以实现本机任意两个进程通信\",{\"1\":{\"149\":1}}],[\"可以实现等待\",{\"1\":{\"126\":1}}],[\"可以保存数据\",{\"1\":{\"735\":1}}],[\"可以保存各种不同类型的值\",{\"1\":{\"626\":1}}],[\"可以保存文本数据或者二进制数据\",{\"1\":{\"624\":1}}],[\"可以保存自己的执行现场\",{\"1\":{\"139\":1}}],[\"可以保证数据不重复\",{\"1\":{\"856\":1}}],[\"可以保证数据库表中每一行数据的唯一性\",{\"1\":{\"528\":1}}],[\"可以保证共享变量的原子\",{\"1\":{\"71\":1}}],[\"可以访问任意的数据\",{\"1\":{\"134\":1}}],[\"可以终止\",{\"1\":{\"121\":1}}],[\"可以多次使用\",{\"1\":{\"121\":1}}],[\"可以看作是线程安全版本的\",{\"1\":{\"607\":1}}],[\"可以看作是当前线程所执行的字节码的行号指示器\",{\"1\":{\"189\":1}}],[\"可以看出\",{\"1\":{\"368\":1,\"428\":1}}],[\"可以看成是一种特殊的文件\",{\"1\":{\"149\":1}}],[\"可以看成是组合式\",{\"1\":{\"115\":1}}],[\"可以看成一个\",{\"1\":{\"128\":1}}],[\"可以看做一个线程安全的\",{\"1\":{\"108\":1}}],[\"可以看到本质上也是通过迭代器来遍历的\",{\"1\":{\"391\":1}}],[\"可以看到\",{\"1\":{\"96\":1,\"295\":1,\"571\":1,\"964\":1,\"1042\":1}}],[\"可以禁止指令重排\",{\"1\":{\"71\":1}}],[\"可以重新安排语句的执行顺序\",{\"1\":{\"71\":1}}],[\"可以比作高速缓存\",{\"1\":{\"66\":1}}],[\"可以通过其子类扩展具体构件的功能\",{\"1\":{\"1085\":1}}],[\"可以通过其中和索引有关的信息来分析是否命中了索引\",{\"1\":{\"556\":1}}],[\"可以通过第三方转发该调用\",{\"1\":{\"1064\":1}}],[\"可以通过多次缩小\",{\"1\":{\"886\":1}}],[\"可以通过以下几种方式来加载配置\",{\"1\":{\"784\":1}}],[\"可以通过表头的三个字段的长度直接定位\",{\"1\":{\"627\":1}}],[\"可以通过参数\",{\"1\":{\"498\":1}}],[\"可以通过使用\",{\"1\":{\"364\":1}}],[\"可以通过maxdirectmemorysize设置\",{\"1\":{\"209\":1}}],[\"可以通过this来访问到这个隐含的参数\",{\"1\":{\"192\":1}}],[\"可以通过classloader的新方法getplatformclassloader\",{\"1\":{\"181\":1}}],[\"可以通过\",{\"1\":{\"61\":1,\"219\":1,\"746\":1}}],[\"可以独立使用的\",{\"1\":{\"26\":1}}],[\"给某对象提供一种代理以控制对这个对象的访问\",{\"1\":{\"1081\":1}}],[\"给客户端\",{\"1\":{\"1053\":1}}],[\"给服务器添加信息\",{\"1\":{\"1040\":1}}],[\"给发送的每一个包进行编号\",{\"1\":{\"1009\":1}}],[\"给定一个二叉树\",{\"1\":{\"956\":1}}],[\"给定a\",{\"0\":{\"896\":1}}],[\"给整数数组赋值\",{\"1\":{\"955\":1}}],[\"给2000千万高考学生排序\",{\"0\":{\"902\":1}}],[\"给40亿个不重复的unsigned\",{\"0\":{\"901\":1}}],[\"给出时间复杂度分析\",{\"0\":{\"899\":1}}],[\"给t1和t2分别配备一个哈希函数\",{\"1\":{\"884\":1}}],[\"给leader发送ack\",{\"1\":{\"853\":1}}],[\"给数据库造成巨大压力\",{\"1\":{\"840\":1}}],[\"给数据库造成很大压力\",{\"1\":{\"464\":1}}],[\"给singleton实例对象分配内存\",{\"1\":{\"714\":1}}],[\"给singleton分配内存\",{\"1\":{\"101\":1}}],[\"给我们提供了一个工具redis\",{\"1\":{\"651\":1}}],[\"给哈希表\",{\"1\":{\"615\":1}}],[\"给\",{\"1\":{\"573\":1,\"623\":1,\"1068\":1}}],[\"给唯一索引加锁的时候\",{\"1\":{\"515\":1}}],[\"给方法调用者来解决\",{\"1\":{\"386\":1}}],[\"给对象中添加一个引用计数器\",{\"1\":{\"233\":1}}],[\"给对象上锁\",{\"1\":{\"85\":1}}],[\"给覆盖\",{\"1\":{\"88\":1}}],[\"给程序员一种幻觉\",{\"1\":{\"76\":1}}],[\"给其他线程机会时不考虑线程的优先级\",{\"1\":{\"35\":1}}],[\"给其它线程\",{\"1\":{\"35\":1}}],[\"给你一个数组\",{\"1\":{\"6\":1}}],[\"让简单工厂类来决定应该用哪个具体子类来实例化\",{\"1\":{\"1077\":1}}],[\"让服务器等待\",{\"1\":{\"1054\":1}}],[\"让本地域名服务器再向顶级域名服务器查询\",{\"1\":{\"1031\":1}}],[\"让tcp报文得以正常消失\",{\"1\":{\"1027\":1}}],[\"让主机知道下次应将数据报发送给另外的路由器\",{\"1\":{\"993\":1}}],[\"让数据在⼀个链路中传输\",{\"1\":{\"961\":1}}],[\"让父节点和最大的值进行交换\",{\"1\":{\"937\":1}}],[\"让index指向交换后的位置\",{\"1\":{\"937\":1}}],[\"让每一位二进制代表一个整数的话\",{\"1\":{\"903\":1}}],[\"让你找出a\",{\"0\":{\"896\":1}}],[\"让你可以快速开发\",{\"1\":{\"362\":1}}],[\"让不同的机器处理一个数值范围\",{\"1\":{\"891\":1}}],[\"让不同的线程排队访问\",{\"1\":{\"40\":1}}],[\"让javaweb\",{\"1\":{\"825\":1}}],[\"让jvm在每次minorgc后打印出当前使用的survivor中对象的年龄分布\",{\"1\":{\"322\":1}}],[\"让别的机器服务\",{\"1\":{\"802\":1}}],[\"让各个哨兵把自己监控的从服务器实现切换主机\",{\"1\":{\"657\":1}}],[\"让它们切换主机\",{\"1\":{\"657\":1,\"677\":1}}],[\"让其他事务得以继续执行\",{\"1\":{\"516\":1}}],[\"让其不会溢出\",{\"1\":{\"64\":1}}],[\"让用户决定如何去做\",{\"1\":{\"513\":1}}],[\"让并发度大大提高\",{\"1\":{\"409\":1}}],[\"让下一阶段用户线程并发运行时\",{\"1\":{\"264\":1}}],[\"让所有存活的对象都向一端移动\",{\"1\":{\"246\":1}}],[\"让一组线程到达一个屏障\",{\"1\":{\"120\":1}}],[\"让两个线程执行时间有交错\",{\"1\":{\"99\":1}}],[\"让\",{\"1\":{\"89\":1,\"293\":1,\"379\":1,\"383\":1,\"657\":1,\"882\":1}}],[\"让重入计数减\",{\"1\":{\"87\":1}}],[\"让出\",{\"1\":{\"35\":1}}],[\"让任务类脱离了\",{\"1\":{\"32\":1}}],[\"只防止用户在不知情的情况下通信被监听\",{\"1\":{\"1046\":1}}],[\"只检错不纠错\",{\"1\":{\"961\":1}}],[\"只用2gb内存在20亿个整数中找到出现次数最多的数\",{\"1\":{\"897\":1}}],[\"只用将磁盘文件的数据复制到页面缓存中一次\",{\"1\":{\"850\":1}}],[\"只发起一次调用\",{\"1\":{\"813\":1}}],[\"只执行一次\",{\"1\":{\"759\":2}}],[\"只作为故障转移使用\",{\"1\":{\"678\":1}}],[\"只允许被一个程序占有\",{\"1\":{\"669\":1}}],[\"只允许一个线程查询数据和写缓存\",{\"1\":{\"642\":1}}],[\"只需将配置好的\",{\"1\":{\"1186\":1}}],[\"只需将这个瞬时节点删除即可\",{\"1\":{\"668\":1}}],[\"只需多写一个相应的工厂类\",{\"1\":{\"1078\":1}}],[\"只需提供一个消费接口给mq即可\",{\"1\":{\"843\":1}}],[\"只需在pom中作如下配置即可实现聚合\",{\"1\":{\"799\":1}}],[\"只需在spring配置文件中配置一个普通的bean就可以\",{\"1\":{\"733\":1}}],[\"只需传入一个待检测的\",{\"1\":{\"612\":1}}],[\"只需要操作聚合根\",{\"1\":{\"1232\":1}}],[\"只需要传入一个正确的参数\",{\"1\":{\"1077\":1}}],[\"只需要4个字节即可\",{\"1\":{\"997\":1}}],[\"只需要1+10=11次\",{\"1\":{\"850\":1}}],[\"只需要知道代理服务器地址就能访问到目标服务器的资源\",{\"1\":{\"826\":1}}],[\"只需要在配置文件中做相关的事务规则声明或者通过注解的方式\",{\"1\":{\"739\":1}}],[\"只需要移除节点上的哈希槽挪到其它节点即可\",{\"1\":{\"680\":1}}],[\"只需要把其它节点的哈希槽挪到新节点即可\",{\"1\":{\"680\":1}}],[\"只需要判断有序节点中序号最小的一个\",{\"1\":{\"668\":1}}],[\"只需要添加节点即可\",{\"1\":{\"587\":1}}],[\"只需要看看原来的\",{\"1\":{\"406\":1}}],[\"只需要通过一个u4的长度属性去说明属性值所占用的位数即可\",{\"1\":{\"291\":1}}],[\"只支持多\",{\"1\":{\"678\":1}}],[\"只支持\",{\"1\":{\"613\":1}}],[\"只支持最简单的\",{\"1\":{\"610\":1}}],[\"只支持精确查找\",{\"1\":{\"537\":1}}],[\"只运行单线程的情况下\",{\"1\":{\"604\":1}}],[\"只写redo\",{\"1\":{\"575\":1}}],[\"只记录该引擎中表的修改记录\",{\"1\":{\"573\":1}}],[\"只取前6位字符作为索引\",{\"1\":{\"554\":1}}],[\"只缓存索引\",{\"1\":{\"493\":1}}],[\"只返回两个表中连接字段相等的行\",{\"1\":{\"485\":1}}],[\"只看尾巴几行\",{\"1\":{\"428\":1}}],[\"只看头几行\",{\"1\":{\"428\":1}}],[\"只删除一个连接并不影响索引节点本身和其它的连接\",{\"1\":{\"427\":1}}],[\"只保留低位值\",{\"1\":{\"405\":1}}],[\"只不过ip数据报的数据段部分被icmp报文替代了而已\",{\"1\":{\"992\":1}}],[\"只不过是无分类的两级编址\",{\"1\":{\"991\":1}}],[\"只不过是调用socket的read和write\",{\"1\":{\"838\":1}}],[\"只不过是利用反射来实现的\",{\"1\":{\"725\":1}}],[\"只不过链表中的每个节点都是一个\",{\"1\":{\"629\":1}}],[\"只不过channel\",{\"1\":{\"379\":1}}],[\"只不过计数不是递增而是递减\",{\"1\":{\"121\":1}}],[\"只可以定义方法\",{\"1\":{\"362\":1}}],[\"只可以直接访问外部类静态成员\",{\"1\":{\"361\":1}}],[\"只对serial\",{\"1\":{\"322\":1}}],[\"只对方法有效\",{\"1\":{\"278\":1}}],[\"只显示本地虚拟机id\",{\"1\":{\"312\":1}}],[\"只具有弱引用的对象拥有更短暂的生命周期\",{\"1\":{\"235\":1}}],[\"只会启动一个进程来写数据库镜像\",{\"1\":{\"661\":1}}],[\"只会返回有事件发⽣的⽂件描述符的个数\",{\"1\":{\"612\":1}}],[\"只会有一个活动的栈帧\",{\"1\":{\"191\":1}}],[\"只会有少量的页内碎片\",{\"1\":{\"155\":1}}],[\"只会阻塞线程\",{\"1\":{\"35\":1}}],[\"只存在于内存中的文件\",{\"1\":{\"149\":1}}],[\"只是接口\",{\"1\":{\"1242\":1}}],[\"只是限界上下文只是站在更高的层面来进行划分\",{\"1\":{\"1221\":1}}],[\"只是把它的引用指向\",{\"1\":{\"1091\":1}}],[\"只是把指向对象实例的地址复制一份到引用上\",{\"1\":{\"343\":1}}],[\"只是先后的问题\",{\"1\":{\"1067\":1}}],[\"只是先把日志写到\",{\"1\":{\"650\":2}}],[\"只是一门语言\",{\"1\":{\"1035\":1}}],[\"只是未按序号\",{\"1\":{\"1013\":1}}],[\"只是重复的次数比较多而已\",{\"1\":{\"895\":1}}],[\"只是响应来自\",{\"1\":{\"874\":1}}],[\"只是leader落盘\",{\"1\":{\"854\":1}}],[\"只是文件扩展名为index\",{\"1\":{\"848\":1}}],[\"只是增加了顺序属性\",{\"1\":{\"818\":1}}],[\"只是解决分布式系统之间远程调用问题\",{\"1\":{\"815\":1}}],[\"只是多了一步虚拟节点到实际节点的映射\",{\"1\":{\"681\":1}}],[\"只是多了一个\",{\"1\":{\"406\":1}}],[\"只是不提供数据服务\",{\"1\":{\"676\":1}}],[\"只是表中数据集合不同\",{\"1\":{\"585\":1}}],[\"只是预提交但不是\",{\"1\":{\"578\":1}}],[\"只是主索引中的key一定得是唯一的\",{\"1\":{\"547\":1}}],[\"只是在写的时候会创建新对\",{\"1\":{\"411\":1}}],[\"只是存起来了\",{\"1\":{\"383\":1}}],[\"只是拥有\",{\"1\":{\"355\":1}}],[\"只是用于标注该对象是可被序列化的\",{\"1\":{\"344\":1}}],[\"只是挂在thread下面而已\",{\"1\":{\"299\":1}}],[\"只是标记gc\",{\"1\":{\"259\":1}}],[\"只是\",{\"1\":{\"136\":1}}],[\"只是维持了一个可获得许可证的数量\",{\"1\":{\"117\":1}}],[\"只是定义了没赋值\",{\"1\":{\"102\":1}}],[\"只是将线程池的状态设为\",{\"1\":{\"59\":1}}],[\"只能使用单例类提供的方法得到单例对象\",{\"1\":{\"1074\":1}}],[\"只能使用一次\",{\"1\":{\"121\":1}}],[\"只能从\",{\"1\":{\"875\":1}}],[\"只能选择cp\",{\"1\":{\"870\":1}}],[\"只能保证单分区\",{\"1\":{\"863\":1}}],[\"只能保证数据不丢失\",{\"1\":{\"856\":1}}],[\"只能保存文本数据\",{\"1\":{\"624\":1}}],[\"只能存储\",{\"1\":{\"840\":1}}],[\"只能当\",{\"1\":{\"820\":1}}],[\"只能成为追随者\",{\"1\":{\"820\":1}}],[\"只能对应一个\",{\"1\":{\"655\":1}}],[\"只能对整张表加锁\",{\"1\":{\"492\":1}}],[\"只能逐个查找\",{\"1\":{\"627\":1}}],[\"只能表示从\",{\"1\":{\"475\":1}}],[\"只能有一个\",{\"1\":{\"462\":1}}],[\"只能退出\",{\"1\":{\"384\":1}}],[\"只能与\",{\"1\":{\"379\":1}}],[\"只能修饰变量\",{\"1\":{\"364\":1}}],[\"只能直接用接口调用静态方法\",{\"1\":{\"362\":1}}],[\"只能通过接口聚合方式解决\",{\"1\":{\"585\":1}}],[\"只能通过\",{\"1\":{\"355\":1}}],[\"只能调用空参构造器\",{\"1\":{\"212\":1}}],[\"只能在程序运行期根据实际的类型绑定相关的方法\",{\"1\":{\"194\":1}}],[\"只能在持有资源的进程完成任务后\",{\"1\":{\"98\":1}}],[\"只能由当前的进程主动放弃\",{\"1\":{\"150\":1}}],[\"只能用于父子进程或者兄弟进程之间的进程的通信\",{\"1\":{\"149\":1}}],[\"只能受限的访问内存\",{\"1\":{\"134\":1}}],[\"只能\",{\"1\":{\"72\":1}}],[\"只要服务端发出确认\",{\"1\":{\"1023\":1}}],[\"只要出现这两种情况之一\",{\"1\":{\"1018\":1}}],[\"只要tcp连接的一方收到一个对方的零窗口通知\",{\"1\":{\"1015\":1}}],[\"只要发现\",{\"1\":{\"973\":1}}],[\"只要求快\",{\"1\":{\"938\":1}}],[\"只要散列表足够大\",{\"1\":{\"924\":1}}],[\"只要还有左子树\",{\"1\":{\"908\":1}}],[\"只要还有强引用指向一个对象\",{\"1\":{\"45\":1}}],[\"只要当前节点不为空\",{\"1\":{\"908\":1}}],[\"只要一个成功即返回\",{\"1\":{\"813\":1}}],[\"只要配置好配置文件\",{\"1\":{\"718\":1}}],[\"只要大部分\",{\"1\":{\"672\":1}}],[\"只要\",{\"1\":{\"650\":1}}],[\"只要读到空字符就表明字符串结束\",{\"1\":{\"624\":1}}],[\"只要列中包含有\",{\"1\":{\"535\":1}}],[\"只要有必要\",{\"1\":{\"452\":1}}],[\"只要哈希函数映射得比较均匀松散\",{\"1\":{\"405\":1}}],[\"只要这个\",{\"1\":{\"381\":1}}],[\"只要对象不会再被程序使用\",{\"1\":{\"302\":1}}],[\"只要描述符不是完全一致的两个方法就可以共存\",{\"1\":{\"290\":1}}],[\"只要两个字段的描述符不是完全相同\",{\"1\":{\"289\":1}}],[\"只要能被invokestatic和invokespecial指令调用的方法\",{\"1\":{\"275\":1}}],[\"只要筛选出卡表中变脏的元素\",{\"1\":{\"249\":1}}],[\"只要卡页内有一个\",{\"1\":{\"249\":1}}],[\"只要不被使用\",{\"1\":{\"237\":1}}],[\"只要不改变程序执行结果\",{\"1\":{\"74\":1}}],[\"只要重新与引用链上的任何一个对象建立关联即可\",{\"1\":{\"236\":1}}],[\"只要强引用关系还存在\",{\"1\":{\"235\":1}}],[\"只要被局部变量表中直接或间接引用的对象都不会被回收\",{\"1\":{\"192\":1}}],[\"只要知道这个方法在方法表中的偏移量就可以直接调用该方法了\",{\"1\":{\"172\":1}}],[\"只要加载它们的classloader不同\",{\"1\":{\"166\":1}}],[\"只要前继结点释放锁\",{\"1\":{\"111\":1}}],[\"只要遇到这条指令\",{\"1\":{\"72\":1}}],[\"只要写到\",{\"1\":{\"72\":1}}],[\"只提供了一份变量\",{\"1\":{\"40\":1}}],[\"只有三个条件都满足\",{\"1\":{\"1075\":1}}],[\"只有重写那个类\",{\"1\":{\"1072\":1}}],[\"只有信息发送接收的双方能够懂得信息内容\",{\"1\":{\"1055\":1}}],[\"只有等到我server端所有的报文都发送完了\",{\"1\":{\"1024\":1}}],[\"只有一种出队顺序\",{\"1\":{\"941\":1}}],[\"只有一个服务器是\",{\"1\":{\"874\":1}}],[\"只有一个master\",{\"1\":{\"833\":1}}],[\"只有一个操作码\",{\"1\":{\"280\":1}}],[\"只有一个线程能执行\",{\"1\":{\"113\":1}}],[\"只有黑色节点才会在\",{\"1\":{\"921\":1}}],[\"只有查询出来的列名和pojo列名和pojo的属性名一致\",{\"1\":{\"751\":1}}],[\"只有java代码发生改变\",{\"1\":{\"731\":1}}],[\"只有部分缓存会失效\",{\"1\":{\"587\":1,\"681\":1}}],[\"只有两种可能数据\",{\"1\":{\"532\":1}}],[\"只有select语句才会走mvcc机制\",{\"1\":{\"499\":1}}],[\"只有符合的记录才会被插入到虚拟表vt7中\",{\"1\":{\"487\":1}}],[\"只有符合的记录才会被放入到虚拟表vt4\",{\"1\":{\"487\":1}}],[\"只有符号引用是不够的\",{\"1\":{\"172\":1}}],[\"只有那些符合条件的行才会被记录在虚拟表vt2中\",{\"1\":{\"487\":1}}],[\"只有bytebuffer\",{\"1\":{\"378\":1}}],[\"只有内部类才可以\",{\"1\":{\"360\":1}}],[\"只有新方法才能被调用\",{\"1\":{\"355\":1}}],[\"只有实现了\",{\"1\":{\"350\":1}}],[\"只有\",{\"1\":{\"341\":1,\"416\":1,\"488\":1,\"504\":1,\"505\":1,\"610\":1,\"875\":2,\"916\":1}}],[\"只有被static关键字修饰的变量\",{\"1\":{\"292\":1}}],[\"只有它从1开始\",{\"1\":{\"286\":1}}],[\"只有它能与\",{\"1\":{\"255\":1}}],[\"只有少部分对象会存活很长时间\",{\"1\":{\"240\":1}}],[\"只有本地缓冲区用完了\",{\"1\":{\"219\":1}}],[\"只有class文件被载入内存\",{\"1\":{\"182\":1}}],[\"只有通过这个阶段的验证后\",{\"1\":{\"170\":1}}],[\"只有磁头朝某个特定方向移动时\",{\"1\":{\"163\":1}}],[\"只有在收到对前一个报文段的确认后才继续发送下一个报文段\",{\"1\":{\"1017\":1}}],[\"只有在\",{\"1\":{\"759\":2}}],[\"只有在使用某个bean时\",{\"1\":{\"712\":1}}],[\"只有在where语句出现\",{\"1\":{\"532\":1}}],[\"只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘\",{\"1\":{\"492\":1}}],[\"只有在需要它不支持的特性时\",{\"1\":{\"491\":1}}],[\"只有在程序运行期间才能确定引用变量到底会指向哪个类的实例对象\",{\"1\":{\"355\":1}}],[\"只有在full\",{\"1\":{\"207\":1}}],[\"只有在内核重启\",{\"1\":{\"149\":1}}],[\"只有在关闭延迟后\",{\"1\":{\"86\":1}}],[\"只有链表的头节点\",{\"1\":{\"131\":1}}],[\"只有当数据写完之后\",{\"1\":{\"829\":1}}],[\"只有当访问一个\",{\"1\":{\"632\":1}}],[\"只有当最后一个连接被删除后\",{\"1\":{\"427\":1}}],[\"只有当父加载器反馈自己无法完成这个加载请求\",{\"1\":{\"184\":1}}],[\"只有当该进程运行完毕后才能释放这块内存空间\",{\"1\":{\"154\":1}}],[\"只有当前线程可以访问该变量\",{\"1\":{\"79\":1}}],[\"只有当其他线程调用notify才能唤醒此线程\",{\"1\":{\"35\":1}}],[\"只有延迟期满时才能从队列中获取元素\",{\"1\":{\"62\":1}}],[\"只有同一个锁上的等待线程\",{\"1\":{\"36\":1}}],[\"只属于\",{\"1\":{\"26\":1}}],[\"释放哈希表\",{\"1\":{\"615\":1}}],[\"释放a上的s锁\",{\"1\":{\"509\":1}}],[\"释放后的变量才可以被其他线程锁定\",{\"1\":{\"294\":1}}],[\"释放后会唤醒后续处于等待状态的节点\",{\"1\":{\"123\":1}}],[\"释放内存\",{\"1\":{\"153\":1}}],[\"释放子进程占用的资源\",{\"1\":{\"151\":1}}],[\"释放同步状态时\",{\"1\":{\"123\":1}}],[\"释放形式\",{\"1\":{\"94\":1}}],[\"释放之后依然是偏向\",{\"1\":{\"88\":1}}],[\"释放之后为无锁不可偏向\",{\"1\":{\"88\":1}}],[\"释放处于锁定状态的变量\",{\"1\":{\"74\":1}}],[\"释放锁的原理\",{\"0\":{\"123\":1}}],[\"释放锁\",{\"1\":{\"35\":2,\"73\":1,\"94\":1,\"96\":1,\"126\":1,\"517\":1,\"668\":1,\"669\":1}}],[\"释放\",{\"1\":{\"35\":3}}],[\"jxwang\",{\"1\":{\"1143\":1,\"1144\":2}}],[\"j=high\",{\"1\":{\"935\":1}}],[\"j+1\",{\"1\":{\"930\":3,\"932\":2,\"935\":1}}],[\"j++\",{\"1\":{\"930\":1,\"954\":1,\"955\":1}}],[\"jetty等东西\",{\"1\":{\"825\":1}}],[\"jetty\",{\"1\":{\"780\":1,\"801\":1}}],[\"just\",{\"1\":{\"767\":1}}],[\"juc\",{\"0\":{\"107\":1},\"1\":{\"106\":1}}],[\"jta\",{\"1\":{\"717\":1}}],[\"jpeg\",{\"1\":{\"1038\":1}}],[\"jprofiler\",{\"1\":{\"313\":1}}],[\"jps\",{\"1\":{\"312\":2}}],[\"jhat\",{\"1\":{\"312\":1}}],[\"jvisualvm\",{\"1\":{\"313\":1}}],[\"jvisualvm来实时查看jvm状态\",{\"1\":{\"308\":1}}],[\"jvm才需要重新编译布署\",{\"1\":{\"731\":1}}],[\"jvm才真正开始执行类中编写的java代码\",{\"1\":{\"173\":1}}],[\"jvm选项参数\",{\"0\":{\"314\":1}}],[\"jvm是怎么运行class文件的\",{\"0\":{\"283\":1}}],[\"jvm支持以下5条\",{\"1\":{\"274\":1}}],[\"jvm就会把这个弱引用加入到与之关联的引用队列中\",{\"1\":{\"235\":1}}],[\"jvm就会把这个软引用加入到与之关联的引用队列中\",{\"1\":{\"235\":1}}],[\"jvmti中注册的回调\",{\"1\":{\"234\":1}}],[\"jvm不会再出现方法区的内存溢出\",{\"1\":{\"205\":1}}],[\"jvm的设计者们提出了栈顶缓存技术\",{\"1\":{\"193\":1}}],[\"jvm使用局部变量表来完成参数值到参数变量列表的传递过程\",{\"1\":{\"192\":1}}],[\"jvm以方法作为最基本的执行单元\",{\"1\":{\"191\":1}}],[\"jvm会尽力但不保证达到\",{\"1\":{\"262\":1}}],[\"jvm会抛出一个stackoverflowerror异常\",{\"1\":{\"190\":1}}],[\"jvm会把所有代码加载到不同的系统域和应用域\",{\"1\":{\"186\":1}}],[\"jvm对java栈的操作只有\",{\"1\":{\"190\":1}}],[\"jvm通过\",{\"1\":{\"182\":1}}],[\"jvm必须保证一个类的<clinit>\",{\"1\":{\"173\":1}}],[\"jvm\",{\"0\":{\"164\":1,\"335\":1},\"1\":{\"74\":1,\"78\":1,\"79\":1,\"81\":1,\"82\":1,\"87\":1,\"88\":3,\"144\":1,\"183\":1,\"184\":1,\"219\":1,\"235\":1,\"277\":1,\"296\":1,\"335\":2,\"336\":1,\"337\":1,\"338\":1,\"345\":1,\"348\":2,\"349\":1,\"352\":1,\"378\":2,\"609\":1,\"1069\":1,\"1075\":6}}],[\"jmc\",{\"1\":{\"313\":1}}],[\"jmap\",{\"1\":{\"308\":1,\"312\":1}}],[\"jmm定义了\",{\"1\":{\"294\":1}}],[\"jmm\",{\"0\":{\"65\":1,\"72\":1,\"73\":1,\"74\":1},\"1\":{\"65\":3,\"66\":1,\"74\":4,\"75\":2,\"337\":3}}],[\"jieba\",{\"0\":{\"1212\":2},\"1\":{\"1139\":1,\"1209\":1,\"1212\":6}}],[\"jit\",{\"1\":{\"283\":1}}],[\"jit编译器借助逃逸分析后发现\",{\"1\":{\"202\":1}}],[\"jinfo等\",{\"1\":{\"308\":1}}],[\"jinfo\",{\"1\":{\"253\":1,\"312\":1}}],[\"json\",{\"0\":{\"1035\":1,\"1139\":1},\"1\":{\"755\":1,\"1035\":2,\"1139\":2,\"1151\":1}}],[\"js等前端技术\",{\"1\":{\"754\":1}}],[\"jsp\",{\"1\":{\"754\":1,\"756\":1,\"825\":2}}],[\"jstatd\",{\"1\":{\"312\":1}}],[\"jstat\",{\"1\":{\"312\":2}}],[\"jstack查看堆栈信息\",{\"1\":{\"308\":1}}],[\"jstack方法\",{\"1\":{\"201\":1}}],[\"jstack\",{\"1\":{\"98\":1,\"201\":1,\"308\":1}}],[\"js\",{\"1\":{\"194\":1,\"959\":1,\"1029\":1,\"1061\":2,\"1139\":1,\"1151\":1,\"1161\":1,\"1208\":1}}],[\"jconsole\",{\"1\":{\"313\":2}}],[\"jconsole工具\",{\"1\":{\"98\":1}}],[\"jcmd\",{\"1\":{\"312\":1}}],[\"jclasslib或jclasslib\",{\"1\":{\"281\":1}}],[\"jce\",{\"1\":{\"185\":1}}],[\"jdo\",{\"1\":{\"717\":1}}],[\"jdb\",{\"1\":{\"335\":1}}],[\"jdbc的连接\",{\"1\":{\"748\":1}}],[\"jdbctemplate\",{\"1\":{\"742\":1}}],[\"jdbc中使用对象preparedstatement来抽象预编译语句\",{\"1\":{\"597\":1}}],[\"jdbc\",{\"0\":{\"744\":1},\"1\":{\"185\":1,\"348\":1,\"586\":1,\"717\":1,\"744\":2,\"746\":4}}],[\"jdk代理和cglib代理是很相似的\",{\"1\":{\"727\":1}}],[\"jdk动态代理只能对实现了接口的类生成代理\",{\"1\":{\"727\":1}}],[\"jdk动态代理原理\",{\"1\":{\"725\":1}}],[\"jdk动态代理\",{\"0\":{\"725\":1},\"1\":{\"724\":1}}],[\"jdk动态代理的核心是invocationhandler接口和proxy类\",{\"1\":{\"715\":1,\"725\":1}}],[\"jdk动态代理和cglib动态代理\",{\"1\":{\"715\":1}}],[\"jdk自带的工具\",{\"1\":{\"313\":1}}],[\"jdk自带的反解析工具\",{\"1\":{\"281\":1}}],[\"jdk中提供的threadlocal类正是为了解决这样的问题\",{\"1\":{\"299\":1}}],[\"jdk每个大版本\",{\"1\":{\"285\":1}}],[\"jdk提供了java\",{\"1\":{\"185\":1}}],[\"jdk9\",{\"0\":{\"260\":1}}],[\"jdk9开始默认\",{\"1\":{\"252\":1}}],[\"jdk9开始\",{\"1\":{\"252\":1}}],[\"jdk9基于模块化构建\",{\"1\":{\"181\":1}}],[\"jdk9新特性\",{\"0\":{\"181\":1}}],[\"jdk7\",{\"0\":{\"129\":1},\"1\":{\"130\":1,\"203\":1,\"395\":1,\"398\":1,\"399\":1,\"406\":1}}],[\"jdk6有了放弃永久代\",{\"1\":{\"203\":1}}],[\"jdk6\",{\"1\":{\"82\":1}}],[\"jdk14开始\",{\"1\":{\"252\":2}}],[\"jdk1\",{\"0\":{\"131\":1},\"1\":{\"78\":1,\"128\":1,\"130\":6,\"131\":2,\"185\":1,\"204\":3,\"207\":1,\"362\":2,\"409\":1}}],[\"jdk\",{\"0\":{\"108\":1,\"335\":1,\"1089\":1},\"1\":{\"60\":2,\"81\":1,\"91\":1,\"108\":2,\"109\":1,\"144\":1,\"292\":1,\"313\":2,\"335\":1,\"389\":1,\"607\":1,\"725\":4,\"804\":1,\"1077\":1,\"1083\":1,\"1084\":1,\"1087\":1,\"1089\":1}}],[\"jdk8中接口中可以包含静态方法\",{\"1\":{\"362\":1}}],[\"jdk8引入了接口默认方法\",{\"1\":{\"362\":1}}],[\"jdk8默认\",{\"1\":{\"252\":1}}],[\"jdk8\",{\"0\":{\"130\":1,\"257\":1,\"258\":1,\"403\":1},\"1\":{\"42\":1,\"395\":1,\"398\":1,\"399\":1,\"403\":1,\"406\":1,\"409\":2}}],[\"jndi现在已经是java的标准服务\",{\"1\":{\"185\":1}}],[\"jaxb和jbi等\",{\"1\":{\"185\":1}}],[\"jar也引用了x\",{\"1\":{\"798\":1}}],[\"jar又引用了x\",{\"1\":{\"798\":1}}],[\"jar又引用了b\",{\"1\":{\"798\":1}}],[\"jar命令来运行\",{\"1\":{\"790\":1}}],[\"jar的\",{\"1\":{\"185\":1}}],[\"jar包去加载之外\",{\"1\":{\"180\":1}}],[\"jar或sun\",{\"1\":{\"176\":1}}],[\"jar\",{\"1\":{\"176\":1,\"317\":2,\"774\":2,\"790\":1,\"798\":9}}],[\"java<\",{\"1\":{\"1266\":2}}],[\"javascript对象标记法\",{\"1\":{\"1035\":1}}],[\"javascript\",{\"1\":{\"1035\":1}}],[\"java开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器\",{\"1\":{\"769\":1}}],[\"java反射机制\",{\"1\":{\"759\":1}}],[\"java8\",{\"1\":{\"338\":1}}],[\"javadoc\",{\"1\":{\"335\":1}}],[\"javac\",{\"1\":{\"335\":1}}],[\"javac编译器\",{\"1\":{\"282\":1}}],[\"javac编译器的数据流分析工作保证了在方法执行的任何时候\",{\"1\":{\"193\":1}}],[\"java运行时追踪工具\",{\"1\":{\"313\":1}}],[\"java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性\",{\"1\":{\"295\":1}}],[\"java语言里符合这个条件的方法共有静态方法\",{\"1\":{\"275\":1}}],[\"java内存模型是通过在变量修改后将新值同步回主内存\",{\"1\":{\"295\":1}}],[\"java内存模型还提供了lock和unlock操作来满足这种需求\",{\"1\":{\"295\":1}}],[\"java内存模型\",{\"1\":{\"293\":1}}],[\"java源代码编译的结果是字节码\",{\"1\":{\"282\":1}}],[\"javap\",{\"1\":{\"281\":1}}],[\"java垃圾回收是java程序执行自动内存管理的过程\",{\"1\":{\"231\":1}}],[\"java程序方法体里面的代码经过javac编译器处理之后\",{\"1\":{\"292\":1}}],[\"java程序会通过栈上的reference数据来操作堆上的具体对象\",{\"1\":{\"228\":1}}],[\"java程序在运行的时候\",{\"1\":{\"182\":1}}],[\"java堆既可以被实现成固定大小的\",{\"1\":{\"199\":1}}],[\"java堆可以处于物理上不连续的内存空间中\",{\"1\":{\"199\":1}}],[\"java堆是虚拟机所管理的内存中最大的一块\",{\"1\":{\"199\":1}}],[\"java堆\",{\"0\":{\"199\":1}}],[\"java堆和栈的区别\",{\"0\":{\"198\":1}}],[\"java的指令都是根据栈来设计的\",{\"1\":{\"190\":1}}],[\"java中涉及spi的加载基本上都采用这种方式来完成\",{\"1\":{\"185\":1}}],[\"java中涉及spi的服务使用这个线程上下文类加载器去加载所需的spi服务代码\",{\"1\":{\"185\":1}}],[\"java类库天然满足扩展需求\",{\"1\":{\"181\":1}}],[\"java代码是很容易被编译和篡改\",{\"1\":{\"180\":1}}],[\"java代码容易被反编译\",{\"1\":{\"180\":1}}],[\"java虚拟机内部的引用\",{\"1\":{\"234\":1}}],[\"java虚拟机对于class文件每一部分\",{\"1\":{\"208\":1}}],[\"java虚拟机将会抛出outofmemoryerror异常\",{\"1\":{\"199\":1}}],[\"java虚拟机的解释执行引擎被称为\",{\"1\":{\"193\":1}}],[\"java虚拟机通过索引定位的方式使用局部变量表\",{\"1\":{\"192\":1}}],[\"java虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间\",{\"1\":{\"192\":1}}],[\"java虚拟机会保证在子类的<clinit>\",{\"1\":{\"173\":1}}],[\"java虚拟机都会同步创建一个栈帧用于存储局部变量表\",{\"1\":{\"190\":1}}],[\"java虚拟机栈\",{\"0\":{\"190\":1}}],[\"java虚拟机规范\",{\"1\":{\"170\":1,\"172\":1,\"190\":1,\"196\":1,\"203\":1,\"208\":1,\"209\":1,\"228\":1,\"293\":1}}],[\"java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中\",{\"1\":{\"168\":1}}],[\"java虚拟机要完成\",{\"1\":{\"168\":1}}],[\"java\",{\"0\":{\"65\":1,\"336\":1,\"337\":1,\"356\":1,\"366\":1,\"375\":1,\"382\":1,\"387\":1,\"1251\":1,\"1262\":1},\"1\":{\"32\":1,\"34\":1,\"38\":1,\"49\":1,\"59\":1,\"62\":1,\"65\":6,\"66\":1,\"74\":3,\"81\":2,\"82\":1,\"85\":2,\"94\":1,\"103\":2,\"108\":1,\"126\":2,\"141\":1,\"142\":1,\"144\":1,\"168\":1,\"170\":2,\"172\":1,\"174\":1,\"176\":1,\"184\":2,\"185\":1,\"194\":1,\"197\":1,\"200\":2,\"202\":1,\"221\":1,\"223\":1,\"229\":1,\"230\":1,\"235\":1,\"282\":1,\"292\":1,\"293\":1,\"295\":2,\"297\":1,\"317\":3,\"335\":8,\"336\":5,\"337\":1,\"338\":1,\"342\":4,\"345\":1,\"348\":2,\"351\":2,\"356\":1,\"358\":2,\"362\":1,\"368\":4,\"369\":3,\"370\":1,\"377\":2,\"379\":1,\"385\":5,\"390\":3,\"559\":2,\"687\":1,\"720\":1,\"721\":1,\"725\":1,\"747\":1,\"790\":1,\"799\":1,\"809\":1,\"825\":1,\"829\":1,\"882\":1,\"951\":2,\"952\":1,\"953\":2,\"955\":2,\"956\":4,\"1075\":2,\"1077\":2,\"1081\":1,\"1255\":1,\"1256\":1,\"1264\":1}}],[\"java并发\",{\"0\":{\"27\":1,\"333\":1,\"686\":1}}],[\"jre<\",{\"1\":{\"882\":1}}],[\"jrescloud3\",{\"1\":{\"1263\":1}}],[\"jres\",{\"1\":{\"687\":1}}],[\"jre\",{\"0\":{\"335\":1},\"1\":{\"176\":1,\"335\":2}}],[\"j\",{\"1\":{\"81\":1,\"368\":1,\"930\":5,\"931\":8,\"932\":8,\"933\":18,\"934\":4,\"935\":11,\"937\":3,\"954\":3,\"955\":4}}],[\"joinpoint\",{\"1\":{\"721\":1}}],[\"join将会很麻烦\",{\"1\":{\"585\":1}}],[\"join\",{\"0\":{\"35\":1,\"49\":1,\"485\":1},\"1\":{\"35\":4,\"38\":2,\"49\":2,\"51\":2,\"75\":1,\"102\":2,\"144\":1,\"485\":3,\"487\":2,\"584\":1,\"1177\":1}}],[\"wget\",{\"1\":{\"1170\":1}}],[\"weixin\",{\"1\":{\"1143\":1}}],[\"weight\",{\"1\":{\"832\":1}}],[\"weaving\",{\"1\":{\"721\":1}}],[\"weak\",{\"1\":{\"239\":1}}],[\"weakreference\",{\"1\":{\"235\":1}}],[\"websocket\",{\"1\":{\"1040\":1}}],[\"web服务器\",{\"1\":{\"826\":1}}],[\"webmvc等相关包及做相关配置就能够立即使用起来\",{\"1\":{\"772\":1}}],[\"web就能使项目支持spring\",{\"1\":{\"772\":1}}],[\"web请求\",{\"1\":{\"759\":1}}],[\"webapplicationobjectsupport\",{\"1\":{\"736\":1}}],[\"webapplicationcontext\",{\"1\":{\"736\":4}}],[\"webapplicationcontextutils\",{\"1\":{\"736\":2}}],[\"web\",{\"1\":{\"606\":2,\"717\":2,\"736\":1,\"770\":2,\"772\":1,\"795\":1,\"796\":1,\"800\":2,\"1039\":1,\"1090\":1}}],[\"wifi\",{\"1\":{\"1042\":1}}],[\"wirte\",{\"1\":{\"568\":1}}],[\"with\",{\"1\":{\"508\":1,\"523\":1,\"1077\":2}}],[\"window\",{\"0\":{\"1192\":1},\"1\":{\"1038\":1}}],[\"windows系统下在catalina\",{\"1\":{\"317\":1}}],[\"windows\",{\"1\":{\"157\":1,\"416\":1,\"427\":1,\"701\":1,\"1124\":1,\"1144\":2,\"1202\":1}}],[\"wine\",{\"0\":{\"19\":1},\"1\":{\"18\":3,\"687\":1,\"689\":2,\"694\":1,\"696\":2}}],[\"wc\",{\"0\":{\"439\":1},\"1\":{\"439\":2,\"443\":2}}],[\"what\",{\"1\":{\"888\":4}}],[\"whatchanged\",{\"1\":{\"449\":1}}],[\"while\",{\"1\":{\"668\":1,\"908\":5,\"911\":1,\"912\":1,\"913\":1,\"934\":3,\"935\":9,\"936\":3,\"937\":3,\"949\":1,\"951\":1,\"952\":1,\"953\":1,\"954\":1,\"955\":1}}],[\"which\",{\"1\":{\"434\":1}}],[\"when\",{\"0\":{\"600\":1}}],[\"where中索引列有运算\",{\"1\":{\"534\":1}}],[\"where\",{\"0\":{\"481\":1},\"1\":{\"481\":1,\"482\":2,\"484\":1,\"486\":4,\"487\":1,\"489\":1,\"501\":4,\"537\":1,\"553\":1,\"555\":1,\"556\":2,\"559\":3,\"601\":1,\"703\":1,\"745\":2}}],[\"whereis\",{\"1\":{\"434\":2}}],[\"w\",{\"1\":{\"430\":2,\"433\":1,\"1190\":6}}],[\"woman\",{\"1\":{\"277\":7}}],[\"world\",{\"1\":{\"255\":1,\"259\":1}}],[\"world带来的不良用户体验\",{\"1\":{\"254\":1}}],[\"world持续的时间尽可能短以及提高并发式gc所能应付的内存分配速率\",{\"1\":{\"240\":1}}],[\"word就会指向monitor对象\",{\"1\":{\"85\":1}}],[\"word\",{\"0\":{\"84\":1},\"1\":{\"84\":1,\"85\":2,\"86\":2,\"87\":3,\"88\":2,\"89\":1,\"891\":1}}],[\"workflows\",{\"1\":{\"1198\":1}}],[\"worker的端口号会变\",{\"1\":{\"837\":1}}],[\"worker\",{\"0\":{\"835\":1,\"836\":1},\"1\":{\"834\":2,\"835\":3}}],[\"workers\",{\"0\":{\"834\":1}}],[\"workers机制\",{\"0\":{\"833\":1}}],[\"worker进行争抢式的方式去获取请求\",{\"1\":{\"833\":1}}],[\"worker进程\",{\"1\":{\"837\":1}}],[\"worker进程是单线程的\",{\"1\":{\"830\":1}}],[\"worker进程模型\",{\"0\":{\"830\":1}}],[\"worker使得worker进程可以高效率地执行单线程i\",{\"1\":{\"830\":1}}],[\"work\",{\"1\":{\"418\":1}}],[\"working\",{\"1\":{\"66\":1,\"337\":1,\"444\":2,\"1121\":1}}],[\"workqueue\",{\"1\":{\"58\":5}}],[\"wangjx\",{\"1\":{\"1126\":1,\"1127\":4}}],[\"watermark\",{\"1\":{\"855\":1}}],[\"wathch\",{\"1\":{\"823\":1}}],[\"watcher\",{\"1\":{\"817\":1}}],[\"watch\",{\"0\":{\"1165\":1},\"1\":{\"665\":3,\"823\":2,\"1157\":5}}],[\"war\",{\"1\":{\"774\":1}}],[\"war格式的基础\",{\"1\":{\"168\":1}}],[\"wac\",{\"1\":{\"736\":3}}],[\"wal机制\",{\"1\":{\"559\":1}}],[\"wal方式\",{\"1\":{\"519\":1}}],[\"wal\",{\"0\":{\"569\":1},\"1\":{\"489\":1,\"568\":1,\"569\":1}}],[\"wait2状态\",{\"1\":{\"1026\":1}}],[\"wait都会返回\",{\"1\":{\"381\":1}}],[\"waiting\",{\"1\":{\"38\":2,\"85\":1,\"148\":1}}],[\"waitset\",{\"1\":{\"37\":1,\"85\":1,\"94\":1,\"109\":1}}],[\"wait\",{\"0\":{\"35\":1,\"36\":1,\"37\":1},\"1\":{\"35\":4,\"36\":2,\"37\":2,\"38\":3,\"62\":1,\"88\":2,\"126\":1,\"144\":1,\"350\":6,\"381\":4,\"516\":2,\"612\":1,\"613\":3,\"1026\":3,\"1027\":1}}],[\"write页的写入后\",{\"1\":{\"496\":1}}],[\"write由两部分组成\",{\"1\":{\"496\":1}}],[\"writeobject\",{\"1\":{\"344\":1}}],[\"write操作\",{\"1\":{\"295\":1}}],[\"write\",{\"1\":{\"73\":2,\"74\":1,\"103\":1,\"149\":1,\"250\":1,\"294\":1,\"295\":1,\"411\":1,\"430\":2,\"489\":1,\"492\":1,\"496\":1,\"510\":1,\"568\":2,\"569\":1,\"571\":1,\"647\":1,\"649\":1,\"804\":1,\"829\":1}}],[\"即什么动作会导致当前事件的发生\",{\"1\":{\"1216\":1}}],[\"即产品的组成部分是不变的\",{\"1\":{\"1086\":1}}],[\"即插即用\",{\"1\":{\"1085\":1}}],[\"即增加其额外功能\",{\"1\":{\"1085\":1}}],[\"即公钥和私钥\",{\"1\":{\"1056\":1}}],[\"即如何安全地将密钥发给对方\",{\"1\":{\"1056\":1}}],[\"即被动攻击和主动攻击\",{\"1\":{\"1054\":1}}],[\"即被调用的目标方法无法在编译期被确定\",{\"1\":{\"194\":1}}],[\"即被调用的目标方法如果在编译期可知\",{\"1\":{\"194\":1}}],[\"即让一个用户请求一直粘在一个服务器上\",{\"1\":{\"1052\":1}}],[\"即tcp连接默认不关闭\",{\"1\":{\"1042\":1}}],[\"即tcp支持的\",{\"1\":{\"1016\":1}}],[\"即发送数据之前不需要建立连接\",{\"1\":{\"1002\":1}}],[\"即发送lcp的配置请求帧\",{\"1\":{\"975\":1}}],[\"即把一个数据包从一个主机发到另一个主机上面\",{\"1\":{\"999\":1}}],[\"即把这些信息传递给其他一些随机选择的节点\",{\"1\":{\"684\":1}}],[\"即数据链路层\",{\"1\":{\"981\":1}}],[\"即数据是按行进行存放的\",{\"1\":{\"498\":1}}],[\"即网络层\",{\"1\":{\"981\":1}}],[\"即下一个元素要插入的位置\",{\"1\":{\"934\":1}}],[\"即hash\",{\"1\":{\"867\":1}}],[\"即到\",{\"1\":{\"861\":1}}],[\"即exactly\",{\"1\":{\"856\":1}}],[\"即follower追上leader之后\",{\"1\":{\"855\":1}}],[\"即与leader保持同步的follower集合\",{\"1\":{\"853\":1}}],[\"即round\",{\"1\":{\"852\":1}}],[\"即reentrantlock的非公平模式与公平模式\",{\"1\":{\"95\":1}}],[\"即消费者组是逻辑上的一个订阅者\",{\"1\":{\"845\":1}}],[\"即从kafka中拉取消息消费的客户端\",{\"1\":{\"845\":1}}],[\"即从辅助索引中就可以得到查询的记录\",{\"1\":{\"550\":1}}],[\"即利用topic存储消息\",{\"1\":{\"844\":1}}],[\"即初次选举\",{\"1\":{\"820\":1}}],[\"即调用\",{\"1\":{\"814\":1}}],[\"即调用哪一个方法\",{\"1\":{\"273\":1}}],[\"即model\",{\"1\":{\"748\":1}}],[\"即view\",{\"1\":{\"748\":1}}],[\"即解耦合\",{\"1\":{\"748\":1}}],[\"即有线程安全问题\",{\"1\":{\"735\":1}}],[\"即有以下两点局限性\",{\"1\":{\"609\":1}}],[\"即实现了基于\",{\"1\":{\"730\":1}}],[\"即实参到形参的传递\",{\"1\":{\"192\":1}}],[\"即永远只有一个\",{\"1\":{\"672\":1}}],[\"即基于关系型数据库\",{\"1\":{\"668\":1}}],[\"即没有获取到锁将直接返回获取锁失败\",{\"1\":{\"667\":1}}],[\"即引入了\",{\"1\":{\"645\":1}}],[\"即以\",{\"1\":{\"624\":1}}],[\"即远程字典服务\",{\"1\":{\"603\":1}}],[\"即二进制日志\",{\"1\":{\"571\":1}}],[\"即存储的是老版本数据\",{\"1\":{\"570\":1}}],[\"即存在一个根节点和若干个叶子节点\",{\"1\":{\"539\":1}}],[\"即只需扫描索引而无须回表\",{\"1\":{\"550\":1}}],[\"即快照读可能读到的并不一定是数据的最新版本\",{\"1\":{\"499\":1}}],[\"即不保证可靠交付\",{\"1\":{\"1002\":1}}],[\"即不要求数据链路层向上提供可靠的传输服务\",{\"1\":{\"974\":1}}],[\"即不加锁的非阻塞读\",{\"1\":{\"499\":1}}],[\"即不能再被任何途径使用的对象就是垃圾\",{\"1\":{\"232\":1}}],[\"即两个区\",{\"1\":{\"496\":1}}],[\"即时通讯\",{\"1\":{\"1001\":1}}],[\"即时管理员修改了该用户的权限\",{\"1\":{\"490\":1}}],[\"即时编译jit\",{\"1\":{\"283\":1}}],[\"即时编译器编译后的代码缓存等数据\",{\"1\":{\"203\":1}}],[\"即对象关系映射\",{\"1\":{\"747\":1}}],[\"即对象指向它的类元数据的指针\",{\"1\":{\"225\":1}}],[\"即对每一个服务节点计算多个哈希\",{\"1\":{\"681\":1}}],[\"即对每次\",{\"1\":{\"412\":1}}],[\"即读线程对数据的更新是延时感知的\",{\"1\":{\"411\":1}}],[\"即读写性能高\",{\"1\":{\"209\":1}}],[\"即写时复制的思想来通过延时更新的策略来实现数据的最终一致性\",{\"1\":{\"411\":1}}],[\"即确定静态分派的动作实际上不是由jvm来执行的\",{\"1\":{\"277\":1}}],[\"即将回收\",{\"1\":{\"236\":1}}],[\"即将暂时获取不到锁的线程加入到队列中\",{\"1\":{\"110\":1}}],[\"即我们在程序代码里面所定义的各种类型的字段内容\",{\"1\":{\"226\":1}}],[\"即class文件中的<init>\",{\"1\":{\"223\":1}}],[\"即采用上述方式\",{\"1\":{\"219\":1}}],[\"即局部变量表所需的容量大小是在编译期确定下来的\",{\"1\":{\"192\":1}}],[\"即父类到子类的一个访问\",{\"1\":{\"179\":1}}],[\"即程序调用类的静态方法\",{\"1\":{\"174\":1}}],[\"即程序给类的静态变量赋值\",{\"1\":{\"174\":1}}],[\"即程序访问类的静态变量\",{\"1\":{\"174\":1}}],[\"即当前节点的左右子树没有访问完毕\",{\"1\":{\"908\":1}}],[\"即当jvm的gc线程处理速度慢时\",{\"1\":{\"260\":1}}],[\"即当程序创建一个类的实例对象\",{\"1\":{\"174\":1}}],[\"即当一个线程正在执行时另一个线程访问同步块获取锁时\",{\"1\":{\"91\":1}}],[\"即在同一个tcp连接里面\",{\"1\":{\"1042\":1}}],[\"即在ip地址后面加上\",{\"1\":{\"991\":1}}],[\"即在内核执行系统调用或等待系统事件所使用的cpu时间\",{\"1\":{\"331\":1}}],[\"即在虚拟机视角中的实例构造器<init>\",{\"1\":{\"173\":1}}],[\"即在自旋的时候持锁的线程释放了锁\",{\"1\":{\"91\":1}}],[\"即静态变量\",{\"1\":{\"171\":2}}],[\"即选择最近最久未使用的页面予以淘汰\",{\"1\":{\"160\":1}}],[\"即淘汰最早调入的页面\",{\"1\":{\"160\":1}}],[\"即可以先将int64分成2^24个区域\",{\"1\":{\"886\":1}}],[\"即可以有多线线程同时读同一个资源\",{\"1\":{\"821\":1}}],[\"即可以将对象自动持久化到数据库中\",{\"1\":{\"747\":1}}],[\"即可以不用升级为轻量级锁\",{\"1\":{\"88\":1}}],[\"即可将这个方法与所属的类型进行绑定\",{\"1\":{\"194\":1}}],[\"即可\",{\"1\":{\"185\":1,\"896\":1,\"919\":1,\"997\":1,\"1202\":1}}],[\"即可运行\",{\"1\":{\"148\":1}}],[\"即进程获得了除了处理器之外的一切所需资源\",{\"1\":{\"148\":1}}],[\"即进程控制块\",{\"1\":{\"136\":1}}],[\"即为所求\",{\"1\":{\"892\":1}}],[\"即为当前\",{\"1\":{\"131\":1}}],[\"即为对象申请\",{\"1\":{\"89\":1}}],[\"即使对应名称的\",{\"1\":{\"1155\":1}}],[\"即使用\",{\"1\":{\"1140\":1}}],[\"即使窗口为0也可发送紧急数据\",{\"1\":{\"1007\":1}}],[\"即使我们让每台机子选出出现次数最多的1000个再归并\",{\"1\":{\"891\":1}}],[\"即使其中的一些节点出现故障也能够继续工作下去\",{\"1\":{\"873\":1}}],[\"即使其中一台服务器宕机\",{\"1\":{\"661\":1}}],[\"即使面对故障\",{\"1\":{\"873\":1}}],[\"即使无法做到强一致性\",{\"1\":{\"871\":1}}],[\"即使依赖了也不能使用其中的类\",{\"1\":{\"790\":1}}],[\"即使原本锁住某资源的\",{\"1\":{\"672\":1}}],[\"即使多个连接也是单线程写入\",{\"1\":{\"665\":1}}],[\"即使有一部分的server宕机了它们仍然能够继续运行\",{\"1\":{\"873\":1}}],[\"即使有一套服务器出现了故障其他服务器仍然可以继续提供服务\",{\"1\":{\"655\":1}}],[\"即使有备用的节点解决高性能\",{\"1\":{\"674\":1}}],[\"即使有冲突\",{\"1\":{\"452\":1}}],[\"即使是千上万个请求也不在话下\",{\"1\":{\"835\":1}}],[\"即使是有损的\",{\"1\":{\"644\":1}}],[\"即使是有损服务\",{\"1\":{\"644\":1}}],[\"即使是一个集合\",{\"1\":{\"614\":1}}],[\"即使某级缓存过期了\",{\"1\":{\"642\":1}}],[\"即使个别节点\",{\"1\":{\"642\":1}}],[\"即使进程没有调⽤\",{\"1\":{\"613\":1}}],[\"即使在刷脏页时宕机了\",{\"1\":{\"593\":1}}],[\"即使长事务最终提交\",{\"1\":{\"525\":1}}],[\"即使数据库发生故障也不应该对其有任何影响\",{\"1\":{\"519\":1}}],[\"即使操作一条记录也会锁住整个表\",{\"1\":{\"493\":1}}],[\"即使那个外部类不再被使用\",{\"1\":{\"304\":1}}],[\"即使两个类对象是源于同一个class文件\",{\"1\":{\"166\":1}}],[\"即使处理器空闲\",{\"1\":{\"148\":1}}],[\"即使重试失败\",{\"1\":{\"105\":1}}],[\"即使本地任务执行完\",{\"1\":{\"58\":1}}],[\"即冲突真的很少发生的时候\",{\"1\":{\"104\":1}}],[\"即一个主站轮流和链路上的多个从站进行通信\",{\"1\":{\"975\":1}}],[\"即一个消息发送到消息队列\",{\"1\":{\"844\":1}}],[\"即一个发送一个接收\",{\"1\":{\"844\":1}}],[\"即一个区中一共有64个连续的页\",{\"1\":{\"498\":1}}],[\"即一个\",{\"1\":{\"427\":1}}],[\"即一个线程获取到了锁\",{\"1\":{\"81\":1}}],[\"即一个线程如果获取到了锁\",{\"1\":{\"81\":1}}],[\"即一次只有一个进程可以使用\",{\"1\":{\"98\":1}}],[\"即按照\",{\"1\":{\"89\":1}}],[\"即语法仍是\",{\"1\":{\"87\":1}}],[\"即比较内存中的值和期望的值是否相同\",{\"1\":{\"81\":1}}],[\"即比较并交换\",{\"1\":{\"81\":1}}],[\"即变量如何从主内存拷贝到工作内存\",{\"1\":{\"74\":1}}],[\"即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节\",{\"1\":{\"293\":1}}],[\"即关注在\",{\"1\":{\"74\":1}}],[\"即便你只有一台服务器\",{\"1\":{\"671\":1}}],[\"即便\",{\"1\":{\"72\":1}}],[\"即必须在\",{\"1\":{\"35\":1}}],[\"即\",{\"1\":{\"34\":1,\"149\":1,\"156\":1,\"442\":1,\"462\":1,\"484\":1,\"583\":1,\"638\":1,\"748\":1,\"753\":1,\"893\":1,\"1019\":1,\"1033\":1,\"1035\":1,\"1042\":1,\"1245\":1}}],[\"​​\",{\"1\":{\"1126\":1,\"1127\":4}}],[\"​\",{\"1\":{\"34\":1,\"39\":5,\"40\":1,\"41\":1,\"42\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":2,\"47\":1,\"49\":1,\"50\":3,\"59\":2,\"61\":1,\"62\":2,\"65\":2,\"66\":3,\"70\":1,\"73\":2,\"74\":5,\"75\":3,\"76\":5,\"77\":1,\"78\":1,\"81\":1,\"85\":2,\"87\":3,\"88\":2,\"89\":1,\"92\":1,\"93\":1,\"95\":1,\"96\":2,\"98\":5,\"99\":1,\"100\":2,\"101\":4,\"102\":1,\"103\":1,\"104\":2,\"105\":1,\"106\":2,\"109\":1,\"110\":4,\"114\":2,\"115\":2,\"119\":1,\"123\":2,\"125\":2,\"126\":1,\"127\":2,\"129\":4,\"130\":1,\"134\":2,\"135\":1,\"136\":2,\"137\":1,\"138\":2,\"139\":1,\"142\":2,\"144\":2,\"149\":1,\"153\":1,\"154\":1,\"156\":1,\"157\":2,\"158\":1,\"159\":2,\"160\":1,\"166\":1,\"168\":2,\"171\":1,\"172\":1,\"182\":2,\"184\":2,\"185\":1,\"187\":1,\"193\":1,\"195\":1,\"197\":1,\"198\":1,\"200\":1,\"203\":2,\"205\":1,\"207\":1,\"214\":1,\"215\":1,\"216\":2,\"217\":2,\"218\":2,\"219\":1,\"221\":2,\"222\":1,\"223\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"229\":1,\"230\":4,\"231\":1,\"232\":1,\"234\":1,\"240\":2,\"242\":1,\"246\":1,\"247\":1,\"249\":2,\"253\":3,\"273\":1,\"274\":3,\"275\":2,\"277\":2,\"298\":3,\"309\":1,\"336\":1,\"338\":1,\"339\":1,\"341\":2,\"342\":2,\"344\":1,\"345\":3,\"348\":3,\"349\":4,\"351\":3,\"360\":1,\"361\":1,\"362\":1,\"364\":1,\"370\":2,\"374\":1,\"378\":3,\"379\":3,\"380\":3,\"381\":9,\"396\":1,\"397\":1,\"398\":1,\"399\":2,\"400\":2,\"401\":2,\"405\":3,\"406\":2,\"410\":4,\"411\":5,\"412\":4,\"413\":1,\"414\":1,\"427\":3,\"430\":1,\"444\":1,\"447\":1,\"450\":1,\"452\":1,\"456\":2,\"458\":1,\"464\":1,\"466\":2,\"469\":1,\"472\":2,\"473\":2,\"475\":1,\"476\":2,\"478\":2,\"486\":2,\"489\":5,\"490\":3,\"496\":5,\"499\":6,\"501\":6,\"503\":2,\"504\":2,\"505\":3,\"506\":1,\"508\":3,\"509\":3,\"510\":1,\"511\":1,\"512\":1,\"513\":5,\"514\":1,\"516\":1,\"518\":2,\"523\":4,\"525\":2,\"527\":2,\"529\":1,\"536\":3,\"537\":2,\"538\":4,\"539\":5,\"541\":2,\"542\":1,\"543\":1,\"547\":3,\"548\":1,\"549\":2,\"550\":4,\"551\":1,\"555\":2,\"556\":1,\"558\":2,\"561\":1,\"562\":2,\"568\":4,\"569\":1,\"570\":2,\"571\":3,\"574\":6,\"576\":2,\"577\":2,\"578\":2,\"579\":2,\"580\":1,\"582\":2,\"583\":1,\"584\":1,\"585\":8,\"591\":1,\"592\":1,\"593\":2,\"597\":2,\"601\":1,\"603\":1,\"609\":1,\"611\":1,\"612\":1,\"614\":2,\"615\":2,\"618\":2,\"619\":1,\"620\":2,\"622\":3,\"623\":12,\"624\":2,\"625\":2,\"627\":4,\"628\":1,\"629\":1,\"630\":1,\"631\":1,\"635\":1,\"640\":2,\"641\":2,\"642\":1,\"643\":2,\"644\":3,\"645\":3,\"646\":1,\"647\":9,\"649\":4,\"650\":1,\"651\":5,\"654\":1,\"655\":4,\"656\":1,\"657\":6,\"658\":2,\"659\":1,\"664\":1,\"665\":2,\"667\":1,\"668\":4,\"671\":3,\"674\":1,\"676\":1,\"679\":2,\"681\":2,\"682\":1,\"683\":3,\"684\":3,\"712\":3,\"713\":3,\"714\":3,\"715\":3,\"718\":9,\"719\":2,\"723\":1,\"724\":1,\"725\":8,\"726\":3,\"727\":1,\"731\":3,\"735\":1,\"740\":1,\"746\":1,\"747\":1,\"748\":1,\"751\":1,\"752\":1,\"753\":1,\"754\":1,\"761\":1,\"762\":1,\"763\":1,\"764\":1,\"765\":1,\"766\":1,\"771\":1,\"801\":2,\"802\":3,\"805\":3,\"806\":1,\"807\":1,\"809\":2,\"816\":2,\"817\":2,\"818\":2,\"821\":1,\"824\":1,\"829\":3,\"830\":4,\"835\":1,\"837\":1,\"838\":1,\"844\":3,\"848\":1,\"849\":1,\"853\":2,\"854\":2,\"855\":2,\"858\":2,\"859\":2,\"860\":3,\"863\":2,\"864\":1,\"870\":2,\"871\":2,\"872\":1,\"873\":2,\"876\":2,\"877\":5,\"878\":4,\"879\":1,\"880\":8,\"882\":2,\"907\":1,\"919\":3,\"921\":1,\"927\":2,\"935\":1,\"937\":1,\"938\":1,\"940\":1,\"941\":1,\"942\":2,\"959\":1,\"961\":3,\"964\":2,\"969\":1,\"973\":1,\"978\":2,\"982\":1,\"984\":1,\"986\":5,\"987\":2,\"989\":2,\"992\":1,\"998\":1,\"999\":4,\"1002\":3,\"1003\":1,\"1004\":1,\"1006\":4,\"1010\":1,\"1013\":3,\"1015\":2,\"1017\":2,\"1018\":3,\"1019\":5,\"1020\":1,\"1022\":2,\"1023\":1,\"1024\":1,\"1025\":1,\"1027\":1,\"1028\":2,\"1029\":1,\"1032\":3,\"1033\":3,\"1036\":1,\"1042\":8,\"1044\":3,\"1045\":1,\"1046\":1,\"1047\":1,\"1049\":3,\"1051\":2,\"1052\":3,\"1054\":1,\"1056\":3,\"1057\":5,\"1060\":1,\"1067\":1,\"1068\":2,\"1069\":1,\"1070\":1,\"1075\":1,\"1076\":1,\"1077\":2,\"1079\":2,\"1082\":1,\"1087\":3,\"1088\":1,\"1089\":2,\"1090\":4,\"1093\":1,\"1094\":1,\"1095\":1,\"1096\":2,\"1097\":3,\"1098\":2,\"1099\":2,\"1100\":2,\"1101\":2,\"1126\":1}}],[\"更通用\",{\"1\":{\"1259\":1}}],[\"更倾向于\",{\"1\":{\"1259\":1}}],[\"更多\",{\"1\":{\"1139\":1}}],[\"更多内容见markdown\",{\"1\":{\"1134\":1}}],[\"更高的安全性\",{\"1\":{\"996\":1}}],[\"更便于查找路由表\",{\"1\":{\"989\":1}}],[\"更变触发回调直接读取\",{\"1\":{\"829\":1}}],[\"更安全\",{\"1\":{\"652\":1}}],[\"更长的列会消耗更多的内存\",{\"1\":{\"478\":1}}],[\"更改文件属主和属组\",{\"0\":{\"432\":1}}],[\"更改文件属组\",{\"0\":{\"431\":1}}],[\"更好的是\",{\"1\":{\"428\":1}}],[\"更进一步\",{\"1\":{\"380\":1}}],[\"更符合人类的思维方式\",{\"1\":{\"354\":1}}],[\"更复杂\",{\"1\":{\"265\":1}}],[\"更重要的是强调在它进行垃圾收集时\",{\"1\":{\"254\":1}}],[\"更关键的是\",{\"1\":{\"246\":1}}],[\"更及时\",{\"1\":{\"236\":1}}],[\"更有优势\",{\"1\":{\"149\":1}}],[\"更新的时间复杂度为logk\",{\"1\":{\"893\":1}}],[\"更新操作\",{\"1\":{\"807\":1}}],[\"更新请求会陆陆续续\",{\"1\":{\"684\":1}}],[\"更新频率高\",{\"1\":{\"652\":1}}],[\"更新太频繁的字段不适合创建索引\",{\"1\":{\"535\":1}}],[\"更新完成\",{\"1\":{\"489\":1}}],[\"更新语句执行流程\",{\"1\":{\"489\":1}}],[\"更新语句执行流程如下\",{\"1\":{\"489\":1}}],[\"更新内存管理的数据结构\",{\"1\":{\"147\":1}}],[\"更新\",{\"1\":{\"147\":1,\"501\":1,\"752\":1}}],[\"更像是一个阀门\",{\"1\":{\"121\":1}}],[\"更加复杂和强大\",{\"1\":{\"120\":1}}],[\"更灵活\",{\"1\":{\"32\":1}}],[\"更容易与线程池等高级\",{\"1\":{\"32\":1}}],[\"用它可以快速地画出\",{\"1\":{\"1271\":1}}],[\"用例分析法\",{\"1\":{\"1216\":1}}],[\"用例图\",{\"1\":{\"1094\":1,\"1271\":1}}],[\"用自己的私钥生成了数字签名\",{\"1\":{\"1057\":1}}],[\"用大括号\",{\"1\":{\"1035\":1}}],[\"用方括号\",{\"1\":{\"1035\":1}}],[\"用链接\",{\"1\":{\"1034\":1}}],[\"用这样的方法可明显地减少所用的网络带宽\",{\"1\":{\"1017\":1}}],[\"用什么数据类型\",{\"0\":{\"997\":1}}],[\"用各网络的子网掩码与d按位相与\",{\"1\":{\"990\":1}}],[\"用转发器和网桥连接起来的若干个局域网仍为一个网络\",{\"1\":{\"984\":1}}],[\"用网关连接两个不兼容系统需要在高层进行协议的转换\",{\"1\":{\"965\":1}}],[\"用逗号分隔\",{\"1\":{\"955\":1}}],[\"用2个位置表示一个数出现的频率\",{\"1\":{\"900\":1}}],[\"用2bit表示一个数即可\",{\"1\":{\"883\":1}}],[\"用一个int型的数组来存储数据\",{\"1\":{\"903\":1}}],[\"用一个100个元素大小的最小堆即可\",{\"1\":{\"885\":1}}],[\"用一个新的worker代替\",{\"1\":{\"830\":1}}],[\"用到工厂模式的地方都可以考虑用ioc模式\",{\"1\":{\"731\":1}}],[\"用的不多\",{\"1\":{\"1188\":1}}],[\"用的端口也不一样\",{\"1\":{\"1048\":1}}],[\"用的很少\",{\"1\":{\"923\":1}}],[\"用的bind方法\",{\"1\":{\"725\":1}}],[\"用的地方不一样\",{\"1\":{\"481\":1}}],[\"用投票机制完成\",{\"1\":{\"660\":1,\"678\":1}}],[\"用临时文件替换原来的快照文件\",{\"1\":{\"647\":1}}],[\"用之前需要对数组的长度取模运算\",{\"1\":{\"405\":1}}],[\"用在方法声明后面\",{\"1\":{\"386\":1}}],[\"用在方法体内\",{\"1\":{\"386\":1}}],[\"用关键词\",{\"1\":{\"370\":2}}],[\"用面向过程的思想是远远不够的\",{\"1\":{\"354\":1}}],[\"用反射的手段就绕过了正常开发中编译器不允许的操作限制\",{\"1\":{\"345\":1}}],[\"用不到哈希表的话\",{\"1\":{\"342\":1}}],[\"用以避免把整个老年代加进gc\",{\"1\":{\"249\":1}}],[\"用户子域等等\",{\"1\":{\"1221\":1}}],[\"用户可以通过\",{\"1\":{\"1210\":1}}],[\"用户可以在发出一个io请求后立即再发出另一个io请求\",{\"1\":{\"496\":1}}],[\"用户只需要知道具体工厂的名称就可得到所要的产品\",{\"1\":{\"1078\":1}}],[\"用户通过用户名和密码发送请求\",{\"1\":{\"1053\":1}}],[\"用户的请求数据如用户名\",{\"1\":{\"1038\":1}}],[\"用户的主目录\",{\"1\":{\"416\":1}}],[\"用户报数据协议udp只在ip数据报服务之上增加了复用\",{\"1\":{\"1002\":1}}],[\"用户数据报\",{\"1\":{\"994\":1}}],[\"用户数据报协议udp\",{\"1\":{\"961\":1}}],[\"用户根据可靠性和延迟的要求进行权衡\",{\"1\":{\"854\":1}}],[\"用户下单请求发送给消息队列之后立即响应\",{\"1\":{\"840\":1}}],[\"用户查询余额发现多扣钱了\",{\"1\":{\"807\":1}}],[\"用户再次点击按钮\",{\"1\":{\"807\":1}}],[\"用户购买商品后支付\",{\"1\":{\"807\":1}}],[\"用户向服务器发送请求\",{\"1\":{\"755\":1}}],[\"用户直接查询事先被预热的缓存数据\",{\"1\":{\"640\":1}}],[\"用户一个库\",{\"1\":{\"585\":1}}],[\"用户无法手动操作意向锁\",{\"1\":{\"514\":1}}],[\"用户组\",{\"1\":{\"433\":1}}],[\"用户才能使用的系统级别管理命令和程序\",{\"1\":{\"416\":1}}],[\"用户进程触发\",{\"1\":{\"380\":1}}],[\"用户追求程序动态性\",{\"1\":{\"185\":1}}],[\"用户自定义类加载器\",{\"1\":{\"175\":1}}],[\"用户需要定义一个要执行的主类\",{\"1\":{\"174\":1}}],[\"用户线程指不需要内核支持而在用户程序中实现的线程\",{\"1\":{\"143\":1}}],[\"用户线程\",{\"0\":{\"143\":1},\"1\":{\"143\":1}}],[\"用户程序的访问能力有限\",{\"1\":{\"134\":1}}],[\"用户态和内核态是共享这一块内存的\",{\"1\":{\"381\":1}}],[\"用户态和内核态的切换\",{\"1\":{\"134\":1}}],[\"用户态执行陷入指令\",{\"1\":{\"134\":1}}],[\"用户态进程主动切换到内核态的一种方式\",{\"1\":{\"134\":1}}],[\"用户态下的\",{\"1\":{\"134\":1}}],[\"用户态\",{\"1\":{\"134\":4}}],[\"用来进行环回测试的请求报文\",{\"1\":{\"1040\":1}}],[\"用来便于人们使用的机器名字转换成ip地址\",{\"1\":{\"1030\":1}}],[\"用来释放一个连接\",{\"1\":{\"1007\":1}}],[\"用来跟踪一个分组从源点到终点的路径\",{\"1\":{\"994\":1}}],[\"用来测试两台主机之间的连通性\",{\"1\":{\"994\":1}}],[\"用来定义网络设备的位置\",{\"1\":{\"981\":1}}],[\"用来暂存合并后的有序数据\",{\"1\":{\"934\":1}}],[\"用来交换\",{\"1\":{\"930\":1}}],[\"用来优化的标志\",{\"1\":{\"930\":1}}],[\"用来优化轻量级锁的锁重入问题\",{\"0\":{\"88\":1},\"1\":{\"88\":1}}],[\"用来判断多个投票是否在同一轮选举周期中\",{\"1\":{\"820\":1}}],[\"用来简化spring应用的初始搭建以及开发过程\",{\"1\":{\"767\":1}}],[\"用来削减程序间的耦合\",{\"1\":{\"729\":1}}],[\"用来计算节点的排位\",{\"1\":{\"630\":1}}],[\"用来\",{\"1\":{\"623\":1}}],[\"用来平常存储\",{\"1\":{\"623\":1}}],[\"用来分析\",{\"1\":{\"558\":1}}],[\"用来撤销指定commit\",{\"1\":{\"453\":1}}],[\"用来存放最近查询过的域名以及从何处获得域名的记录\",{\"1\":{\"1032\":1}}],[\"用来存放所有的系统管理所需要的配置文件和子目录\",{\"1\":{\"416\":1}}],[\"用来存储元素\",{\"1\":{\"619\":1}}],[\"用来存储键值对数据\",{\"1\":{\"399\":1}}],[\"用来做数组下标访问\",{\"1\":{\"405\":1}}],[\"用来当做参数\",{\"1\":{\"369\":1}}],[\"用来限制注解的使用范围\",{\"1\":{\"338\":1}}],[\"用来避免内存过小造成应用不能正常工作\",{\"1\":{\"297\":1}}],[\"用来描述还有用\",{\"1\":{\"235\":1}}],[\"用来帮助恢复它的上层主调方法的执行状态\",{\"1\":{\"195\":1}}],[\"用来生产一组相同任务的线程\",{\"1\":{\"58\":1}}],[\"用通过final\",{\"1\":{\"81\":1}}],[\"用于控制正则表达式的匹配方式\",{\"1\":{\"1188\":1}}],[\"用于表示一类对象与另一类对象之间的联系\",{\"1\":{\"1097\":1}}],[\"用于表尾向表头遍历\",{\"1\":{\"630\":1}}],[\"用于减少创建对象的数量\",{\"1\":{\"1091\":1}}],[\"用于传输实体主体\",{\"1\":{\"1041\":1}}],[\"用于获取资源\",{\"1\":{\"1041\":1}}],[\"用于代理服务器\",{\"1\":{\"1040\":1}}],[\"用于链表构建\",{\"1\":{\"955\":1}}],[\"用于连续依赖时使用\",{\"1\":{\"797\":1}}],[\"用于test任务时使用\",{\"1\":{\"797\":1}}],[\"用于编译\",{\"1\":{\"797\":1}}],[\"用于释放资源\",{\"1\":{\"759\":1}}],[\"用于加载资源\",{\"1\":{\"759\":1}}],[\"用于执行静态\",{\"1\":{\"745\":1}}],[\"用于协调与连接调用者\",{\"1\":{\"715\":1}}],[\"用于快速开发可维护\",{\"1\":{\"685\":1}}],[\"用于记录两个节点间的距离\",{\"1\":{\"630\":1}}],[\"用于从表头向表尾方向访问节点\",{\"1\":{\"630\":1}}],[\"用于排序\",{\"1\":{\"630\":1}}],[\"用于保存字符串\",{\"1\":{\"624\":1}}],[\"用于数据库的回滚操作以及\",{\"1\":{\"570\":1}}],[\"用于把来自多个\",{\"1\":{\"480\":1}}],[\"用于与其它表的外键关联以及本记录的修改与删除\",{\"1\":{\"464\":1}}],[\"用于和数据库通信的语言\",{\"1\":{\"457\":1}}],[\"用于创建和管理数据库\",{\"1\":{\"457\":1}}],[\"用于磁盘分区\",{\"1\":{\"441\":1}}],[\"用于目录的复制行为\",{\"1\":{\"423\":1}}],[\"用于\",{\"1\":{\"412\":1,\"1269\":1}}],[\"用于标识前置节点和后置节点\",{\"1\":{\"412\":1}}],[\"用于监听多个通道的事件\",{\"1\":{\"377\":1}}],[\"用于开发重复注解\",{\"1\":{\"338\":1}}],[\"用于开发和调试jvm\",{\"1\":{\"316\":1}}],[\"用于指示一个注解将被文档化\",{\"1\":{\"338\":1}}],[\"用于查看jvm上运行的基于java的应用程序的详细信息\",{\"1\":{\"313\":1}}],[\"用于描述栈帧中局部变量表的变量与java源码中定义的变量之间的关系\",{\"1\":{\"292\":1}}],[\"用于描述接口或者类中声明的变量\",{\"1\":{\"289\":1}}],[\"用于描述有层次关系的复合结构的数据\",{\"1\":{\"284\":1}}],[\"用于调用接口方法\",{\"1\":{\"274\":1}}],[\"用于调用所有的虚方法\",{\"1\":{\"274\":1}}],[\"用于调用实例构造器<init>\",{\"1\":{\"274\":1}}],[\"用于调用静态方法\",{\"1\":{\"274\":1}}],[\"用于处理并发阶段结束后仍遗留下来的最后那少量的satb记录\",{\"1\":{\"264\":1}}],[\"用于存放系统非正常关机留下的文件\",{\"1\":{\"416\":1}}],[\"用于存放编译期生成的各种字面量和符号引用\",{\"1\":{\"208\":1}}],[\"用于存放编译期生成的各种字面量与符号引用\",{\"1\":{\"208\":1}}],[\"用于存放方法参数和方法内部定义的局部变量\",{\"1\":{\"192\":1}}],[\"用于存储已被虚拟机加载的类型信息\",{\"1\":{\"203\":1}}],[\"用于多进程对共享数据的访问\",{\"1\":{\"149\":1}}],[\"用于通知\",{\"1\":{\"149\":1}}],[\"用于解决了数据一致性的问题\",{\"1\":{\"578\":1}}],[\"用于解决\",{\"1\":{\"129\":1}}],[\"用于进行线程间的数据交换\",{\"1\":{\"127\":1}}],[\"用于判断共享资源是否被占用的标记位\",{\"1\":{\"110\":1,\"111\":1}}],[\"用于提交需要返回值的任务\",{\"1\":{\"61\":1}}],[\"用于提交不需要返回值的任务\",{\"1\":{\"61\":1}}],[\"用于线程间数据隔离\",{\"1\":{\"40\":1}}],[\"用于线程间的数据共享\",{\"1\":{\"40\":1}}],[\"用调用者所在的线程来执行任务\",{\"1\":{\"60\":1}}],[\"用了\",{\"1\":{\"43\":1}}],[\"用独立的方法实现了\",{\"1\":{\"42\":1}}],[\"用\",{\"1\":{\"32\":2,\"109\":1,\"342\":1,\"391\":2,\"426\":1,\"685\":1,\"781\":1,\"899\":1,\"1033\":1,\"1091\":1,\"1126\":1,\"1201\":1}}],[\"用单连字符\",{\"1\":{\"26\":1}}],[\"但此处\",{\"1\":{\"1221\":1}}],[\"但此时客户端进入time\",{\"1\":{\"1026\":1}}],[\"但此时客户端并没有发出建立连接的请求\",{\"1\":{\"1022\":1}}],[\"但此时服务器\",{\"1\":{\"820\":1}}],[\"但组件接口定义和自己要求的接口定义不同\",{\"1\":{\"1092\":1}}],[\"但办理具体业务因人而异\",{\"1\":{\"1087\":1}}],[\"但某些步骤的具体实现还未知\",{\"1\":{\"1087\":1}}],[\"但两者可以结合使用\",{\"1\":{\"1086\":1}}],[\"但两者都实现了\",{\"1\":{\"407\":1}}],[\"但每一部分是可以灵活选择的\",{\"1\":{\"1086\":1}}],[\"但每次只使用其中的某一族产品\",{\"1\":{\"1079\":1}}],[\"但每个应用都可以根据自身业务特点\",{\"1\":{\"871\":1}}],[\"但每个进程里只有一个主线程\",{\"1\":{\"835\":1}}],[\"但每个任务执行时间较短的情况\",{\"1\":{\"56\":1}}],[\"但又经常用到的对象\",{\"1\":{\"1073\":1}}],[\"但实际上接收的已经是被篡改的数据\",{\"1\":{\"1057\":1}}],[\"但私钥只有自己知道\",{\"1\":{\"1056\":1}}],[\"但私有方法不行\",{\"1\":{\"355\":1}}],[\"但只有dhcp服务器\",{\"1\":{\"1049\":1}}],[\"但b要发送数据\",{\"1\":{\"1026\":1}}],[\"但因连接请求报文丢失而未收到确认\",{\"1\":{\"1023\":1}}],[\"但服务器端却以为新的连接已经建立\",{\"1\":{\"1022\":1}}],[\"但要消耗一个序号\",{\"1\":{\"1022\":1}}],[\"但要注意子类的访问范围必须大于等于父类的访问范围\",{\"1\":{\"359\":1}}],[\"但发送的数据报是40字节长\",{\"1\":{\"1018\":1}}],[\"但尚未被应用程序读取的数据\",{\"1\":{\"1015\":1}}],[\"但tcp传送的数据单元却是报文段\",{\"1\":{\"1007\":1}}],[\"但当发送的数据包过小时\",{\"1\":{\"1006\":1}}],[\"但udp把首部和数据部分一起检验\",{\"1\":{\"1002\":1}}],[\"但仍然可以使用同一个ppp协议进行通信\",{\"1\":{\"975\":1}}],[\"但缺点是具有一定的错误识别率和删除难度\",{\"1\":{\"882\":1}}],[\"但缺点是在调用者与被调用者之间增加了代理对象\",{\"1\":{\"715\":1}}],[\"但问题是\",{\"1\":{\"880\":1}}],[\"但问题是一个\",{\"1\":{\"405\":1}}],[\"但与哈希算法不同的是\",{\"1\":{\"880\":1}}],[\"但maven采用了两种避免冲突的策略\",{\"1\":{\"798\":1}}],[\"但支持你期待jdk或者容器提供\",{\"1\":{\"797\":1}}],[\"但业务量大功能复杂时\",{\"1\":{\"739\":1}}],[\"但一般不会更改\",{\"1\":{\"981\":1}}],[\"但一般不会出现线程安全问题\",{\"1\":{\"735\":1}}],[\"但一条消息只能被一个消费者消费\",{\"1\":{\"844\":1}}],[\"但一个等值查询\",{\"1\":{\"501\":1}}],[\"但关注于控制对象的访问\",{\"1\":{\"716\":1}}],[\"但同样要消耗一个序号\",{\"1\":{\"1022\":1}}],[\"但同样地\",{\"1\":{\"290\":1}}],[\"但同时还要发送确认\",{\"1\":{\"1010\":1}}],[\"但同一时刻只有一个实例对外提供服务\",{\"1\":{\"674\":1}}],[\"但事务不保证原子性\",{\"1\":{\"665\":1}}],[\"但持久化文件也更大\",{\"1\":{\"652\":1}}],[\"但持久化没保证\",{\"1\":{\"650\":1}}],[\"但其接口同新系统的接口不一致\",{\"1\":{\"1092\":1}}],[\"但其实有\",{\"1\":{\"651\":1}}],[\"但其region具有动态性\",{\"1\":{\"268\":1}}],[\"但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去\",{\"1\":{\"1056\":1}}],[\"但对应的\",{\"1\":{\"641\":1}}],[\"但对于\",{\"1\":{\"408\":1,\"624\":1}}],[\"但对于运行时常量池\",{\"1\":{\"208\":1}}],[\"但查询数据时不会用到后退指针\",{\"1\":{\"630\":1}}],[\"但查询速度比较慢\",{\"1\":{\"392\":1}}],[\"但随着用户量增大\",{\"1\":{\"585\":1}}],[\"但之后由于马上要访问这个数据页\",{\"1\":{\"574\":1}}],[\"但累积n个事务后才fsync\",{\"1\":{\"571\":1}}],[\"但没有将表分布到不同机器的库上\",{\"1\":{\"585\":1}}],[\"但没有丢失数据的风险\",{\"1\":{\"563\":1}}],[\"但没有获得锁而进入\",{\"1\":{\"85\":1}}],[\"但还是可以通过抓包获取其它用户的\",{\"1\":{\"1061\":1}}],[\"但还需要回表查询\",{\"1\":{\"556\":1}}],[\"但还没被修改\",{\"1\":{\"72\":1}}],[\"但进行检索时\",{\"1\":{\"533\":1}}],[\"但幻读仍有可能发生\",{\"1\":{\"522\":1,\"741\":1}}],[\"但后者在排序时会消耗更多内存\",{\"1\":{\"478\":1}}],[\"但保持暂存区和工作区不变\",{\"1\":{\"453\":1}}],[\"但工作区不变\",{\"1\":{\"453\":2}}],[\"但依然停留在当前分支\",{\"1\":{\"451\":1}}],[\"但该文件会保留在工作区\",{\"1\":{\"447\":1}}],[\"但限于\",{\"1\":{\"442\":1}}],[\"但指向的是一个无效的链接\",{\"1\":{\"427\":1}}],[\"但允许多个空值\",{\"1\":{\"408\":1}}],[\"但模运算的效率不如位运算\",{\"1\":{\"404\":1}}],[\"但最主要的就是指定初始值大小和负载因子大小\",{\"1\":{\"399\":1}}],[\"但最终的返回结果为\",{\"1\":{\"383\":1}}],[\"但增删慢\",{\"1\":{\"392\":1}}],[\"但运行时出现的错误\",{\"1\":{\"385\":1}}],[\"但本质上都是同步\",{\"1\":{\"381\":1}}],[\"但有两种情况除外\",{\"1\":{\"1015\":1}}],[\"但有一个follower因为某种故障\",{\"1\":{\"853\":1}}],[\"但有一种特殊用法是用\",{\"1\":{\"360\":1}}],[\"但有可能出现原本java代码之中不存在的字段\",{\"1\":{\"289\":1}}],[\"但可能产生丢包\",{\"1\":{\"1001\":1}}],[\"但可以有多个worker\",{\"1\":{\"833\":1}}],[\"但可以对最终的结果集进行排序\",{\"1\":{\"485\":1}}],[\"但可以被继承\",{\"1\":{\"346\":1}}],[\"但可与用户程序并发执行\",{\"1\":{\"264\":1}}],[\"但接口可以多继承\",{\"1\":{\"336\":1}}],[\"但现在的处理器不会声言\",{\"1\":{\"296\":1}}],[\"但并非所有的方法表都必须存在这个属性\",{\"1\":{\"292\":1}}],[\"但并不是每个节点都需要获得同步支持的\",{\"1\":{\"131\":1}}],[\"但返回值不同\",{\"1\":{\"290\":1}}],[\"但在做完\",{\"1\":{\"895\":1}}],[\"但在远程调用过程中\",{\"1\":{\"804\":1}}],[\"但在远程调用中\",{\"1\":{\"804\":1}}],[\"但在t释放a上的s锁之前不能对a做任何修改\",{\"1\":{\"509\":1}}],[\"但在表有读取操作的同时\",{\"1\":{\"492\":1}}],[\"但在管理堆内存方面\",{\"1\":{\"267\":1}}],[\"但在逻辑上它应该被视为连续的\",{\"1\":{\"199\":1}}],[\"但耗时很短\",{\"1\":{\"264\":1}}],[\"但g1的卡表实现更为复杂\",{\"1\":{\"262\":1}}],[\"但它是一种更强烈的聚合关系\",{\"1\":{\"1099\":1}}],[\"但它在很多情况下\",{\"1\":{\"499\":1}}],[\"但它在进行重排序时会考虑指令之间的数据依赖性\",{\"1\":{\"70\":1}}],[\"但它们输出的值有可能不同\",{\"1\":{\"442\":1}}],[\"但它一般有两种使用情况\",{\"1\":{\"340\":1}}],[\"但它的过期时间会很短\",{\"1\":{\"641\":1}}],[\"但它的\",{\"1\":{\"254\":1}}],[\"但直至g1收集器出现之前\",{\"1\":{\"250\":1}}],[\"但非必须的对象\",{\"1\":{\"235\":1}}],[\"但从\",{\"1\":{\"223\":1}}],[\"但字符串常量池\",{\"1\":{\"204\":1}}],[\"但已经逐步\",{\"1\":{\"204\":1}}],[\"但⾃从在\",{\"1\":{\"203\":1}}],[\"但完成一项操作的时候必然需要使用更多的入栈和出栈指令\",{\"1\":{\"193\":1}}],[\"但jndi存在的目的就是对资源进行查找和集中管理\",{\"1\":{\"185\":1}}],[\"但为java应用提供了极高的拓展性和灵活性\",{\"1\":{\"165\":1}}],[\"但局部性访问方面性能差\",{\"1\":{\"163\":1}}],[\"但无法实现\",{\"1\":{\"160\":1}}],[\"但创建了很多线程来处理\",{\"1\":{\"144\":1}}],[\"但凡进程管理所需要的信息\",{\"1\":{\"136\":1}}],[\"但作用都是相同的\",{\"1\":{\"130\":1}}],[\"但也与原本的单例模式初衷违背\",{\"1\":{\"101\":1,\"714\":1}}],[\"但这是指其语法规则是参考javascript对象的\",{\"1\":{\"1035\":1}}],[\"但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性\",{\"1\":{\"1033\":1}}],[\"但这种做法有明显弊端\",{\"1\":{\"679\":1}}],[\"但这种方式需要你事先知道所有可能会用到的锁\",{\"1\":{\"98\":1}}],[\"但这个问题仍然存在\",{\"1\":{\"660\":1}}],[\"但这个增删慢也不是绝对的\",{\"1\":{\"392\":1}}],[\"但这个安全问题不是因为其有序性\",{\"1\":{\"71\":1}}],[\"但却执行了加锁操作\",{\"1\":{\"92\":1}}],[\"但另一个线程中的操作可能与这个线程的操作有数据依赖关系\",{\"1\":{\"76\":1}}],[\"但上一次修改的值还在\",{\"1\":{\"72\":1}}],[\"但如果学校停办了\",{\"1\":{\"1098\":1}}],[\"但如果除去重复后\",{\"1\":{\"890\":1,\"893\":1}}],[\"但如果一旦\",{\"1\":{\"660\":1}}],[\"但如果此时突然在队首添加一个\",{\"1\":{\"628\":1}}],[\"但如果是脏页\",{\"1\":{\"594\":1}}],[\"但如果是多写的情况\",{\"1\":{\"104\":1}}],[\"但如果直接简单这么做\",{\"1\":{\"513\":1}}],[\"但如果大量进程竞争使用磁盘\",{\"1\":{\"163\":1}}],[\"但如果\",{\"1\":{\"72\":1}}],[\"但引入内存缓冲区后\",{\"1\":{\"72\":1}}],[\"但\",{\"1\":{\"64\":1,\"72\":2,\"261\":1,\"383\":1,\"392\":1,\"604\":1,\"660\":1,\"1003\":1}}],[\"但不再回应\",{\"1\":{\"1054\":1}}],[\"但不允许数据有太大时延的应用非常的合适\",{\"1\":{\"1002\":1}}],[\"但不限于\",{\"1\":{\"718\":1}}],[\"但不支持\",{\"1\":{\"551\":1}}],[\"但不使用gaplock\",{\"1\":{\"506\":1}}],[\"但不包括查询语句\",{\"1\":{\"566\":1}}],[\"但不包括对象头\",{\"1\":{\"221\":1}}],[\"但不包括局部变量与方法参数\",{\"1\":{\"74\":1}}],[\"但不会产生内碎片\",{\"1\":{\"155\":1}}],[\"但不会产生外碎片\",{\"1\":{\"155\":1}}],[\"但不会发生全局的样式污染\",{\"1\":{\"24\":1}}],[\"但不能修改\",{\"1\":{\"509\":1}}],[\"但不能解决更新丢失问题\",{\"1\":{\"499\":1}}],[\"但不能通过返回类型是否相同来判断重载\",{\"1\":{\"359\":1}}],[\"但不能\",{\"1\":{\"46\":1}}],[\"但不希望被多线程共享\",{\"1\":{\"39\":1,\"44\":1}}],[\"但监控依然保持\",{\"1\":{\"37\":1}}],[\"但是实体在复杂场景下需要编排领域服务\",{\"1\":{\"1230\":1}}],[\"但是实际开发中会有大量的字符串被创建\",{\"1\":{\"207\":1}}],[\"但是貌似也有例外\",{\"1\":{\"1156\":1}}],[\"但是成员对象可以脱离整体对象而独立存在\",{\"1\":{\"1098\":1}}],[\"但是两个线程都会执行\",{\"1\":{\"1067\":1}}],[\"但是整个继承体系的可复用性会比较差\",{\"1\":{\"1064\":1}}],[\"但是整理会花一定的时间\",{\"1\":{\"246\":1}}],[\"但是伪造的\",{\"1\":{\"1060\":1}}],[\"但是和对称加密比起来\",{\"1\":{\"1056\":1}}],[\"但是和事务恢复以及崩溃恢复不同\",{\"1\":{\"492\":1}}],[\"但是网络上的dhcp服务器太多会造成浪费\",{\"1\":{\"1049\":1}}],[\"但是服务端还是按顺序执行的\",{\"1\":{\"1042\":1}}],[\"但是服务器\",{\"1\":{\"820\":1}}],[\"但是关闭连接时\",{\"1\":{\"1024\":1}}],[\"但是第一个丢失的报文段只是在某些网络结点长时间滞留了\",{\"1\":{\"1023\":1}}],[\"但是丢失了\",{\"1\":{\"1015\":1}}],[\"但是重传时间的选择确实tcp最复杂的问题之一\",{\"1\":{\"1012\":1}}],[\"但是真正实现起来还是非常复杂的\",{\"1\":{\"1004\":1}}],[\"但是出现偶尔断续不是太大问题\",{\"1\":{\"1001\":1}}],[\"但是要求在红黑树中体现为一黑色节点带两红色儿子\",{\"1\":{\"921\":1}}],[\"但是仔细\",{\"1\":{\"902\":1}}],[\"但是数据种类小可以放入内存\",{\"1\":{\"890\":1,\"891\":1}}],[\"但是数据的写入\",{\"1\":{\"522\":1}}],[\"但是内存只有1m做hash有些不够\",{\"1\":{\"889\":1}}],[\"但是内核代码少\",{\"1\":{\"133\":1}}],[\"但是内核代码庞大\",{\"1\":{\"133\":1}}],[\"但是有丢包和乱序\",{\"1\":{\"1006\":1}}],[\"但是有一个很致命的问题\",{\"1\":{\"880\":1}}],[\"但是有三个需要实现的技术重点\",{\"1\":{\"804\":1}}],[\"但是因为sack文档没有指明发送方怎么响应sack\",{\"1\":{\"1013\":1}}],[\"但是因为某些故障\",{\"1\":{\"870\":1}}],[\"但是因为还被持有它的引用而不能被回收\",{\"1\":{\"304\":1}}],[\"但是绝大多数用户都可以通过message\",{\"1\":{\"865\":1}}],[\"但是存在值key\",{\"1\":{\"852\":1}}],[\"但是存在一定的隐患\",{\"1\":{\"643\":1}}],[\"但是worker里的单线程是非阻塞的\",{\"1\":{\"838\":1}}],[\"但是也有个问题\",{\"1\":{\"829\":1}}],[\"但是也可以看做一个整体独立于前两个层进行开发\",{\"1\":{\"766\":1}}],[\"但是事无绝对\",{\"1\":{\"825\":1}}],[\"但是返回结果时网络异常\",{\"1\":{\"807\":1}}],[\"但是springboot中也可以使用xml配置\",{\"1\":{\"787\":1}}],[\"但是semi\",{\"1\":{\"501\":1}}],[\"但是resultmap要更强大一些\",{\"1\":{\"751\":1}}],[\"但是对少量丢包并没有太大要求的场景\",{\"1\":{\"1001\":1}}],[\"但是对象\",{\"1\":{\"749\":1}}],[\"但是对于网络传输过程中产生的丢包\",{\"1\":{\"1001\":1}}],[\"但是对于内存则不一样\",{\"1\":{\"478\":1}}],[\"但是对于class文件格式来讲\",{\"1\":{\"289\":1}}],[\"但是灵活的前提是\",{\"1\":{\"749\":1}}],[\"但是需要更多的关注底层复杂的细节\",{\"1\":{\"805\":1}}],[\"但是需要注意一点\",{\"1\":{\"736\":1}}],[\"但是需要再回到原表去取数据\",{\"1\":{\"484\":1}}],[\"但是applicationcontextaware是子接口\",{\"1\":{\"733\":1}}],[\"但是动态代理的代理类是在程序运行时创建的\",{\"1\":{\"723\":1}}],[\"但是2\",{\"1\":{\"714\":1}}],[\"但是普通哈希的取模算法是对服务器的数量进行取模\",{\"1\":{\"681\":1}}],[\"但是仍然不能解决缓存预热问题\",{\"1\":{\"674\":1}}],[\"但是仍旧需要加gap锁\",{\"1\":{\"501\":1}}],[\"但是从容器中获得的其实已经是代理对象\",{\"1\":{\"728\":1}}],[\"但是从长久来看做这点牺牲是值得的\",{\"1\":{\"671\":1}}],[\"但是从服务器的里面读取\",{\"1\":{\"582\":1}}],[\"但是假如一个线程发送\",{\"1\":{\"665\":1}}],[\"但是落盘的时机已经不在\",{\"1\":{\"650\":1}}],[\"但是保证完全的持久化\",{\"1\":{\"650\":1}}],[\"但是会存在数据不一致的情况\",{\"1\":{\"643\":1}}],[\"但是会占用大量的\",{\"1\":{\"632\":1}}],[\"但是会影响速度\",{\"1\":{\"219\":1}}],[\"但是多个节点保存的分值却可以是相同的\",{\"1\":{\"630\":1}}],[\"但是相比正常的\",{\"1\":{\"622\":1}}],[\"但是缺陷也很明显\",{\"1\":{\"607\":1}}],[\"但是很容易出现问题比如缓存穿透\",{\"1\":{\"607\":1}}],[\"但是很大\",{\"1\":{\"381\":1}}],[\"但是使用内存进行数据存储开销也是比较大的\",{\"1\":{\"606\":1}}],[\"但是查找表的内容不能失效\",{\"1\":{\"603\":1}}],[\"但是主服务器如果不断的有更新操作源源不断的写入\",{\"1\":{\"582\":1}}],[\"但是共用同一份\",{\"1\":{\"571\":1}}],[\"但是持久化到磁盘的速度就慢多了\",{\"1\":{\"568\":1}}],[\"但是没有持久化\",{\"1\":{\"568\":1}}],[\"但是没有竞争\",{\"1\":{\"88\":1}}],[\"但是突然中间\",{\"1\":{\"562\":1}}],[\"但是失去了有序性\",{\"1\":{\"537\":1}}],[\"但是可以通过提取方法的方式完成声明式事务管理的配置\",{\"1\":{\"739\":1}}],[\"但是可以索引下推优化\",{\"1\":{\"533\":1}}],[\"但是可以实现多个接口\",{\"1\":{\"32\":1}}],[\"但是幻读或不可重复读仍有可能发生\",{\"1\":{\"522\":1,\"741\":1}}],[\"但是发生锁冲突的概率很大\",{\"1\":{\"510\":1}}],[\"但是并非唯一索引\",{\"1\":{\"506\":1}}],[\"但是不适用分布式系统\",{\"1\":{\"880\":1}}],[\"但是不如专业的\",{\"1\":{\"825\":1}}],[\"但是不要使用同步\",{\"1\":{\"757\":1}}],[\"但是不满足条件的记录上的加锁\",{\"1\":{\"501\":1}}],[\"但是不支持\",{\"1\":{\"473\":1}}],[\"但是如何执行\",{\"1\":{\"490\":1}}],[\"但是如果在follower同步完成后\",{\"1\":{\"854\":1}}],[\"但是如果发生宕机\",{\"1\":{\"650\":1}}],[\"但是如果\",{\"1\":{\"623\":1}}],[\"但是如果执行时间特别长\",{\"1\":{\"303\":1}}],[\"但是如果操作之间不存在数据依赖关系\",{\"1\":{\"76\":1}}],[\"但是性能低\",{\"1\":{\"477\":1}}],[\"但是比\",{\"1\":{\"428\":1}}],[\"但是队列的效率不如arrayqueue高\",{\"1\":{\"394\":1}}],[\"但是栈的效率不如linkedlist高\",{\"1\":{\"394\":1}}],[\"但是还是返回\",{\"1\":{\"383\":1}}],[\"但是还是保留了分代的概念\",{\"1\":{\"261\":1}}],[\"但是这台机器挂了就没办法了\",{\"1\":{\"1052\":1}}],[\"但是这不是标准字段\",{\"1\":{\"1042\":1}}],[\"但是这样容易造成consumer来不及处理消息\",{\"1\":{\"858\":1}}],[\"但是这种方法能够较好地降低后端存储负载\",{\"1\":{\"643\":1}}],[\"但是这个子域中只有一个实体\",{\"1\":{\"1240\":1}}],[\"但是这个时候\",{\"1\":{\"578\":1}}],[\"但是这个对象内部的属性是可以变化的\",{\"1\":{\"371\":1}}],[\"但是这部分内存也被频繁使用\",{\"1\":{\"209\":1}}],[\"但是父类中的私有属性和方法子类是无法访问\",{\"1\":{\"355\":1}}],[\"但是当系统引入了\",{\"1\":{\"718\":1}}],[\"但是当数据量起来之后\",{\"1\":{\"645\":1}}],[\"但是当问题的规模变得更大时\",{\"1\":{\"354\":1}}],[\"但是当前线程是持有锁线程\",{\"1\":{\"96\":1}}],[\"但是我们知道\",{\"1\":{\"1013\":1}}],[\"但是我们可以利用ip协议使这个网络在网络层看起来好像是一个统一的网络\",{\"1\":{\"965\":1}}],[\"但是我们都知道\",{\"1\":{\"725\":1}}],[\"但是我们最好为每个表设置一个主键\",{\"1\":{\"464\":1}}],[\"但是我们用的最多的就是\",{\"1\":{\"349\":1}}],[\"但是我不那么认为它们之间的区别仅仅就是这么简单的一点\",{\"1\":{\"121\":1}}],[\"但是指向的对象可以改变\",{\"1\":{\"346\":1}}],[\"但是效率不理想\",{\"1\":{\"343\":1}}],[\"但是由于它特殊的操作顺序性规定\",{\"1\":{\"337\":1}}],[\"但是msg的生命周期与对象的生命周期相同\",{\"1\":{\"304\":1}}],[\"但是一直不能被回收\",{\"1\":{\"304\":1}}],[\"但是gc又不能回收的情况\",{\"1\":{\"302\":1}}],[\"但是java里面的运算操作符并非原子操作\",{\"1\":{\"296\":1}}],[\"但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作\",{\"1\":{\"295\":1}}],[\"但是反过来说\",{\"1\":{\"284\":1}}],[\"但是最差的情况要好很多\",{\"1\":{\"261\":1}}],[\"但是目前主流的虚拟机中并没有选择这个算法来管理内存\",{\"1\":{\"233\":1}}],[\"但是超大对象直接放old区\",{\"1\":{\"199\":1}}],[\"但是面向对象的引入使得对待问题的思考方式发生了改变\",{\"1\":{\"198\":1}}],[\"但是体积可能会相对大一些\",{\"1\":{\"161\":1}}],[\"但是该进程却使用不到的内存空间\",{\"1\":{\"154\":1}}],[\"但是高频率的进程上下文切换增加开销\",{\"1\":{\"150\":1}}],[\"但是进程切换是不同的\",{\"1\":{\"145\":1}}],[\"但是它被分到了10台机子\",{\"1\":{\"891\":1}}],[\"但是它没有最大连接数的限制\",{\"1\":{\"381\":1}}],[\"但是它却有一个别名叫作\",{\"1\":{\"203\":1}}],[\"但是它不是普通的文件\",{\"1\":{\"149\":1}}],[\"但是它并不需要将数据读取到操作系统的内核缓冲区\",{\"1\":{\"138\":1}}],[\"但是它的功能比\",{\"1\":{\"120\":1}}],[\"但是它的监控状态依然保持着\",{\"1\":{\"35\":1}}],[\"但是其他代码在使用时不会有问题\",{\"1\":{\"718\":1}}],[\"但是其中的value与next变量由volatile修饰\",{\"1\":{\"129\":1}}],[\"但是其它线程已经占用了该\",{\"1\":{\"38\":1}}],[\"但是公平锁会判断等待队列是否有线程处于等待状态\",{\"1\":{\"114\":1}}],[\"但是按照不同的顺序加锁\",{\"1\":{\"98\":1}}],[\"但是在现实生活中许多工厂是综合型的工厂\",{\"1\":{\"1079\":1}}],[\"但是在服务器发完一个对象后\",{\"1\":{\"1042\":1}}],[\"但是在查找路由表时可能会得到不止一个匹配结果\",{\"1\":{\"991\":1}}],[\"但是在这种模式下主从和哨兵存在难以扩容以及单机存储\",{\"1\":{\"678\":1}}],[\"但是在这种模式下每台\",{\"1\":{\"659\":1}}],[\"但是在效率方面\",{\"1\":{\"513\":1}}],[\"但是在数据库或者主机崩溃时会造成索引损坏\",{\"1\":{\"492\":1}}],[\"但是在\",{\"1\":{\"350\":1}}],[\"但是在广义上讲\",{\"1\":{\"302\":1}}],[\"但是在class文件格式之中\",{\"1\":{\"290\":1}}],[\"但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担\",{\"1\":{\"251\":1}}],[\"但是在更新的时候会判断一下在此期间别人有没有去更新这个数据\",{\"1\":{\"103\":1}}],[\"但是在调用lock\",{\"1\":{\"96\":1}}],[\"但是在操作系统层面\",{\"1\":{\"38\":1}}],[\"但是加锁的时间是错开的\",{\"1\":{\"87\":1}}],[\"但是创建的细节未知\",{\"1\":{\"56\":1}}],[\"但是\",{\"1\":{\"40\":1,\"71\":1,\"72\":1,\"88\":1,\"101\":1,\"128\":1,\"199\":1,\"350\":1,\"427\":1,\"501\":1,\"571\":1,\"577\":1,\"578\":1,\"607\":1,\"610\":2,\"637\":1,\"645\":1,\"679\":1,\"720\":2,\"751\":1,\"860\":1,\"870\":1,\"872\":1,\"919\":1,\"1006\":1,\"1041\":2,\"1042\":2}}],[\"因而要结合在一起开发\",{\"1\":{\"766\":1}}],[\"因而对系统内存的使用频率也会降低\",{\"1\":{\"713\":1}}],[\"因而它是目前被公认的一种较好的进程调度算法\",{\"1\":{\"150\":1}}],[\"因业务而异\",{\"1\":{\"478\":1}}],[\"因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录\",{\"1\":{\"259\":1}}],[\"因时间片用完而被暂停执行\",{\"1\":{\"148\":1}}],[\"因此单例类也不会被回收\",{\"1\":{\"1075\":1}}],[\"因此现在是每个网络至少有一个dhcp中继代理\",{\"1\":{\"1049\":1}}],[\"因此状态也就发生了改变\",{\"1\":{\"1041\":1}}],[\"因此为了保证数据的正确性\",{\"1\":{\"1033\":1}}],[\"因此大多数的实现还是重传所有未被确认的数据块\",{\"1\":{\"1013\":1}}],[\"因此大小是已知的\",{\"1\":{\"542\":1}}],[\"因此每访问一次对象\",{\"1\":{\"1042\":1}}],[\"因此每发送完一个分组需要设置一个超时计时器\",{\"1\":{\"1011\":1}}],[\"因此每条记录\",{\"1\":{\"501\":1}}],[\"因此应用层必须选择合适大小的报文\",{\"1\":{\"1002\":1}}],[\"因此主机不需要维持复杂的连接状态\",{\"1\":{\"1002\":1}}],[\"因此其传输是不可靠的\",{\"1\":{\"992\":1}}],[\"因此ip地址又回到了两级编址\",{\"1\":{\"991\":1}}],[\"因此要在排序过程中设置一个标志\",{\"1\":{\"930\":1}}],[\"因此反应在红黑树中就是黑色完美平衡\",{\"1\":{\"921\":1}}],[\"因此我们只需要调整\",{\"1\":{\"919\":1}}],[\"因此我们程序要保证⼀次性将内核缓冲区的数据读取完\",{\"1\":{\"613\":1}}],[\"因此无法将\",{\"1\":{\"919\":1}}],[\"因此无法直接引用\",{\"1\":{\"790\":1}}],[\"因此整个集群可以适应适合的数据\",{\"1\":{\"852\":1}}],[\"因此数据链路层的ppp协议不需要进行纠错\",{\"1\":{\"975\":1}}],[\"因此数据\",{\"1\":{\"820\":1}}],[\"因此服务器\",{\"1\":{\"820\":1}}],[\"因此删除操作也是具有幂等性的\",{\"1\":{\"807\":1}}],[\"因此即使这些\",{\"1\":{\"735\":1}}],[\"因此使用ioc要看有没有必要\",{\"1\":{\"731\":1}}],[\"因此使用代理模式时\",{\"1\":{\"716\":1}}],[\"因此存储上限低\",{\"1\":{\"627\":1}}],[\"因此对字典的查找操作也需要到对应的\",{\"1\":{\"623\":1}}],[\"因此对于一个长时间运行的库来说\",{\"1\":{\"594\":1}}],[\"因此对于减轻mysql数据库的压力来说\",{\"1\":{\"585\":1}}],[\"因此对于写多读少的业务来说\",{\"1\":{\"574\":1}}],[\"因此必须对哈希表中的每一个\",{\"1\":{\"623\":1}}],[\"因此还必须记录每条语句在执行的时候的一些相关信息\",{\"1\":{\"572\":1}}],[\"因此可能会增加语句的响应时间\",{\"1\":{\"563\":1}}],[\"因此可以获得比其他并发控制方法更高的吞吐量\",{\"1\":{\"513\":1}}],[\"因此可以有多个线程同时对一张表增删改查\",{\"1\":{\"511\":1}}],[\"因此可以放心地进行缓存\",{\"1\":{\"369\":1}}],[\"因此可以采用消息进行线程间通信\",{\"1\":{\"141\":1}}],[\"因此可以减少加锁带来的性能损耗\",{\"1\":{\"93\":1}}],[\"因此如果业务可以接受\",{\"1\":{\"555\":1}}],[\"因此用页的大小除每个节点的大小\",{\"1\":{\"542\":1}}],[\"因此尽可能直接做下去\",{\"1\":{\"513\":1}}],[\"因此不是根本的解决办法\",{\"1\":{\"1042\":1}}],[\"因此不能一起发送\",{\"1\":{\"1024\":1}}],[\"因此不能将数据随便均分到不同机子上\",{\"1\":{\"891\":1}}],[\"因此不断有人尝试简化这一算法\",{\"1\":{\"872\":1}}],[\"因此不适用于数据可靠性要求高的业务\",{\"1\":{\"674\":1}}],[\"因此不论这个事务多大\",{\"1\":{\"571\":1}}],[\"因此不会被优先选择\",{\"1\":{\"484\":1}}],[\"因此不一定会很快发现那些只具有弱引用的对象\",{\"1\":{\"235\":1}}],[\"因此一个大小是\",{\"1\":{\"442\":1}}],[\"因此读线程不会存在等待的情况\",{\"1\":{\"411\":1}}],[\"因此它会忽略服务器端发来的确认\",{\"1\":{\"1022\":1}}],[\"因此它们被设计成单例的\",{\"1\":{\"735\":1}}],[\"因此它们都适合在类加载阶段进行解析\",{\"1\":{\"274\":1}}],[\"因此它可以使用\",{\"1\":{\"408\":1}}],[\"因此它的访问速度比\",{\"1\":{\"393\":1}}],[\"因此阻塞\",{\"1\":{\"380\":1}}],[\"因此是\",{\"1\":{\"380\":1}}],[\"因此当dns客户向某个根域名服务器的ip地址查询报文时\",{\"1\":{\"1030\":1}}],[\"因此当平台发生改变的时候\",{\"1\":{\"348\":1}}],[\"因此当需要强可见性和有序性时\",{\"1\":{\"72\":1}}],[\"因此选择了sayhello\",{\"1\":{\"277\":1}}],[\"因此也有些资料将其归为\",{\"1\":{\"277\":1}}],[\"因此g1收集器要比其他的传统垃圾收集器有着更高的内存占用负担\",{\"1\":{\"265\":1}}],[\"因此这类开销积少成多也是一项极为可观的执行成本\",{\"1\":{\"230\":1}}],[\"因此这种同步也被称为阻塞同步\",{\"1\":{\"142\":1}}],[\"因此会限制住栈存储内容的能力\",{\"1\":{\"198\":1}}],[\"因此会给低优先级的线程以运行的机会\",{\"1\":{\"35\":1}}],[\"因此频繁地执行内存读\",{\"1\":{\"193\":1}}],[\"因此所有的加载请求最终都应该传送到最顶层的启动类加载器中\",{\"1\":{\"184\":1}}],[\"因此在maven中是不存在依赖冲突的\",{\"1\":{\"798\":1}}],[\"因此在插入删除操作之后\",{\"1\":{\"538\":1}}],[\"因此在建表的时候需要考察你的表是否有可能达到这个上限\",{\"1\":{\"468\":1}}],[\"因此在扩容时不需要取余\",{\"1\":{\"406\":1}}],[\"因此在使用普通的\",{\"1\":{\"391\":1}}],[\"因此在synchronized块之间的操作也具备原子性\",{\"1\":{\"295\":1}}],[\"因此在并发环境下从堆区中划分空间是线程不安全的\",{\"1\":{\"219\":1}}],[\"因此在java虚拟机中第一个被执行的<clinit>\",{\"1\":{\"173\":1}}],[\"因此在共享式获取锁的自旋过程中\",{\"1\":{\"123\":1}}],[\"因此\",{\"1\":{\"159\":1,\"198\":1,\"218\":1,\"227\":1,\"261\":1,\"348\":1,\"377\":1,\"413\":1,\"473\":1,\"494\":1,\"511\":2,\"526\":1,\"535\":1,\"624\":1,\"628\":1,\"647\":1,\"725\":1,\"849\":1,\"980\":1,\"1042\":1,\"1060\":1,\"1075\":1}}],[\"因此段对用户是可见的\",{\"1\":{\"155\":1}}],[\"因此全局变量最好声明为\",{\"1\":{\"141\":1}}],[\"因此先尝试两次通过不加锁的方式统计结果\",{\"1\":{\"129\":1}}],[\"因此线程不会出现阻塞停顿状态\",{\"1\":{\"105\":1}}],[\"因此需要想办法减少系统中类的个数\",{\"1\":{\"1083\":1}}],[\"因此需要遍历两次\",{\"1\":{\"927\":1}}],[\"因此需要决定electiontimeout的时间\",{\"1\":{\"879\":1}}],[\"因此需要客户端把参数转换成字节流\",{\"1\":{\"804\":1}}],[\"因此需要volatile来避免指令重排序\",{\"1\":{\"714\":1}}],[\"因此需要从\",{\"1\":{\"559\":1}}],[\"因此需要\",{\"1\":{\"101\":1}}],[\"因此需要等待前驱线程获取并释放锁后才能获取锁\",{\"1\":{\"96\":1}}],[\"因此有了偏向锁\",{\"1\":{\"88\":1}}],[\"因此由其重排序可能会改变数据结果\",{\"1\":{\"76\":1}}],[\"因此出现了安全问题\",{\"1\":{\"71\":1}}],[\"因此继承了\",{\"1\":{\"32\":1}}],[\"因为清华镜像源地址有更新\",{\"1\":{\"1184\":1}}],[\"因为即使修改了也会马上被计算覆盖\",{\"1\":{\"1156\":1}}],[\"因为即使你把所有的行都加上record\",{\"1\":{\"504\":1}}],[\"因为科学上网等原因\",{\"1\":{\"1124\":1}}],[\"因为枚举类型是线程安全的\",{\"1\":{\"1070\":1}}],[\"因为当server端收到client端的syn连接请求报文后\",{\"1\":{\"1024\":1}}],[\"因为现在还不知道网络的负载情况\",{\"1\":{\"1019\":1}}],[\"因为tcp层是不知道ip层进行分片的细节的\",{\"1\":{\"982\":1}}],[\"因为上图的复杂过程对用户屏蔽\",{\"1\":{\"963\":1}}],[\"因为基础排序不在乎稳定性\",{\"1\":{\"938\":1}}],[\"因为stack2得继续放入右\",{\"1\":{\"908\":1}}],[\"因为2^32为40亿多\",{\"1\":{\"901\":1}}],[\"因为可能存在大量个数为1001个的发生聚集\",{\"1\":{\"891\":1}}],[\"因为可能已经获取了小于\",{\"1\":{\"672\":1}}],[\"因为比如出现次数最多的第100个可能有1万个\",{\"1\":{\"891\":1}}],[\"因为元素范围很大\",{\"1\":{\"886\":1}}],[\"因为不同的字符串可能哈希出来的位置相同\",{\"1\":{\"882\":1}}],[\"因为不会有排序的效果\",{\"1\":{\"485\":1}}],[\"因为分布式系统意味着数据水平切分到了不同的节点上\",{\"1\":{\"880\":1}}],[\"因为好的随机数本身就很均衡\",{\"1\":{\"869\":1}}],[\"因为同一个key的message可以保证只发送到同一个partition\",{\"1\":{\"865\":1}}],[\"因为消费者类似监听状态获取数据消费的\",{\"1\":{\"858\":1}}],[\"因为消息会发送到不一样的分区\",{\"1\":{\"865\":1}}],[\"因为消息发送率是由broker决定的\",{\"1\":{\"858\":1}}],[\"因为消息队列中进来的任务数量不确定\",{\"1\":{\"374\":1}}],[\"因为订单系统已经完成它的工作\",{\"1\":{\"840\":1}}],[\"因为master不能挂\",{\"1\":{\"837\":1}}],[\"因为merge的时候是真正进行数据更新的时刻\",{\"1\":{\"574\":1}}],[\"因为nginx服务器是一个高性能的http\",{\"1\":{\"826\":1}}],[\"因为对于目标服务器而言所有请求都是从正向代理服务器发出的\",{\"1\":{\"826\":1}}],[\"因为对应该目录的索引节点有一个以上的连接\",{\"1\":{\"427\":1}}],[\"因为两个进程的地址空间完全不同\",{\"1\":{\"804\":1}}],[\"因为两个是不同的文件\",{\"1\":{\"427\":1}}],[\"因为调用者本地会缓存注册中心获取的服务列表\",{\"1\":{\"803\":1}}],[\"因为调用它的\",{\"1\":{\"349\":1}}],[\"因为既要调用dao层的接口又要提供接口给controller层\",{\"1\":{\"763\":1}}],[\"因为resultmap要配置一下\",{\"1\":{\"751\":1}}],[\"因为ca是工信机构会内置到浏览器或者操作系统中\",{\"1\":{\"1044\":1}}],[\"因为cglib动态代理是使用继承被代理类的方式进行扩展\",{\"1\":{\"727\":1}}],[\"因为cls相当于真实对象的类\",{\"1\":{\"726\":1}}],[\"因为commit可以一次提交很多文件\",{\"1\":{\"447\":1}}],[\"因为熟悉业务\",{\"1\":{\"690\":1}}],[\"因为数据同步传送的数据量比一个请求和应答的数据量要多\",{\"1\":{\"1033\":1}}],[\"因为数据中数据已经存在了\",{\"1\":{\"668\":1}}],[\"因为数据的\",{\"1\":{\"668\":1}}],[\"因为集群的\",{\"1\":{\"659\":1}}],[\"因为只要\",{\"1\":{\"656\":1}}],[\"因为只提供了缓存的功能\",{\"1\":{\"607\":1}}],[\"因为要恢复数据库的状态\",{\"1\":{\"651\":1}}],[\"因为跳表是从上层往下层查找的\",{\"1\":{\"630\":1}}],[\"因为通过结构体中的\",{\"1\":{\"624\":1}}],[\"因为减少\",{\"1\":{\"613\":1}}],[\"因为本地缓存只在当前机器上有\",{\"1\":{\"609\":1}}],[\"因为是左\",{\"1\":{\"908\":2}}],[\"因为是从硬盘上读取的\",{\"1\":{\"606\":1}}],[\"因为是静态的\",{\"1\":{\"227\":1}}],[\"因为缓存不作为可靠的数据来源\",{\"1\":{\"603\":1}}],[\"因为占位符进行替换变量后会加上单引号\",{\"1\":{\"596\":1}}],[\"因为所有的\",{\"1\":{\"582\":1}}],[\"因为最开始\",{\"1\":{\"577\":1}}],[\"因为最终释放掉了\",{\"1\":{\"303\":1}}],[\"因为回表是因为在聚簇索引的叶子节点里才有数据\",{\"1\":{\"550\":1}}],[\"因为我们建立的是联\",{\"1\":{\"550\":1}}],[\"因为局部预读性原理告诉我们\",{\"1\":{\"543\":1}}],[\"因为局部变量的生命周期很短\",{\"1\":{\"198\":1}}],[\"因为索引文件比数据文件小很多\",{\"1\":{\"556\":1}}],[\"因为索引是以b+树节点的形式存储在硬盘的每个页中的\",{\"1\":{\"542\":1}}],[\"因为索引使用了b+树数据结构来存储\",{\"1\":{\"529\":1}}],[\"因为一个数据可能被均分到不同的机子上\",{\"1\":{\"891\":1}}],[\"因为一致性\",{\"1\":{\"681\":1}}],[\"因为一次io只能访问一个数据块\",{\"1\":{\"541\":1}}],[\"因为一些原因导致对象的生命周期变得很长甚至导致oom\",{\"1\":{\"302\":1}}],[\"因为undo\",{\"1\":{\"519\":1}}],[\"因为其唯一\",{\"1\":{\"501\":1}}],[\"因为gap锁的目的是防止同一事物两次当前读出现幻读\",{\"1\":{\"501\":1}}],[\"因为查询缓存失效在实际业务场景中可能会非常频繁\",{\"1\":{\"490\":1}}],[\"因为涉及到文件排序或者基于磁盘的临时表时\",{\"1\":{\"478\":1}}],[\"因为默认仅统计目录底下的文件量而已\",{\"1\":{\"441\":1}}],[\"因为使用\",{\"1\":{\"405\":1}}],[\"因为key\",{\"1\":{\"405\":1}}],[\"因为迭代器强制将\",{\"1\":{\"391\":1}}],[\"因为他们都需要在读写事件就绪后自己负责进行读写\",{\"1\":{\"381\":1}}],[\"因为被\",{\"1\":{\"370\":1}}],[\"因为静态方法必须实现\",{\"1\":{\"362\":1}}],[\"因为方法重写是基于运行时动态绑定的\",{\"1\":{\"358\":1}}],[\"因为子类会调用\",{\"1\":{\"355\":1}}],[\"因为如果在ip层进行分片了话\",{\"1\":{\"982\":1}}],[\"因为如果用\",{\"1\":{\"641\":1}}],[\"因为如果\",{\"1\":{\"355\":1}}],[\"因为如果可以的化\",{\"1\":{\"88\":1}}],[\"因为栈空间存的是基本数据类型的值\",{\"1\":{\"351\":1}}],[\"因为无法确定该方法什么时候被调用\",{\"1\":{\"350\":1}}],[\"因为会发生散列冲突\",{\"1\":{\"341\":1}}],[\"因为在网络编程中\",{\"1\":{\"982\":1}}],[\"因为在\",{\"1\":{\"735\":1}}],[\"因为在一个索引页中\",{\"1\":{\"496\":1}}],[\"因为在哈希\",{\"1\":{\"341\":1}}],[\"因为在单个线程中两个操作没有依赖性\",{\"1\":{\"76\":1}}],[\"因为单例的静态性\",{\"1\":{\"304\":1}}],[\"因为模块描述文件\",{\"1\":{\"292\":1}}],[\"因为避免了在java堆和native堆中来回复制数据\",{\"1\":{\"209\":1}}],[\"因为永久代的回收效率很低\",{\"1\":{\"207\":1}}],[\"因为线程同步的代价很高\",{\"1\":{\"202\":1}}],[\"因为该方法需要得到一个classloader对象\",{\"1\":{\"183\":1}}],[\"因为final在编译阶段就会分配了\",{\"1\":{\"171\":1}}],[\"因为进程是直接对内存进行存取\",{\"1\":{\"149\":1}}],[\"因为进程切换要切换页目录以使用新的地址空间\",{\"1\":{\"28\":1,\"139\":1}}],[\"因为以下一些原因导致\",{\"1\":{\"144\":1}}],[\"因为释放同步状态的操作会同时来自多个线程\",{\"1\":{\"123\":1}}],[\"因为它是把数据存到内存中\",{\"1\":{\"494\":1}}],[\"因为它比\",{\"1\":{\"475\":1}}],[\"因为它们一开始要证书验证和协商密钥\",{\"1\":{\"1044\":1}}],[\"因为它们是从\",{\"1\":{\"840\":1}}],[\"因为它们是线程私有的\",{\"1\":{\"74\":1}}],[\"因为它们都有\",{\"1\":{\"125\":1}}],[\"因为它的吞吐量比较大\",{\"1\":{\"114\":1}}],[\"因为每次扩容都是翻倍\",{\"1\":{\"406\":1}}],[\"因为每次\",{\"1\":{\"105\":1}}],[\"因为持有锁的线程只有一个\",{\"1\":{\"96\":1}}],[\"因为那是轻量级锁的解锁方式\",{\"1\":{\"89\":1}}],[\"因为前面发的fin报文消耗了一个序号\",{\"1\":{\"1026\":1}}],[\"因为前面并没有筛选出goods\",{\"1\":{\"481\":1}}],[\"因为前\",{\"1\":{\"88\":1}}],[\"因为wait\",{\"1\":{\"88\":1}}],[\"因为这些局域网都具有同样的网络号\",{\"1\":{\"984\":1}}],[\"因为这些方法在操作同步线程时\",{\"1\":{\"36\":1}}],[\"因为这几个层次画在一起很像一个栈结构\",{\"1\":{\"963\":1}}],[\"因为这类软件需求变化频繁\",{\"1\":{\"749\":1}}],[\"因为这段时间内假设它的值先改为\",{\"1\":{\"106\":1}}],[\"因为这种重排序会改变执行结果\",{\"1\":{\"76\":1}}],[\"因为溢出会走拒绝策略\",{\"1\":{\"64\":1}}],[\"因为\",{\"1\":{\"32\":1,\"36\":1,\"39\":1,\"44\":1,\"104\":1,\"115\":1,\"173\":1,\"227\":1,\"358\":1,\"364\":1,\"393\":2,\"408\":1,\"411\":1,\"537\":1,\"559\":1,\"604\":1,\"630\":1,\"725\":1,\"746\":1,\"803\":1,\"819\":1,\"1041\":1,\"1197\":1}}],[\"不就是\",{\"1\":{\"1247\":1}}],[\"不做持久化动作\",{\"1\":{\"1242\":1}}],[\"不涉及过长的数据库事务\",{\"1\":{\"1230\":1}}],[\"不详\",{\"1\":{\"1206\":1}}],[\"不上去的问题\",{\"0\":{\"1201\":1,\"1202\":1}}],[\"不知道是干嘛的\",{\"1\":{\"1170\":1}}],[\"不然代码很多\",{\"1\":{\"1163\":1}}],[\"不然就按照链表的方式遍历匹配返回值\",{\"1\":{\"398\":1}}],[\"不好用\",{\"1\":{\"1150\":1}}],[\"不足\",{\"1\":{\"1077\":1}}],[\"不停监视系统的半连接和不活动连接\",{\"1\":{\"1060\":1}}],[\"不停创建对象\",{\"1\":{\"297\":1}}],[\"不握第三次手\",{\"1\":{\"1054\":1}}],[\"不受浏览器和操作系统信任\",{\"1\":{\"1045\":1}}],[\"不受jvm内存回收管理\",{\"1\":{\"209\":1}}],[\"不采用三次握手\",{\"1\":{\"1023\":1}}],[\"不完整的包是不会有的\",{\"1\":{\"1006\":1}}],[\"不完整就回滚事务\",{\"1\":{\"578\":1}}],[\"不合并\",{\"1\":{\"1001\":1}}],[\"不拆分\",{\"1\":{\"1001\":1}}],[\"不便于阅读\",{\"1\":{\"997\":1}}],[\"不发送icmp差错报告报文\",{\"1\":{\"993\":2}}],[\"不应发送icmp差错报告报文的情况\",{\"1\":{\"993\":1}}],[\"不匹配\",{\"1\":{\"990\":1}}],[\"不太行\",{\"1\":{\"927\":1}}],[\"不对应的小文件不可能有相同的\",{\"1\":{\"896\":1}}],[\"不对键进行排序\",{\"1\":{\"408\":1}}],[\"不如完全统计后在求前n大效率高\",{\"1\":{\"891\":1}}],[\"不超过3百万个\",{\"1\":{\"890\":1,\"893\":1}}],[\"不重复或重复的数字\",{\"1\":{\"886\":1}}],[\"不适合机器配置不同的场景\",{\"1\":{\"869\":1}}],[\"不适合服务器配置不同的情况\",{\"1\":{\"869\":1}}],[\"不适合高并发操作\",{\"1\":{\"493\":1}}],[\"不至于把自己弄跨\",{\"1\":{\"843\":1}}],[\"不至于将所有压力都在同一时间集中到后端服务器上\",{\"1\":{\"587\":1,\"681\":1}}],[\"不参与投票\",{\"1\":{\"820\":1}}],[\"不依赖\",{\"1\":{\"759\":1}}],[\"不必把原程序停止\",{\"1\":{\"731\":1}}],[\"不必须要的流量占用了大量的网络资源\",{\"1\":{\"660\":1}}],[\"不断发送一系列的syn请求到目标系统\",{\"1\":{\"1054\":1}}],[\"不断向\",{\"1\":{\"677\":1}}],[\"不断检查\",{\"1\":{\"677\":1}}],[\"不保证传输数据的有序性\",{\"1\":{\"1001\":1}}],[\"不保证每次请求的可用性比如在\",{\"1\":{\"870\":1}}],[\"不保证\",{\"1\":{\"735\":1}}],[\"不保证数据的强一致性\",{\"1\":{\"678\":1}}],[\"不保证数据的可靠性\",{\"1\":{\"674\":1}}],[\"不保证原子性\",{\"1\":{\"337\":1}}],[\"不提供请求\",{\"1\":{\"678\":1}}],[\"不提供数据持久化和备份策略\",{\"1\":{\"674\":1}}],[\"不提供指针来直接访问内存\",{\"1\":{\"336\":1}}],[\"不具备自动容错和恢复功能\",{\"1\":{\"656\":1}}],[\"不想再从其他地方获取\",{\"1\":{\"653\":1}}],[\"不去数据库查询\",{\"1\":{\"644\":1}}],[\"不包含指向的内存空间\",{\"1\":{\"631\":1}}],[\"不包括记录本身\",{\"1\":{\"504\":1}}],[\"不包括启动类加载器\",{\"1\":{\"182\":1}}],[\"不包括实例变量\",{\"1\":{\"171\":1}}],[\"不使用确认和重传机制\",{\"1\":{\"974\":1}}],[\"不使用这样一些结构呢\",{\"1\":{\"630\":1}}],[\"不使用表连接或子查询\",{\"1\":{\"556\":1}}],[\"不宜使用数组来实现\",{\"1\":{\"630\":1}}],[\"不宜过小\",{\"1\":{\"64\":1}}],[\"不咋重要\",{\"1\":{\"622\":1}}],[\"不论是脏页还是干净页\",{\"1\":{\"592\":1}}],[\"不容易出现热点和并发访问的瓶颈\",{\"1\":{\"587\":1}}],[\"不持久化\",{\"1\":{\"582\":1}}],[\"不持有外部类的引用\",{\"1\":{\"361\":1}}],[\"不在内存中\",{\"1\":{\"575\":1}}],[\"不在需要强制转换\",{\"1\":{\"345\":1}}],[\"不记录sql语句上下文相关信息\",{\"1\":{\"572\":1}}],[\"不fsync\",{\"1\":{\"571\":1}}],[\"不一定安全\",{\"1\":{\"1045\":1}}],[\"不一定确保元素有序\",{\"1\":{\"619\":1}}],[\"不一定\",{\"1\":{\"550\":1}}],[\"不一定为\",{\"1\":{\"341\":1}}],[\"不光把当前磁盘地址的数据\",{\"1\":{\"543\":1}}],[\"不走索引\",{\"0\":{\"534\":1}}],[\"不建议使用因为gap锁会被释放\",{\"1\":{\"501\":1}}],[\"不建议使用finalize\",{\"1\":{\"236\":1}}],[\"不加锁的\",{\"1\":{\"523\":1}}],[\"不加锁\",{\"1\":{\"501\":1}}],[\"不缓存真实数据\",{\"1\":{\"493\":1}}],[\"不仅在本地域名服务器中需要高速缓存\",{\"1\":{\"1032\":1}}],[\"不仅仅解决发布者和订阅者直接代码级别耦合也解决两者在物理部署上的耦合\",{\"1\":{\"673\":1}}],[\"不仅仅支持简单的\",{\"1\":{\"610\":1}}],[\"不仅会为\",{\"1\":{\"624\":1}}],[\"不仅会消耗系统资源\",{\"1\":{\"53\":1}}],[\"不仅记录了\",{\"1\":{\"570\":1}}],[\"不仅缓存索引还要缓存真实数据\",{\"1\":{\"493\":1}}],[\"不要做断开单例类对象与类中静态引用的危险操作\",{\"1\":{\"1074\":1}}],[\"不要使用反射\",{\"1\":{\"1074\":1}}],[\"不要建立臃肿庞大的接口\",{\"1\":{\"1064\":1}}],[\"不要在索引列上进行运算或使用函数\",{\"1\":{\"535\":1}}],[\"不要新建索引\",{\"1\":{\"533\":1}}],[\"不要求合并的表列名称相同时\",{\"1\":{\"485\":1}}],[\"不要通过这种方法创建\",{\"1\":{\"56\":1}}],[\"不用管库存系统\",{\"1\":{\"840\":1}}],[\"不用遍历\",{\"1\":{\"829\":1}}],[\"不用关心接口的实现类是哪个类\",{\"1\":{\"762\":1}}],[\"不用去考虑各种锁的问题\",{\"1\":{\"604\":1}}],[\"不用这个next\",{\"1\":{\"506\":1}}],[\"不用再回到原表去取数据\",{\"1\":{\"484\":1}}],[\"不用重新\",{\"1\":{\"88\":1}}],[\"不用重新获取锁\",{\"1\":{\"81\":1}}],[\"不设长度\",{\"1\":{\"477\":1}}],[\"不够友好\",{\"1\":{\"467\":1}}],[\"不安全\",{\"1\":{\"461\":1,\"596\":1,\"750\":1,\"1040\":3}}],[\"不显示密码登录\",{\"1\":{\"459\":1}}],[\"不以终端机来区分\",{\"1\":{\"426\":1}}],[\"不允许分割\",{\"1\":{\"519\":1}}],[\"不允许值重复\",{\"1\":{\"413\":1}}],[\"不允许空键\",{\"1\":{\"408\":1}}],[\"不允许独占\",{\"1\":{\"134\":1}}],[\"不推荐使用\",{\"1\":{\"1040\":1}}],[\"不推荐\",{\"1\":{\"374\":1}}],[\"不经常有插入删除元素的时候\",{\"1\":{\"373\":1}}],[\"不稳定\",{\"1\":{\"316\":1}}],[\"不引用任何一个常量池项目\",{\"1\":{\"286\":1}}],[\"不通过则返回java\",{\"1\":{\"278\":1}}],[\"不移动则内存分配时会更复杂\",{\"1\":{\"246\":1}}],[\"不是从公共证书机构\",{\"1\":{\"1045\":1}}],[\"不是存储他们的值\",{\"1\":{\"895\":1}}],[\"不是依赖注入就是\",{\"1\":{\"770\":1}}],[\"不是在加载spring配置文件的时候创建对象\",{\"1\":{\"713\":1,\"734\":1}}],[\"不是在构造方法中创建数组\",{\"1\":{\"399\":1}}],[\"不是集中在一个地方\",{\"1\":{\"684\":1}}],[\"不是以空字符串来判断是否结束\",{\"1\":{\"624\":1}}],[\"不是一下子全复制\",{\"1\":{\"615\":1}}],[\"不是每一次直接插入到索引页中\",{\"1\":{\"574\":1}}],[\"不是每一次都直接插入到索引页中\",{\"1\":{\"496\":1}}],[\"不是某个数据库软件特有的\",{\"1\":{\"457\":1}}],[\"不是由\",{\"1\":{\"418\":1}}],[\"不是固定不变的\",{\"1\":{\"369\":1}}],[\"不是最初的1\",{\"1\":{\"245\":1}}],[\"不是静态常量\",{\"1\":{\"174\":1}}],[\"不再发送icmp差错报告报文\",{\"1\":{\"993\":1}}],[\"不再将真实节点映射到哈希环上\",{\"1\":{\"880\":1}}],[\"不再需要\",{\"1\":{\"617\":1}}],[\"不再显示该文件内容\",{\"1\":{\"429\":1}}],[\"不再使用时\",{\"1\":{\"304\":1}}],[\"不再使用的类型\",{\"1\":{\"237\":1}}],[\"不再要求各个属性表具有严格顺序\",{\"1\":{\"291\":1}}],[\"不再执行当前的线程\",{\"1\":{\"144\":1}}],[\"不调用任何构造器\",{\"1\":{\"212\":1}}],[\"不直接返回\",{\"1\":{\"202\":1}}],[\"不直接进入阻塞状态进行等待\",{\"1\":{\"91\":1}}],[\"不被篡改\",{\"1\":{\"184\":1}}],[\"不利于远端磁头一端的访问请求\",{\"1\":{\"163\":1}}],[\"不方便按照逻辑模块实现信息的共享和保护\",{\"1\":{\"155\":1}}],[\"不需要每个规则定义一个实现类\",{\"1\":{\"1089\":1}}],[\"不需要修改原代码\",{\"1\":{\"1079\":1}}],[\"不需要建立http连接\",{\"1\":{\"1037\":1}}],[\"不需要经过\",{\"1\":{\"1033\":1}}],[\"不需要时可全用0\",{\"1\":{\"1002\":1}}],[\"不需要设置序号\",{\"1\":{\"975\":1}}],[\"不需要手动开关连接\",{\"1\":{\"746\":1}}],[\"不需要花费精力去处理加载驱动\",{\"1\":{\"746\":1}}],[\"不需要注入的方式\",{\"1\":{\"736\":1}}],[\"不需要多例\",{\"1\":{\"734\":1}}],[\"不需要中间代理层\",{\"1\":{\"659\":1}}],[\"不需要像\",{\"1\":{\"612\":1}}],[\"不需要拆分业务模块\",{\"1\":{\"585\":1}}],[\"不需要记录每一行的变化\",{\"1\":{\"572\":1}}],[\"不需要根据主键或行号去进行回表查询\",{\"1\":{\"547\":1}}],[\"不需要显式使用\",{\"1\":{\"511\":1}}],[\"不需要加记录x锁\",{\"1\":{\"501\":1}}],[\"不需要加锁\",{\"1\":{\"144\":1,\"834\":1}}],[\"不需要\",{\"1\":{\"368\":1}}],[\"不需要先创建外部类\",{\"1\":{\"361\":1}}],[\"不需要进行大量向下转型\",{\"1\":{\"345\":1}}],[\"不需要程序员手动释放无用内存\",{\"1\":{\"336\":1}}],[\"不需要用户去手动释放锁\",{\"1\":{\"94\":1}}],[\"不支持当前事务的情况\",{\"1\":{\"740\":1}}],[\"不支持跨\",{\"1\":{\"678\":1}}],[\"不支持范围查询和模糊查询\",{\"1\":{\"541\":1}}],[\"不支持\",{\"1\":{\"493\":3,\"610\":1}}],[\"不支持事务\",{\"1\":{\"493\":1}}],[\"不支持锁升级\",{\"1\":{\"125\":1}}],[\"不支持多继承\",{\"1\":{\"32\":1}}],[\"不为\",{\"1\":{\"118\":1}}],[\"不为空\",{\"1\":{\"101\":1}}],[\"不灵活\",{\"1\":{\"94\":1}}],[\"不过不能续租\",{\"1\":{\"1049\":1}}],[\"不过也已经不能满足分布式的业务要求了\",{\"1\":{\"1037\":1}}],[\"不过也带来了查找时遍历单链表的损耗\",{\"1\":{\"924\":1}}],[\"不过我们可以通过文件告诉\",{\"1\":{\"649\":1}}],[\"不过如果\",{\"1\":{\"623\":1}}],[\"不过性能要比单库的慢10倍左右\",{\"1\":{\"589\":1}}],[\"不过性能已经不是二者的选择标准\",{\"1\":{\"94\":1}}],[\"不过垂直分表是基于列的\",{\"1\":{\"585\":1}}],[\"不过最大的存储空间和\",{\"1\":{\"477\":1}}],[\"不过这动作只对文件有用\",{\"1\":{\"429\":1}}],[\"不过这个开销与minor\",{\"1\":{\"250\":1}}],[\"不过会发生数据覆盖的情况\",{\"1\":{\"409\":1}}],[\"不过为了提高效率\",{\"1\":{\"350\":1}}],[\"不过后续可能会删改\",{\"1\":{\"315\":1}}],[\"不过越\",{\"1\":{\"295\":1}}],[\"不过hotspot并没有强制要求使用javac来编译\",{\"1\":{\"282\":1}}],[\"不过一般来说\",{\"1\":{\"208\":1}}],[\"不过当前主流的java虚拟机都是按照可扩展来实现的\",{\"1\":{\"199\":1}}],[\"不过\",{\"1\":{\"185\":1,\"192\":1,\"235\":1,\"607\":1,\"826\":1}}],[\"不过本质都是对monitor的获取\",{\"1\":{\"82\":1}}],[\"不管数据报发送到哪个目的地址\",{\"1\":{\"993\":1}}],[\"不管传输什么样的比特组合\",{\"1\":{\"973\":1}}],[\"不管消费者处于何种状态\",{\"1\":{\"843\":1}}],[\"不管正向代理还是反向代理\",{\"1\":{\"826\":1}}],[\"不管用没用到\",{\"1\":{\"712\":1}}],[\"不管是数据存储空间\",{\"1\":{\"997\":1}}],[\"不管是数据不存在\",{\"1\":{\"641\":1}}],[\"不管是扩容还是收缩\",{\"1\":{\"623\":1}}],[\"不管是io瓶颈\",{\"1\":{\"584\":1}}],[\"不管是否页在内存中\",{\"1\":{\"568\":1}}],[\"不管怎样\",{\"1\":{\"383\":1}}],[\"不管怎么重排序\",{\"1\":{\"76\":1}}],[\"不管当前内存空间足够与否\",{\"1\":{\"235\":1}}],[\"不管内存空间足够与否\",{\"1\":{\"45\":1}}],[\"不能只有一个孩子\",{\"1\":{\"918\":1}}],[\"不能利用直接寻址表\",{\"1\":{\"886\":1}}],[\"不能用于存放大量的数据\",{\"1\":{\"818\":1}}],[\"不能通过内存来传递参数\",{\"1\":{\"804\":1}}],[\"不能通过以下方法获取spring\",{\"1\":{\"736\":1}}],[\"不能直接调用\",{\"1\":{\"801\":1}}],[\"不能直接读取\",{\"1\":{\"566\":1}}],[\"不能直接读写主内存数据\",{\"1\":{\"74\":1}}],[\"不能随意更换数据库\",{\"1\":{\"746\":1}}],[\"不能保存数据\",{\"1\":{\"735\":1}}],[\"不能保证\",{\"1\":{\"992\":1}}],[\"不能保证数据传输的可靠性\",{\"1\":{\"961\":1}}],[\"不能保证数据不重复\",{\"1\":{\"856\":1}}],[\"不能保证数据不丢失\",{\"1\":{\"856\":1}}],[\"不能保证数据的实时一致性\",{\"1\":{\"411\":2}}],[\"不能保证全局有序\",{\"1\":{\"845\":1}}],[\"不能保证原子性\",{\"1\":{\"79\":1}}],[\"不能保证同优先级元素的顺序\",{\"1\":{\"62\":1}}],[\"不能缓解读压力\",{\"1\":{\"678\":1}}],[\"不能再依赖数据库自身的主键生成机制\",{\"1\":{\"589\":1}}],[\"不能回滚\",{\"1\":{\"501\":1}}],[\"不能存在依赖传递\",{\"1\":{\"455\":1}}],[\"不能产生部分依赖\",{\"1\":{\"455\":1}}],[\"不能为\",{\"1\":{\"412\":1}}],[\"不能修饰类和方法\",{\"1\":{\"364\":1}}],[\"不能修饰变量\",{\"1\":{\"83\":1}}],[\"不能出现在一个构造函数里面\",{\"1\":{\"364\":1}}],[\"不能根据返回类型进行区分\",{\"1\":{\"359\":1}}],[\"不能比父类被重写方法声明更多的异常\",{\"1\":{\"359\":1}}],[\"不能从读锁升级到写锁\",{\"1\":{\"125\":1}}],[\"不止在\",{\"1\":{\"71\":1}}],[\"不处理队列中的任务\",{\"1\":{\"63\":1}}],[\"不同变量类型的映射\",{\"0\":{\"1252\":1}}],[\"不同实现的行为可能不一致\",{\"1\":{\"1042\":1}}],[\"不同网络之间必须使用路由器进行互连\",{\"1\":{\"984\":1}}],[\"不同为\",{\"1\":{\"943\":1}}],[\"不同partition之间不能保证顺序\",{\"1\":{\"865\":1}}],[\"不同级别的缓存设置的超时时间不同\",{\"1\":{\"642\":1}}],[\"不同层指针到下一个节点的跨度不同\",{\"1\":{\"630\":1}}],[\"不同sql语句对加锁的影响\",{\"0\":{\"501\":1}}],[\"不同于\",{\"1\":{\"381\":1}}],[\"不同点在于\",{\"1\":{\"1092\":1}}],[\"不同点\",{\"1\":{\"362\":1,\"408\":1,\"411\":1}}],[\"不同点是\",{\"1\":{\"128\":1}}],[\"不同平台cpu架构不同\",{\"1\":{\"190\":1}}],[\"不同classloader加载的同名类属于不同的类型\",{\"1\":{\"187\":1}}],[\"不同\",{\"1\":{\"173\":1}}],[\"不同进程可以及时看到对方进程中对共享内存中数据的更新\",{\"1\":{\"149\":1}}],[\"不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑\",{\"1\":{\"76\":1}}],[\"不同线程间无法直接访问对方工作内存中的变量\",{\"1\":{\"74\":1}}],[\"不同核心\",{\"1\":{\"72\":1}}],[\"不同的排序规则其实就是不同的策略\",{\"1\":{\"1089\":1}}],[\"不同的套餐有不同的组成部分\",{\"1\":{\"1086\":1}}],[\"不同的负载均衡算法适用的业务场景也不同的\",{\"1\":{\"880\":1}}],[\"不同的\",{\"1\":{\"501\":1}}],[\"不同的存储引擎导致底层表在存储数据时采用不同方式存储\",{\"1\":{\"490\":1}}],[\"不同的线程之间无法直接访问对方本地内存中的变量\",{\"1\":{\"294\":1}}],[\"不同的线程之间也无法直接访问对方工作内存中的变量\",{\"1\":{\"66\":1,\"337\":1}}],[\"不同的线程处理不同段的数据\",{\"1\":{\"144\":1}}],[\"不同的自定义同步器争用共享资源的方式也不同\",{\"1\":{\"115\":1}}],[\"不同的是cookie保存在客户端浏览器中\",{\"1\":{\"1052\":1}}],[\"不同的是\",{\"1\":{\"35\":2,\"149\":1,\"734\":1}}],[\"不同操作系统中实现方式不同\",{\"1\":{\"62\":1}}],[\"不存在枚举项\",{\"1\":{\"1260\":1}}],[\"不存在\",{\"1\":{\"643\":1}}],[\"不存在加锁释放锁操作\",{\"1\":{\"604\":1}}],[\"不存在单库数据量过大\",{\"1\":{\"585\":1}}],[\"不存在任何问题\",{\"1\":{\"499\":1}}],[\"不存在也可以加载进来\",{\"1\":{\"348\":1}}],[\"不存在gc的问题\",{\"1\":{\"190\":1}}],[\"不存在多线程竞争\",{\"1\":{\"74\":1}}],[\"不存在才读取主存的数据\",{\"1\":{\"72\":1}}],[\"不存在则创建并返回初始值\",{\"1\":{\"39\":1}}],[\"不存储元素的阻塞队列\",{\"1\":{\"62\":1}}],[\"不接受新任务\",{\"1\":{\"59\":1,\"63\":2}}],[\"不可修改\",{\"1\":{\"1231\":1}}],[\"不可缓存\",{\"1\":{\"1041\":1}}],[\"不可靠传输\",{\"1\":{\"961\":1,\"1001\":1}}],[\"不可一次读入\",{\"1\":{\"891\":1}}],[\"不可用\",{\"1\":{\"657\":1}}],[\"不可避免的会影响主线程性能\",{\"1\":{\"650\":1}}],[\"不可避免会带来跨库事务问题\",{\"1\":{\"589\":1}}],[\"不可重复读以及幻读\",{\"1\":{\"522\":1}}],[\"不可重复读\",{\"1\":{\"499\":2,\"521\":1,\"522\":1}}],[\"不可回滚\",{\"1\":{\"483\":2}}],[\"不可以做到稳定性\",{\"1\":{\"931\":1,\"937\":1}}],[\"不可以有null\",{\"1\":{\"548\":1}}],[\"不可以\",{\"1\":{\"370\":1}}],[\"不可以直接访问外部类的非静态成员\",{\"1\":{\"361\":1}}],[\"不可以对不同锁中的线程进行唤醒\",{\"1\":{\"36\":1}}],[\"不可再分的\",{\"1\":{\"294\":1}}],[\"不可达对象不是非死不可\",{\"0\":{\"236\":1}}],[\"不可变\",{\"1\":{\"48\":1}}],[\"不会重复发送\",{\"1\":{\"1042\":1}}],[\"不会缓存\",{\"1\":{\"1040\":1}}],[\"不会有连续的红色节点\",{\"1\":{\"921\":1}}],[\"不会有新的插入进来\",{\"1\":{\"501\":1}}],[\"不会被少数运行缓慢的服务器来影响整体系统性能\",{\"1\":{\"873\":1}}],[\"不会被清理掉\",{\"1\":{\"300\":1}}],[\"不会造成堵塞\",{\"1\":{\"838\":1}}],[\"不会造成线程的阻塞\",{\"1\":{\"79\":1}}],[\"不会对应用程序或者数据库的现有设计造成任何影响\",{\"1\":{\"746\":1}}],[\"不会影响业务逻辑的实现\",{\"1\":{\"739\":1}}],[\"不会影响程序并发的正确性\",{\"1\":{\"106\":1}}],[\"不会立即执行这些命令\",{\"1\":{\"665\":1}}],[\"不会立即将修改的索引数据写入磁盘\",{\"1\":{\"492\":1}}],[\"不会存在两个\",{\"1\":{\"623\":1}}],[\"不会忽略age字段\",{\"1\":{\"553\":1}}],[\"不会询问而直接覆盖\",{\"1\":{\"425\":1}}],[\"不会出现死锁的情况\",{\"1\":{\"510\":1,\"672\":1}}],[\"不会出现警告信息\",{\"1\":{\"424\":1}}],[\"不会出现紧耦合的问题\",{\"1\":{\"362\":1}}],[\"不会排序\",{\"1\":{\"408\":1}}],[\"不会产生空间碎片\",{\"1\":{\"246\":1}}],[\"不会产生外部碎片\",{\"1\":{\"155\":1}}],[\"不会再直接操作字节流\",{\"1\":{\"170\":1}}],[\"不会导致\",{\"1\":{\"163\":2}}],[\"不会导致饥饿\",{\"1\":{\"150\":3}}],[\"不会饥饿\",{\"1\":{\"163\":1}}],[\"不会发生抢占情况\",{\"1\":{\"134\":1}}],[\"不会自动释放锁\",{\"1\":{\"94\":1}}],[\"不会消耗\",{\"1\":{\"86\":1}}],[\"不会改变执行结果\",{\"1\":{\"76\":1}}],[\"不会释放对象锁\",{\"1\":{\"37\":1}}],[\"不会释放锁\",{\"1\":{\"35\":1}}],[\"不会让线程进入阻塞状态\",{\"1\":{\"35\":1}}],[\"不会穿透到当前组件的后代组件上去\",{\"1\":{\"24\":1}}],[\"不释放锁\",{\"1\":{\"35\":2}}],[\"gpg\",{\"1\":{\"1202\":1}}],[\"gpu\",{\"0\":{\"1145\":1},\"1\":{\"1145\":2}}],[\"gmt\",{\"1\":{\"1038\":1}}],[\"gif\",{\"1\":{\"1038\":1}}],[\"gitlab\",{\"1\":{\"1127\":1}}],[\"git\",{\"0\":{\"415\":1,\"444\":1,\"1120\":1,\"1202\":1},\"1\":{\"444\":7,\"445\":3,\"446\":4,\"447\":8,\"448\":6,\"449\":22,\"450\":10,\"451\":15,\"452\":10,\"453\":11,\"1121\":3,\"1126\":7,\"1127\":8,\"1201\":2,\"1202\":6}}],[\"github\",{\"0\":{\"1122\":1,\"1123\":1,\"1124\":1,\"1195\":1,\"1196\":1,\"1199\":1,\"1200\":1,\"1201\":1,\"1202\":1,\"1204\":1,\"1206\":1},\"1\":{\"1\":1,\"1115\":2,\"1123\":1,\"1124\":3,\"1127\":1,\"1170\":3,\"1197\":3,\"1198\":2,\"1199\":1,\"1200\":1,\"1203\":1,\"1206\":1,\"1208\":1}}],[\"gb内存\",{\"1\":{\"900\":1}}],[\"gbytes\",{\"1\":{\"441\":1}}],[\"google\",{\"1\":{\"882\":1}}],[\"google开源的guava中自带的布隆过滤器\",{\"1\":{\"882\":1}}],[\"goods\",{\"1\":{\"481\":8}}],[\"goss\",{\"1\":{\"660\":1}}],[\"gossip\",{\"1\":{\"660\":2,\"678\":1,\"684\":2}}],[\"gap\",{\"0\":{\"504\":1},\"1\":{\"505\":1,\"933\":16,\"953\":1}}],[\"garbagecat等\",{\"1\":{\"271\":1,\"332\":1}}],[\"garbage\",{\"1\":{\"260\":1}}],[\"global\",{\"1\":{\"446\":3,\"557\":2,\"701\":1,\"734\":1,\"1143\":1,\"1201\":1,\"1202\":2}}],[\"gzip\",{\"1\":{\"1038\":1}}],[\"gz\",{\"1\":{\"437\":3,\"1170\":3}}],[\"g=rx\",{\"1\":{\"433\":1}}],[\"g\",{\"1\":{\"433\":2,\"700\":1}}],[\"graphviz\",{\"0\":{\"1269\":1},\"1\":{\"1269\":2,\"1270\":1}}],[\"gradle\",{\"1\":{\"781\":1}}],[\"groupid\",{\"1\":{\"795\":1}}],[\"groupid和artifactid构成了一个jar包的坐标\",{\"1\":{\"795\":1}}],[\"groupid>\",{\"1\":{\"776\":1,\"790\":2,\"795\":1,\"796\":1,\"800\":3,\"882\":1}}],[\"group\",{\"0\":{\"860\":1},\"1\":{\"433\":1,\"487\":1,\"563\":2,\"584\":1,\"589\":1,\"845\":1,\"859\":1,\"860\":1}}],[\"grub\",{\"1\":{\"416\":1}}],[\"grep\",{\"1\":{\"201\":1,\"434\":1,\"436\":2,\"443\":2,\"449\":1}}],[\"guava<\",{\"1\":{\"882\":1}}],[\"guava来说\",{\"1\":{\"607\":1}}],[\"guava\",{\"0\":{\"608\":1},\"1\":{\"607\":6,\"608\":1,\"609\":1}}],[\"gui篇\",{\"0\":{\"313\":1}}],[\"gui应用对界面启动速度就有一定要求\",{\"1\":{\"283\":1}}],[\"guy\",{\"1\":{\"277\":6}}],[\"g1至少要耗费大约相当于java堆容量10\",{\"1\":{\"265\":1}}],[\"g1存在跨region引用的问题\",{\"1\":{\"265\":1}}],[\"g1垃圾回收过程\",{\"0\":{\"264\":1}}],[\"g1提供了三种垃圾回收模式\",{\"1\":{\"263\":1}}],[\"g1的记忆集在存储结构的本质上是一种哈希表\",{\"1\":{\"265\":1}}],[\"g1的记忆集\",{\"0\":{\"265\":1}}],[\"g1的吞吐量目标是90\",{\"1\":{\"263\":1}}],[\"g1的设计原则是简化jvm性能调优\",{\"1\":{\"263\":1}}],[\"g1的优势更加明显\",{\"1\":{\"261\":1}}],[\"g1调优\",{\"0\":{\"263\":1}}],[\"g1heapregionsize\",{\"1\":{\"262\":1}}],[\"g1除了使用写后屏障来进行同样的\",{\"1\":{\"262\":1}}],[\"g1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比cms要高\",{\"1\":{\"262\":1}}],[\"g1不具备全方位的优势\",{\"1\":{\"262\":1}}],[\"g1未必能做到cms在最好情况下的停顿时间\",{\"1\":{\"261\":1}}],[\"g1拥有与应用程序交替执行的能力\",{\"1\":{\"261\":1}}],[\"g1能充分利用\",{\"1\":{\"261\":1}}],[\"g1可能比cms好\",{\"1\":{\"261\":1}}],[\"g1跨region引用对象主要靠记忆集解决\",{\"1\":{\"260\":1}}],[\"g1跟踪各个region垃圾堆积的价值大小\",{\"1\":{\"260\":1}}],[\"g1认为只要大小超过1\",{\"1\":{\"260\":1}}],[\"g1开创了收集器面向局部收集的设计思路和基于region的内存布局形式\",{\"1\":{\"260\":1}}],[\"g1收集器是一个并行回收器\",{\"1\":{\"260\":1}}],[\"g1收集器\",{\"0\":{\"260\":1}}],[\"g1\",{\"1\":{\"251\":1,\"252\":1,\"260\":1,\"261\":5}}],[\"generation\",{\"1\":{\"715\":1}}],[\"generational\",{\"1\":{\"239\":2}}],[\"generalization\",{\"0\":{\"1100\":1}}],[\"general\",{\"1\":{\"566\":1,\"1199\":1}}],[\"gen\",{\"1\":{\"546\":1}}],[\"gender\",{\"1\":{\"486\":2}}],[\"getname\",{\"1\":{\"1255\":2,\"1256\":2,\"1260\":1}}],[\"getfollowervalue\",{\"1\":{\"1242\":1}}],[\"getinitenums\",{\"1\":{\"1159\":1}}],[\"getinstnce\",{\"1\":{\"1070\":2}}],[\"getinstance\",{\"1\":{\"101\":1,\"1066\":2,\"1070\":2,\"1072\":1,\"1075\":1}}],[\"getresult\",{\"1\":{\"1086\":1}}],[\"getrequiredwebapplicationcontext\",{\"1\":{\"736\":1}}],[\"getproxyobject\",{\"1\":{\"1083\":1}}],[\"getparent\",{\"1\":{\"182\":1}}],[\"getuniqueinstance\",{\"1\":{\"1067\":3,\"1068\":1,\"1069\":1}}],[\"get和post是最常见的http方法\",{\"1\":{\"1038\":1}}],[\"getattribute\",{\"1\":{\"736\":1}}],[\"getwebapplicationcontext\",{\"1\":{\"736\":1}}],[\"getbean\",{\"1\":{\"736\":4}}],[\"getbean的dogetbean方法调用getsingleton进行bean\",{\"1\":{\"713\":1}}],[\"getmethod\",{\"1\":{\"356\":1}}],[\"getdeclaremethod\",{\"1\":{\"356\":1}}],[\"getter\",{\"1\":{\"355\":1,\"1261\":2}}],[\"getsystemclassloader\",{\"1\":{\"182\":1}}],[\"getstatic\",{\"1\":{\"174\":2}}],[\"getstate\",{\"1\":{\"96\":2,\"110\":1}}],[\"getcodebyspenum\",{\"1\":{\"1261\":1}}],[\"getcodeordefault\",{\"1\":{\"1260\":1}}],[\"getconstructor\",{\"1\":{\"356\":1}}],[\"getcontextclassloader\",{\"1\":{\"182\":1}}],[\"getcurrentwebapplicationcontext\",{\"1\":{\"736\":1}}],[\"getclass\",{\"1\":{\"350\":2}}],[\"getclass方法\",{\"1\":{\"339\":1}}],[\"getclassloader\",{\"1\":{\"182\":1}}],[\"getcallerclassloader\",{\"1\":{\"182\":1}}],[\"getexclusiveownerthread\",{\"1\":{\"96\":3}}],[\"get\",{\"0\":{\"398\":1},\"1\":{\"31\":1,\"39\":3,\"46\":2,\"61\":3,\"129\":4,\"299\":1,\"300\":1,\"348\":1,\"355\":1,\"393\":1,\"408\":1,\"410\":1,\"517\":2,\"637\":1,\"823\":1,\"1040\":1,\"1041\":6}}],[\"gc日志分析工具\",{\"0\":{\"332\":1}}],[\"gc日志剖析\",{\"0\":{\"328\":1}}],[\"gc日志参数选项\",{\"0\":{\"325\":1}}],[\"gc中的吞吐量=1\",{\"1\":{\"310\":1}}],[\"gc频繁\",{\"1\":{\"307\":1}}],[\"gclogviewer\",{\"1\":{\"271\":1,\"332\":1}}],[\"gchisto\",{\"1\":{\"271\":1,\"332\":1}}],[\"gceasy\",{\"1\":{\"271\":1,\"332\":1}}],[\"gcviewer\",{\"1\":{\"271\":1,\"332\":1}}],[\"gc停顿时间过长\",{\"1\":{\"261\":1}}],[\"gc将region作为单次回收的最小单元\",{\"1\":{\"260\":1}}],[\"gc的次数\",{\"1\":{\"309\":1}}],[\"gc的日志分析\",{\"0\":{\"269\":1}}],[\"gc的时候同步完成的\",{\"1\":{\"264\":1}}],[\"gc的时候才会触发\",{\"1\":{\"207\":1}}],[\"gc的产生\",{\"1\":{\"259\":1}}],[\"gctimeratio\",{\"1\":{\"257\":1,\"310\":1}}],[\"gc之后存活的对象时\",{\"1\":{\"245\":1}}],[\"gc后内存还不足\",{\"1\":{\"243\":1}}],[\"gc触发\",{\"1\":{\"243\":1}}],[\"gc时间\",{\"0\":{\"331\":1}}],[\"gc时扫描整个老年代的代价相比还是低得多的\",{\"1\":{\"250\":1}}],[\"gc时to指向的survivor区还是空的\",{\"1\":{\"242\":1}}],[\"gc时\",{\"1\":{\"242\":1}}],[\"gc同义\",{\"1\":{\"240\":1}}],[\"gc与full\",{\"1\":{\"240\":1}}],[\"gc收集器\",{\"1\":{\"216\":1,\"217\":1}}],[\"gc是老年代\",{\"1\":{\"207\":1}}],[\"gc\",{\"0\":{\"242\":1,\"243\":1,\"329\":1,\"330\":1},\"1\":{\"84\":1,\"200\":1,\"220\":4,\"222\":1,\"225\":1,\"234\":3,\"240\":7,\"241\":1,\"242\":1,\"243\":2,\"247\":1,\"261\":3,\"263\":3,\"270\":2,\"297\":1,\"325\":1,\"326\":1,\"332\":1,\"346\":1,\"392\":1,\"411\":2}}],[\"ok\",{\"1\":{\"1038\":1}}],[\"okhttp\",{\"1\":{\"685\":1}}],[\"o操作\",{\"1\":{\"830\":1}}],[\"observing\",{\"1\":{\"820\":1}}],[\"obj2\",{\"1\":{\"350\":1}}],[\"obj1\",{\"1\":{\"350\":2}}],[\"obj\",{\"1\":{\"85\":2,\"304\":2,\"344\":2,\"733\":2}}],[\"objectinputstream\",{\"1\":{\"356\":1}}],[\"objectoutputstream\",{\"1\":{\"344\":2}}],[\"object\",{\"0\":{\"36\":1,\"350\":1,\"1231\":1},\"1\":{\"35\":1,\"36\":2,\"37\":1,\"38\":6,\"89\":1,\"98\":4,\"126\":2,\"173\":1,\"184\":2,\"304\":2,\"340\":1,\"343\":2,\"344\":1,\"345\":1,\"346\":1,\"349\":4,\"350\":2,\"392\":1,\"405\":1,\"641\":1,\"733\":2,\"747\":1,\"1035\":1,\"1218\":1}}],[\"odown\",{\"1\":{\"657\":2}}],[\"openssl\",{\"1\":{\"1168\":2}}],[\"open\",{\"1\":{\"1157\":1}}],[\"opened\",{\"1\":{\"884\":1}}],[\"opsforvalue\",{\"1\":{\"642\":1}}],[\"option\",{\"1\":{\"1040\":1}}],[\"options\",{\"1\":{\"423\":1,\"425\":1,\"1038\":1}}],[\"optional\",{\"1\":{\"416\":1,\"797\":1,\"1260\":1}}],[\"opts=\",{\"1\":{\"317\":2}}],[\"opt\",{\"1\":{\"160\":1,\"416\":1}}],[\"o频率过高\",{\"1\":{\"579\":1}}],[\"osi\",{\"1\":{\"981\":2}}],[\"osi把对等层之间传送的数据单位称为该层的协议数据单元pdu\",{\"1\":{\"963\":1}}],[\"osi七层参考模型\",{\"1\":{\"961\":1}}],[\"os\",{\"1\":{\"495\":1,\"647\":2,\"649\":2,\"650\":1}}],[\"o线程写入的relay\",{\"1\":{\"469\":1,\"580\":1}}],[\"o线程接收到\",{\"1\":{\"469\":1,\"580\":1}}],[\"orelse\",{\"1\":{\"1260\":1}}],[\"orelsethrow\",{\"1\":{\"1260\":1}}],[\"org\",{\"1\":{\"769\":1,\"1136\":1,\"1179\":1}}],[\"orm\",{\"0\":{\"747\":1},\"1\":{\"746\":1,\"747\":1,\"748\":1,\"749\":2}}],[\"or\",{\"1\":{\"556\":1,\"560\":2,\"717\":1,\"1144\":1,\"1168\":1,\"1190\":1}}],[\"orders\",{\"1\":{\"486\":4}}],[\"order\",{\"0\":{\"484\":1},\"1\":{\"484\":1,\"485\":3,\"487\":1,\"560\":1,\"584\":1,\"589\":1,\"703\":1}}],[\"oracle\",{\"1\":{\"457\":1,\"741\":1}}],[\"origin是默认习惯命名\",{\"1\":{\"452\":1}}],[\"origin\",{\"1\":{\"450\":1,\"451\":1,\"452\":3,\"1126\":1,\"1127\":3}}],[\"original\",{\"1\":{\"447\":1}}],[\"other\",{\"1\":{\"433\":1}}],[\"o=r\",{\"1\":{\"433\":1}}],[\"onmonted\",{\"1\":{\"1159\":2}}],[\"once即精确的一次\",{\"1\":{\"856\":1}}],[\"once\",{\"1\":{\"856\":5}}],[\"only\",{\"0\":{\"649\":1},\"1\":{\"449\":1}}],[\"oneline\",{\"1\":{\"449\":1}}],[\"on\",{\"1\":{\"411\":1,\"487\":1,\"516\":1,\"527\":2,\"647\":1,\"701\":1,\"1144\":1}}],[\"onoutofmemoryerror\",{\"1\":{\"324\":1}}],[\"oop\",{\"1\":{\"354\":1}}],[\"oom相关的选项\",{\"0\":{\"324\":1}}],[\"oomtest\",{\"1\":{\"304\":1}}],[\"oom\",{\"0\":{\"297\":1},\"1\":{\"297\":2,\"307\":1}}],[\"oldboy36\",{\"1\":{\"443\":1}}],[\"old等\",{\"1\":{\"260\":1}}],[\"old是serial收集器的老年代版本\",{\"1\":{\"256\":1}}],[\"old收集器这个组合\",{\"1\":{\"258\":1}}],[\"old收集器\",{\"0\":{\"256\":1,\"258\":1}}],[\"old区用\",{\"0\":{\"246\":1}}],[\"old\",{\"1\":{\"240\":1,\"252\":1,\"407\":1}}],[\"o方式\",{\"1\":{\"209\":1}}],[\"ofnullable\",{\"1\":{\"1260\":1}}],[\"offsets\",{\"1\":{\"860\":1}}],[\"offset不是该message在partition数据文件中的实际存储位置\",{\"1\":{\"847\":1}}],[\"offset表示message在这个partition中的偏移量\",{\"1\":{\"847\":1}}],[\"offset\",{\"0\":{\"860\":1},\"1\":{\"847\":1,\"855\":1}}],[\"offffset\",{\"0\":{\"847\":1}}],[\"offerfirst\",{\"1\":{\"394\":1}}],[\"offerlast\",{\"1\":{\"394\":1}}],[\"offer\",{\"1\":{\"394\":1,\"1049\":1}}],[\"of\",{\"1\":{\"193\":1,\"891\":3}}],[\"o\",{\"0\":{\"137\":1,\"933\":1},\"1\":{\"102\":1,\"130\":2,\"135\":1,\"137\":4,\"162\":1,\"209\":1,\"380\":5,\"381\":10,\"392\":1,\"401\":3,\"408\":1,\"433\":2,\"440\":1,\"470\":1,\"535\":1,\"537\":2,\"581\":1,\"604\":1,\"612\":1,\"614\":1,\"622\":2,\"624\":3,\"626\":2,\"627\":2,\"630\":5,\"645\":1,\"880\":1,\"893\":3,\"916\":2,\"930\":2,\"931\":2,\"932\":3,\"933\":1,\"934\":2,\"937\":5,\"942\":1,\"1170\":1}}],[\"owner\",{\"1\":{\"85\":2,\"89\":1}}],[\"overide\",{\"1\":{\"1247\":1}}],[\"over\",{\"1\":{\"703\":1,\"964\":2}}],[\"overhead\",{\"1\":{\"200\":1,\"297\":1}}],[\"overflow\",{\"1\":{\"45\":1}}],[\"overrided\",{\"1\":{\"338\":1}}],[\"override\",{\"1\":{\"31\":2,\"39\":1,\"98\":2,\"338\":1}}],[\"output\",{\"1\":{\"1144\":1}}],[\"outofmemory\",{\"1\":{\"235\":1}}],[\"outofmemoryerror\",{\"1\":{\"200\":2,\"234\":1,\"235\":1,\"297\":1,\"384\":1}}],[\"outofmemoryerror错误\",{\"1\":{\"200\":1}}],[\"out\",{\"1\":{\"31\":1,\"39\":1,\"98\":2,\"277\":3,\"882\":4,\"908\":3,\"935\":1,\"940\":1,\"941\":1,\"951\":1,\"952\":1,\"953\":1,\"955\":2,\"1082\":2}}],[\"rudp\",{\"1\":{\"1004\":1}}],[\"ruby\",{\"1\":{\"825\":1}}],[\"run就能创建一个独立的\",{\"1\":{\"767\":1}}],[\"runoob\",{\"1\":{\"420\":6}}],[\"runtimeexception\",{\"1\":{\"385\":2}}],[\"runtime\",{\"1\":{\"335\":1,\"797\":1,\"825\":1}}],[\"running\",{\"1\":{\"63\":1,\"148\":1}}],[\"runnnable\",{\"1\":{\"38\":1}}],[\"runnable\",{\"0\":{\"32\":1,\"33\":1},\"1\":{\"31\":3,\"32\":4,\"33\":1,\"38\":1,\"98\":2}}],[\"run\",{\"0\":{\"34\":1},\"1\":{\"31\":4,\"33\":2,\"34\":4,\"98\":2,\"774\":1,\"1177\":1}}],[\"rvalue\",{\"1\":{\"804\":2}}],[\"rpc的技术重点\",{\"0\":{\"804\":1}}],[\"rpc\",{\"0\":{\"801\":1,\"804\":1,\"805\":1,\"806\":1,\"807\":1,\"811\":1},\"1\":{\"801\":6,\"804\":3,\"805\":4,\"806\":2,\"809\":1,\"815\":1}}],[\"rpop\",{\"1\":{\"705\":1}}],[\"rsa\",{\"1\":{\"1202\":2}}],[\"rs\",{\"1\":{\"745\":1}}],[\"rset\",{\"1\":{\"249\":1}}],[\"rset的价值在于使得垃圾回收不需要扫描整个堆\",{\"1\":{\"249\":1}}],[\"rb\",{\"1\":{\"659\":1}}],[\"rdb备份策略\",{\"1\":{\"708\":1}}],[\"rdb恢复数据的速度远远比\",{\"1\":{\"648\":1}}],[\"rdbload\",{\"1\":{\"647\":1}}],[\"rdbsave\",{\"1\":{\"647\":1}}],[\"rdb\",{\"0\":{\"647\":1,\"648\":1,\"652\":1},\"1\":{\"646\":1,\"647\":11,\"648\":4,\"649\":1,\"652\":5,\"653\":6,\"655\":1,\"662\":3,\"708\":2}}],[\"raft\",{\"0\":{\"873\":1},\"1\":{\"872\":1,\"874\":1,\"876\":2,\"877\":2,\"879\":1}}],[\"rate\",{\"1\":{\"645\":1}}],[\"rate越小\",{\"1\":{\"645\":1}}],[\"raw\",{\"1\":{\"617\":1}}],[\"random\",{\"1\":{\"636\":2,\"642\":1,\"706\":2,\"812\":1,\"935\":1}}],[\"randomaccess\",{\"1\":{\"391\":2,\"392\":1}}],[\"range策略\",{\"1\":{\"859\":1}}],[\"range\",{\"1\":{\"556\":2,\"859\":1}}],[\"rcvd\",{\"1\":{\"1022\":1,\"1025\":1}}],[\"rc\",{\"1\":{\"503\":1,\"523\":1,\"1139\":4}}],[\"right\",{\"1\":{\"485\":1,\"908\":6,\"911\":4,\"912\":5,\"913\":11,\"935\":7,\"956\":1,\"1012\":1}}],[\"roaming\",{\"1\":{\"1143\":1}}],[\"robin循环\",{\"1\":{\"859\":1}}],[\"robin\",{\"1\":{\"852\":1}}],[\"router4\",{\"1\":{\"1148\":1}}],[\"router\",{\"1\":{\"1139\":1,\"1148\":1}}],[\"round\",{\"1\":{\"859\":1}}],[\"roundrobin\",{\"1\":{\"812\":1}}],[\"roubounds\",{\"1\":{\"753\":1}}],[\"rocketmq\",{\"0\":{\"709\":1,\"1179\":1},\"1\":{\"687\":1,\"843\":1,\"1179\":2}}],[\"roll\",{\"1\":{\"499\":1}}],[\"rollback\",{\"1\":{\"493\":1,\"526\":1}}],[\"rowbounds\",{\"1\":{\"753\":1}}],[\"rows\",{\"1\":{\"702\":1}}],[\"rowid\",{\"1\":{\"484\":3,\"547\":1}}],[\"rowid排序\",{\"1\":{\"484\":1}}],[\"row\",{\"1\":{\"468\":4,\"499\":1,\"523\":1,\"566\":2,\"572\":1,\"703\":1}}],[\"root=root\",{\"1\":{\"908\":2}}],[\"root=stack\",{\"1\":{\"908\":2}}],[\"root开始对堆中对象进行可达性分析\",{\"1\":{\"264\":1}}],[\"root\",{\"1\":{\"247\":1,\"416\":1,\"420\":3,\"443\":1,\"736\":1,\"908\":21,\"956\":3,\"1177\":2,\"1178\":3}}],[\"roots引用链的信息\",{\"1\":{\"298\":1}}],[\"roots相关联的导致垃圾回收机制无法将其回收\",{\"1\":{\"298\":1}}],[\"roots相连接的引用链\",{\"1\":{\"236\":1}}],[\"roots的引用链\",{\"1\":{\"298\":1}}],[\"roots的直接关联对象开始遍历整个对象图的过程\",{\"1\":{\"259\":1}}],[\"roots与对象之间有路径避免垃圾回收\",{\"1\":{\"297\":1}}],[\"roots扫描\",{\"1\":{\"265\":1}}],[\"roots扫描范围\",{\"1\":{\"249\":1}}],[\"roots能直接关联到的对象\",{\"1\":{\"259\":1,\"264\":1}}],[\"roots中一并扫描\",{\"1\":{\"249\":1}}],[\"roots集合\",{\"1\":{\"234\":1}}],[\"roots集合以外\",{\"1\":{\"234\":1}}],[\"roots\",{\"1\":{\"234\":3}}],[\"rwx\",{\"1\":{\"430\":1,\"433\":1,\"443\":1}}],[\"rn\",{\"1\":{\"426\":1,\"703\":2}}],[\"r\",{\"1\":{\"423\":1,\"424\":1,\"430\":2,\"431\":2,\"432\":2,\"433\":1,\"443\":2,\"451\":1,\"804\":3,\"934\":11,\"954\":2,\"1144\":3}}],[\"rmr\",{\"1\":{\"823\":1}}],[\"rm\",{\"0\":{\"424\":1},\"1\":{\"418\":1,\"424\":2,\"447\":2,\"1177\":1}}],[\"rmdir\",{\"1\":{\"418\":2}}],[\"rto\",{\"1\":{\"1012\":1}}],[\"rtt\",{\"1\":{\"1012\":5}}],[\"rtp\",{\"1\":{\"1004\":1}}],[\"rt\",{\"1\":{\"176\":1}}],[\"rr\",{\"0\":{\"523\":1},\"1\":{\"150\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":2,\"522\":1,\"523\":3}}],[\"regular\",{\"0\":{\"1193\":1}}],[\"registry\",{\"1\":{\"801\":3}}],[\"region\",{\"1\":{\"267\":1}}],[\"region之间是复制算法\",{\"1\":{\"261\":1}}],[\"region中还有一类特殊的humongous区域\",{\"1\":{\"260\":1}}],[\"re\",{\"0\":{\"1188\":1,\"1189\":1},\"1\":{\"1108\":1,\"1188\":3,\"1189\":1,\"1190\":2}}],[\"requirements\",{\"1\":{\"1144\":5}}],[\"requires\",{\"1\":{\"740\":1,\"1144\":1}}],[\"requiredargsconstructor\",{\"1\":{\"1261\":2}}],[\"required\",{\"1\":{\"740\":2}}],[\"requestfacade\",{\"1\":{\"1090\":1}}],[\"requestvoterpc\",{\"1\":{\"877\":1,\"878\":1}}],[\"request内有效\",{\"1\":{\"713\":1}}],[\"request\",{\"1\":{\"713\":1,\"734\":2,\"755\":1,\"804\":1,\"1083\":1,\"1090\":2,\"1127\":1}}],[\"rewrite\",{\"1\":{\"708\":2}}],[\"recv\",{\"1\":{\"1006\":1,\"1060\":1}}],[\"record\",{\"0\":{\"503\":1},\"1\":{\"505\":2,\"515\":1}}],[\"recently\",{\"1\":{\"633\":1}}],[\"recentlyused\",{\"1\":{\"160\":1}}],[\"receivemsg\",{\"1\":{\"304\":1}}],[\"reduce过程\",{\"1\":{\"891\":1}}],[\"redirect\",{\"1\":{\"758\":1}}],[\"redis中的布隆过滤器\",{\"1\":{\"882\":1}}],[\"redis4\",{\"1\":{\"653\":1}}],[\"redistemplate\",{\"1\":{\"642\":2}}],[\"redis集群可以做到这样\",{\"1\":{\"638\":1}}],[\"redis3\",{\"1\":{\"626\":1,\"659\":1,\"678\":1}}],[\"redisobject\",{\"0\":{\"631\":1},\"1\":{\"617\":3}}],[\"redis5\",{\"0\":{\"616\":1}}],[\"redis\",{\"0\":{\"602\":1,\"603\":1,\"604\":1,\"605\":1,\"606\":1,\"608\":1,\"610\":1,\"611\":1,\"614\":1,\"632\":1,\"633\":1,\"635\":1,\"636\":1,\"637\":1,\"638\":1,\"646\":1,\"647\":1,\"654\":1,\"661\":1,\"665\":1,\"669\":1,\"670\":1,\"671\":1,\"674\":1,\"675\":1,\"676\":1,\"678\":1,\"680\":1,\"704\":1,\"1170\":1,\"1192\":1},\"1\":{\"434\":1,\"561\":1,\"603\":5,\"604\":10,\"606\":3,\"608\":5,\"610\":10,\"611\":2,\"614\":1,\"615\":1,\"616\":1,\"619\":1,\"622\":2,\"623\":6,\"624\":3,\"625\":1,\"626\":2,\"630\":2,\"631\":1,\"632\":3,\"635\":1,\"636\":1,\"637\":9,\"638\":3,\"640\":1,\"642\":8,\"644\":1,\"645\":1,\"646\":5,\"647\":9,\"648\":2,\"649\":6,\"650\":1,\"651\":7,\"654\":1,\"655\":4,\"656\":4,\"657\":8,\"658\":1,\"659\":10,\"660\":4,\"661\":5,\"663\":2,\"664\":1,\"665\":8,\"668\":2,\"669\":1,\"670\":1,\"671\":6,\"672\":9,\"673\":4,\"674\":3,\"675\":2,\"676\":17,\"678\":6,\"679\":3,\"683\":1,\"684\":1,\"687\":1,\"706\":1,\"707\":1,\"807\":2,\"835\":1,\"870\":1,\"882\":3,\"1170\":7,\"1192\":1,\"1242\":1}}],[\"redlock\",{\"0\":{\"672\":1},\"1\":{\"672\":1}}],[\"reds4\",{\"1\":{\"660\":1}}],[\"redo\",{\"0\":{\"568\":1,\"573\":1,\"577\":1},\"1\":{\"488\":1,\"489\":6,\"493\":1,\"519\":1,\"567\":2,\"568\":22,\"569\":1,\"570\":1,\"573\":3,\"575\":1,\"577\":1,\"578\":9,\"594\":1}}],[\"redolog\",{\"1\":{\"488\":1}}],[\"relational\",{\"1\":{\"747\":1}}],[\"relay\",{\"1\":{\"469\":2,\"470\":1,\"566\":1,\"580\":2,\"581\":1}}],[\"reload\",{\"1\":{\"647\":1,\"834\":1,\"837\":1,\"1136\":1}}],[\"release\",{\"0\":{\"1212\":1},\"1\":{\"117\":1,\"517\":3,\"1212\":1}}],[\"releaseshared\",{\"1\":{\"123\":1}}],[\"releases\",{\"1\":{\"96\":3}}],[\"revert\",{\"1\":{\"453\":1}}],[\"remote\",{\"1\":{\"450\":2,\"451\":3,\"452\":10,\"603\":1,\"801\":1,\"1121\":1}}],[\"remove方法中调用了\",{\"1\":{\"301\":1}}],[\"remove\",{\"0\":{\"301\":1},\"1\":{\"39\":1,\"45\":1,\"46\":3,\"300\":1,\"392\":1,\"393\":1,\"418\":2}}],[\"renamed\",{\"1\":{\"447\":1}}],[\"replicated\",{\"1\":{\"878\":1}}],[\"replicas\",{\"1\":{\"853\":2}}],[\"replica\",{\"1\":{\"845\":1,\"853\":1}}],[\"replay\",{\"1\":{\"470\":1,\"581\":1}}],[\"repackage\",{\"1\":{\"774\":1}}],[\"repo\",{\"1\":{\"452\":1}}],[\"repository\",{\"1\":{\"444\":2,\"743\":1,\"1121\":1,\"1239\":1}}],[\"repeatable\",{\"1\":{\"338\":1,\"499\":1,\"519\":1,\"522\":2,\"741\":2}}],[\"reactor\",{\"1\":{\"380\":1}}],[\"realization\",{\"0\":{\"1101\":1}}],[\"realsubject\",{\"1\":{\"1083\":1}}],[\"realsize\",{\"1\":{\"623\":1}}],[\"real\",{\"1\":{\"331\":2}}],[\"readme1\",{\"1\":{\"1206\":2}}],[\"readme\",{\"0\":{\"1206\":1},\"1\":{\"1206\":1}}],[\"readable\",{\"1\":{\"1035\":1}}],[\"readview\",{\"1\":{\"523\":1}}],[\"read本身也会带来其他问题\",{\"1\":{\"501\":1}}],[\"read隔离级别下\",{\"1\":{\"501\":1}}],[\"read隔离级别则每次事务只获取⼀个read\",{\"1\":{\"499\":1}}],[\"readobject\",{\"1\":{\"356\":1}}],[\"readfromnet\",{\"1\":{\"304\":1}}],[\"ready\",{\"1\":{\"148\":1}}],[\"readlock\",{\"1\":{\"115\":1}}],[\"readwritelock\",{\"1\":{\"115\":2}}],[\"read\",{\"1\":{\"73\":2,\"74\":2,\"149\":1,\"294\":1,\"295\":1,\"377\":1,\"381\":2,\"430\":2,\"499\":4,\"501\":1,\"508\":1,\"510\":1,\"519\":1,\"521\":2,\"522\":6,\"613\":2,\"741\":5,\"1006\":1,\"1087\":1,\"1177\":1}}],[\"rehashidx++\",{\"1\":{\"623\":1}}],[\"rehashidx\",{\"1\":{\"622\":2,\"623\":3}}],[\"rehash\",{\"0\":{\"615\":1},\"1\":{\"301\":2,\"623\":14}}],[\"ref=\",{\"1\":{\"1155\":1}}],[\"refused\",{\"0\":{\"1124\":1}}],[\"refresh\",{\"1\":{\"712\":1}}],[\"refs\",{\"1\":{\"450\":1,\"1170\":1}}],[\"reflog\",{\"1\":{\"449\":1}}],[\"reflect\",{\"1\":{\"174\":1,\"348\":2,\"725\":1}}],[\"references\",{\"1\":{\"462\":1,\"601\":3}}],[\"referencequeue\",{\"1\":{\"235\":3}}],[\"reference\",{\"1\":{\"229\":1,\"230\":1,\"239\":1}}],[\"ref\",{\"0\":{\"1155\":1},\"1\":{\"174\":3,\"556\":4,\"702\":1,\"1155\":5,\"1156\":1}}],[\"res\",{\"1\":{\"949\":5,\"952\":3}}],[\"restful\",{\"0\":{\"805\":1}}],[\"responsethreadpoolprocessor\",{\"1\":{\"804\":2}}],[\"responsefilter\",{\"1\":{\"804\":1}}],[\"result\",{\"1\":{\"1144\":1}}],[\"resultmap\",{\"1\":{\"751\":1}}],[\"resultmap和resulttype的区别\",{\"0\":{\"751\":1}}],[\"resulttype就比较鸡肋了\",{\"1\":{\"751\":1}}],[\"resulttype和resultmap功能类似\",{\"1\":{\"751\":1}}],[\"resulttype\",{\"1\":{\"751\":1}}],[\"resultset\",{\"1\":{\"745\":1,\"753\":1}}],[\"resize\",{\"0\":{\"402\":1},\"1\":{\"399\":1,\"402\":3,\"406\":1}}],[\"reset\",{\"1\":{\"121\":1,\"453\":5}}],[\"resource>\",{\"1\":{\"1266\":3}}],[\"resources<\",{\"1\":{\"1266\":1}}],[\"resources>\",{\"1\":{\"1266\":2}}],[\"resources\",{\"1\":{\"176\":1}}],[\"resource\",{\"1\":{\"98\":2,\"743\":1,\"1266\":1}}],[\"resource2\",{\"1\":{\"98\":3}}],[\"resource1\",{\"1\":{\"98\":3}}],[\"reentrantreadwritelock\",{\"0\":{\"125\":1},\"1\":{\"115\":2,\"125\":1}}],[\"reentrantlock的实现tryacquire方法里面不管是公平锁还是非公平锁\",{\"1\":{\"96\":1}}],[\"reentrantlock内部定义了专门的组件sync\",{\"1\":{\"95\":1}}],[\"reentrantlock实现了lock接口\",{\"1\":{\"95\":1}}],[\"reentrantlock\",{\"0\":{\"95\":1,\"96\":1},\"1\":{\"48\":1,\"68\":1,\"81\":7,\"94\":4,\"96\":1,\"98\":2,\"100\":1,\"109\":1,\"113\":3,\"115\":1,\"117\":1,\"120\":2,\"126\":1,\"128\":1,\"129\":1,\"131\":2,\"141\":1,\"142\":1,\"410\":1}}],[\"retries>1\",{\"1\":{\"866\":1}}],[\"retry\",{\"1\":{\"104\":1}}],[\"retention\",{\"1\":{\"338\":1}}],[\"returning\",{\"1\":{\"722\":1}}],[\"return\",{\"1\":{\"31\":1,\"39\":1,\"96\":2,\"101\":1,\"110\":2,\"202\":2,\"368\":1,\"383\":10,\"390\":1,\"394\":1,\"404\":1,\"405\":1,\"413\":1,\"804\":1,\"908\":1,\"911\":2,\"912\":2,\"913\":2,\"930\":1,\"932\":1,\"933\":1,\"934\":2,\"935\":7,\"936\":4,\"937\":1,\"938\":1,\"949\":3,\"952\":1,\"956\":1,\"1066\":2,\"1067\":3,\"1068\":1,\"1069\":1,\"1070\":3,\"1077\":3,\"1260\":3,\"1261\":6}}],[\"rejectedexecutionhandler\",{\"1\":{\"58\":1}}],[\"ignorecase\",{\"1\":{\"1190\":1}}],[\"i|re\",{\"1\":{\"1190\":1}}],[\"izwz9b5a76d7cz6z7r9v4gz\",{\"1\":{\"1178\":1}}],[\"i18n\",{\"1\":{\"1148\":1}}],[\"imix\",{\"1\":{\"1259\":1}}],[\"immediate\",{\"1\":{\"1157\":1}}],[\"image\",{\"1\":{\"1038\":2}}],[\"importresource\",{\"1\":{\"787\":1,\"788\":1}}],[\"import\",{\"0\":{\"1165\":1},\"1\":{\"771\":1,\"951\":2,\"952\":1,\"953\":2,\"955\":2,\"956\":4,\"1159\":1}}],[\"impl\",{\"1\":{\"736\":1}}],[\"implements\",{\"1\":{\"31\":1,\"399\":1,\"1077\":3,\"1082\":2,\"1247\":1,\"1261\":2}}],[\"icmp时间戳请求报文是请某台主机回答当前的日期和时间\",{\"1\":{\"993\":1}}],[\"icmp回送请求报文是由主机或路由器向一个特定的目的主机发出的询问\",{\"1\":{\"993\":1}}],[\"icmp报文的种类\",{\"0\":{\"993\":1}}],[\"icmp\",{\"1\":{\"992\":1}}],[\"icmp和igmp画在这一层的上部\",{\"1\":{\"983\":1}}],[\"i<r\",{\"1\":{\"954\":1}}],[\"i<n\",{\"1\":{\"951\":1}}],[\"i<j\",{\"1\":{\"935\":5}}],[\"i=0\",{\"1\":{\"951\":1,\"954\":1}}],[\"i=low\",{\"1\":{\"935\":1}}],[\"i++\",{\"1\":{\"933\":2,\"934\":3,\"935\":3,\"937\":1,\"951\":1,\"953\":1,\"954\":1,\"955\":1,\"956\":2}}],[\"i+1\",{\"1\":{\"931\":1}}],[\"itd\",{\"1\":{\"1177\":1}}],[\"it\",{\"1\":{\"888\":6,\"1134\":1,\"1177\":1,\"1178\":1}}],[\"iteartor\",{\"1\":{\"389\":1}}],[\"iterators\",{\"1\":{\"622\":1}}],[\"iterator\",{\"0\":{\"389\":1},\"1\":{\"389\":4,\"391\":4,\"957\":1}}],[\"iterable\",{\"0\":{\"389\":1},\"1\":{\"389\":2,\"391\":2}}],[\"ibdata\",{\"1\":{\"525\":1}}],[\"ix\",{\"1\":{\"514\":2}}],[\"ipv6\",{\"0\":{\"996\":1},\"1\":{\"996\":3}}],[\"ipv4\",{\"0\":{\"996\":1},\"1\":{\"996\":3}}],[\"ip层下面的每一种数据链路层协议都规定了一个数据帧中的数据字段的最大长度\",{\"1\":{\"987\":1}}],[\"ip数据报的格式\",{\"0\":{\"987\":1}}],[\"ip头\",{\"1\":{\"982\":1}}],[\"ip地址管理机构在分配ip地址时只分配网络号\",{\"1\":{\"985\":1}}],[\"ip地址的一些特点\",{\"1\":{\"984\":1}}],[\"ip地址的编址方法经过了三个历史阶段\",{\"1\":{\"983\":1}}],[\"ip地址是网络层以及以上各层使用的地址\",{\"1\":{\"981\":1}}],[\"ip地址\",{\"0\":{\"981\":1},\"1\":{\"984\":1,\"989\":1,\"991\":2,\"1049\":1}}],[\"ip地址最多有\",{\"1\":{\"892\":1}}],[\"ip协议允许ip协议在各式各样的网络构成的互联网上运行\",{\"1\":{\"964\":1}}],[\"ip协议可以为各式各样的应用提供服务\",{\"1\":{\"964\":1}}],[\"ip协议族中\",{\"1\":{\"975\":1}}],[\"ip协议族示意\",{\"1\":{\"964\":1}}],[\"ip协议族按照层次由上到下\",{\"1\":{\"964\":1}}],[\"ip协议就在这里\",{\"1\":{\"964\":1}}],[\"ip协议中\",{\"1\":{\"961\":1}}],[\"ip的有效期等信息\",{\"1\":{\"1049\":1}}],[\"ip的运输层用一个16位端口号来标志一个端口\",{\"1\":{\"1000\":1}}],[\"ip的参考模型将协议分成四个层次\",{\"1\":{\"964\":1}}],[\"ip的体系结构\",{\"0\":{\"964\":1}}],[\"ip的数目还是有限的\",{\"1\":{\"884\":1}}],[\"ip报文\",{\"1\":{\"960\":1}}],[\"ip\",{\"1\":{\"426\":1,\"612\":1,\"656\":2,\"681\":2,\"801\":3,\"811\":1,\"832\":2,\"861\":1,\"880\":1,\"892\":7,\"959\":3,\"961\":4,\"964\":2,\"981\":6,\"982\":3,\"986\":1,\"992\":4,\"994\":1,\"996\":4,\"1003\":1,\"1029\":3,\"1031\":3,\"1060\":4}}],[\"ipc\",{\"1\":{\"149\":2}}],[\"i\",{\"0\":{\"137\":1},\"1\":{\"134\":1,\"135\":1,\"137\":4,\"209\":1,\"368\":3,\"380\":5,\"381\":6,\"423\":1,\"424\":1,\"425\":1,\"440\":1,\"470\":1,\"535\":1,\"581\":1,\"604\":1,\"930\":4,\"931\":11,\"932\":7,\"933\":10,\"934\":1,\"935\":13,\"937\":10,\"951\":2,\"953\":3,\"954\":1,\"955\":3,\"956\":13,\"1184\":1,\"1190\":1}}],[\"id对应的任务状态\",{\"1\":{\"863\":1}}],[\"id获得原来的pid\",{\"1\":{\"863\":1}}],[\"id进行绑定\",{\"1\":{\"863\":1}}],[\"ids\",{\"1\":{\"861\":1}}],[\"id<=0\",{\"1\":{\"641\":1}}],[\"id指向父评论\",{\"1\":{\"601\":1}}],[\"id问题\",{\"1\":{\"589\":1}}],[\"id分别为1\",{\"1\":{\"553\":1}}],[\"id列上有一个非唯一索引\",{\"1\":{\"501\":1}}],[\"id无索引时\",{\"1\":{\"501\":2}}],[\"id为主键时\",{\"1\":{\"501\":1}}],[\"id为非唯一索引时\",{\"1\":{\"501\":2}}],[\"id为唯一索引时\",{\"1\":{\"501\":2}}],[\"id为为主键时\",{\"1\":{\"501\":1}}],[\"id隐藏主键等字段\",{\"1\":{\"499\":1}}],[\"id最近插入的事务id\",{\"1\":{\"499\":1}}],[\"idb\",{\"1\":{\"493\":1}}],[\"id=\",{\"1\":{\"713\":1,\"734\":1,\"736\":1}}],[\"id=1\",{\"1\":{\"559\":1}}],[\"id=2\",{\"1\":{\"489\":3,\"573\":1}}],[\"id=n\",{\"1\":{\"468\":2}}],[\"idea\",{\"1\":{\"1269\":3,\"1270\":1,\"1273\":1}}],[\"idea中也有一个插件\",{\"1\":{\"313\":1}}],[\"idempotence=true\",{\"1\":{\"866\":1}}],[\"idempotence=true即可\",{\"1\":{\"856\":1}}],[\"idempotence\",{\"1\":{\"863\":1}}],[\"identity\",{\"1\":{\"88\":1}}],[\"id\",{\"0\":{\"466\":1},\"1\":{\"88\":2,\"98\":1,\"136\":1,\"144\":1,\"156\":1,\"227\":1,\"462\":1,\"466\":1,\"468\":4,\"482\":1,\"484\":9,\"485\":7,\"486\":7,\"489\":1,\"499\":3,\"501\":5,\"523\":1,\"539\":1,\"548\":1,\"555\":1,\"556\":3,\"557\":1,\"558\":1,\"559\":3,\"588\":1,\"641\":2,\"751\":1,\"801\":2,\"804\":5,\"807\":6,\"820\":12,\"847\":1,\"863\":2,\"865\":1,\"1042\":2,\"1052\":1,\"1117\":1,\"1202\":1,\"1219\":1,\"1245\":1}}],[\"illegalaccesserror异常\",{\"1\":{\"278\":1}}],[\"illegalargumentexception\",{\"1\":{\"58\":1,\"349\":1,\"385\":1,\"1260\":1,\"1261\":2}}],[\"illegalmonitorstateexception\",{\"1\":{\"96\":1}}],[\"illegalmonitorstateexception的异常的原因\",{\"1\":{\"85\":1}}],[\"illegalmonitorstateexception的异常\",{\"1\":{\"35\":1}}],[\"ifconfig\",{\"1\":{\"426\":2,\"435\":1}}],[\"if\",{\"0\":{\"76\":1,\"77\":1},\"1\":{\"58\":2,\"71\":1,\"76\":4,\"77\":1,\"96\":5,\"101\":4,\"601\":1,\"669\":1,\"908\":7,\"911\":3,\"912\":4,\"913\":4,\"930\":3,\"932\":2,\"933\":1,\"934\":2,\"935\":7,\"936\":6,\"937\":2,\"949\":3,\"955\":1,\"956\":3,\"1067\":6,\"1068\":3,\"1077\":4,\"1088\":1,\"1257\":1,\"1260\":1,\"1261\":2}}],[\"ioexception\",{\"1\":{\"956\":2}}],[\"io就借鉴了linux\",{\"1\":{\"829\":1}}],[\"ioc注入\",{\"1\":{\"733\":1}}],[\"ioc的灵活性是有代价的\",{\"1\":{\"731\":1}}],[\"ioc的一个重点是在系统运行中\",{\"1\":{\"718\":1}}],[\"ioc与工厂模式区别\",{\"0\":{\"731\":1}}],[\"ioc好处\",{\"1\":{\"718\":1}}],[\"ioc容器负责创建对象\",{\"1\":{\"718\":1}}],[\"ioc容器就像是一个工厂一样\",{\"1\":{\"718\":1}}],[\"ioc容器可以理解为一个对象工厂\",{\"1\":{\"718\":1}}],[\"ioc容易管理对象\",{\"1\":{\"718\":1}}],[\"ioc\",{\"0\":{\"718\":1},\"1\":{\"718\":5,\"770\":2,\"771\":1}}],[\"io操作变多\",{\"1\":{\"585\":1}}],[\"io瓶颈\",{\"1\":{\"584\":1,\"585\":1}}],[\"io性能瓶颈怎么解决\",{\"0\":{\"563\":1}}],[\"io\",{\"0\":{\"375\":1,\"376\":1,\"377\":1,\"381\":1,\"611\":1},\"1\":{\"57\":3,\"64\":2,\"136\":1,\"137\":2,\"138\":1,\"148\":1,\"377\":5,\"379\":9,\"380\":32,\"381\":1,\"466\":1,\"539\":2,\"541\":1,\"558\":2,\"560\":1,\"571\":1,\"583\":1,\"604\":6,\"610\":3,\"611\":2,\"613\":1,\"643\":1,\"656\":1,\"829\":1,\"835\":1,\"916\":3,\"919\":2,\"956\":3,\"1144\":1,\"1197\":2}}],[\"inject\",{\"1\":{\"1159\":1}}],[\"injection\",{\"1\":{\"718\":1}}],[\"input\",{\"1\":{\"1144\":1}}],[\"inputstream\",{\"1\":{\"1087\":3}}],[\"inputstreamreader\",{\"1\":{\"956\":1}}],[\"includes>\",{\"1\":{\"1266\":3}}],[\"include>\",{\"1\":{\"1266\":5}}],[\"include\",{\"1\":{\"1144\":1,\"1168\":1}}],[\"increment\",{\"1\":{\"601\":1}}],[\"ini\",{\"1\":{\"701\":1,\"1143\":1}}],[\"inittab\",{\"1\":{\"416\":1}}],[\"initializingbean接口\",{\"1\":{\"737\":1}}],[\"initialheapsize\",{\"1\":{\"315\":1}}],[\"initialvalue\",{\"1\":{\"39\":2}}],[\"initiatingheapoccupancypercent\",{\"1\":{\"262\":1}}],[\"init\",{\"1\":{\"39\":1,\"151\":2,\"416\":1,\"445\":2,\"759\":2,\"1159\":2}}],[\"in可以乱序\",{\"1\":{\"533\":1}}],[\"inner\",{\"1\":{\"485\":1}}],[\"innodb用缓冲池\",{\"1\":{\"594\":1}}],[\"innodb用它\",{\"1\":{\"505\":1}}],[\"innodb的策略是尽量使用内存\",{\"1\":{\"594\":1}}],[\"innodb的redo\",{\"1\":{\"594\":1}}],[\"innodb的逻辑存储结构\",{\"0\":{\"498\":1}}],[\"innodb特有\",{\"1\":{\"568\":1,\"570\":1}}],[\"innodb就可以保证即使数据库发生异常重启\",{\"1\":{\"568\":1}}],[\"innodb在处理更新语句时\",{\"1\":{\"559\":1}}],[\"innodb中辅助索引叶子节点存储的不再是行的物理位置\",{\"1\":{\"548\":1}}],[\"innodb中的辅助索引\",{\"1\":{\"547\":1}}],[\"innodb加锁规则\",{\"0\":{\"515\":1}}],[\"innodb根据唯一索引\",{\"1\":{\"506\":1}}],[\"innodb工作在可重复读隔离级别下\",{\"1\":{\"505\":1}}],[\"innodb是面向列的\",{\"1\":{\"498\":1}}],[\"innodb存储引擎页的大小为16kb\",{\"1\":{\"498\":1}}],[\"innodb存储引擎一次从磁盘申请4~5个区\",{\"1\":{\"498\":1}}],[\"innodb索引的后台线程\",{\"0\":{\"497\":1}}],[\"innodb会将这些更新操作缓存在change\",{\"1\":{\"574\":1}}],[\"innodb会检测该页所在区的所有页\",{\"1\":{\"496\":1}}],[\"innodb会监控对表上各索引页的查询\",{\"1\":{\"496\":1}}],[\"innodb引擎的关键特性\",{\"0\":{\"496\":1}}],[\"innodb对普通\",{\"1\":{\"495\":1}}],[\"innodb都使用了这种算法\",{\"1\":{\"495\":1}}],[\"innodb\",{\"0\":{\"491\":1,\"493\":1,\"502\":1},\"1\":{\"466\":1,\"468\":4,\"484\":1,\"488\":4,\"489\":2,\"493\":2,\"498\":1,\"514\":2,\"516\":4,\"519\":3,\"528\":1,\"537\":1,\"539\":2,\"545\":4,\"546\":2,\"547\":1,\"549\":1,\"563\":1,\"567\":1,\"568\":4,\"569\":2,\"577\":3,\"582\":3,\"591\":1,\"700\":1,\"1177\":6}}],[\"in中的sql查询只会查询一次\",{\"1\":{\"482\":1}}],[\"in\",{\"0\":{\"482\":1},\"1\":{\"482\":2,\"500\":1,\"501\":1,\"509\":1,\"514\":1,\"556\":1,\"559\":1,\"560\":2,\"853\":2,\"891\":1,\"940\":1,\"941\":1,\"951\":1,\"952\":1,\"953\":1,\"954\":1,\"955\":1}}],[\"insensitive\",{\"1\":{\"1190\":1}}],[\"inset\",{\"1\":{\"625\":2}}],[\"insertsort\",{\"1\":{\"932\":1}}],[\"insert\",{\"1\":{\"492\":1,\"496\":1,\"501\":1,\"523\":1,\"565\":4,\"574\":3,\"668\":2,\"807\":1,\"1119\":1}}],[\"insert和update操作时使用自增id的性能比uuid好\",{\"1\":{\"467\":1}}],[\"install\",{\"1\":{\"458\":1,\"793\":1,\"1144\":6,\"1168\":2,\"1184\":1,\"1212\":3}}],[\"instance\",{\"1\":{\"71\":1,\"101\":7,\"657\":1,\"714\":1,\"1069\":2,\"1070\":4}}],[\"instruction\",{\"1\":{\"193\":1}}],[\"inode\",{\"1\":{\"427\":7}}],[\"inherited\",{\"1\":{\"338\":1}}],[\"inheritance\",{\"1\":{\"184\":1}}],[\"index文件中并没有为数据文件中的每条message建立索引\",{\"1\":{\"848\":1}}],[\"index文件是索引文件\",{\"1\":{\"846\":1}}],[\"index是否缺失\",{\"1\":{\"562\":1}}],[\"index2\",{\"1\":{\"554\":1}}],[\"index1\",{\"1\":{\"554\":1}}],[\"index强行选择一个索引\",{\"1\":{\"536\":1}}],[\"index可以看到一个索引的基数\",{\"1\":{\"536\":1}}],[\"indexfor\",{\"1\":{\"404\":2}}],[\"indexoutofboundsexception\",{\"1\":{\"385\":1}}],[\"index\",{\"0\":{\"1206\":1},\"1\":{\"289\":2,\"290\":2,\"391\":1,\"392\":1,\"397\":1,\"398\":1,\"427\":1,\"444\":1,\"527\":5,\"546\":1,\"554\":2,\"556\":3,\"591\":1,\"702\":2,\"875\":2,\"937\":16,\"1121\":1,\"1143\":1,\"1206\":3,\"1210\":1}}],[\"inference\",{\"1\":{\"1144\":2}}],[\"info\",{\"1\":{\"292\":1,\"657\":2,\"677\":1,\"774\":1}}],[\"info类型的常量来表示\",{\"1\":{\"291\":1}}],[\"info类型的常量中的全限定名字符串\",{\"1\":{\"288\":1}}],[\"info类型的常量中的索引值可以找到定义在constant\",{\"1\":{\"288\":1}}],[\"info的类描述符常量\",{\"1\":{\"288\":1}}],[\"inf\",{\"1\":{\"185\":2,\"771\":1,\"790\":1}}],[\"invocationhandler接口\",{\"1\":{\"725\":1}}],[\"invocationhandler通过invoke\",{\"1\":{\"715\":1,\"725\":1}}],[\"invocationhandler\",{\"1\":{\"349\":9,\"804\":1}}],[\"invoke中的invoke\",{\"1\":{\"725\":1}}],[\"invoke方法可以实现代理逻辑\",{\"1\":{\"725\":1}}],[\"invoke是代理逻辑的实现方法\",{\"1\":{\"725\":1}}],[\"invokedynamic\",{\"1\":{\"274\":1}}],[\"invokeinterface\",{\"1\":{\"274\":1}}],[\"invokevirtual指令的运行时解析过程大致分为以下几步\",{\"1\":{\"278\":1}}],[\"invokevirtual\",{\"1\":{\"274\":1}}],[\"invokesprecial\",{\"1\":{\"274\":1}}],[\"invokestatic\",{\"1\":{\"174\":1,\"274\":1}}],[\"invoke\",{\"1\":{\"174\":1,\"348\":1,\"349\":3,\"801\":1,\"804\":2}}],[\"invalid\",{\"1\":{\"71\":1,\"72\":12}}],[\"intro\",{\"0\":{\"1121\":1,\"1138\":1,\"1208\":1,\"1249\":1}}],[\"ints\",{\"1\":{\"955\":5}}],[\"intset\",{\"0\":{\"625\":1},\"1\":{\"619\":2,\"625\":1}}],[\"int值\",{\"1\":{\"901\":1}}],[\"int的整数\",{\"0\":{\"901\":1}}],[\"into\",{\"1\":{\"565\":3,\"1119\":1}}],[\"int和char可以互换\",{\"1\":{\"367\":1}}],[\"int\",{\"0\":{\"368\":1,\"476\":1},\"1\":{\"58\":2,\"81\":1,\"96\":6,\"110\":6,\"111\":1,\"120\":1,\"123\":1,\"124\":1,\"134\":2,\"227\":1,\"368\":7,\"390\":1,\"392\":1,\"394\":3,\"404\":3,\"405\":4,\"472\":2,\"476\":2,\"539\":1,\"624\":2,\"804\":7,\"886\":1,\"903\":1,\"911\":5,\"912\":5,\"913\":5,\"930\":4,\"931\":8,\"932\":7,\"933\":11,\"934\":15,\"935\":30,\"936\":16,\"937\":14,\"938\":3,\"947\":2,\"949\":1,\"951\":6,\"952\":1,\"953\":2,\"954\":6,\"955\":6,\"956\":5,\"997\":1,\"1077\":2}}],[\"integration\",{\"0\":{\"1270\":1}}],[\"integerfunnel\",{\"1\":{\"882\":1}}],[\"integerserializer\",{\"1\":{\"867\":1}}],[\"integercache\",{\"1\":{\"368\":2}}],[\"integer\",{\"0\":{\"368\":1},\"1\":{\"31\":1,\"56\":1,\"62\":1,\"368\":19,\"390\":1,\"755\":1,\"952\":1,\"955\":1}}],[\"intercept\",{\"1\":{\"1084\":1}}],[\"interceptor\",{\"1\":{\"759\":1}}],[\"internet\",{\"1\":{\"996\":1,\"1042\":1}}],[\"internal\",{\"1\":{\"181\":1}}],[\"interval2\",{\"1\":{\"938\":4}}],[\"interval1\",{\"1\":{\"938\":4}}],[\"interger\",{\"1\":{\"390\":1}}],[\"intergenerational\",{\"1\":{\"239\":1}}],[\"interfaces\",{\"1\":{\"349\":2}}],[\"interface\",{\"1\":{\"185\":2,\"349\":1,\"825\":1,\"1077\":1,\"1082\":1,\"1255\":1,\"1256\":1,\"1260\":1}}],[\"interprocess\",{\"1\":{\"149\":1}}],[\"interrupt\",{\"1\":{\"59\":1,\"75\":1,\"98\":1,\"102\":2,\"350\":1}}],[\"interrupted\",{\"1\":{\"35\":1,\"37\":1,\"102\":1}}],[\"interruptedexception\",{\"1\":{\"31\":1,\"98\":1,\"126\":2,\"350\":1}}],[\"issuer\",{\"1\":{\"1144\":1}}],[\"isempty\",{\"1\":{\"908\":1,\"1261\":1}}],[\"isr队列中最小的leo\",{\"1\":{\"855\":1}}],[\"isr\",{\"0\":{\"853\":1},\"1\":{\"853\":1}}],[\"ismale=1\",{\"1\":{\"553\":1}}],[\"isolation\",{\"1\":{\"519\":1,\"741\":5}}],[\"isinstance\",{\"1\":{\"166\":1}}],[\"isinterrupted\",{\"1\":{\"102\":1}}],[\"isassignablefrom\",{\"1\":{\"166\":1}}],[\"isalive\",{\"1\":{\"75\":1,\"102\":2}}],[\"isheldexclusively\",{\"1\":{\"109\":1}}],[\"is\",{\"1\":{\"18\":1,\"482\":1,\"514\":2,\"888\":6,\"891\":1,\"1100\":1,\"1266\":1}}],[\"fname=\",{\"1\":{\"537\":1}}],[\"fk\",{\"1\":{\"462\":1}}],[\"fk+unique\",{\"1\":{\"455\":1}}],[\"fec\",{\"1\":{\"1042\":3}}],[\"fetch\",{\"1\":{\"452\":1}}],[\"feature\",{\"1\":{\"449\":1,\"1126\":1,\"1127\":4}}],[\"found\",{\"1\":{\"1275\":1}}],[\"follewer\",{\"1\":{\"820\":1}}],[\"following\",{\"1\":{\"820\":1}}],[\"follower会读取本地磁盘记录的上次的hw\",{\"1\":{\"855\":1}}],[\"follower发生故障后会被临时踢出isr\",{\"1\":{\"855\":1}}],[\"follower故障\",{\"1\":{\"855\":1}}],[\"follower故障和leader故障\",{\"1\":{\"855\":1}}],[\"follower\",{\"1\":{\"819\":1,\"820\":3,\"845\":1,\"874\":4,\"875\":1,\"876\":1,\"877\":3,\"878\":2}}],[\"follow\",{\"1\":{\"449\":1}}],[\"forge\",{\"1\":{\"1143\":1}}],[\"forward\",{\"1\":{\"758\":1}}],[\"foreign\",{\"1\":{\"462\":2,\"601\":3}}],[\"force\",{\"1\":{\"424\":1,\"425\":1,\"452\":1}}],[\"for\",{\"1\":{\"282\":1,\"391\":11,\"500\":1,\"501\":1,\"509\":1,\"514\":1,\"558\":1,\"927\":1,\"930\":2,\"931\":2,\"932\":2,\"933\":6,\"934\":1,\"935\":1,\"937\":1,\"951\":1,\"952\":1,\"953\":1,\"954\":2,\"955\":2,\"956\":2,\"1119\":1,\"1178\":1}}],[\"forname\",{\"0\":{\"183\":1},\"1\":{\"174\":1,\"183\":2,\"339\":1,\"348\":2,\"356\":1}}],[\"forking\",{\"1\":{\"813\":1}}],[\"fork\",{\"0\":{\"49\":1},\"1\":{\"49\":2,\"647\":5,\"648\":1,\"651\":1}}],[\"format\",{\"1\":{\"953\":1,\"1151\":1,\"1260\":1,\"1261\":2}}],[\"form\",{\"1\":{\"26\":1}}],[\"fdisk\",{\"1\":{\"441\":2}}],[\"fd\",{\"1\":{\"381\":12}}],[\"flood\",{\"1\":{\"1054\":1,\"1060\":2}}],[\"float\",{\"1\":{\"368\":1,\"473\":2}}],[\"flushdns\",{\"1\":{\"1124\":1}}],[\"flushlog\",{\"1\":{\"582\":1}}],[\"flush\",{\"1\":{\"508\":1,\"563\":1,\"568\":1,\"582\":2,\"592\":1,\"1177\":1}}],[\"flags=0\",{\"1\":{\"1188\":1}}],[\"flag<name>=<value><pid>设置非boolean类型参数\",{\"1\":{\"317\":1}}],[\"flag\",{\"1\":{\"253\":1,\"289\":1,\"290\":1,\"317\":1,\"930\":5,\"1144\":1,\"1188\":1}}],[\"funnels\",{\"1\":{\"882\":1}}],[\"full\",{\"0\":{\"330\":1},\"1\":{\"220\":1,\"240\":1,\"263\":1,\"309\":1,\"441\":1,\"951\":1}}],[\"futuretask\",{\"1\":{\"33\":1}}],[\"futuretask<>\",{\"1\":{\"31\":1}}],[\"futuretask<integer>\",{\"1\":{\"31\":1}}],[\"future\",{\"1\":{\"31\":1,\"33\":1,\"61\":2}}],[\"frozen\",{\"1\":{\"1202\":1}}],[\"from\",{\"0\":{\"1165\":1},\"1\":{\"200\":1,\"481\":2,\"482\":2,\"484\":1,\"485\":4,\"486\":5,\"487\":1,\"501\":3,\"514\":2,\"527\":1,\"537\":1,\"553\":1,\"555\":1,\"556\":2,\"559\":2,\"601\":1,\"703\":2,\"745\":2,\"1144\":1,\"1159\":1,\"1209\":2}}],[\"fragment\",{\"1\":{\"987\":2}}],[\"frequently\",{\"1\":{\"633\":1}}],[\"freemarker\",{\"1\":{\"755\":1,\"756\":1}}],[\"free\",{\"1\":{\"96\":3,\"153\":1,\"436\":1,\"624\":4,\"1143\":1}}],[\"frm\",{\"1\":{\"493\":1,\"494\":1}}],[\"fcfs\",{\"1\":{\"150\":1,\"163\":2}}],[\"faststone\",{\"0\":{\"1130\":1}}],[\"fastleaderelection\",{\"1\":{\"820\":2}}],[\"facade\",{\"1\":{\"1090\":1}}],[\"factory\",{\"1\":{\"1083\":2,\"1247\":1}}],[\"factories文件\",{\"1\":{\"773\":1}}],[\"factories\",{\"1\":{\"771\":1}}],[\"fatal\",{\"1\":{\"1144\":1,\"1168\":1}}],[\"fat\",{\"1\":{\"442\":1}}],[\"failed\",{\"1\":{\"1266\":1}}],[\"failures\",{\"1\":{\"879\":1}}],[\"failure时使用\",{\"1\":{\"256\":1}}],[\"failback\",{\"1\":{\"813\":1}}],[\"failsafe\",{\"1\":{\"813\":1}}],[\"failfast\",{\"1\":{\"813\":1}}],[\"fail\",{\"1\":{\"659\":2}}],[\"failover\",{\"1\":{\"657\":2,\"660\":1,\"678\":1,\"813\":1}}],[\"fair\",{\"1\":{\"125\":1,\"832\":1}}],[\"false\",{\"1\":{\"96\":2,\"102\":1,\"117\":1,\"368\":1,\"413\":1,\"759\":1,\"882\":1,\"930\":2,\"956\":1}}],[\"filtering>\",{\"1\":{\"1266\":3}}],[\"filter映射为这340亿bit\",{\"1\":{\"896\":1}}],[\"filter可以看做是对bit\",{\"1\":{\"883\":1}}],[\"filter\",{\"1\":{\"759\":5,\"804\":3,\"881\":1,\"882\":7,\"896\":2,\"1260\":1}}],[\"filter接口\",{\"1\":{\"759\":1}}],[\"fileinputstream\",{\"1\":{\"1087\":1}}],[\"file声明周期不同\",{\"1\":{\"864\":1}}],[\"filed\",{\"1\":{\"622\":1}}],[\"filename\",{\"1\":{\"449\":2}}],[\"file2\",{\"1\":{\"447\":2,\"448\":2}}],[\"file1\",{\"1\":{\"447\":2,\"448\":2}}],[\"file\",{\"0\":{\"649\":1},\"1\":{\"418\":2,\"433\":1,\"447\":3,\"449\":5,\"453\":3,\"559\":1,\"568\":1,\"701\":1,\"1144\":1,\"1168\":1,\"1177\":2}}],[\"filesystemxmlapplicationcontext\",{\"1\":{\"736\":1}}],[\"filesystemxmlapplication\",{\"1\":{\"712\":1}}],[\"filesort\",{\"1\":{\"702\":1}}],[\"files\",{\"1\":{\"418\":1,\"1177\":3}}],[\"fileoutputstream\",{\"1\":{\"344\":1}}],[\"fix加上文件名appendonly\",{\"1\":{\"651\":1}}],[\"fiu\",{\"1\":{\"425\":1}}],[\"fir\",{\"1\":{\"424\":1}}],[\"first\",{\"1\":{\"260\":1,\"449\":1,\"940\":1,\"941\":2}}],[\"field\",{\"1\":{\"348\":2,\"622\":1}}],[\"fin报文段即使不携带数据\",{\"1\":{\"1026\":1}}],[\"fin\",{\"1\":{\"1026\":4}}],[\"findfirst\",{\"1\":{\"1260\":1}}],[\"findkthlargest\",{\"1\":{\"936\":1}}],[\"find\",{\"0\":{\"1212\":1},\"1\":{\"424\":1,\"434\":1,\"1212\":1}}],[\"findclass\",{\"1\":{\"182\":1,\"185\":1}}],[\"final方法\",{\"1\":{\"194\":1}}],[\"finally或者其他方式都可以做得更好\",{\"1\":{\"236\":1}}],[\"finally\",{\"0\":{\"346\":1,\"383\":1},\"1\":{\"94\":1,\"126\":2,\"346\":2,\"383\":10}}],[\"finalize\",{\"0\":{\"346\":1},\"1\":{\"75\":1,\"102\":1,\"236\":2,\"346\":2,\"350\":2}}],[\"final\",{\"0\":{\"346\":1,\"371\":1},\"1\":{\"67\":1,\"96\":2,\"101\":1,\"110\":3,\"174\":1,\"295\":3,\"346\":1,\"350\":1,\"355\":2,\"362\":2,\"370\":5,\"371\":1,\"405\":1,\"1066\":1,\"1069\":1,\"1245\":1,\"1261\":4}}],[\"fifo\",{\"1\":{\"109\":2,\"110\":1,\"117\":1,\"122\":2,\"149\":2,\"160\":1,\"612\":1,\"941\":1}}],[\"f\",{\"0\":{\"1205\":1,\"1211\":1,\"1244\":1},\"1\":{\"94\":1,\"131\":1,\"424\":2,\"425\":1,\"426\":1,\"429\":1,\"501\":1,\"537\":1,\"922\":3,\"923\":2}}],[\"fsync\",{\"1\":{\"568\":2,\"649\":1}}],[\"fstab\",{\"1\":{\"416\":1}}],[\"fs\",{\"1\":{\"94\":1}}],[\"fttx技术\",{\"1\":{\"968\":1}}],[\"ftwrl\",{\"1\":{\"508\":1}}],[\"ft\",{\"1\":{\"31\":3}}],[\"创建优化后的mysql配置文件\",{\"1\":{\"1177\":1}}],[\"创建配置目录与优化配置文件\",{\"1\":{\"1177\":1}}],[\"创建虚拟环境\",{\"1\":{\"1144\":1}}],[\"创建头节点\",{\"1\":{\"955\":1}}],[\"创建了一个最多存放最多\",{\"1\":{\"882\":1}}],[\"创建日志\",{\"1\":{\"874\":1}}],[\"创建独立的spring应用程序\",{\"1\":{\"767\":1}}],[\"创建连接\",{\"1\":{\"746\":1}}],[\"创建数据库操作对象\",{\"1\":{\"744\":1}}],[\"创建后spring将不再对其管理\",{\"1\":{\"734\":1}}],[\"创建后尚未启动\",{\"1\":{\"38\":1}}],[\"创建工厂类\",{\"1\":{\"729\":1}}],[\"创建表\",{\"0\":{\"599\":1}}],[\"创建索引和维护索引需要耗费许多时间\",{\"1\":{\"528\":1}}],[\"创建和删除标签都是瞬间完成的\",{\"1\":{\"450\":1}}],[\"创建新目录\",{\"0\":{\"422\":1}}],[\"创建新的对象\",{\"1\":{\"348\":1}}],[\"创建一个枚举对象\",{\"1\":{\"1070\":1}}],[\"创建一个新的事务\",{\"1\":{\"740\":1}}],[\"创建一个新的目录\",{\"1\":{\"418\":1}}],[\"创建一个新的\",{\"1\":{\"406\":1}}],[\"创建一个新的对象\",{\"1\":{\"343\":1}}],[\"创建一个长度为\",{\"1\":{\"399\":1}}],[\"创建的代理对象是在\",{\"1\":{\"349\":1}}],[\"创建的字节流是与平台无关的\",{\"1\":{\"344\":1}}],[\"创建对象时耗时过多或者耗资源过多\",{\"1\":{\"1073\":1}}],[\"创建对象是为了使用对象\",{\"1\":{\"228\":1}}],[\"创建对象的步骤\",{\"0\":{\"213\":1}}],[\"创建对象的方式\",{\"0\":{\"212\":1}}],[\"创建状态\",{\"1\":{\"148\":1}}],[\"创建元素时可以指定多久才能从队列中获取当前元素\",{\"1\":{\"62\":1}}],[\"创建并赋初始值\",{\"1\":{\"39\":1}}],[\"创建\",{\"0\":{\"59\":1},\"1\":{\"39\":1,\"56\":1,\"59\":1,\"399\":1,\"623\":1,\"712\":1,\"729\":1,\"742\":1,\"746\":1,\"804\":1,\"1127\":1,\"1198\":1}}],[\"创建线程\",{\"1\":{\"31\":1}}],[\"创建线程的四种方式\",{\"0\":{\"31\":1}}],[\"创建任务对象\",{\"1\":{\"31\":1}}],[\"pyconfig\",{\"1\":{\"1144\":1}}],[\"py\",{\"1\":{\"1144\":2}}],[\"pyopenssl\",{\"1\":{\"1144\":3}}],[\"pypi\",{\"1\":{\"1143\":1,\"1184\":1}}],[\"pytorch\",{\"1\":{\"1108\":1,\"1145\":1}}],[\"pythonlearning\",{\"1\":{\"1206\":1}}],[\"python=3\",{\"1\":{\"1144\":2}}],[\"python\",{\"0\":{\"1180\":1,\"1187\":1},\"1\":{\"194\":1,\"825\":1,\"1108\":1,\"1144\":2}}],[\"pkgs\",{\"1\":{\"1143\":2}}],[\"pp\",{\"1\":{\"1082\":2}}],[\"ppp链路的两端的网络控制协议ncp根据网络层的不同协议互相交换网络层特定的网络控制分组\",{\"1\":{\"975\":1}}],[\"ppp协议两端的网络层可以运行不同的网络层协议\",{\"1\":{\"975\":1}}],[\"ppp协议的工作状态\",{\"1\":{\"975\":1}}],[\"ppp协议的帧格式\",{\"1\":{\"975\":1}}],[\"ppp协议的组成\",{\"1\":{\"975\":1}}],[\"ppp协议只支持全双工链路\",{\"1\":{\"975\":1}}],[\"ppp协议不支持多点线路\",{\"1\":{\"975\":1}}],[\"ppp协议应满足的要求\",{\"1\":{\"975\":1}}],[\"ppp协议是用户计算机与isp进行通信时所使用的的数据链路层协议\",{\"1\":{\"975\":1}}],[\"pc1\",{\"1\":{\"986\":6}}],[\"pc0\",{\"1\":{\"986\":4}}],[\"pcb\",{\"0\":{\"136\":1},\"1\":{\"136\":7,\"147\":3,\"156\":2}}],[\"p≤m\",{\"1\":{\"923\":1}}],[\"plantuml\",{\"0\":{\"1269\":1,\"1270\":1,\"1271\":1,\"1272\":1},\"1\":{\"1269\":4,\"1271\":7}}],[\"plant\",{\"0\":{\"1267\":1}}],[\"platform\",{\"1\":{\"181\":1}}],[\"plus\",{\"1\":{\"1117\":1}}],[\"plugins\",{\"0\":{\"1149\":1},\"1\":{\"1136\":1}}],[\"plugins>\",{\"1\":{\"790\":1}}],[\"plugins<\",{\"1\":{\"790\":1}}],[\"plugin>\",{\"1\":{\"790\":2}}],[\"plugin<\",{\"1\":{\"790\":2}}],[\"plugin\",{\"0\":{\"774\":1},\"1\":{\"774\":1,\"1139\":1,\"1209\":1}}],[\"pdf等等\",{\"1\":{\"755\":1}}],[\"pdr\",{\"1\":{\"423\":1}}],[\"perform\",{\"1\":{\"1190\":1}}],[\"person\",{\"1\":{\"1100\":1}}],[\"percentage\",{\"1\":{\"708\":1}}],[\"peter\",{\"1\":{\"537\":4}}],[\"peeklast\",{\"1\":{\"394\":1}}],[\"peekfirst\",{\"1\":{\"394\":1}}],[\"peek\",{\"1\":{\"394\":2}}],[\"phantom\",{\"1\":{\"521\":1}}],[\"phantomreference\",{\"1\":{\"235\":1}}],[\"pth\",{\"1\":{\"1144\":1}}],[\"pthread\",{\"1\":{\"62\":1}}],[\"ptr\",{\"1\":{\"617\":1}}],[\"ptr回滚指针\",{\"1\":{\"499\":1}}],[\"pip镜像源配置文件位置\",{\"1\":{\"1143\":1}}],[\"pip镜像源\",{\"1\":{\"1143\":1}}],[\"pip\",{\"1\":{\"1143\":4,\"1144\":7,\"1184\":1}}],[\"pinia2\",{\"1\":{\"1148\":1}}],[\"pinia\",{\"1\":{\"687\":1,\"1148\":1}}],[\"ping是应用层直接使用网络层icmp的一个例子\",{\"1\":{\"994\":1}}],[\"ping使用了icmp回送请求与回送回答报文\",{\"1\":{\"994\":1}}],[\"ping\",{\"0\":{\"994\":1},\"1\":{\"435\":1,\"657\":3,\"659\":1,\"660\":1,\"677\":3,\"683\":2}}],[\"pick\",{\"1\":{\"451\":1}}],[\"pid在重启之后会发生变化\",{\"1\":{\"856\":1}}],[\"pid\",{\"1\":{\"136\":1,\"156\":1,\"426\":1,\"436\":1}}],[\"psubscribe\",{\"1\":{\"673\":2}}],[\"psync\",{\"1\":{\"662\":2,\"675\":1}}],[\"ps\",{\"1\":{\"426\":15,\"436\":2,\"1242\":4}}],[\"psw\",{\"1\":{\"134\":1}}],[\"p\",{\"1\":{\"418\":2,\"421\":2,\"422\":2,\"423\":1,\"435\":1,\"447\":1,\"449\":1,\"459\":1,\"870\":1,\"923\":1,\"955\":4,\"1177\":5,\"1178\":1,\"1192\":1}}],[\"pwd\",{\"0\":{\"421\":1},\"1\":{\"418\":1,\"421\":1,\"1177\":3}}],[\"pq\",{\"1\":{\"394\":1}}],[\"pom\",{\"0\":{\"1265\":1},\"1\":{\"1266\":2}}],[\"port\",{\"0\":{\"1124\":1},\"1\":{\"1003\":1,\"1177\":1}}],[\"povit+1\",{\"1\":{\"936\":1}}],[\"povit<len\",{\"1\":{\"936\":1}}],[\"povit=nums\",{\"1\":{\"936\":1}}],[\"povit==len\",{\"1\":{\"936\":1}}],[\"povit=partition\",{\"1\":{\"936\":1}}],[\"povit\",{\"1\":{\"935\":7,\"936\":1}}],[\"postrequest\",{\"1\":{\"1083\":1}}],[\"post和get的区别与应用场景\",{\"0\":{\"1041\":1}}],[\"post\",{\"1\":{\"1038\":1,\"1040\":1,\"1041\":7}}],[\"posthandle\",{\"1\":{\"759\":1}}],[\"postprocessbeforeinitialization\",{\"1\":{\"733\":1}}],[\"possible\",{\"1\":{\"556\":1}}],[\"pointcut\",{\"1\":{\"721\":3}}],[\"poc\",{\"1\":{\"690\":1,\"696\":2}}],[\"pong\",{\"1\":{\"683\":1}}],[\"pop3协议等\",{\"1\":{\"1062\":1}}],[\"pop\",{\"1\":{\"394\":1,\"453\":1,\"908\":4}}],[\"polllast\",{\"1\":{\"394\":1}}],[\"pollfirst\",{\"1\":{\"394\":1}}],[\"poll\",{\"1\":{\"381\":4,\"394\":1,\"612\":3}}],[\"pool<\",{\"1\":{\"799\":1}}],[\"pool\",{\"0\":{\"495\":1},\"1\":{\"208\":1,\"594\":1,\"1177\":1}}],[\"p421例子\",{\"1\":{\"278\":1}}],[\"p2p方式\",{\"1\":{\"960\":1}}],[\"p2++\",{\"1\":{\"934\":2}}],[\"p209\",{\"1\":{\"278\":1}}],[\"p2\",{\"1\":{\"98\":1,\"927\":3,\"934\":4}}],[\"pnpm\",{\"0\":{\"1137\":1},\"1\":{\"1138\":1,\"1139\":1,\"1212\":5}}],[\"pn\",{\"1\":{\"98\":4}}],[\"p1++\",{\"1\":{\"934\":2}}],[\"p123456\",{\"1\":{\"459\":1}}],[\"p1\",{\"1\":{\"98\":3,\"927\":4,\"934\":4}}],[\"p0\",{\"1\":{\"98\":3}}],[\"puml\",{\"1\":{\"1274\":1}}],[\"publish\",{\"1\":{\"673\":2}}],[\"public\",{\"1\":{\"31\":5,\"39\":3,\"58\":1,\"98\":4,\"101\":2,\"109\":1,\"126\":2,\"202\":2,\"227\":4,\"277\":5,\"304\":4,\"349\":1,\"355\":1,\"356\":3,\"357\":1,\"359\":2,\"362\":6,\"368\":1,\"390\":1,\"394\":1,\"413\":1,\"743\":1,\"930\":1,\"931\":2,\"932\":2,\"933\":4,\"934\":3,\"935\":8,\"936\":3,\"937\":4,\"938\":1,\"949\":1,\"951\":2,\"952\":2,\"953\":2,\"955\":3,\"956\":4,\"1066\":4,\"1067\":6,\"1068\":2,\"1069\":2,\"1070\":5,\"1077\":10,\"1082\":7,\"1083\":1,\"1247\":1,\"1255\":1,\"1256\":1,\"1260\":1,\"1261\":2}}],[\"pub\",{\"1\":{\"673\":3,\"1202\":1}}],[\"pull模式不足在于如果kafka中没有数据\",{\"1\":{\"858\":1}}],[\"pull\",{\"0\":{\"843\":1},\"1\":{\"452\":1,\"843\":1,\"859\":1,\"1126\":1,\"1127\":2,\"1177\":1}}],[\"push推的模式很难适应消费速率不同的消费者\",{\"1\":{\"858\":1}}],[\"push和pull都是可以的\",{\"1\":{\"843\":1}}],[\"push\",{\"0\":{\"843\":1,\"1201\":1,\"1202\":1},\"1\":{\"394\":1,\"450\":3,\"451\":1,\"452\":5,\"843\":1,\"908\":7,\"1016\":1,\"1127\":2,\"1201\":2,\"1202\":1}}],[\"putval\",{\"1\":{\"410\":1}}],[\"putstatic\",{\"1\":{\"174\":1}}],[\"putstatic或invokestatic\",{\"1\":{\"174\":1}}],[\"put\",{\"0\":{\"397\":1},\"1\":{\"62\":1,\"129\":1,\"131\":1,\"402\":1,\"408\":1,\"412\":1,\"413\":1,\"882\":2,\"1038\":1,\"1040\":1,\"1041\":2}}],[\"prerequest\",{\"1\":{\"1083\":1}}],[\"prehandle\",{\"1\":{\"759\":3}}],[\"prehandler\",{\"1\":{\"755\":1}}],[\"preamble\",{\"1\":{\"708\":1}}],[\"preparestatement\",{\"0\":{\"745\":1},\"1\":{\"745\":7}}],[\"preparedstate\",{\"1\":{\"597\":1}}],[\"preparedstatement\",{\"1\":{\"597\":1,\"745\":2}}],[\"prepare\",{\"1\":{\"489\":2}}],[\"prettier\",{\"0\":{\"1151\":1},\"1\":{\"1150\":1,\"1151\":1}}],[\"pretty\",{\"1\":{\"449\":1}}],[\"pretty=format\",{\"1\":{\"449\":1}}],[\"pretrained\",{\"1\":{\"1144\":1}}],[\"pretenuresizethreadshold=1024\",{\"1\":{\"322\":1}}],[\"present\",{\"1\":{\"413\":2}}],[\"previous\",{\"1\":{\"627\":1,\"628\":2}}],[\"prev\",{\"1\":{\"105\":1,\"626\":1}}],[\"programdata\",{\"1\":{\"1144\":1}}],[\"product\",{\"1\":{\"1077\":14,\"1079\":1,\"1086\":1}}],[\"producer就是通过有和transaction\",{\"1\":{\"863\":1}}],[\"producer事务\",{\"0\":{\"863\":1}}],[\"producer等待broker的ack\",{\"1\":{\"854\":2}}],[\"producer不等待broker的ack\",{\"1\":{\"854\":1}}],[\"producer可以通过随机或者hash等方式\",{\"1\":{\"849\":1}}],[\"producer生产的数据会不断追加到该log文件的末端\",{\"1\":{\"846\":1}}],[\"producer\",{\"1\":{\"845\":1,\"856\":2,\"863\":1,\"866\":1}}],[\"provide\",{\"1\":{\"1159\":2}}],[\"provided\",{\"1\":{\"797\":1}}],[\"provider\",{\"1\":{\"185\":2,\"801\":2,\"802\":1,\"803\":1}}],[\"props\",{\"1\":{\"1157\":1,\"1162\":1,\"1163\":1}}],[\"propertysource\",{\"1\":{\"785\":1}}],[\"propertyplaceholderconfigurer\",{\"1\":{\"737\":1}}],[\"properties<\",{\"1\":{\"1266\":1}}],[\"properties中指定端口\",{\"1\":{\"786\":1}}],[\"properties配置文件\",{\"1\":{\"785\":1}}],[\"properties文件\",{\"1\":{\"784\":1}}],[\"properties和application\",{\"1\":{\"779\":1}}],[\"properties或者是application\",{\"1\":{\"775\":1}}],[\"properties或yml文件\",{\"1\":{\"767\":1}}],[\"propagation\",{\"1\":{\"740\":8}}],[\"propagate\",{\"1\":{\"111\":1}}],[\"prototype\",{\"1\":{\"734\":3}}],[\"prototype多实例\",{\"1\":{\"713\":1}}],[\"protected\",{\"1\":{\"39\":2,\"96\":1,\"110\":4,\"356\":1,\"357\":1,\"362\":1}}],[\"profile\",{\"1\":{\"558\":3}}],[\"profiles\",{\"0\":{\"558\":1},\"1\":{\"557\":1}}],[\"project\",{\"0\":{\"1102\":1},\"1\":{\"445\":1}}],[\"procedure\",{\"1\":{\"801\":1}}],[\"process\",{\"1\":{\"822\":1,\"891\":1}}],[\"processlist\",{\"1\":{\"557\":1,\"701\":1}}],[\"processes\",{\"1\":{\"416\":1}}],[\"proc\",{\"1\":{\"416\":1}}],[\"proxyobject\",{\"1\":{\"1083\":2}}],[\"proxyfactory\",{\"1\":{\"1083\":2}}],[\"proxypoint\",{\"1\":{\"1082\":3}}],[\"proxying\",{\"1\":{\"720\":1}}],[\"proxy去创建代理对象\",{\"1\":{\"715\":1}}],[\"proxy\",{\"1\":{\"349\":5,\"1083\":2}}],[\"promotion\",{\"1\":{\"245\":1}}],[\"price\",{\"1\":{\"481\":3}}],[\"primary\",{\"1\":{\"462\":1,\"527\":1,\"556\":1,\"601\":1}}],[\"priv权限表\",{\"1\":{\"458\":2}}],[\"priv和host\",{\"1\":{\"458\":1}}],[\"priv\",{\"1\":{\"458\":1}}],[\"private\",{\"0\":{\"358\":1},\"1\":{\"39\":1,\"98\":3,\"101\":2,\"110\":1,\"111\":1,\"304\":1,\"355\":1,\"356\":1,\"357\":1,\"358\":3,\"362\":1,\"1066\":4,\"1067\":6,\"1068\":2,\"1069\":3,\"1070\":3,\"1082\":1,\"1245\":1,\"1261\":4}}],[\"priority\",{\"1\":{\"510\":1,\"677\":1}}],[\"priorityqueue<int\",{\"1\":{\"394\":2}}],[\"priorityblockingqueue\",{\"1\":{\"62\":1}}],[\"print\",{\"1\":{\"418\":1,\"955\":2}}],[\"printf方法\",{\"1\":{\"201\":1}}],[\"printf\",{\"1\":{\"162\":1,\"201\":1}}],[\"printstacktrance\",{\"1\":{\"98\":1}}],[\"println\",{\"1\":{\"31\":1,\"39\":1,\"98\":2,\"277\":3,\"882\":4,\"908\":3,\"935\":1,\"951\":1,\"952\":1,\"953\":1,\"1082\":2}}],[\"palette\",{\"1\":{\"1210\":2}}],[\"password\",{\"1\":{\"1178\":2}}],[\"password=208941\",{\"1\":{\"1177\":1}}],[\"packet\",{\"1\":{\"1177\":1}}],[\"packaging>\",{\"1\":{\"795\":1,\"796\":1,\"800\":1}}],[\"package\",{\"0\":{\"1139\":1},\"1\":{\"793\":1,\"1139\":2}}],[\"pandas\",{\"1\":{\"1108\":1}}],[\"pang\",{\"1\":{\"660\":1}}],[\"paxos\",{\"1\":{\"872\":3}}],[\"paxos算法\",{\"0\":{\"872\":1}}],[\"pattern\",{\"1\":{\"1188\":2}}],[\"pattern订阅一个或多个符合给定模式的频道\",{\"1\":{\"673\":1}}],[\"patch\",{\"1\":{\"1144\":4}}],[\"path\",{\"1\":{\"332\":1,\"369\":1,\"452\":1,\"823\":3,\"1039\":2,\"1144\":1}}],[\"path指定路径下的类库\",{\"1\":{\"178\":1}}],[\"path路径下的内容\",{\"1\":{\"176\":1}}],[\"pagehelper\",{\"1\":{\"753\":1}}],[\"page\",{\"0\":{\"1200\":1,\"1204\":1},\"1\":{\"495\":1,\"498\":1,\"543\":1,\"568\":4,\"1115\":1,\"1200\":1,\"1202\":1}}],[\"pagenumber\",{\"1\":{\"486\":1}}],[\"pageup\",{\"1\":{\"429\":1}}],[\"pagedown\",{\"1\":{\"429\":1}}],[\"pagesize\",{\"1\":{\"486\":1}}],[\"pages\",{\"0\":{\"1195\":1},\"1\":{\"1\":1,\"1123\":1,\"1200\":1,\"1208\":1}}],[\"parseint\",{\"1\":{\"952\":1,\"955\":1}}],[\"parent>\",{\"1\":{\"800\":2}}],[\"parent有什么作用\",{\"0\":{\"779\":1}}],[\"parent项目\",{\"1\":{\"778\":1}}],[\"parentid\",{\"1\":{\"601\":4}}],[\"param\",{\"1\":{\"338\":1,\"934\":7}}],[\"parallelgcthread\",{\"1\":{\"262\":1}}],[\"parallel\",{\"0\":{\"257\":1,\"258\":1},\"1\":{\"252\":2,\"257\":1}}],[\"partiton和key是可选的\",{\"1\":{\"865\":1}}],[\"partition的leader和isr的follower全部落盘成功才返回ack\",{\"1\":{\"854\":1}}],[\"partition的leader落盘成功后返回ack\",{\"1\":{\"854\":1}}],[\"partition的数据文件\",{\"0\":{\"847\":1}}],[\"partition中的每条message包含了以下三个属性\",{\"1\":{\"847\":1}}],[\"partition\",{\"1\":{\"703\":1,\"845\":1,\"856\":3,\"859\":2,\"861\":6,\"865\":1,\"870\":1,\"935\":2,\"936\":1}}],[\"partial\",{\"1\":{\"240\":1}}],[\"parties\",{\"1\":{\"120\":1}}],[\"parnew收集器有效\",{\"1\":{\"322\":1}}],[\"parnew收集器实质上是serial收集器的多线程并行版本\",{\"1\":{\"255\":1}}],[\"parnew收集器\",{\"0\":{\"255\":1}}],[\"parnew等带压缩整理过程的收集器时\",{\"1\":{\"218\":1}}],[\"parnew\",{\"1\":{\"216\":1}}],[\"parkuntil\",{\"1\":{\"38\":1}}],[\"parknanos\",{\"1\":{\"38\":1}}],[\"park\",{\"1\":{\"38\":1,\"62\":1,\"144\":1}}],[\"=>\",{\"1\":{\"1159\":2}}],[\"=>a\",{\"1\":{\"1157\":1}}],[\"=>return\",{\"1\":{\"1156\":1}}],[\"=1460byte\",{\"1\":{\"982\":1}}],[\"=sc\",{\"1\":{\"951\":2}}],[\"=povit\",{\"1\":{\"936\":1}}],[\"=temp\",{\"1\":{\"936\":3}}],[\"=tmp\",{\"1\":{\"935\":1}}],[\"=nums\",{\"1\":{\"936\":5}}],[\"=null||\",{\"1\":{\"908\":1}}],[\"=null\",{\"1\":{\"908\":4,\"1257\":1}}],[\"=random\",{\"1\":{\"923\":1}}],[\"=key\",{\"1\":{\"923\":1}}],[\"=o\",{\"1\":{\"893\":1}}],[\"=8784\",{\"1\":{\"537\":1}}],[\"=0\",{\"1\":{\"96\":1}}],[\"==null\",{\"1\":{\"413\":1}}],[\"==>\",{\"1\":{\"381\":3}}],[\"==obj2\",{\"1\":{\"350\":1}}],[\"==true\",{\"1\":{\"350\":1}}],[\"==\",{\"0\":{\"340\":1},\"1\":{\"58\":1,\"96\":2,\"101\":2,\"114\":1,\"340\":2,\"908\":1,\"911\":1,\"912\":1,\"913\":1,\"930\":1,\"932\":1,\"934\":2,\"937\":2,\"938\":1,\"946\":2,\"948\":1,\"949\":1,\"955\":1,\"956\":1,\"1067\":4,\"1068\":2,\"1077\":4}}],[\"=\",{\"1\":{\"31\":6,\"39\":2,\"56\":4,\"57\":1,\"58\":6,\"59\":1,\"81\":1,\"96\":6,\"98\":4,\"101\":3,\"110\":1,\"126\":2,\"134\":1,\"135\":3,\"156\":2,\"183\":1,\"202\":2,\"227\":4,\"277\":3,\"304\":2,\"310\":1,\"367\":1,\"368\":4,\"394\":6,\"404\":3,\"405\":1,\"433\":2,\"486\":2,\"501\":11,\"523\":1,\"533\":3,\"539\":3,\"543\":1,\"559\":3,\"582\":1,\"601\":1,\"623\":1,\"713\":1,\"714\":1,\"734\":1,\"736\":5,\"743\":1,\"745\":4,\"777\":1,\"804\":4,\"816\":1,\"836\":2,\"856\":1,\"863\":1,\"882\":1,\"888\":3,\"903\":1,\"908\":12,\"911\":5,\"912\":7,\"913\":7,\"930\":9,\"931\":7,\"932\":5,\"933\":16,\"934\":10,\"935\":29,\"937\":11,\"947\":10,\"949\":5,\"951\":3,\"952\":4,\"953\":6,\"954\":6,\"955\":14,\"956\":13,\"984\":2,\"989\":1,\"991\":1,\"1004\":2,\"1012\":2,\"1066\":2,\"1067\":4,\"1068\":2,\"1069\":1,\"1077\":6,\"1082\":2,\"1083\":2,\"1091\":2,\"1155\":1,\"1159\":1,\"1177\":20,\"1260\":1,\"1261\":1}}],[\"t>\",{\"1\":{\"1247\":1,\"1260\":2}}],[\"tsinghua\",{\"1\":{\"1143\":4}}],[\"tsl\",{\"1\":{\"1044\":1}}],[\"tuna\",{\"1\":{\"1143\":4}}],[\"tuser\",{\"1\":{\"553\":1}}],[\"tls主要分为两层\",{\"1\":{\"1062\":1}}],[\"tls协议的架构\",{\"1\":{\"1062\":1}}],[\"tls是一个安全通信框架\",{\"1\":{\"1062\":1}}],[\"tls是一种密码通信框架\",{\"1\":{\"1062\":1}}],[\"tls综合运用了密码学中的对称密码\",{\"1\":{\"1062\":1}}],[\"tls\",{\"0\":{\"1062\":1},\"1\":{\"1042\":1,\"1062\":1}}],[\"tlabsize\",{\"1\":{\"326\":1}}],[\"tlab\",{\"1\":{\"219\":2}}],[\"tmp\",{\"1\":{\"933\":3,\"935\":1}}],[\"t0\",{\"1\":{\"888\":1}}],[\"ttl\",{\"1\":{\"636\":1,\"672\":4,\"706\":1}}],[\"type=bind\",{\"1\":{\"1177\":3}}],[\"type=2\",{\"1\":{\"486\":1}}],[\"type\",{\"1\":{\"556\":1,\"702\":1,\"1038\":1,\"1077\":6}}],[\"tzvf\",{\"1\":{\"437\":1}}],[\"txt\",{\"1\":{\"437\":2,\"1144\":6}}],[\"tcp还有一个保活计时器\",{\"1\":{\"1028\":1}}],[\"tcp四次挥手\",{\"1\":{\"1026\":1}}],[\"tcp三次握手\",{\"1\":{\"1022\":1}}],[\"tcp拥塞控制和网络层采取的策略有着密切的联系\",{\"1\":{\"1021\":1}}],[\"tcp接收方的缓存已满\",{\"1\":{\"1018\":1}}],[\"tcp通常对不按序到达的数据先存在缓存中\",{\"1\":{\"1015\":1}}],[\"tcp为每一个连接设有一个持续计时器\",{\"1\":{\"1015\":1}}],[\"tcp保留了一个rtt的一个加权平均往返时间rtts\",{\"1\":{\"1012\":1}}],[\"tcp采用了一种自适应算法\",{\"1\":{\"1012\":1}}],[\"tcp的拥塞控制\",{\"0\":{\"1019\":1}}],[\"tcp的传输效率\",{\"0\":{\"1016\":1}}],[\"tcp的流量控制\",{\"0\":{\"1014\":1}}],[\"tcp的首部中没有哪个字段能够提供上述这些字节块的边界信息\",{\"1\":{\"1013\":1}}],[\"tcp的首部格式\",{\"0\":{\"1007\":1}}],[\"tcp的可靠传输\",{\"0\":{\"1008\":1}}],[\"tcp规定\",{\"1\":{\"1007\":1}}],[\"tcp虽然是面向字节流的\",{\"1\":{\"1007\":1}}],[\"tcp是面向字节流的\",{\"1\":{\"1006\":1}}],[\"tcp20个字节\",{\"1\":{\"1002\":1}}],[\"tcp有流量控制和拥塞控制\",{\"1\":{\"1001\":1}}],[\"tcp传输速度相对udp较慢\",{\"1\":{\"1001\":1}}],[\"tcp不保存数据边界\",{\"1\":{\"1001\":1}}],[\"tcp头\",{\"1\":{\"982\":1}}],[\"tcp\",{\"0\":{\"964\":1,\"1001\":1,\"1005\":1},\"1\":{\"435\":1,\"489\":1,\"612\":1,\"804\":1,\"805\":1,\"806\":1,\"959\":2,\"962\":1,\"964\":4,\"982\":2,\"1000\":1,\"1001\":6,\"1003\":2,\"1004\":2,\"1006\":6,\"1009\":10,\"1015\":2,\"1019\":2,\"1027\":3,\"1029\":2,\"1033\":5,\"1042\":7,\"1047\":1,\"1060\":1}}],[\"tcb\",{\"0\":{\"136\":1},\"1\":{\"136\":4,\"1060\":3}}],[\"t<终端机编号>\",{\"1\":{\"426\":1}}],[\"tensorflow\",{\"1\":{\"1108\":1}}],[\"teacher\",{\"1\":{\"1100\":1}}],[\"tem\",{\"1\":{\"933\":2}}],[\"temp=nums\",{\"1\":{\"936\":3}}],[\"temp>=arr\",{\"1\":{\"935\":1}}],[\"temp<=arr\",{\"1\":{\"935\":1}}],[\"temp就是基准位\",{\"1\":{\"935\":1}}],[\"temp\",{\"1\":{\"930\":3,\"931\":2,\"932\":2,\"935\":10,\"936\":1,\"937\":2}}],[\"template\",{\"1\":{\"742\":1}}],[\"term\",{\"1\":{\"876\":7,\"878\":1}}],[\"terminated\",{\"1\":{\"38\":1,\"63\":3,\"148\":1}}],[\"text\",{\"1\":{\"477\":1,\"601\":1,\"1012\":3,\"1035\":1,\"1077\":1}}],[\"testconvertor\",{\"1\":{\"1255\":1,\"1256\":1}}],[\"test命令\",{\"1\":{\"651\":1}}],[\"testhash\",{\"1\":{\"537\":1}}],[\"testfile文件的行数为3\",{\"1\":{\"439\":1}}],[\"testfile文件的统计信息\",{\"1\":{\"439\":1}}],[\"testfile\",{\"1\":{\"439\":2}}],[\"test4\",{\"1\":{\"422\":1}}],[\"test3\",{\"1\":{\"422\":1}}],[\"test2\",{\"1\":{\"422\":1,\"437\":1}}],[\"test1\",{\"1\":{\"422\":1,\"437\":1}}],[\"test\",{\"1\":{\"227\":1,\"437\":3,\"651\":1,\"793\":1,\"797\":1,\"818\":4}}],[\"totarget\",{\"1\":{\"1255\":1,\"1256\":1}}],[\"todo\",{\"1\":{\"1108\":1}}],[\"tolerance\",{\"1\":{\"870\":1}}],[\"token区别\",{\"1\":{\"1050\":1}}],[\"token\",{\"0\":{\"1050\":1,\"1053\":1},\"1\":{\"807\":6}}],[\"tomcat层面\",{\"1\":{\"959\":1,\"1029\":1}}],[\"tomcat也可以直接提供http服务\",{\"1\":{\"825\":1}}],[\"tomcat更多用来做一个应用容器\",{\"1\":{\"825\":1}}],[\"tomcat等\",{\"1\":{\"825\":1}}],[\"tomcat\",{\"1\":{\"685\":1,\"780\":1,\"825\":4,\"836\":1,\"1038\":1,\"1090\":2}}],[\"tomcat中使用ecj编译器来编译jsp文件\",{\"1\":{\"282\":1}}],[\"to\",{\"0\":{\"1124\":1},\"1\":{\"200\":1,\"332\":1,\"521\":1,\"638\":1,\"891\":1,\"1266\":1}}],[\"topic设置多个分区\",{\"1\":{\"865\":2}}],[\"topic设置一个分区\",{\"1\":{\"865\":1}}],[\"topic的每个partition收到producer发送的数据后\",{\"1\":{\"854\":1}}],[\"topic是一个逻辑概念\",{\"1\":{\"845\":1}}],[\"topic\",{\"1\":{\"845\":1,\"859\":1,\"861\":3,\"865\":1}}],[\"top\",{\"1\":{\"193\":1,\"201\":1,\"436\":1,\"713\":1,\"734\":1}}],[\"tostring\",{\"1\":{\"202\":1,\"350\":2,\"955\":1}}],[\"tos\",{\"1\":{\"193\":1}}],[\"tonanos\",{\"1\":{\"58\":1}}],[\"trie\",{\"1\":{\"891\":1,\"895\":1}}],[\"trie树+堆\",{\"1\":{\"891\":1}}],[\"trie树\",{\"0\":{\"890\":1},\"1\":{\"881\":1,\"899\":1}}],[\"trib\",{\"1\":{\"659\":1}}],[\"trx\",{\"1\":{\"499\":4,\"563\":1,\"568\":1,\"582\":2,\"1177\":1}}],[\"trusted\",{\"1\":{\"1184\":1}}],[\"trunk\",{\"1\":{\"1126\":6,\"1127\":5}}],[\"truncate\",{\"0\":{\"483\":1},\"1\":{\"483\":1}}],[\"true\",{\"0\":{\"341\":1},\"1\":{\"81\":1,\"96\":4,\"125\":1,\"341\":1,\"368\":1,\"759\":3,\"769\":1,\"863\":1,\"882\":1,\"930\":1,\"1061\":1,\"1157\":2}}],[\"treeinput\",{\"1\":{\"956\":1}}],[\"treeify\",{\"1\":{\"131\":1}}],[\"treenode\",{\"1\":{\"908\":1,\"956\":9}}],[\"tree索引\",{\"0\":{\"538\":1}}],[\"tree\",{\"1\":{\"534\":1,\"538\":2}}],[\"treemap\",{\"0\":{\"408\":1,\"412\":1},\"1\":{\"408\":6,\"412\":7}}],[\"trainstation\",{\"1\":{\"1082\":3}}],[\"trace\",{\"1\":{\"1038\":1,\"1040\":1}}],[\"traceroute\",{\"0\":{\"994\":1},\"1\":{\"994\":2}}],[\"track\",{\"1\":{\"451\":1}}],[\"transport\",{\"1\":{\"1062\":1}}],[\"translation\",{\"1\":{\"995\":1}}],[\"transmit\",{\"1\":{\"982\":1}}],[\"transactiondefinition\",{\"1\":{\"740\":9,\"741\":6}}],[\"transactional\",{\"1\":{\"739\":1}}],[\"transaction\",{\"1\":{\"526\":2,\"863\":1}}],[\"transfer\",{\"1\":{\"406\":2,\"972\":1}}],[\"transient\",{\"0\":{\"364\":1},\"1\":{\"364\":5}}],[\"trap\",{\"1\":{\"135\":1}}],[\"try\",{\"1\":{\"98\":1,\"126\":2,\"346\":1,\"383\":7}}],[\"tryreleaseshared\",{\"1\":{\"109\":1,\"123\":1}}],[\"tryrelease\",{\"1\":{\"96\":1,\"109\":1}}],[\"tryacquire\",{\"1\":{\"96\":1,\"109\":1,\"114\":2}}],[\"tryacquireshared\",{\"1\":{\"81\":1,\"109\":1,\"123\":1}}],[\"tinyint\",{\"1\":{\"472\":1}}],[\"tidying\",{\"1\":{\"63\":1}}],[\"times\",{\"1\":{\"804\":1,\"1012\":3}}],[\"timestamp\",{\"1\":{\"475\":5,\"533\":1,\"601\":2}}],[\"time=3\",{\"1\":{\"557\":1}}],[\"time的\",{\"1\":{\"331\":1}}],[\"time是小于sys+user\",{\"1\":{\"331\":1}}],[\"timeunit\",{\"1\":{\"58\":1,\"59\":1,\"61\":1,\"642\":1}}],[\"time\",{\"1\":{\"38\":1,\"533\":2,\"566\":2,\"632\":1,\"701\":1,\"853\":1,\"879\":1,\"1027\":1,\"1117\":1,\"1177\":1}}],[\"timeout\",{\"1\":{\"38\":4,\"61\":1,\"126\":1,\"350\":1,\"516\":2,\"517\":1,\"1060\":1}}],[\"theme\",{\"1\":{\"1139\":1}}],[\"the\",{\"1\":{\"240\":1,\"254\":1,\"255\":1,\"259\":1,\"891\":2,\"1077\":2,\"1144\":1}}],[\"this代表的是当前对象\",{\"1\":{\"725\":1}}],[\"this关键字\",{\"1\":{\"236\":1}}],[\"this逃逸很危险\",{\"1\":{\"295\":1}}],[\"this逃逸是指在构造函数返回之前其他线程就持有该对象的引用\",{\"1\":{\"202\":1}}],[\"this逃逸\",{\"1\":{\"202\":1}}],[\"this\",{\"1\":{\"58\":6,\"110\":1,\"295\":2,\"364\":2,\"955\":1,\"956\":1}}],[\"threshold\",{\"1\":{\"131\":1}}],[\"threadstacksize=128k\",{\"1\":{\"321\":1}}],[\"threadstacksize\",{\"1\":{\"315\":1}}],[\"thread内部都是使用仅有那个threadlocalmap\",{\"1\":{\"299\":1}}],[\"thread类的setcontextclassloader\",{\"1\":{\"179\":1}}],[\"threadfactory\",{\"1\":{\"58\":6}}],[\"threadpoolexecutor\",{\"0\":{\"58\":1},\"1\":{\"56\":1,\"58\":2,\"59\":3}}],[\"threadref\",{\"1\":{\"45\":1}}],[\"threadlocal方法后\",{\"1\":{\"300\":1}}],[\"threadlocal导致的oom\",{\"0\":{\"300\":1}}],[\"threadlocal变量\",{\"1\":{\"299\":1}}],[\"threadlocal对象\",{\"1\":{\"299\":1}}],[\"threadlocal类主要解决的就是让每个线程绑定自己的值\",{\"1\":{\"299\":1}}],[\"threadlocal<>\",{\"1\":{\"39\":1}}],[\"threadlocal<string>\",{\"1\":{\"39\":3}}],[\"threadlocal中的缺省实现直接返回一个null\",{\"1\":{\"39\":1}}],[\"threadlocalmap实现中已经考虑了这种情况\",{\"1\":{\"300\":1}}],[\"threadlocalmap的\",{\"1\":{\"299\":1}}],[\"threadlocalmap是threadlocal的静态内部类\",{\"1\":{\"299\":1}}],[\"threadlocalmap\",{\"0\":{\"42\":1},\"1\":{\"39\":2,\"41\":1,\"42\":2,\"45\":1,\"46\":2,\"299\":1,\"300\":2}}],[\"threadlocal\",{\"0\":{\"39\":1,\"40\":1,\"41\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":1,\"47\":1,\"299\":1},\"1\":{\"39\":8,\"40\":3,\"41\":2,\"42\":2,\"43\":3,\"44\":1,\"45\":4,\"46\":2,\"47\":1,\"48\":1,\"299\":5,\"300\":2}}],[\"thread\",{\"0\":{\"32\":1},\"1\":{\"31\":9,\"32\":5,\"35\":2,\"37\":1,\"38\":7,\"39\":2,\"41\":2,\"42\":1,\"45\":2,\"75\":3,\"85\":6,\"89\":5,\"96\":1,\"98\":5,\"102\":3,\"144\":1,\"182\":1,\"1177\":1}}],[\"throwing\",{\"1\":{\"722\":1}}],[\"throwable\",{\"1\":{\"349\":1,\"384\":1}}],[\"throw\",{\"0\":{\"386\":1},\"1\":{\"58\":2,\"96\":2,\"386\":1,\"1261\":2}}],[\"throws\",{\"0\":{\"386\":1},\"1\":{\"31\":1,\"126\":2,\"349\":2,\"386\":1,\"956\":1}}],[\"tagname\",{\"1\":{\"450\":1}}],[\"tags\",{\"1\":{\"450\":2,\"1170\":1}}],[\"tag\",{\"0\":{\"450\":1},\"1\":{\"449\":2,\"450\":13}}],[\"tail\",{\"1\":{\"428\":2,\"630\":1}}],[\"tac\",{\"1\":{\"428\":2}}],[\"tar\",{\"1\":{\"416\":1,\"437\":6,\"1170\":4}}],[\"target=\",{\"1\":{\"1177\":3,\"1255\":1,\"1256\":1}}],[\"target>\",{\"1\":{\"790\":1}}],[\"target等\",{\"1\":{\"728\":1}}],[\"target\",{\"1\":{\"338\":1,\"911\":4,\"912\":7,\"913\":6,\"1092\":1,\"1249\":1,\"1255\":1,\"1256\":1,\"1257\":3}}],[\"targetsurvivorratio\",{\"1\":{\"322\":1}}],[\"take\",{\"1\":{\"62\":1}}],[\"table进行统计了\",{\"1\":{\"886\":1}}],[\"table之类的语句的时候\",{\"1\":{\"572\":1}}],[\"tables语法除了会限制别的线程的读写外\",{\"1\":{\"510\":1}}],[\"tables\",{\"1\":{\"459\":1,\"508\":1,\"510\":1}}],[\"table的每一个元素都对应着其标识的内存区域中一块特定大小的内存块\",{\"1\":{\"249\":1}}],[\"table\",{\"0\":{\"247\":1},\"1\":{\"47\":1,\"208\":1,\"234\":1,\"247\":1,\"249\":1,\"399\":2,\"404\":1,\"406\":6,\"458\":2,\"462\":1,\"486\":3,\"510\":4,\"514\":2,\"527\":3,\"554\":2,\"565\":1,\"601\":1,\"622\":2,\"623\":1,\"702\":1,\"703\":1}}],[\"task2\",{\"1\":{\"31\":2}}],[\"t\",{\"1\":{\"35\":2,\"39\":3,\"51\":2,\"312\":1,\"345\":8,\"390\":1,\"484\":1,\"489\":1,\"509\":3,\"555\":1,\"556\":1,\"559\":3,\"935\":3,\"987\":1,\"1202\":1,\"1247\":2,\"1260\":3}}],[\"t2\",{\"1\":{\"31\":3,\"88\":4,\"98\":2,\"101\":1,\"102\":4,\"521\":1,\"888\":1}}],[\"t1\",{\"1\":{\"31\":3,\"88\":1,\"98\":2,\"102\":3,\"501\":3,\"521\":2,\"888\":1}}],[\"类图\",{\"1\":{\"1271\":1}}],[\"类图中\",{\"1\":{\"1097\":1,\"1098\":1,\"1099\":1,\"1100\":1,\"1101\":1}}],[\"类统一完成两个系统之间的枚举映射\",{\"1\":{\"1259\":1}}],[\"类映射为\",{\"1\":{\"1249\":1}}],[\"类都是\",{\"1\":{\"1100\":1}}],[\"类间关系\",{\"0\":{\"1095\":1}}],[\"类适配器模式是现有组件库中已经存在的组件\",{\"1\":{\"1092\":1}}],[\"类适配器模式耦合度高\",{\"1\":{\"1092\":1}}],[\"类就使用了模板方法模式\",{\"1\":{\"1087\":1}}],[\"类就无法继承其它类\",{\"1\":{\"32\":1}}],[\"类包含了实例化的代码\",{\"1\":{\"1077\":1}}],[\"类别\",{\"1\":{\"1040\":1,\"1190\":1}}],[\"类获取\",{\"1\":{\"736\":1}}],[\"类会议论文\",{\"1\":{\"687\":1}}],[\"类和\",{\"1\":{\"384\":1,\"1100\":1}}],[\"类和接口的全限定名\",{\"1\":{\"286\":1}}],[\"类可以被继承么\",{\"0\":{\"370\":1}}],[\"类构造函数私有化了\",{\"1\":{\"355\":1}}],[\"类在第一次使用时才动态加载到\",{\"1\":{\"348\":1}}],[\"类实现了接口\",{\"1\":{\"1101\":1}}],[\"类实现\",{\"1\":{\"343\":2,\"408\":1}}],[\"类重写了\",{\"1\":{\"340\":1}}],[\"类没有重写\",{\"1\":{\"340\":1}}],[\"类名\",{\"1\":{\"339\":1}}],[\"类名也相同\",{\"1\":{\"180\":1}}],[\"类库中广泛使用了简单工厂模式\",{\"1\":{\"1077\":1}}],[\"类库主要包含了以下三个类\",{\"1\":{\"348\":1}}],[\"类库\",{\"1\":{\"335\":1}}],[\"类变量\",{\"1\":{\"292\":1}}],[\"类索引和父类索引各自指向一个类型constant\",{\"1\":{\"288\":1}}],[\"类索引和父类索引都是一个u2类型的数据\",{\"1\":{\"288\":1}}],[\"类索引用于确定这个类的全限定名\",{\"1\":{\"288\":1}}],[\"类索引\",{\"0\":{\"288\":1}}],[\"类或接口并不一定都得定义在文件里\",{\"1\":{\"284\":1}}],[\"类文件概述\",{\"0\":{\"279\":1}}],[\"类信息⼜包括了类的版本\",{\"1\":{\"203\":1}}],[\"类相关信息\",{\"1\":{\"203\":1}}],[\"类方法\",{\"1\":{\"172\":1}}],[\"类加载就会导致该单实例对象被创建\",{\"1\":{\"1066\":1}}],[\"类加载相当于\",{\"1\":{\"348\":1}}],[\"类加载检查\",{\"0\":{\"214\":1}}],[\"类加载\",{\"1\":{\"203\":1,\"338\":1}}],[\"类加载的解析阶段\",{\"1\":{\"194\":1}}],[\"类加载器情况等\",{\"1\":{\"313\":1}}],[\"类加载器有了名称\",{\"1\":{\"181\":1}}],[\"类加载器的分类\",{\"0\":{\"175\":1}}],[\"类加载过程\",{\"0\":{\"167\":1}}],[\"类加载机制\",{\"0\":{\"165\":1},\"1\":{\"182\":1}}],[\"类的子类\",{\"1\":{\"1100\":1}}],[\"类的个数容易过多\",{\"1\":{\"1078\":1}}],[\"类的父类都是\",{\"1\":{\"384\":1}}],[\"类的\",{\"1\":{\"356\":1,\"1083\":1}}],[\"类的newinstance\",{\"1\":{\"356\":1}}],[\"类的作用是动态创建一个代理对象的类\",{\"1\":{\"349\":1}}],[\"类的一个方法\",{\"1\":{\"346\":1}}],[\"类的全限定名\",{\"1\":{\"339\":1}}],[\"类的话\",{\"1\":{\"184\":1}}],[\"类的完整类名必须一致\",{\"1\":{\"166\":1}}],[\"类的方法\",{\"1\":{\"37\":1}}],[\"类型字段用来标志上一层使用的是什么协议\",{\"1\":{\"980\":1}}],[\"类型中会占用更少的内存\",{\"1\":{\"622\":1}}],[\"类型为\",{\"1\":{\"494\":1}}],[\"类型提供的封装类\",{\"1\":{\"368\":1}}],[\"类型转换异常\",{\"1\":{\"345\":1}}],[\"类型擦除\",{\"0\":{\"345\":1},\"1\":{\"345\":1}}],[\"类型能否被回收的判定\",{\"1\":{\"237\":1}}],[\"类型信息\",{\"1\":{\"204\":1}}],[\"类型数据安置在方法区之后\",{\"1\":{\"168\":1}}],[\"类型\",{\"1\":{\"123\":1,\"345\":1,\"349\":1,\"539\":1,\"622\":2,\"756\":1}}],[\"类型的数据\",{\"1\":{\"610\":1}}],[\"类型的计算\",{\"1\":{\"473\":1}}],[\"类型的\",{\"1\":{\"368\":1,\"622\":1}}],[\"类型的加载\",{\"1\":{\"165\":1}}],[\"类型的getstate\",{\"1\":{\"110\":1}}],[\"类型的对象\",{\"1\":{\"61\":1}}],[\"类似与归并排序\",{\"1\":{\"894\":1}}],[\"类似都采用了\",{\"1\":{\"835\":1}}],[\"类似上面方法\",{\"1\":{\"736\":1}}],[\"类似的哨兵\",{\"1\":{\"659\":1}}],[\"类似的存储结构\",{\"1\":{\"128\":1}}],[\"类似于多路\",{\"1\":{\"852\":1}}],[\"类似于classpath\",{\"1\":{\"797\":1}}],[\"类似于编译\",{\"1\":{\"797\":1}}],[\"类似于servlet中的application\",{\"1\":{\"734\":1}}],[\"类似于\",{\"1\":{\"537\":1,\"649\":1}}],[\"类似于传统的\",{\"1\":{\"379\":1}}],[\"类似\",{\"1\":{\"109\":2,\"120\":1,\"129\":2,\"270\":1,\"428\":1}}],[\"类锁\",{\"1\":{\"83\":1}}],[\"类用来提供线程内部的局部变量\",{\"1\":{\"39\":1}}],[\"类中定义了多个read\",{\"1\":{\"1087\":1}}],[\"类中的操作实现了接口中所声明的所有的抽象操作\",{\"1\":{\"1101\":1}}],[\"类中的\",{\"1\":{\"185\":1,\"343\":2}}],[\"类中的方法\",{\"1\":{\"35\":1}}],[\"类中\",{\"1\":{\"36\":1}}],[\"类开销过大\",{\"1\":{\"32\":1}}],[\"类\",{\"0\":{\"36\":1,\"339\":1},\"1\":{\"31\":1,\"35\":2,\"184\":1,\"209\":1,\"355\":1,\"369\":1,\"384\":1,\"407\":2,\"1088\":3,\"1092\":2,\"1249\":1}}],[\"多行匹配\",{\"1\":{\"1190\":1}}],[\"多行匹配等等\",{\"1\":{\"1188\":1}}],[\"多行输入\",{\"0\":{\"951\":1}}],[\"多重条件语句不易维护\",{\"1\":{\"1088\":1}}],[\"多产品角色\",{\"1\":{\"1086\":1}}],[\"多了一层\",{\"1\":{\"1044\":1}}],[\"多播\",{\"1\":{\"1001\":1}}],[\"多播帧\",{\"1\":{\"979\":1}}],[\"多对一映射\",{\"0\":{\"1254\":1}}],[\"多对一\",{\"1\":{\"1002\":1}}],[\"多对一和多对多的交互通信\",{\"1\":{\"1001\":1}}],[\"多对多的交互通信\",{\"1\":{\"1002\":1}}],[\"多对多\",{\"1\":{\"456\":1}}],[\"多种类型链路\",{\"1\":{\"975\":1}}],[\"多种网络层协议\",{\"1\":{\"975\":1}}],[\"多出来的则按照consumer的字典序挨个分配\",{\"1\":{\"859\":1}}],[\"多用于分布式系统之间进行通信\",{\"1\":{\"840\":1}}],[\"多大\",{\"1\":{\"820\":1}}],[\"多副本\",{\"0\":{\"675\":1},\"1\":{\"675\":1}}],[\"多次\",{\"1\":{\"643\":1}}],[\"多路查找树\",{\"0\":{\"917\":1}}],[\"多路\",{\"0\":{\"611\":1}}],[\"多路复用程序\",{\"1\":{\"611\":1}}],[\"多路复用机制同时监听多个\",{\"1\":{\"611\":1}}],[\"多路复用机制\",{\"1\":{\"604\":1,\"835\":1}}],[\"多路复用的机制\",{\"1\":{\"381\":1}}],[\"多路复用就通过一种机制\",{\"1\":{\"381\":1}}],[\"多路复用\",{\"0\":{\"381\":1},\"1\":{\"604\":1,\"1042\":1}}],[\"多表关联查询出的记录只有一条\",{\"1\":{\"556\":1}}],[\"多表查询的时候如何选择关联顺序等\",{\"1\":{\"490\":1}}],[\"多是平级\",{\"1\":{\"532\":1}}],[\"多数用于数据争用不大\",{\"1\":{\"513\":1}}],[\"多这一个功能\",{\"1\":{\"414\":1}}],[\"多态实现的前提\",{\"1\":{\"355\":1}}],[\"多态性的特性\",{\"1\":{\"354\":1}}],[\"多态\",{\"1\":{\"336\":1,\"349\":1,\"355\":1,\"626\":1}}],[\"多功能命令行\",{\"1\":{\"312\":1}}],[\"多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业\",{\"1\":{\"150\":1}}],[\"多级反馈队列调度算法\",{\"1\":{\"150\":1}}],[\"多读场景\",{\"1\":{\"104\":1}}],[\"多个实体和值对象组成的集合叫聚合\",{\"1\":{\"1232\":1}}],[\"多个标志位可通过按位\",{\"1\":{\"1190\":1}}],[\"多个类加载器\",{\"1\":{\"1075\":1}}],[\"多个请求stream共享一个tcp连接\",{\"1\":{\"1042\":1}}],[\"多个服务器使用的是同一个ip地址\",{\"1\":{\"1030\":1}}],[\"多个系统通过消息中间件交互\",{\"1\":{\"841\":1}}],[\"多个worker进程通过\",{\"1\":{\"830\":1}}],[\"多个节点之前的网络本来是连通的\",{\"1\":{\"870\":1}}],[\"多个节点\",{\"1\":{\"660\":1,\"678\":1}}],[\"多个哨兵构成一个哨兵集群\",{\"1\":{\"657\":1}}],[\"多个依赖等\",{\"1\":{\"643\":1}}],[\"多个文件名指向同一索引节点是存在的\",{\"1\":{\"427\":1}}],[\"多个线程\",{\"1\":{\"121\":1}}],[\"多个线程可同时执行\",{\"1\":{\"115\":1}}],[\"多个线程都可以去直接操作共享资源\",{\"1\":{\"104\":1}}],[\"多个线程之间访问资源的同步\",{\"1\":{\"40\":1}}],[\"多个进程可以竞争有限数量的资源\",{\"1\":{\"98\":1}}],[\"多个\",{\"1\":{\"94\":1,\"381\":1,\"611\":1,\"661\":1,\"859\":1}}],[\"多少会影响性能\",{\"1\":{\"64\":1}}],[\"多线程使用单例使用共享资源时\",{\"1\":{\"1074\":1}}],[\"多线程就是为了防止单线程堵塞\",{\"1\":{\"838\":1}}],[\"多线程操作只会锁住当前操作索引的节点\",{\"1\":{\"409\":1}}],[\"多线程竞争时\",{\"1\":{\"144\":1}}],[\"多线程给下游系统造成的并发等于你设置的线程数\",{\"1\":{\"64\":1}}],[\"多线程同时入队时减少了竞争\",{\"1\":{\"62\":1}}],[\"多线程中让每个线程间数据隔离问题\",{\"1\":{\"40\":1}}],[\"多线程基础知识\",{\"0\":{\"29\":1}}],[\"多核\",{\"1\":{\"30\":1,\"91\":1}}],[\"为文件夹生成类图\",{\"0\":{\"1273\":1}}],[\"为以下\",{\"1\":{\"1202\":1}}],[\"为多个子系统对外提供一个共同的接口\",{\"1\":{\"1090\":1}}],[\"为保持高速缓存中的内容正确\",{\"1\":{\"1032\":1}}],[\"为保证producer发送的数据能够可靠的发送到指定的topic中\",{\"1\":{\"854\":1}}],[\"为保证集群中某个节点发生故障\",{\"1\":{\"845\":1}}],[\"为解决这个问题\",{\"1\":{\"1015\":1}}],[\"为解决对象跨代引用的问题\",{\"1\":{\"249\":1}}],[\"为待传送的数据加一个以太网协议头为最后的数据传输做准备\",{\"1\":{\"964\":1}}],[\"为边缘部分提供服务\",{\"1\":{\"960\":1}}],[\"为0表示不存在\",{\"1\":{\"901\":1}}],[\"为1表示存在\",{\"1\":{\"901\":1}}],[\"为300万\",{\"1\":{\"893\":1}}],[\"为该\",{\"1\":{\"893\":1}}],[\"为query\",{\"1\":{\"893\":1}}],[\"为的是使得系统稳定运行\",{\"1\":{\"879\":1}}],[\"为的是使leader能够持续发送心跳信息\",{\"1\":{\"879\":1}}],[\"为一个分界点\",{\"1\":{\"846\":1}}],[\"为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知\",{\"1\":{\"235\":1}}],[\"为主要的系统架构模式\",{\"1\":{\"748\":1}}],[\"为主要瓶颈\",{\"1\":{\"674\":1}}],[\"为防止以后的扩容\",{\"1\":{\"671\":1}}],[\"为此需要使用各种密码技术\",{\"1\":{\"1055\":1}}],[\"为此\",{\"1\":{\"657\":1}}],[\"为搜索字段创建索引\",{\"1\":{\"560\":1}}],[\"为索引列选择合适的数据类型\",{\"1\":{\"535\":1}}],[\"为啥加了索引\",{\"0\":{\"529\":1}}],[\"为数据的处理安全提供了保证\",{\"1\":{\"513\":1}}],[\"为当前读\",{\"1\":{\"501\":3}}],[\"为每个修改保存一个版本\",{\"1\":{\"499\":1}}],[\"为每一个线程都提供了一份变量副本\",{\"1\":{\"40\":1}}],[\"为单位缓存数据\",{\"1\":{\"495\":1}}],[\"为单位进行映射的\",{\"1\":{\"156\":1}}],[\"为高精度小数类型\",{\"1\":{\"473\":1}}],[\"为浮点类型\",{\"1\":{\"473\":1}}],[\"为我们自动创建的第一个分支master\",{\"1\":{\"444\":1}}],[\"为我们需要认定为相同的两个对象返回相同的哈希值\",{\"1\":{\"342\":1}}],[\"为例\",{\"1\":{\"405\":1,\"551\":1,\"608\":1,\"714\":1,\"1198\":1}}],[\"为具体类提供准则时创建抽象类\",{\"1\":{\"362\":1}}],[\"为特定数据类型或对象分配单一的存储空间\",{\"1\":{\"352\":1}}],[\"为对象分配空间的任务实际上便等同于把一块确定大小的内存块从java堆中划分出来\",{\"1\":{\"215\":1}}],[\"为永久代设置空间大小比较困难\",{\"1\":{\"206\":1}}],[\"为栈提供数据存储服务\",{\"1\":{\"198\":1}}],[\"为最小单位\",{\"1\":{\"192\":1}}],[\"为某个接口寻找服务实现的机制\",{\"1\":{\"185\":1}}],[\"为实现spi服务\",{\"1\":{\"185\":1}}],[\"为类中定义的变量\",{\"1\":{\"171\":1}}],[\"为之分配了处理机后\",{\"1\":{\"148\":1}}],[\"为了把协议软件做成通用可移植的\",{\"1\":{\"1049\":1}}],[\"为了弥补html的缺陷和局限性\",{\"1\":{\"1035\":1}}],[\"为了便于不同平台\",{\"1\":{\"1035\":1}}],[\"为了让旧连接的重复分节在网络中自然消失\",{\"1\":{\"1027\":1}}],[\"为了让发送方尽早知道发生了个别报文段的丢失\",{\"1\":{\"1019\":1}}],[\"为了进行拥塞控制\",{\"1\":{\"1019\":1}}],[\"为了更方便地进行路由选择\",{\"1\":{\"991\":1}}],[\"为了更快的构建产品就绪应用程序\",{\"1\":{\"770\":1}}],[\"为了求得主机b的硬件地址\",{\"1\":{\"986\":1}}],[\"为了有效地利用光纤资源\",{\"1\":{\"968\":1}}],[\"为了有效利用broker集群的性能\",{\"1\":{\"849\":1}}],[\"为了换行读取可以使用nextline\",{\"1\":{\"954\":1}}],[\"为了打破一个结点只能存储一个元素的限制\",{\"1\":{\"916\":1}}],[\"为了管理transaction\",{\"1\":{\"863\":1}}],[\"为了跨分区\",{\"1\":{\"863\":1}}],[\"为了优化这个流程\",{\"1\":{\"850\":1}}],[\"为了加快网站的解析速度\",{\"1\":{\"827\":1}}],[\"为了方便\",{\"1\":{\"825\":1}}],[\"为了提高\",{\"1\":{\"1032\":1}}],[\"为了提高扩展性\",{\"1\":{\"752\":1}}],[\"为了提高磁盘的访问性能\",{\"1\":{\"163\":1}}],[\"为了满足客户的信创需求\",{\"1\":{\"687\":1}}],[\"为了将不同的\",{\"1\":{\"679\":1}}],[\"为了保证\",{\"1\":{\"1027\":1}}],[\"为了保证上述要求\",{\"1\":{\"879\":1}}],[\"为了保证多个副本之间的数据的一致性\",{\"1\":{\"855\":1}}],[\"为了保证各节点的协同工作\",{\"1\":{\"820\":1}}],[\"为了保证高吞吐和低延迟\",{\"1\":{\"818\":1}}],[\"为了保证高可用\",{\"1\":{\"659\":1}}],[\"为了保证迁移的一致性\",{\"1\":{\"660\":1}}],[\"为了保证区中页的连续性\",{\"1\":{\"498\":1}}],[\"为了分载\",{\"1\":{\"656\":1}}],[\"为了避免分布式系统在扩容或者缩容时\",{\"1\":{\"880\":1}}],[\"为了避免出现这样的情况\",{\"1\":{\"802\":1}}],[\"为了避免单点故障\",{\"1\":{\"655\":1}}],[\"为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率\",{\"1\":{\"220\":1}}],[\"为了查询效率和唯一性\",{\"1\":{\"619\":1}}],[\"为了这些语句能在slave上正确运行\",{\"1\":{\"572\":1}}],[\"为了控制\",{\"1\":{\"568\":1}}],[\"为了效率考量\",{\"1\":{\"501\":1}}],[\"为了开发上的便利行可能就采用一个字段了\",{\"1\":{\"455\":1}}],[\"为了实现扩展性\",{\"1\":{\"845\":1}}],[\"为了实现键到值的快速访问\",{\"1\":{\"614\":1}}],[\"为了实现数据实时性\",{\"1\":{\"411\":1}}],[\"为了实现stab算法\",{\"1\":{\"262\":1}}],[\"为了减少开销\",{\"1\":{\"1031\":1}}],[\"为了减少内存也得过多分离\",{\"1\":{\"623\":1}}],[\"为了减少哈希冲突\",{\"1\":{\"405\":1}}],[\"为了减少散列冲突\",{\"1\":{\"129\":1}}],[\"为了能让\",{\"1\":{\"404\":1}}],[\"为了支持基于\",{\"1\":{\"342\":1}}],[\"为了修正并发标记期间\",{\"1\":{\"259\":1}}],[\"为了解决这种数据倾斜问题\",{\"1\":{\"681\":1}}],[\"为了解决这个问题\",{\"1\":{\"193\":1}}],[\"为了解决并发扫描时的对象消失问题\",{\"1\":{\"251\":1}}],[\"为了解决标记\",{\"1\":{\"245\":1}}],[\"为了使stop\",{\"1\":{\"240\":1}}],[\"为了使其能够在信创设备上运行\",{\"1\":{\"18\":1}}],[\"为了消除这种极不优雅的实现方式\",{\"1\":{\"185\":1}}],[\"为了防止\",{\"1\":{\"1061\":1}}],[\"为了防止用户通过\",{\"1\":{\"1061\":1}}],[\"为了防止拥塞窗口cwnd增长过大引起网络拥塞\",{\"1\":{\"1019\":1}}],[\"为了防止log文件过大导致定位效率低下\",{\"1\":{\"846\":1}}],[\"为了防止一个线程在获取锁后程序出现异常\",{\"1\":{\"668\":1}}],[\"为了防止编译和篡改\",{\"1\":{\"180\":1}}],[\"为了防止请求调页的过程出现过多的内存页面错误而使得程序执行效率下降\",{\"1\":{\"160\":1}}],[\"为了确定首先执行哪个进程以及最后执行哪个进程以实现最大\",{\"1\":{\"150\":1}}],[\"为了维护同步队列的\",{\"1\":{\"122\":1}}],[\"为了遵循\",{\"1\":{\"76\":1}}],[\"为了屏蔽硬件和操作系统访问内存的各种差异\",{\"1\":{\"65\":1}}],[\"为了平衡生产和消费速度不一致的问题\",{\"1\":{\"50\":1}}],[\"为\",{\"1\":{\"46\":1,\"118\":1,\"125\":1,\"300\":2,\"368\":1,\"407\":1,\"412\":1,\"486\":1,\"539\":1,\"558\":1,\"672\":1,\"771\":1,\"807\":1,\"892\":1,\"1084\":1,\"1260\":1}}],[\"为强引用的线程变量副本\",{\"1\":{\"39\":1}}],[\"为使用弱引用的\",{\"1\":{\"39\":1}}],[\"为什么加\",{\"1\":{\"1068\":1}}],[\"为什么客户端需要等待2msl\",{\"1\":{\"1026\":1}}],[\"为什么连接的时候是三次握手\",{\"0\":{\"1024\":1}}],[\"为什么做不到全局有序\",{\"1\":{\"865\":1}}],[\"为什么worker内部不使用多线程\",{\"0\":{\"838\":1}}],[\"为什么master不会挂\",{\"0\":{\"837\":1}}],[\"为什么还要使用\",{\"0\":{\"805\":1}}],[\"为什么还要引入\",{\"1\":{\"450\":1}}],[\"为什么我们需要\",{\"0\":{\"774\":1}}],[\"为什么我只查一行的语句\",{\"1\":{\"559\":1}}],[\"为什么不能两\",{\"0\":{\"1023\":1}}],[\"为什么不用本地缓存\",{\"0\":{\"609\":1}}],[\"为什么不直接通过\",{\"0\":{\"405\":1}}],[\"为什么这么快\",{\"0\":{\"604\":1}}],[\"为什么日志需要\",{\"0\":{\"578\":1}}],[\"为什么同时需要binlog\",{\"0\":{\"577\":1}}],[\"为什么索引不使用\",{\"1\":{\"541\":2}}],[\"为什么索引不使用红黑树\",{\"1\":{\"541\":1}}],[\"为什么索引不使用二叉树结构\",{\"1\":{\"541\":1}}],[\"为什么使用\",{\"1\":{\"919\":1}}],[\"为什么使用跳表\",{\"1\":{\"630\":1}}],[\"为什么使用b+树\",{\"0\":{\"541\":1}}],[\"为什么使用弱引用\",{\"0\":{\"46\":1}}],[\"为什么尽量不要使用长事务\",{\"0\":{\"525\":1}}],[\"为什么id为主键或者唯一索引时不需要加gap锁\",{\"1\":{\"501\":1}}],[\"为什么建表使用自增\",{\"0\":{\"466\":1}}],[\"为什么一张表只能有一个主键\",{\"0\":{\"464\":1}}],[\"为什么文件占用的磁盘空间比文件本身大\",{\"1\":{\"442\":1}}],[\"为什么用分段锁\",{\"1\":{\"410\":1}}],[\"为什么必须是\",{\"0\":{\"404\":1}}],[\"为什么重写\",{\"0\":{\"342\":1}}],[\"为什么需要等待2msl\",{\"0\":{\"1027\":1}}],[\"为什么需要三次握手\",{\"1\":{\"1022\":1}}],[\"为什么需要\",{\"1\":{\"646\":1,\"1240\":1}}],[\"为什么需要预编译\",{\"1\":{\"597\":1}}],[\"为什么需要分代\",{\"0\":{\"240\":1}}],[\"为什么需要使用本地方法\",{\"1\":{\"197\":1}}],[\"为什么进程上下文切换代价更高\",{\"0\":{\"145\":1}}],[\"为什么只有前驱节点是头节点时才能尝试获取同步状态\",{\"0\":{\"122\":1}}],[\"为什么要做持久化和orm设计\",{\"0\":{\"748\":1}}],[\"为什么要有\",{\"1\":{\"381\":1}}],[\"为什么要设计成不可变类\",{\"0\":{\"369\":1}}],[\"为什么要堆栈分离\",{\"0\":{\"198\":1}}],[\"为什么要这么设计\",{\"0\":{\"198\":1},\"1\":{\"198\":1}}],[\"为什么要自定义类加载器\",{\"1\":{\"180\":1}}],[\"为什么要用缓存\",{\"0\":{\"606\":1}}],[\"为什么要用\",{\"0\":{\"104\":1,\"605\":1,\"606\":1}}],[\"为什么要使用多线程\",{\"0\":{\"30\":1}}],[\"为什么两次if判断\",{\"1\":{\"714\":1}}],[\"为什么两次\",{\"1\":{\"101\":1,\"1068\":1}}],[\"为什么\",{\"0\":{\"36\":1,\"403\":1,\"671\":1},\"1\":{\"364\":1,\"447\":1,\"630\":1,\"649\":1}}],[\"一步一步装配这些组成部分\",{\"1\":{\"1086\":1}}],[\"一定不要使用反射产生新的对象\",{\"1\":{\"1075\":1}}],[\"一定安全吗\",{\"0\":{\"1045\":1}}],[\"一定要寻址存储该数据的节点\",{\"1\":{\"880\":1}}],[\"一套网络控制协议ncp\",{\"1\":{\"975\":1}}],[\"一段时间内\",{\"1\":{\"974\":1}}],[\"一串数字\",{\"1\":{\"955\":1}}],[\"一维数组输入\",{\"0\":{\"953\":1}}],[\"一共有\",{\"1\":{\"1094\":1}}],[\"一共有n个机器\",{\"1\":{\"891\":1}}],[\"一共进行arr\",{\"1\":{\"930\":1}}],[\"一共进行数组的个数\",{\"1\":{\"930\":1}}],[\"一一与堆顶元素进行比较\",{\"1\":{\"893\":1}}],[\"一组server的状态机计算相同状态的副本\",{\"1\":{\"873\":1}}],[\"一来一回\",{\"1\":{\"836\":2}}],[\"一直移到\",{\"1\":{\"912\":1}}],[\"一直往左走\",{\"1\":{\"908\":1}}],[\"一直返回空数据\",{\"1\":{\"858\":1}}],[\"一直属于\",{\"1\":{\"820\":1}}],[\"一直占着内存不释放\",{\"1\":{\"303\":1}}],[\"一切显得非常清晰简单\",{\"1\":{\"766\":1}}],[\"一切都是透明的\",{\"1\":{\"657\":1}}],[\"一级缓存作用域太低\",{\"1\":{\"752\":1}}],[\"一级缓存\",{\"1\":{\"752\":1}}],[\"一但需求变化要求迅速输出成果\",{\"1\":{\"749\":1}}],[\"一战上岸\",{\"1\":{\"689\":1}}],[\"一开始时不会太快\",{\"1\":{\"1044\":1}}],[\"一开始就多设置几个\",{\"1\":{\"671\":1}}],[\"一开始插入数据时\",{\"1\":{\"615\":1}}],[\"一边将这些改动追加到现有\",{\"1\":{\"651\":1}}],[\"一是实现有序集合键\",{\"1\":{\"630\":1}}],[\"一下的那个瞬间\",{\"1\":{\"592\":1}}],[\"一半的时候\",{\"1\":{\"568\":1}}],[\"一台计算机想和\",{\"1\":{\"986\":1}}],[\"一台kafka服务器就是一个broker\",{\"1\":{\"845\":1}}],[\"一台机器挂了\",{\"1\":{\"803\":1}}],[\"一台mater只负责写操作\",{\"1\":{\"579\":1}}],[\"一台500\",{\"1\":{\"543\":1}}],[\"一台服务器当主服务器\",{\"1\":{\"469\":1,\"580\":1}}],[\"一把写锁加在id索引上id\",{\"1\":{\"501\":2}}],[\"一部分是内存中的doublewrite\",{\"1\":{\"496\":1}}],[\"一条记录占用空间过大会导致跨页\",{\"1\":{\"585\":1}}],[\"一条sql语句插入多条数据\",{\"1\":{\"564\":1}}],[\"一条\",{\"1\":{\"490\":1}}],[\"一条指令在执行期间\",{\"1\":{\"159\":1}}],[\"一对全体\",{\"1\":{\"979\":1}}],[\"一对多\",{\"1\":{\"456\":1,\"844\":1,\"979\":1,\"1001\":1,\"1002\":1}}],[\"一对一\",{\"1\":{\"456\":1,\"844\":1,\"979\":1}}],[\"一对一设计\",{\"1\":{\"455\":1}}],[\"一行占用空间越小\",{\"1\":{\"585\":1}}],[\"一行一行排列的很整齐\",{\"1\":{\"548\":1}}],[\"一行\",{\"1\":{\"429\":1}}],[\"一页一页的显示文件内容\",{\"1\":{\"428\":1}}],[\"一种通过网络通信将自身从一个结点发送到另一个节点并自动启动的程序\",{\"1\":{\"1054\":1}}],[\"一种情况是可以发送紧急数据\",{\"1\":{\"1015\":1}}],[\"一种入队顺序\",{\"1\":{\"941\":1}}],[\"一种特殊的线性表\",{\"1\":{\"940\":1}}],[\"一种索引方法\",{\"1\":{\"888\":1}}],[\"一种是open\",{\"1\":{\"884\":1}}],[\"一种是一对一的消费\",{\"1\":{\"844\":1}}],[\"一种是\",{\"1\":{\"568\":1}}],[\"一种是按照读取\",{\"1\":{\"414\":1}}],[\"一种是按照插入\",{\"1\":{\"414\":1}}],[\"一种被称为硬链接\",{\"1\":{\"427\":1}}],[\"一起列出来\",{\"1\":{\"419\":1}}],[\"一起对反射提供了支持\",{\"1\":{\"348\":1}}],[\"一致哈希算法也用了取模运算\",{\"1\":{\"880\":1}}],[\"一致性不依赖时序\",{\"1\":{\"873\":1}}],[\"一致性哈希是指将\",{\"1\":{\"880\":1}}],[\"一致性哈希要进行两步哈希\",{\"1\":{\"880\":1}}],[\"一致性哈希缺点\",{\"1\":{\"681\":1}}],[\"一致性哈希优点\",{\"1\":{\"681\":1}}],[\"一致性哈希算法并不保证节点能够在哈希环上分布均匀\",{\"1\":{\"880\":1}}],[\"一致性哈希算法\",{\"1\":{\"880\":1}}],[\"一致性哈希算法引入了虚拟节点机制\",{\"1\":{\"681\":1}}],[\"一致性哈希算法在服务节点太少的情况下\",{\"1\":{\"681\":1}}],[\"一致性哈希算法将整个哈希值空间按照顺时针反向组织成一个虚拟的圆环\",{\"1\":{\"681\":1}}],[\"一致性哈希算法也是使用取模算法\",{\"1\":{\"681\":1}}],[\"一致性哈希\",{\"0\":{\"681\":1,\"880\":1}}],[\"一致性hash算法对于节点的增减都只需重定位环空间中的一小部分数据\",{\"1\":{\"587\":1}}],[\"一致性才能得到保障\",{\"1\":{\"519\":1}}],[\"一致性可以理解为我们使用事务的目的\",{\"1\":{\"519\":1}}],[\"一致性\",{\"1\":{\"519\":1,\"812\":1,\"870\":1,\"873\":1}}],[\"一致\",{\"1\":{\"410\":1}}],[\"一样去重复\",{\"1\":{\"805\":1}}],[\"一样打包或者运行应用程序的命令\",{\"1\":{\"774\":1}}],[\"一样\",{\"1\":{\"393\":1,\"820\":1}}],[\"一样长\",{\"1\":{\"45\":1}}],[\"一次链接是一次事务\",{\"1\":{\"1037\":1}}],[\"一次连接发一次数据不存在粘包\",{\"1\":{\"1006\":1}}],[\"一次读取一行数据\",{\"0\":{\"952\":1}}],[\"一次交换都没有发生过\",{\"1\":{\"930\":1}}],[\"一次\",{\"1\":{\"632\":1}}],[\"一次插入多条数据\",{\"1\":{\"565\":1}}],[\"一次io只能访问一个数据块\",{\"1\":{\"543\":1}}],[\"一次io能存入一个节点\",{\"1\":{\"541\":1}}],[\"一次锁定相邻的一组记录\",{\"1\":{\"512\":1}}],[\"一次删除多级空目录\",{\"1\":{\"418\":1}}],[\"一次遍历就能找到相应元素\",{\"1\":{\"391\":1}}],[\"一次编译\",{\"1\":{\"336\":1}}],[\"一次性就可以加入到内存了\",{\"1\":{\"895\":1}}],[\"一次性创建所有的bean\",{\"1\":{\"712\":1}}],[\"一次性创建了所有的bean\",{\"1\":{\"712\":1}}],[\"一次性查询所有结果会变得很慢\",{\"1\":{\"486\":1}}],[\"一次性\",{\"1\":{\"303\":1}}],[\"一方面我们可以考虑上面的字典方法能否被改进以适应这种情形\",{\"1\":{\"891\":1}}],[\"一方面\",{\"1\":{\"675\":1}}],[\"一方面这是一种\",{\"1\":{\"265\":1}}],[\"一方面提供了一种有效的数据交互方式\",{\"1\":{\"198\":1}}],[\"一些网站会使用自签名证书\",{\"1\":{\"1045\":1}}],[\"一些常驻的异常对象\",{\"1\":{\"234\":1}}],[\"一些比较重要的比如从硬盘读取数据\",{\"1\":{\"134\":1}}],[\"一旦整体对象不存在\",{\"1\":{\"1099\":1}}],[\"一旦发生冲突\",{\"1\":{\"924\":1}}],[\"一旦发现有变动\",{\"1\":{\"829\":1}}],[\"一旦发现了只具有弱引用的对象\",{\"1\":{\"235\":1}}],[\"一旦选出了\",{\"1\":{\"878\":1}}],[\"一旦某台服务器的票数超过半数以上\",{\"1\":{\"820\":1}}],[\"一旦某个\",{\"1\":{\"381\":1}}],[\"一旦客户端会话失效\",{\"1\":{\"818\":1}}],[\"一旦被其调用就会带来问题\",{\"1\":{\"802\":1}}],[\"一旦被占用\",{\"1\":{\"110\":1,\"111\":1}}],[\"一旦节点\",{\"1\":{\"683\":1}}],[\"一旦这个\",{\"1\":{\"674\":1}}],[\"一旦你添加了另一台服务器\",{\"1\":{\"671\":1}}],[\"一旦插入失败就会直接报错\",{\"1\":{\"668\":1}}],[\"一旦解锁操作失败\",{\"1\":{\"668\":1}}],[\"一旦挂掉快速切换到备库上\",{\"1\":{\"668\":1}}],[\"一旦数据库挂掉\",{\"1\":{\"668\":1}}],[\"一旦开启了混合持久化\",{\"1\":{\"653\":1}}],[\"一旦宕机对应的数据就丢失了\",{\"1\":{\"650\":1}}],[\"一旦未分配足够长度的内存空间\",{\"1\":{\"624\":1}}],[\"一旦有消息到达mq\",{\"1\":{\"843\":1}}],[\"一旦有请求到达\",{\"1\":{\"604\":1}}],[\"一旦有别的会话插入新的记录\",{\"1\":{\"504\":1}}],[\"一旦超过\",{\"1\":{\"399\":1}}],[\"一旦该\",{\"1\":{\"381\":1}}],[\"一旦把对象引用放入到缓存中\",{\"1\":{\"304\":1}}],[\"一旦收集器在写屏障中增加了更新卡表操作\",{\"1\":{\"250\":1}}],[\"一旦得到处理器资源\",{\"1\":{\"148\":1}}],[\"一般包括增删改查方法\",{\"1\":{\"1239\":1}}],[\"一般使用事件风暴法\",{\"1\":{\"1216\":1}}],[\"一般使用接口或抽象类实现\",{\"1\":{\"1088\":1}}],[\"一般使用的是轻量级锁\",{\"1\":{\"86\":1}}],[\"一般代理会被理解为代码增强\",{\"1\":{\"1081\":1}}],[\"一般免费证书很少\",{\"1\":{\"1048\":1}}],[\"一般返回的内容不会超过\",{\"1\":{\"1033\":1}}],[\"一般按照下面这个式子\",{\"1\":{\"1012\":1}}],[\"一般有两个通用的解决方法\",{\"1\":{\"1006\":1}}],[\"一般都在路由表中设置一个默认路由器的ip地址\",{\"1\":{\"993\":1}}],[\"一般都是放一个表示默认不存在的\",{\"1\":{\"641\":1}}],[\"一般为一两个月\",{\"1\":{\"879\":1}}],[\"一般为\",{\"1\":{\"879\":1}}],[\"一般为了便于决策选举\",{\"1\":{\"657\":1}}],[\"一般为4k或8k\",{\"1\":{\"543\":1}}],[\"一般时间很短\",{\"1\":{\"647\":1}}],[\"一般并发量不是特别多的时候\",{\"1\":{\"642\":1}}],[\"一般建议使用其来替代\",{\"1\":{\"607\":1}}],[\"一般我们只是使用\",{\"1\":{\"606\":1}}],[\"一般可使用\",{\"1\":{\"589\":1}}],[\"一般采用\",{\"1\":{\"1229\":1}}],[\"一般采用mod来切分\",{\"1\":{\"588\":1}}],[\"一般采用hash取模mod的切分方式\",{\"1\":{\"587\":1}}],[\"一般将不常用的\",{\"1\":{\"585\":1}}],[\"一般的语句修改使用statment格式保存binlog\",{\"1\":{\"572\":1}}],[\"一般的gc时间中\",{\"1\":{\"331\":1}}],[\"一般肯定要kill掉这些线程\",{\"1\":{\"562\":1}}],[\"一般以整型值为主的表在千万级以下\",{\"1\":{\"561\":1}}],[\"一般在租期时间的1\",{\"1\":{\"1049\":1}}],[\"一般在零点几毫秒\",{\"1\":{\"543\":1}}],[\"一般在大多数情况下我们都是不推荐去使用查询缓存的\",{\"1\":{\"490\":1}}],[\"一般原则\",{\"1\":{\"535\":1}}],[\"一般通过提问的方式来驱动交流\",{\"1\":{\"1216\":1}}],[\"一般通过记录数据版本\",{\"1\":{\"513\":1}}],[\"一般通过数据库的锁机制实现\",{\"1\":{\"513\":1}}],[\"一般分页查询\",{\"1\":{\"486\":1}}],[\"一般不支持重复读取\",{\"1\":{\"612\":1}}],[\"一般不建议将这个参数设成\",{\"1\":{\"571\":1}}],[\"一般不直接使用\",{\"1\":{\"485\":1}}],[\"一般不会在整个回收阶段发生stw的情况\",{\"1\":{\"261\":1}}],[\"一般情况下我们会使用\",{\"1\":{\"753\":1}}],[\"一般情况下越小的列越好\",{\"1\":{\"472\":1}}],[\"一般情况下msg是要定义在这个里面的\",{\"1\":{\"304\":1}}],[\"一般该目录名是以用户的账号命名的\",{\"1\":{\"416\":1}}],[\"一般应用是很难出现碰撞的\",{\"1\":{\"405\":1}}],[\"一般大家都会说\",{\"1\":{\"393\":1}}],[\"一般是~\",{\"1\":{\"1178\":1}}],[\"一般是第一个收到的ip\",{\"1\":{\"1049\":1}}],[\"一般是超过半数\",{\"1\":{\"677\":1}}],[\"一般是缓存时间到期\",{\"1\":{\"643\":1}}],[\"一般是表中的主键索引\",{\"1\":{\"547\":1}}],[\"一般是在外键上创建索引\",{\"1\":{\"528\":1}}],[\"一般是一次性的\",{\"1\":{\"494\":1}}],[\"一般是读就绪或者写就绪\",{\"1\":{\"381\":1}}],[\"一般是通过优化磁盘的访问请求顺序来做到\",{\"1\":{\"163\":1}}],[\"一般必须满足\",{\"1\":{\"350\":1}}],[\"一般\",{\"1\":{\"350\":1,\"644\":1,\"895\":1}}],[\"一般子类都有覆盖\",{\"1\":{\"350\":1}}],[\"一般用cookie和session来弥补http的无状态特性\",{\"1\":{\"1037\":1}}],[\"一般用来解决应用解耦\",{\"1\":{\"840\":1}}],[\"一般用来修饰成员变量或方法\",{\"1\":{\"360\":1}}],[\"一般用来存放一些关闭资源的操作\",{\"1\":{\"346\":1}}],[\"一般用于等待异步线程执行完结果之后才能继续运行的场景\",{\"1\":{\"35\":1}}],[\"一般作用在\",{\"1\":{\"346\":1}}],[\"一般而言在使用\",{\"1\":{\"606\":1}}],[\"一般而言\",{\"1\":{\"304\":1}}],[\"一般手段是\",{\"1\":{\"298\":1}}],[\"一般会把动态连接\",{\"1\":{\"196\":1}}],[\"一般会经常产生冲突\",{\"1\":{\"104\":1}}],[\"一般来说数据范围是int的10倍以下\",{\"1\":{\"883\":1}}],[\"一般来说我们在speing\",{\"1\":{\"783\":1}}],[\"一般来说\",{\"1\":{\"195\":1,\"249\":1,\"304\":1,\"541\":1,\"556\":1,\"879\":1}}],[\"一般处于特权级\",{\"1\":{\"134\":1}}],[\"一个上下文通过一些适配\",{\"1\":{\"1222\":1}}],[\"一个数据包中包含了发送端发送的两个数据包的信息\",{\"1\":{\"1006\":1}}],[\"一个数据块中最多存放一个文件的内容\",{\"1\":{\"442\":1}}],[\"一个ipv4最小需要7个字符\",{\"1\":{\"997\":1}}],[\"一个用来建立\",{\"1\":{\"975\":1}}],[\"一个用户的事务不被其他事务所干扰\",{\"1\":{\"519\":1}}],[\"一个将ip数据报封装到串行链路的方法\",{\"1\":{\"975\":1}}],[\"一个http请求到来\",{\"1\":{\"959\":1,\"1029\":1}}],[\"一个结点存储一个元素\",{\"1\":{\"916\":1}}],[\"一个文本文件\",{\"0\":{\"899\":1}}],[\"一个查询串的重复度越高\",{\"1\":{\"893\":1}}],[\"一个最大堆与一个最小堆结合\",{\"1\":{\"885\":1}}],[\"一个或多个\",{\"1\":{\"876\":1}}],[\"一个leader和多个follower\",{\"1\":{\"845\":1}}],[\"一个topic的每个partition有若干个副本\",{\"1\":{\"845\":1}}],[\"一个topic可以分为多个partition\",{\"1\":{\"845\":1}}],[\"一个bit位\",{\"1\":{\"901\":1}}],[\"一个broker可以容纳多个topic\",{\"1\":{\"845\":1}}],[\"一个bug\",{\"1\":{\"515\":1}}],[\"一个集群由多个broker组成\",{\"1\":{\"845\":1}}],[\"一个订单多条消息问题\",{\"1\":{\"841\":1}}],[\"一个nginx\",{\"1\":{\"833\":1}}],[\"一个标注为worker\",{\"1\":{\"830\":1}}],[\"一个标注为master\",{\"1\":{\"830\":1}}],[\"一个负责监听\",{\"1\":{\"822\":1}}],[\"一个负责网络连接通信\",{\"1\":{\"822\":1}}],[\"一个应用部署在\",{\"1\":{\"801\":1}}],[\"一个可引用\",{\"1\":{\"790\":1}}],[\"一个可执行\",{\"1\":{\"790\":1}}],[\"一个可行实现热替换的方法是灵活运用classloader\",{\"1\":{\"187\":1}}],[\"一个节点想要分享一些信息给网络中的其它的一些节点\",{\"1\":{\"684\":1}}],[\"一个实际物理节点可以对应多个虚拟节点\",{\"1\":{\"681\":1}}],[\"一个方法在同一时间只能被一个机器的一个线程执行\",{\"1\":{\"667\":1}}],[\"一个主节点对应一个或者多个从节点\",{\"1\":{\"659\":1}}],[\"一个比较常见的做法就是\",{\"1\":{\"644\":1}}],[\"一个一定不存在的数据会被这个\",{\"1\":{\"641\":1}}],[\"一个稍微完善一点的缓存框架至少要提供\",{\"1\":{\"607\":1}}],[\"一个页的大小一般是16kb\",{\"1\":{\"591\":1}}],[\"一个页的大小是\",{\"1\":{\"539\":1}}],[\"一个事务的\",{\"1\":{\"571\":1}}],[\"一个事务被提交之后\",{\"1\":{\"519\":1}}],[\"一个没有提交的事务的\",{\"1\":{\"568\":1}}],[\"一个没加主键的表\",{\"1\":{\"548\":1}}],[\"一个块的大小是\",{\"1\":{\"539\":1}}],[\"一个扇区的大小是\",{\"1\":{\"539\":1}}],[\"一个非常大的topic可以分布到多个broker上\",{\"1\":{\"845\":1}}],[\"一个非叶子节点可以存放\",{\"1\":{\"539\":1}}],[\"一个非数组类的加载阶段\",{\"1\":{\"168\":1}}],[\"一个索引上不同的值越多\",{\"1\":{\"536\":1}}],[\"一个表只能有一个主键索引\",{\"1\":{\"548\":1}}],[\"一个表只能有一个\",{\"1\":{\"546\":1}}],[\"一个表中可以有多少个\",{\"1\":{\"462\":1}}],[\"一个表项包含\",{\"1\":{\"392\":1}}],[\"一个进程退出后\",{\"1\":{\"834\":1}}],[\"一个进程可以监视多个描述符\",{\"1\":{\"381\":1}}],[\"一个进程至少应该占有一个资源\",{\"1\":{\"98\":1}}],[\"一个变量定义的作用域大于其适用范围\",{\"1\":{\"304\":1}}],[\"一个变量在同一个时刻只允许一条线程对其进行lock操作\",{\"1\":{\"295\":1}}],[\"一个处理器的缓存回写到内存会导致其他处理器的缓存无效\",{\"1\":{\"296\":1}}],[\"一个卡页的内存中通常包含不止一个对象\",{\"1\":{\"249\":1}}],[\"一个新的对象已经产生了\",{\"1\":{\"223\":1}}],[\"一个对象并没有逃逸出方法的话\",{\"1\":{\"202\":1}}],[\"一个对象的初始化完成先行发生于他的\",{\"1\":{\"75\":1,\"102\":1}}],[\"一个栈帧需要分配多少内存\",{\"1\":{\"191\":1}}],[\"一个典型的例子便是jndi服务\",{\"1\":{\"185\":1}}],[\"一个类尽量减少自己对其它对象的依赖\",{\"1\":{\"1064\":1}}],[\"一个类对另一个类的依赖应该建立在最小的接口上\",{\"1\":{\"1064\":1}}],[\"一个类只干一件事\",{\"1\":{\"1064\":1}}],[\"一个类\",{\"1\":{\"174\":1}}],[\"一个连续完整的地址空间\",{\"1\":{\"157\":1}}],[\"一个父进程退出\",{\"1\":{\"151\":1}}],[\"一个++\",{\"1\":{\"99\":1}}],[\"一个是插槽\",{\"1\":{\"659\":1}}],[\"一个是真正的数据存储位置\",{\"1\":{\"622\":1}}],[\"一个是\",{\"1\":{\"81\":2}}],[\"一个\",{\"0\":{\"399\":1},\"1\":{\"75\":1,\"99\":1,\"102\":1,\"129\":2,\"349\":3,\"381\":1,\"655\":2,\"673\":1,\"825\":1,\"874\":1,\"877\":1,\"918\":3}}],[\"一个线程可以有多个协程\",{\"1\":{\"831\":1}}],[\"一个线程可以拥有多个协程\",{\"1\":{\"139\":1}}],[\"一个线程\",{\"1\":{\"121\":1}}],[\"一个线程中\",{\"1\":{\"102\":1}}],[\"一个线程由于\",{\"1\":{\"100\":1}}],[\"一个线程观察其他线程中的指令执行顺序\",{\"1\":{\"67\":1}}],[\"一个线程对主内存的修改可以及时地被其他线程看到\",{\"1\":{\"67\":1}}],[\"一\",{\"0\":{\"29\":1,\"165\":1,\"334\":1,\"601\":1}}],[\"把适配者接口转换成目标接口\",{\"1\":{\"1092\":1}}],[\"把使用算法的责任和算法的实现分割开来\",{\"1\":{\"1088\":1}}],[\"把协议软件中给这些参数赋值的动作叫做协议配置\",{\"1\":{\"1049\":1}}],[\"把header从数据中分离\",{\"1\":{\"1042\":1}}],[\"把heap转存\",{\"1\":{\"324\":1}}],[\"把待解析的域名放在dns请求报文中\",{\"1\":{\"1031\":1}}],[\"把后面到达的数据字节都缓存起来\",{\"1\":{\"1017\":1}}],[\"把有序数据传送给应用层\",{\"1\":{\"1009\":1}}],[\"把这些数据块仅仅看成一连串无结构的字节流\",{\"1\":{\"1006\":1}}],[\"把这个值加上\",{\"1\":{\"489\":1}}],[\"把这个虚引用加入到与之关联的引用队列中\",{\"1\":{\"235\":1}}],[\"把这个\",{\"1\":{\"39\":1}}],[\"把32位的ip地址划分为前后两个部分\",{\"1\":{\"991\":1}}],[\"把它的排序码依次与有序表元素的排序码进行比较\",{\"1\":{\"932\":1}}],[\"把它们加入gc\",{\"1\":{\"249\":1}}],[\"把对应的ip地址放在回答报文中返回\",{\"1\":{\"1031\":1}}],[\"把对应位是01的整数输出即可\",{\"1\":{\"900\":1}}],[\"把对象的控制权交给他了\",{\"1\":{\"718\":1}}],[\"把对象按照程序员的意愿进行初始化\",{\"1\":{\"223\":1}}],[\"把包含20亿个数的小文件用哈希函数分为16个小文件\",{\"1\":{\"897\":1}}],[\"把最先遍历到的k个数存放到最小堆中\",{\"1\":{\"893\":1}}],[\"把海量\",{\"1\":{\"892\":1}}],[\"把整个大文件映射为1000个小文件\",{\"1\":{\"892\":1}}],[\"把静态文件独立成单独的域名\",{\"1\":{\"827\":1}}],[\"把大型系统划分为一个个小的功能模块\",{\"1\":{\"809\":1}}],[\"把大任务切分成若干个子任务并行的执行\",{\"1\":{\"49\":1}}],[\"把服务的唯一\",{\"1\":{\"801\":1}}],[\"把逻辑视图解析成具体的视图\",{\"1\":{\"756\":1}}],[\"把复杂的web应用分成逻辑清晰的几部分\",{\"1\":{\"754\":1}}],[\"把切面应用到目标对象并创建新的代理对象的过程\",{\"1\":{\"721\":1}}],[\"把软件系统分为两个部分\",{\"1\":{\"719\":1}}],[\"把你要的东西主动给你\",{\"1\":{\"718\":1}}],[\"把具体技术相关的异常\",{\"1\":{\"717\":1}}],[\"把上下文文件当成类路径资源\",{\"1\":{\"712\":1}}],[\"把当前数据生成快照保存在硬盘上\",{\"1\":{\"646\":1}}],[\"把哈希表\",{\"1\":{\"615\":1}}],[\"把需要监控的\",{\"1\":{\"612\":1}}],[\"把需要的字段都放到\",{\"1\":{\"484\":1}}],[\"把该事件交给对应的事件处理器进行处理\",{\"1\":{\"611\":1}}],[\"把一个报文划分成几个分组\",{\"1\":{\"960\":1}}],[\"把一个\",{\"1\":{\"597\":1}}],[\"把checkpoint往前推进\",{\"1\":{\"594\":1}}],[\"把class文件加载到内存中\",{\"1\":{\"182\":1}}],[\"把结果放在临时表中\",{\"1\":{\"556\":1}}],[\"把其中有几条记录上了行锁了\",{\"1\":{\"514\":1}}],[\"把数据全部存在内存之中\",{\"1\":{\"610\":1}}],[\"把数据和操作数据的方法封装\",{\"1\":{\"355\":1}}],[\"把数据及对数据的操作方法放在一起\",{\"1\":{\"354\":1}}],[\"把数据从工作内存中\",{\"1\":{\"73\":1}}],[\"把内存中的对象状态保存到一个文件中或者数据库中时候\",{\"1\":{\"344\":1}}],[\"把gc日志写入到每一个文件中去\",{\"1\":{\"325\":1}}],[\"把msg保存到数据库中\",{\"1\":{\"304\":1}}],[\"把为编译部分的源码逐行编译\",{\"1\":{\"282\":1}}],[\"把写前屏障和写后屏障中要做的事情都放到队列里\",{\"1\":{\"262\":1}}],[\"把原有自己掌控的事去交给别人去处理\",{\"1\":{\"718\":1}}],[\"把原本存储于一个表的数据分块存储到多个表上\",{\"1\":{\"583\":1}}],[\"把原本存储于一个库的数据分块存储到多个库上\",{\"1\":{\"583\":1}}],[\"把原本存活的对象错误标记为已消亡\",{\"1\":{\"251\":1}}],[\"把原进程的数据段代码换出去\",{\"1\":{\"28\":1,\"139\":1}}],[\"把描述类的数据从class文件加载到内存\",{\"1\":{\"165\":1}}],[\"把进程的\",{\"1\":{\"147\":1}}],[\"把单线程程序保护起来\",{\"1\":{\"76\":1}}],[\"把工作内存的变量值传到主内存\",{\"1\":{\"74\":1}}],[\"把工作内存中的变量值传给执行引擎\",{\"1\":{\"74\":1}}],[\"把工作内存中的数据传给执行引擎\",{\"1\":{\"73\":1}}],[\"把从执行引擎接收的值赋给工作内存变量\",{\"1\":{\"74\":1}}],[\"把从执行引擎收到的值赋给工作内存中的变量\",{\"1\":{\"73\":1}}],[\"把\",{\"1\":{\"74\":2,\"637\":1,\"649\":1,\"932\":1,\"1108\":1}}],[\"把变量声明为\",{\"1\":{\"78\":1}}],[\"把变量值从主内存传到工作内存\",{\"1\":{\"74\":1}}],[\"把变量标识为线程独占状态\",{\"1\":{\"74\":1}}],[\"把要执行的进程内容换进来\",{\"1\":{\"28\":1,\"139\":1}}],[\"资源共享的情况下\",{\"1\":{\"1073\":1}}],[\"资源消耗\",{\"1\":{\"1048\":1}}],[\"资源未找到\",{\"1\":{\"1040\":1}}],[\"资源使用过量\",{\"1\":{\"713\":1}}],[\"资源的利用率\",{\"1\":{\"678\":1}}],[\"资源浪费\",{\"1\":{\"676\":1}}],[\"资源去处理过期的数据\",{\"1\":{\"632\":1}}],[\"资源库\",{\"1\":{\"444\":1,\"1121\":1}}],[\"资源得到满足或错误处理完毕时\",{\"1\":{\"148\":1}}],[\"资源不能被抢占\",{\"1\":{\"98\":1}}],[\"资源必须处于非共享模式\",{\"1\":{\"98\":1}}],[\"资源\",{\"1\":{\"64\":1,\"98\":2,\"583\":1,\"632\":1}}],[\"资源开销比行锁少\",{\"1\":{\"510\":1}}],[\"资源开销\",{\"1\":{\"28\":1,\"139\":1}}],[\"资源拥有\",{\"1\":{\"28\":1,\"139\":1}}],[\"而我们知道该\",{\"1\":{\"1090\":1}}],[\"而将算法的一些步骤延迟到子类中\",{\"1\":{\"1087\":1}}],[\"而工厂方法模式更注重零部件的创建过程\",{\"1\":{\"1086\":1}}],[\"而工作中的场景是常常用到\",{\"1\":{\"342\":1}}],[\"而使这些子系统更加容易被访问的模式\",{\"1\":{\"1090\":1}}],[\"而使调用者无感知\",{\"1\":{\"1081\":1}}],[\"而使用策略模式可以避免使用多重条件语句\",{\"1\":{\"1088\":1}}],[\"而使用一致性哈希算法就可以很好的解决这个问题\",{\"1\":{\"681\":1}}],[\"而使用\",{\"0\":{\"131\":1},\"1\":{\"61\":1,\"480\":1,\"850\":1}}],[\"而动态代理类是在\",{\"1\":{\"1081\":1}}],[\"而抽象工厂模式可生产多个等级的产品\",{\"1\":{\"1079\":1}}],[\"而减少此时间值可提高域名解析的正确性\",{\"1\":{\"1032\":1}}],[\"而重传会使tcp连接的发送端认为发生了拥塞\",{\"1\":{\"1021\":1}}],[\"而改为一个一个增加的线性增长阶段\",{\"1\":{\"1019\":1}}],[\"而应用进程一次只从接收缓存中读取1个字节\",{\"1\":{\"1018\":1}}],[\"而下一个数据又到来并有一部分放入的缓冲区末尾\",{\"1\":{\"1006\":1}}],[\"而目前\",{\"1\":{\"996\":1}}],[\"而只支持点对点的链路通信\",{\"1\":{\"975\":1}}],[\"而只能根据统计信息来估算记录数\",{\"1\":{\"536\":1}}],[\"而位数比较少的情况\",{\"1\":{\"923\":1}}],[\"而插入删除也为\",{\"1\":{\"916\":1}}],[\"而另一个>=10亿\",{\"1\":{\"901\":1}}],[\"而另一个>=20亿\",{\"1\":{\"901\":1}}],[\"而另一个则可能完全聚集到一个机子上\",{\"1\":{\"891\":1}}],[\"而反向索引则是单词指向了包含它的文档\",{\"1\":{\"888\":1}}],[\"而互不干扰\",{\"1\":{\"873\":1}}],[\"而互斥是实现同步的一种手段\",{\"1\":{\"142\":1}}],[\"而事务能够保证跨分区\",{\"1\":{\"863\":1}}],[\"而事务得保证一组操作同时成功或失败\",{\"1\":{\"43\":1}}],[\"而各个\",{\"1\":{\"861\":1}}],[\"而各处都基本相似\",{\"1\":{\"719\":1}}],[\"而pull方式则可以让consumer根据自己的消费处理能力以适当的速度消费消息\",{\"1\":{\"858\":1}}],[\"而parallel\",{\"1\":{\"257\":1}}],[\"而broker端会对<pid\",{\"1\":{\"856\":1}}],[\"而随机写只有200k\",{\"1\":{\"850\":1}}],[\"而epoll模型避免了阻塞\",{\"1\":{\"830\":1}}],[\"而epoll模型\",{\"1\":{\"829\":1}}],[\"而文件系统中只有文件节点可以存放数据而目录节点不行\",{\"1\":{\"818\":1}}],[\"而该jar包又引用了其他jar包\",{\"1\":{\"796\":1}}],[\"而该资源被其他进程所占有\",{\"1\":{\"98\":1}}],[\"而session保存在服务器上\",{\"1\":{\"1052\":1}}],[\"而springboot打包成的可执行jar解压后\",{\"1\":{\"790\":1}}],[\"而synchronized则是由\",{\"1\":{\"295\":1}}],[\"而无须知道其创建细节\",{\"1\":{\"1077\":1}}],[\"而无须逐条记录去检测\",{\"1\":{\"514\":1}}],[\"而无需重新启动服务器\",{\"1\":{\"769\":1}}],[\"而三层架构是一种软件架构\",{\"1\":{\"754\":1}}],[\"而持久化的设计则实现了数据处理层内部的业务逻辑和数据逻辑分离的解耦合\",{\"1\":{\"748\":1}}],[\"而编程式事务管理是可以到代码块的\",{\"1\":{\"739\":1}}],[\"而声明式事务不同\",{\"1\":{\"739\":1}}],[\"而xml文件的修改并没有发生java代码发生改变\",{\"1\":{\"731\":1}}],[\"而ioc只需\",{\"1\":{\"731\":1}}],[\"而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的\",{\"1\":{\"274\":1}}],[\"而代理逻辑类要实现接口的一个方法\",{\"1\":{\"727\":1}}],[\"而代理模式虽然也可以增加新的行为\",{\"1\":{\"716\":1}}],[\"而装饰者能够在运行时递归地被构造\",{\"1\":{\"716\":1}}],[\"而装饰器模式的通常做法是将原始对象作为参数传给装饰者的构造器\",{\"1\":{\"716\":1}}],[\"而产生的死锁问题\",{\"1\":{\"668\":1}}],[\"而进入死锁状态\",{\"1\":{\"668\":1}}],[\"而成员对象较大的节点则会排在后面\",{\"1\":{\"630\":1}}],[\"而查找其他元素时\",{\"1\":{\"627\":1}}],[\"而套接字多应用于网络进程间数据的传递\",{\"1\":{\"612\":1}}],[\"而缓存的内容可以失效\",{\"1\":{\"603\":1}}],[\"而表名是不能加单引号的\",{\"1\":{\"596\":1}}],[\"而内存不够用的时候\",{\"1\":{\"594\":1}}],[\"而内部类不需使用外部类\",{\"1\":{\"361\":1}}],[\"而mysql偶尔\",{\"1\":{\"592\":1}}],[\"而有些分片存储的历史数据\",{\"1\":{\"587\":1}}],[\"而有可能是之前的历史版本\",{\"1\":{\"499\":1}}],[\"而分布式事务处理比较复杂\",{\"1\":{\"585\":1}}],[\"而页中存储的是行数据\",{\"1\":{\"585\":1}}],[\"而水平分表是基于全表的\",{\"1\":{\"585\":1}}],[\"而一致哈希算法是对\",{\"1\":{\"880\":1}}],[\"而一致性哈希算法是对\",{\"1\":{\"681\":1}}],[\"而一台服务器的\",{\"1\":{\"583\":1}}],[\"而一个topic又可以有多个partition组成\",{\"1\":{\"852\":1}}],[\"而一个索引上不同的值的个数称之为\",{\"1\":{\"536\":1}}],[\"而一个或多个其它的服务器来当从服务器\",{\"1\":{\"469\":1,\"580\":1}}],[\"而cglib既可以代理接口又可以代理非抽象类\",{\"1\":{\"727\":1}}],[\"而change\",{\"1\":{\"574\":1,\"575\":1}}],[\"而copyonwritearraylist\",{\"1\":{\"411\":1}}],[\"而如果创建复杂对象\",{\"1\":{\"1086\":1}}],[\"而如果使用无符号整数来存储\",{\"1\":{\"997\":1}}],[\"而如果集群内超过半数的节点认为\",{\"1\":{\"683\":1}}],[\"而如果这个数据页还没有在内存中的话\",{\"1\":{\"574\":1}}],[\"而如果对于\",{\"1\":{\"391\":1}}],[\"而二进制日志不包含查询数据的\",{\"1\":{\"566\":1}}],[\"而二级索引只存储了主键值\",{\"1\":{\"549\":1}}],[\"而哈希索引\",{\"1\":{\"550\":1}}],[\"而唯一索引\",{\"1\":{\"549\":1}}],[\"而叶子节点就很难确定了\",{\"1\":{\"542\":1}}],[\"而硬盘的最小存储单位页的大小通常是固定的\",{\"1\":{\"542\":1}}],[\"而指针大小在\",{\"1\":{\"539\":1}}],[\"而回滚段有\",{\"1\":{\"525\":1}}],[\"而隔离性\",{\"1\":{\"519\":1}}],[\"而执行期间另一个线程对这个表结构做变更\",{\"1\":{\"511\":1}}],[\"而非对称加密是指使用一对非对称密钥\",{\"1\":{\"1056\":1}}],[\"而非交换\",{\"1\":{\"935\":1}}],[\"而非物理分页\",{\"1\":{\"753\":1}}],[\"而非数据本身\",{\"1\":{\"503\":1}}],[\"而非使用默认属性\",{\"1\":{\"423\":1}}],[\"而非使用连结\",{\"1\":{\"421\":1}}],[\"而从innodb\",{\"1\":{\"498\":1}}],[\"而其数据文件都是存储在内存中\",{\"1\":{\"494\":1}}],[\"而其他的\",{\"1\":{\"121\":1}}],[\"而where是从数据表中的字段直接进行的筛选的\",{\"1\":{\"481\":1}}],[\"而已\",{\"1\":{\"430\":1}}],[\"而旧容器的对象还在使用\",{\"1\":{\"411\":1}}],[\"而迭代器的实现就是指向下一个元素\",{\"1\":{\"391\":1}}],[\"而采用\",{\"1\":{\"381\":1}}],[\"而异步\",{\"1\":{\"381\":1}}],[\"而当前只有\",{\"1\":{\"638\":1}}],[\"而当要读入的数据页没有再内存的时候\",{\"1\":{\"594\":1}}],[\"而当\",{\"1\":{\"380\":1}}],[\"而当使用cms这种基于清除算法的收集器时\",{\"1\":{\"218\":1}}],[\"而读取数据的过程就是一个内核态到用户态的数据拷贝过程\",{\"1\":{\"380\":1}}],[\"而后更新整个堆\",{\"1\":{\"893\":1}}],[\"而后遍历后续的n\",{\"1\":{\"893\":1}}],[\"而后再进行\",{\"1\":{\"380\":1}}],[\"而后者实现的是运行时的多态性\",{\"1\":{\"359\":1}}],[\"而后者是移动式的\",{\"1\":{\"246\":1}}],[\"而数据则需要大量数据移动\",{\"1\":{\"372\":1}}],[\"而接口中的成员只可以是\",{\"1\":{\"362\":1}}],[\"而接口中只能有抽象方法\",{\"1\":{\"362\":1}}],[\"而接口索引集合是一组u2类型的数据的集合\",{\"1\":{\"288\":1}}],[\"而引用传递一般是对于对象型变量而言的\",{\"1\":{\"351\":1}}],[\"而引用仅仅是一个地址\",{\"1\":{\"101\":1,\"714\":1}}],[\"而栈空间存的引用类型的地址\",{\"1\":{\"351\":1}}],[\"而list\",{\"1\":{\"345\":1}}],[\"而在读写混合场景中\",{\"1\":{\"491\":1}}],[\"而在et\",{\"1\":{\"381\":1}}],[\"而在\",{\"1\":{\"336\":1}}],[\"而在垃圾收集的场景中\",{\"1\":{\"249\":1}}],[\"而threadlocalmap可以存储以threadlocal为key的键值对\",{\"1\":{\"299\":1}}],[\"而属性值的结构则是完全自定义的\",{\"1\":{\"291\":1}}],[\"而实际类型变化的结果在运行期才可确定\",{\"1\":{\"277\":1}}],[\"而实际上\",{\"1\":{\"157\":1,\"404\":1}}],[\"而g1在大内存的应用上在发挥优势\",{\"1\":{\"262\":1}}],[\"而g1就不得不将其实现为类似于消息队列的结构\",{\"1\":{\"262\":1}}],[\"而g1可以采用应用线程承担后台运行的gc工作\",{\"1\":{\"260\":1}}],[\"而hotspot虚拟机确实也是这样做的\",{\"1\":{\"249\":1}}],[\"而关注延迟的cms收集器则是基于标记\",{\"1\":{\"246\":1}}],[\"而reference本身不需要被修改\",{\"1\":{\"230\":1}}],[\"而句柄中包含了对象实例数据与类型数据各自的具体地址信息\",{\"1\":{\"229\":1}}],[\"而java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理的能力决定\",{\"1\":{\"218\":1}}],[\"而full\",{\"1\":{\"207\":1}}],[\"而新的对象则放入eden区\",{\"1\":{\"200\":1}}],[\"而对访问元素时的效率没有很高的要求的话\",{\"1\":{\"373\":1}}],[\"而对象头部分正好是\",{\"1\":{\"227\":1}}],[\"而对象的方法就是处理逻辑\",{\"1\":{\"198\":1}}],[\"而对于一些二进制文件\",{\"1\":{\"624\":1}}],[\"而对于这个区间之外的数就需要\",{\"1\":{\"368\":1}}],[\"而对于\",{\"1\":{\"121\":1}}],[\"而堆不同\",{\"1\":{\"198\":1}}],[\"而堆代表了数据\",{\"1\":{\"198\":1}}],[\"而堆内存存放的实体会被垃圾回收机制不定时回收\",{\"1\":{\"198\":1}}],[\"而本地方法栈则是为虚拟机使用到的本地\",{\"1\":{\"197\":1}}],[\"而方法异常退出时\",{\"1\":{\"195\":1}}],[\"而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式\",{\"1\":{\"191\":1}}],[\"而这些输入大都是sql语法里的一些组合\",{\"1\":{\"595\":1}}],[\"而这些表中的记录就是我们日常所称的\",{\"1\":{\"591\":1}}],[\"而这些数据却又对用户程序来说非常重要\",{\"1\":{\"134\":1}}],[\"而这个负责拆分\",{\"1\":{\"1042\":1}}],[\"而这个默认路由器知道到每一个目的网络的最佳路由\",{\"1\":{\"993\":1}}],[\"而这个connection是由spring注入到a中的\",{\"1\":{\"718\":1}}],[\"而这个更新往往是在系统比较空闲的时候做\",{\"1\":{\"489\":1,\"569\":1}}],[\"而这个解密的操作\",{\"1\":{\"180\":1}}],[\"而这里hashset\",{\"1\":{\"413\":1}}],[\"而返回时直接快速移动至起始端\",{\"1\":{\"163\":1}}],[\"而且确定了这些步骤的执行顺序\",{\"1\":{\"1087\":1}}],[\"而且产品较多时\",{\"1\":{\"1077\":1}}],[\"而且一旦子类发生改变\",{\"1\":{\"1077\":1}}],[\"而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式\",{\"1\":{\"1070\":1}}],[\"而且由\",{\"1\":{\"1069\":1}}],[\"而且由于数据库中也没有该数据\",{\"1\":{\"641\":1}}],[\"而且由于唯一索引用不上\",{\"1\":{\"555\":1}}],[\"而且由于\",{\"1\":{\"391\":1}}],[\"而且每次都要重复发送\",{\"1\":{\"1042\":1}}],[\"而且每块碎片都很小\",{\"1\":{\"154\":1}}],[\"而且不用按照顺序一一对应\",{\"1\":{\"1042\":1}}],[\"而且不同的segment\",{\"1\":{\"864\":1}}],[\"而且不同的客户在每次访问中根据需要会去访问不同的数据库\",{\"1\":{\"742\":1}}],[\"而且主机必须从缓存中删除无效的项\",{\"1\":{\"1032\":1}}],[\"而且只能重传整个tcp分组\",{\"1\":{\"982\":1}}],[\"而且要纠错\",{\"1\":{\"961\":1}}],[\"而且需要在\",{\"1\":{\"942\":1}}],[\"而且时间复杂度为o\",{\"1\":{\"901\":1}}],[\"而且适合节点规模会发生变化的场景\",{\"1\":{\"880\":1}}],[\"而且worker进程是master进程的子进程\",{\"1\":{\"830\":1}}],[\"而且在多实例的情况下\",{\"1\":{\"609\":1}}],[\"而且任何操作都不会加锁\",{\"1\":{\"522\":1}}],[\"而且所有数据都存在内存中\",{\"1\":{\"494\":1}}],[\"而且修复操作是非常慢的\",{\"1\":{\"492\":1}}],[\"而且查询的数据越多\",{\"1\":{\"486\":1}}],[\"而且还在原来的基础上添加了额外处理的新功能\",{\"1\":{\"349\":1}}],[\"而且是在epoll中\",{\"1\":{\"838\":1}}],[\"而且是库独立的\",{\"1\":{\"467\":1}}],[\"而且是借用进行minor\",{\"1\":{\"264\":1}}],[\"而且是java虚拟机能够识别的库到虚拟机的内存中\",{\"1\":{\"176\":1}}],[\"而且堆中每个region都必须有一份卡表\",{\"1\":{\"262\":1}}],[\"而且也可能导致outofmemoryerror异常出现\",{\"1\":{\"209\":1}}],[\"而且总是由同一线程多次获得\",{\"1\":{\"88\":1}}],[\"而外部碎片不属于任何进程\",{\"1\":{\"154\":1}}],[\"而它的一个或多个子进程还在运行\",{\"1\":{\"151\":1}}],[\"而父进程又没有回收子进程\",{\"1\":{\"151\":1}}],[\"而头节点的线程释放了同步状态之后\",{\"1\":{\"122\":1}}],[\"而公平锁则不同\",{\"1\":{\"96\":1}}],[\"而现在则把最新修改值写到store\",{\"1\":{\"72\":1}}],[\"而不必专门引入多个新的类来进行管理\",{\"1\":{\"1079\":1}}],[\"而不会产生一致性问题\",{\"1\":{\"873\":1}}],[\"而不用修改每个代理类中的方法\",{\"1\":{\"723\":1,\"724\":1}}],[\"而不用考虑重新分区的问题\",{\"1\":{\"671\":1}}],[\"而不用直接读取数据库\",{\"1\":{\"645\":1}}],[\"而不需要等待对方确认\",{\"1\":{\"1011\":1}}],[\"而不需要查询聚集索引中的记录\",{\"1\":{\"550\":1}}],[\"而不需要像b树一样需要对每一层进行遍历\",{\"1\":{\"541\":1}}],[\"而不需要在磁盘上存储多个拷贝\",{\"1\":{\"161\":1}}],[\"而不包含路径\",{\"1\":{\"426\":1}}],[\"而不再产生异常\",{\"1\":{\"159\":1}}],[\"而不利于短作业\",{\"1\":{\"150\":1}}],[\"而不能加\",{\"1\":{\"509\":1}}],[\"而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致\",{\"1\":{\"296\":1}}],[\"而不能直接读写主内存中的数据\",{\"1\":{\"294\":1}}],[\"而不能直接读写主内存中的变量\",{\"1\":{\"66\":1,\"337\":1}}],[\"而不能在内核态执行的指令\",{\"1\":{\"134\":1}}],[\"而不是默认的整个\",{\"1\":{\"1190\":1}}],[\"而不是默认路由器\",{\"1\":{\"993\":1}}],[\"而不是通过修改已有的代码来完成变化\",{\"1\":{\"1064\":1}}],[\"而不是指只能用于javascript\",{\"1\":{\"1035\":1}}],[\"而不是数据显示\",{\"1\":{\"1035\":1}}],[\"而不是使用字符串\",{\"1\":{\"997\":1}}],[\"而不是内存\",{\"1\":{\"891\":1}}],[\"而不是一个模式\",{\"1\":{\"718\":1}}],[\"而不是创建或查找依赖的对象们\",{\"1\":{\"717\":1}}],[\"而不是记录\",{\"1\":{\"566\":1}}],[\"而不是继续查询下一条是否符合标准\",{\"1\":{\"535\":1}}],[\"而不是列出目录内的文件数据\",{\"1\":{\"419\":1}}],[\"而不是打印到标准输出中\",{\"1\":{\"325\":1}}],[\"而不是因为弱引用\",{\"1\":{\"45\":1}}],[\"而不是运行在其自身的线程中\",{\"1\":{\"34\":1}}],[\"而不是另一个\",{\"1\":{\"26\":1}}],[\"而等待是主动的\",{\"1\":{\"38\":1}}],[\"而\",{\"1\":{\"37\":1,\"79\":1,\"81\":1,\"104\":1,\"105\":1,\"120\":1,\"121\":2,\"138\":1,\"230\":1,\"300\":2,\"358\":1,\"368\":3,\"393\":1,\"407\":2,\"411\":1,\"577\":1,\"582\":1,\"610\":3,\"623\":1,\"642\":1,\"660\":1,\"720\":2,\"748\":1,\"820\":1,\"825\":1,\"860\":1,\"996\":1,\"1033\":1,\"1041\":4,\"1060\":1,\"1086\":1,\"1259\":1}}],[\"而锁可以是任意对象\",{\"1\":{\"36\":1}}],[\"而是发送完\",{\"1\":{\"1027\":1}}],[\"而是快恢复\",{\"1\":{\"1019\":1}}],[\"而是快速重传包3\",{\"1\":{\"1019\":1}}],[\"而是要立即发送确认\",{\"1\":{\"1019\":1}}],[\"而是要根据hash\",{\"1\":{\"891\":1}}],[\"而是按需动态地分配时隙\",{\"1\":{\"967\":1}}],[\"而是将虚拟节点映射到哈希环上\",{\"1\":{\"880\":1}}],[\"而是将它们放到队列\",{\"1\":{\"665\":1}}],[\"而是逻辑上一个值\",{\"1\":{\"847\":1}}],[\"而是交给下面的worker进程来处理\",{\"1\":{\"830\":1}}],[\"而是spring\",{\"1\":{\"718\":1}}],[\"而是一种解耦的设计思想\",{\"1\":{\"718\":1}}],[\"而是引入了哈希槽的概念\",{\"1\":{\"679\":1}}],[\"而是引用已经存在的对象\",{\"1\":{\"369\":1}}],[\"而是自持久化开始到持久化结束的这段时间发生的增量\",{\"1\":{\"653\":1}}],[\"而是采用了稀疏存储的方式\",{\"1\":{\"848\":1}}],[\"而是采用了一种简单的贪心策略\",{\"1\":{\"632\":1}}],[\"而是采用渐进方式\",{\"1\":{\"623\":1}}],[\"而是记录上一届点和本节点的长度来寻址\",{\"1\":{\"627\":1}}],[\"而是以\",{\"1\":{\"624\":1}}],[\"而是使用\",{\"1\":{\"624\":1}}],[\"而是使用本地内存\",{\"1\":{\"205\":1}}],[\"而是内存和网络带宽\",{\"1\":{\"604\":1}}],[\"而是copy到内存中的doublewrite\",{\"1\":{\"593\":1}}],[\"而是键值和主键\",{\"1\":{\"548\":1}}],[\"而是数据存放的地址\",{\"1\":{\"547\":1}}],[\"而是主键值\",{\"1\":{\"547\":1}}],[\"而是存放数据的地址\",{\"1\":{\"546\":1}}],[\"而是存储在cpu寄存器中\",{\"1\":{\"202\":1}}],[\"而是把数据积累成足够大的报文段\",{\"1\":{\"1018\":1}}],[\"而是把相邻的数据也都读取到内存缓冲区内\",{\"1\":{\"543\":1}}],[\"而是把这个请求委派给父类加载器的loadclass\",{\"1\":{\"184\":1}}],[\"而是先将记录写入\",{\"1\":{\"568\":1}}],[\"而是先判断插入的非聚集索引页是否在缓冲池中\",{\"1\":{\"496\":1,\"574\":1}}],[\"而是先转入就绪状态\",{\"1\":{\"148\":1}}],[\"而是会通过memcpy函数将脏页先复制到内存中的doublewrite\",{\"1\":{\"496\":1}}],[\"而是会写到内存中的键缓冲区\",{\"1\":{\"492\":1}}],[\"而是会锁定这块内存区域的缓存并回写到内存\",{\"1\":{\"296\":1}}],[\"而是需要找一个合适的位置\",{\"1\":{\"466\":1}}],[\"而是无规律的数据\",{\"1\":{\"466\":1}}],[\"而是几乎所有的主流数据库软件通用的语言\",{\"1\":{\"457\":1}}],[\"而是\",{\"1\":{\"444\":1}}],[\"而是操作系统帮你做完\",{\"1\":{\"380\":1}}],[\"而是真实地址\",{\"1\":{\"208\":1}}],[\"而是每个类加载器加载自己的话就会出现一些问题\",{\"1\":{\"184\":1}}],[\"而是通常采用union\",{\"1\":{\"485\":1}}],[\"而是通常使用组合\",{\"1\":{\"184\":1}}],[\"而是通过binlog日志复制到需要同步的从服务器上\",{\"1\":{\"469\":1,\"580\":1}}],[\"而是通过记录一系列符号和参数\",{\"1\":{\"161\":1}}],[\"而是通过\",{\"1\":{\"59\":1}}],[\"而是通过阻塞队列来进行通信\",{\"1\":{\"50\":1}}],[\"而是直接返回默认值给用户\",{\"1\":{\"644\":1}}],[\"而是直接在索引内部对\",{\"1\":{\"553\":1}}],[\"而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系\",{\"1\":{\"138\":1}}],[\"而是直接从阻塞队列里取\",{\"1\":{\"50\":1}}],[\"而是在运行是动态生成的一个对象\",{\"1\":{\"349\":1}}],[\"而是在元素的节点上采用\",{\"1\":{\"128\":1}}],[\"而是在应用代码中直接调用\",{\"1\":{\"34\":1}}],[\"而是简单判断自己的前驱是否为头节点\",{\"1\":{\"122\":1}}],[\"而是进行自旋重试等待如果当前线程自旋成功\",{\"1\":{\"91\":1}}],[\"而是说前一个写操作结果对后续操作是可见的\",{\"1\":{\"75\":1}}],[\"而是因为这个对象在代码块也有\",{\"1\":{\"71\":1}}],[\"而是让线程重回就绪状态\",{\"1\":{\"35\":1}}],[\"而主线程要取得这个数据值才能运行\",{\"1\":{\"35\":1}}],[\"而多个线程共享内存资源\",{\"1\":{\"28\":1,\"139\":1}}],[\"是类似充血的的对象\",{\"1\":{\"1217\":1}}],[\"是父类与子类之间的关系\",{\"1\":{\"1100\":1}}],[\"是整体和部分之间的关系\",{\"1\":{\"1098\":1}}],[\"是整个算法中的一个步骤\",{\"1\":{\"1087\":1}}],[\"是强关联关系\",{\"1\":{\"1098\":1}}],[\"是强引用\",{\"1\":{\"300\":1}}],[\"是临时性的关联\",{\"1\":{\"1096\":1}}],[\"是第三方提供的包\",{\"1\":{\"1084\":1}}],[\"是第一批时间复杂度突破\",{\"1\":{\"933\":1}}],[\"是简单工厂实现\",{\"1\":{\"1077\":1}}],[\"是开源项目中比较常用的一种单例模式\",{\"1\":{\"1069\":1}}],[\"是4个协议中最最复杂的部分\",{\"1\":{\"1062\":1}}],[\"是1994年由netscape公司设计的一套协议\",{\"1\":{\"1062\":1}}],[\"是世界上使用最广泛的密码通信方法\",{\"1\":{\"1062\":1}}],[\"是超文本传输协议\",{\"1\":{\"1048\":1}}],[\"是超文本系统的扩充\",{\"1\":{\"1034\":1}}],[\"是加密传输\",{\"1\":{\"1044\":1}}],[\"是哪种浏览器\",{\"1\":{\"1039\":1}}],[\"是万维网能够可靠地交换文件的重要基础\",{\"1\":{\"1037\":1}}],[\"是期望收到对方的下一个报文段的第一个数据字节的序号\",{\"1\":{\"1007\":1}}],[\"是数据链路层和物理层使用的地址\",{\"1\":{\"981\":1}}],[\"是internet的核心协议\",{\"1\":{\"964\":1}}],[\"是ioc的核心\",{\"1\":{\"712\":1}}],[\"是包含了一系列构成互联网基础的网络协议\",{\"1\":{\"964\":1}}],[\"是通过应用进程间的交互来完成特定的网络应用\",{\"1\":{\"961\":1}}],[\"是体系结构的最高层\",{\"1\":{\"961\":1}}],[\"是稳定的\",{\"1\":{\"938\":1}}],[\"是插入排序的改进版本\",{\"1\":{\"933\":1}}],[\"是关键字\",{\"1\":{\"919\":2}}],[\"是夹着\",{\"1\":{\"912\":1,\"913\":1}}],[\"是o\",{\"1\":{\"899\":1}}],[\"是被动的\",{\"1\":{\"874\":1}}],[\"是主动方\",{\"1\":{\"843\":1}}],[\"是主键\",{\"1\":{\"489\":1}}],[\"是目前主流的方案\",{\"1\":{\"827\":1}}],[\"是高性能的\",{\"1\":{\"824\":1}}],[\"是高速工作方式\",{\"1\":{\"613\":1}}],[\"是集群的管理者\",{\"1\":{\"816\":1}}],[\"是标准的mvc模式\",{\"1\":{\"761\":1}}],[\"是单例模式\",{\"1\":{\"757\":1}}],[\"是单线程机制\",{\"1\":{\"674\":1}}],[\"是默认开启的\",{\"1\":{\"752\":1}}],[\"是默认的模式\",{\"1\":{\"381\":1}}],[\"是全自动\",{\"1\":{\"749\":1}}],[\"是全局锁\",{\"1\":{\"508\":1}}],[\"是半自动\",{\"1\":{\"749\":1}}],[\"是降低系统耦合度迫切要做的\",{\"1\":{\"748\":1}}],[\"是非线程安全的\",{\"1\":{\"735\":1}}],[\"是非阻塞式的\",{\"1\":{\"377\":1}}],[\"是编译时增强\",{\"1\":{\"720\":1}}],[\"是轻量的\",{\"1\":{\"717\":1}}],[\"是可以构建\",{\"1\":{\"1046\":1}}],[\"是可以应用到状态机的操作\",{\"1\":{\"875\":1}}],[\"是可观的一笔系统开销\",{\"1\":{\"713\":1}}],[\"是可控性最强的阶段\",{\"1\":{\"168\":1}}],[\"是如此的轻量\",{\"1\":{\"671\":1}}],[\"是如何保证线程安全的\",{\"0\":{\"128\":1}}],[\"是前期做还是后期规模上来了再做好\",{\"0\":{\"671\":1}}],[\"是前开后闭的区间\",{\"1\":{\"515\":1}}],[\"是依赖数据库的唯一性来实现资源锁定\",{\"1\":{\"668\":1}}],[\"是指攻击者网络上窃听他人的通信内容\",{\"1\":{\"1054\":1}}],[\"是指发送方不同的应用程序都可使用同一个传输层协议传送数据\",{\"1\":{\"999\":1}}],[\"是指在接收方的运输层可以把这些数据正确交付目的进程\",{\"1\":{\"997\":1}}],[\"是指在发送方不同的应用进程都可以使用同一个传输层协议传送数据\",{\"1\":{\"997\":1}}],[\"是指局域网上的每一台计算机中固化在是适配器的rom中的地址\",{\"1\":{\"979\":1}}],[\"是指向子树的指针\",{\"1\":{\"919\":1}}],[\"是指一个\",{\"1\":{\"859\":1}}],[\"是指将一台\",{\"1\":{\"661\":1}}],[\"是指用户进程触发\",{\"1\":{\"380\":1}}],[\"是无连接的\",{\"1\":{\"1001\":1}}],[\"是无中心节点的集群架构\",{\"1\":{\"660\":1}}],[\"是无序的\",{\"1\":{\"412\":1}}],[\"是以非阻塞的方式为\",{\"1\":{\"656\":1}}],[\"是启动不起来的\",{\"1\":{\"651\":1}}],[\"是针对\",{\"1\":{\"647\":1}}],[\"是多线程\",{\"1\":{\"610\":1}}],[\"是两个独立的逻辑\",{\"1\":{\"578\":1}}],[\"是没有\",{\"1\":{\"577\":1}}],[\"是另一个公司以插件形式引入\",{\"1\":{\"577\":1}}],[\"是server层逻辑日志\",{\"1\":{\"571\":1}}],[\"是很快的\",{\"1\":{\"568\":1}}],[\"是回滚日志\",{\"1\":{\"567\":1}}],[\"是重做日志\",{\"1\":{\"567\":1}}],[\"是执行性读\",{\"1\":{\"559\":1}}],[\"是当前读\",{\"1\":{\"559\":1}}],[\"是不能被拆开的\",{\"1\":{\"571\":1}}],[\"是不能重复的\",{\"1\":{\"413\":1}}],[\"是不是覆盖索引失效一定会做回表查询\",{\"1\":{\"550\":1}}],[\"是怎样得到索引的基数的呢\",{\"1\":{\"536\":1}}],[\"是怎么保证\",{\"1\":{\"519\":1}}],[\"是怎么工作的\",{\"0\":{\"484\":1}}],[\"是找到一个最优的执行方案\",{\"1\":{\"536\":1}}],[\"是因为它们要使用ip协议\",{\"1\":{\"983\":1}}],[\"是因为其省去了大量磁头寻址的时间\",{\"1\":{\"850\":1}}],[\"是因为所有被代理执行的方法\",{\"1\":{\"724\":1}}],[\"是因为所做的更改仍然在主内存的缓冲区中\",{\"1\":{\"520\":1}}],[\"是因为先进行了一次快照读\",{\"1\":{\"523\":1}}],[\"是在网络中传输的\",{\"1\":{\"1061\":1}}],[\"是在目前覆盖面很广的有线电视网的基础上开发的一种居民宽带接入网\",{\"1\":{\"968\":1}}],[\"是在另一个进程中执行的\",{\"1\":{\"804\":1}}],[\"是在索引的间隙之间加上锁\",{\"1\":{\"504\":1}}],[\"是在告诉\",{\"1\":{\"78\":1}}],[\"是满足条件的记录上的锁\",{\"1\":{\"501\":1}}],[\"是行锁的一个变种\",{\"1\":{\"499\":1}}],[\"是结果集\",{\"1\":{\"490\":1}}],[\"是查询预计\",{\"1\":{\"490\":1}}],[\"是字符串替换\",{\"1\":{\"461\":1,\"596\":1,\"750\":1}}],[\"是字母l的小写\",{\"1\":{\"417\":1}}],[\"是预编译处理\",{\"1\":{\"461\":1,\"750\":1}}],[\"是最大的范畴\",{\"1\":{\"457\":1}}],[\"是有限的\",{\"1\":{\"583\":1}}],[\"是有三个函数来做这件事\",{\"1\":{\"414\":1}}],[\"是有一定限制的\",{\"1\":{\"381\":1}}],[\"是按照\",{\"1\":{\"412\":1}}],[\"是相反的\",{\"1\":{\"406\":1}}],[\"是相同的\",{\"1\":{\"397\":1}}],[\"是就直接返回\",{\"1\":{\"398\":1}}],[\"是直接通过数组来进行存储\",{\"1\":{\"391\":1}}],[\"是面向连接的\",{\"1\":{\"1001\":1}}],[\"是面向数据报的传输方式\",{\"1\":{\"1001\":1}}],[\"是面向字节流的传输方式\",{\"1\":{\"1001\":1}}],[\"是面向缓冲区的基于通道的\",{\"1\":{\"377\":1}}],[\"是面向流的\",{\"1\":{\"377\":1}}],[\"是动态生成的\",{\"1\":{\"349\":1}}],[\"是个关键字\",{\"1\":{\"346\":1}}],[\"是确保能和\",{\"1\":{\"345\":1}}],[\"是核心清理函数\",{\"1\":{\"301\":1}}],[\"是为长期运行的服务器端应用程序做性能调优的编译器\",{\"1\":{\"283\":1}}],[\"是为了管理主存的方便而划分的\",{\"1\":{\"155\":1}}],[\"是必须暂停用户线程\",{\"1\":{\"264\":1}}],[\"是parallel\",{\"1\":{\"258\":1}}],[\"是应该倾向于同时生存或者同时消亡的\",{\"1\":{\"239\":1}}],[\"是即时编译器优化技术中一个十分重要的手段\",{\"1\":{\"202\":1}}],[\"是更接近于自然的思考方式\",{\"1\":{\"198\":1}}],[\"是classloader类中的getsystemclassloader\",{\"1\":{\"178\":1}}],[\"是jdbc预编译处理\",{\"1\":{\"596\":1}}],[\"是jvm自身的一部分\",{\"1\":{\"176\":1}}],[\"是java虚拟机将常量池内的符号引用替换为直接引用的过程\",{\"1\":{\"172\":1}}],[\"是日后jar\",{\"1\":{\"168\":1}}],[\"是线程安全的\",{\"1\":{\"410\":1,\"735\":1}}],[\"是线程不安全的\",{\"1\":{\"409\":1}}],[\"是线程私有的\",{\"1\":{\"144\":1}}],[\"是线程名字\",{\"1\":{\"31\":1}}],[\"是存储和恢复\",{\"1\":{\"144\":1}}],[\"是给操作系统用的\",{\"1\":{\"136\":1}}],[\"是操作系统最基本\",{\"1\":{\"133\":1}}],[\"是操作系统提出的一种高级原语\",{\"1\":{\"85\":1}}],[\"是对需要进行数据操作的\",{\"1\":{\"130\":1}}],[\"是计数器\",{\"1\":{\"121\":2}}],[\"是基于列字段进行的\",{\"1\":{\"585\":1}}],[\"是基于提高并发性能的考虑\",{\"1\":{\"499\":1}}],[\"是基于树结构\",{\"1\":{\"408\":1}}],[\"是基于哈希表实现的\",{\"1\":{\"408\":1}}],[\"是基于链表的数据结构\",{\"1\":{\"393\":1}}],[\"是基于\",{\"1\":{\"120\":1,\"538\":1,\"617\":1,\"752\":1,\"871\":1}}],[\"是共享锁的一种实现\",{\"1\":{\"118\":1}}],[\"是将每条请求共享资源的线程封装成一个\",{\"1\":{\"110\":1}}],[\"是用来统计每个query的出现次数\",{\"1\":{\"895\":1}}],[\"是用于线程间协作的工具类\",{\"1\":{\"127\":1}}],[\"是用\",{\"1\":{\"110\":1}}],[\"是一款实用工具\",{\"1\":{\"1249\":1}}],[\"是一段连续空间\",{\"1\":{\"617\":1}}],[\"是一组变量值的存储空间\",{\"1\":{\"192\":1}}],[\"是一种继承关系\",{\"1\":{\"1100\":1}}],[\"是一种通过为多个复杂的子系统提供一个一致的接口\",{\"1\":{\"1090\":1}}],[\"是一种为访问类提供一个创建一组相关或相互依赖对象的接口\",{\"1\":{\"1079\":1}}],[\"是一种曾经很经典的攻击方式\",{\"1\":{\"1054\":1}}],[\"是一种轻量级\",{\"1\":{\"1035\":1}}],[\"是一种改进的时分复用\",{\"1\":{\"967\":1}}],[\"是一种专用计算器\",{\"1\":{\"960\":1}}],[\"是一种进程间通信方式\",{\"1\":{\"801\":1}}],[\"是一种思想\",{\"1\":{\"718\":1}}],[\"是一种消息通信模式\",{\"1\":{\"673\":1}}],[\"是一种伪文件系统\",{\"1\":{\"416\":1}}],[\"是一种行为规范\",{\"1\":{\"362\":1}}],[\"是一种模板设计\",{\"1\":{\"362\":1}}],[\"是一种增量式编译器\",{\"1\":{\"282\":1}}],[\"是一种能够将java源码编译成字节码的全量式编译的前端编译器\",{\"1\":{\"282\":1}}],[\"是一种服务发现机制\",{\"1\":{\"185\":1}}],[\"是一种最优的方案\",{\"1\":{\"160\":1}}],[\"是一种最常见也是最主要的并发正确性保障手段\",{\"1\":{\"142\":1}}],[\"是一种运行时在后台提供通用服务的线程\",{\"1\":{\"143\":1}}],[\"是一种数组和链表结构\",{\"1\":{\"129\":1}}],[\"是一种乐观锁策略\",{\"1\":{\"105\":1}}],[\"是一次性的\",{\"1\":{\"119\":1}}],[\"是一个画图脚本语言\",{\"1\":{\"1271\":1}}],[\"是一个固定的值\",{\"1\":{\"880\":1}}],[\"是一个逻辑时间\",{\"1\":{\"876\":1}}],[\"是一个物理概念\",{\"1\":{\"845\":1}}],[\"是一个分布式服务框架\",{\"1\":{\"816\":1}}],[\"是一个分布式计算的\",{\"1\":{\"801\":1}}],[\"是一个序列化和反序列化的过程\",{\"1\":{\"804\":1}}],[\"是一个与数据库打交道的持久层框架\",{\"1\":{\"746\":1}}],[\"是一个半orm\",{\"1\":{\"746\":1}}],[\"是一个原则\",{\"1\":{\"718\":1}}],[\"是一个代码生成的类库\",{\"1\":{\"715\":1}}],[\"是一个异步的\",{\"1\":{\"685\":1}}],[\"是一个热点\",{\"1\":{\"643\":1}}],[\"是一个双端链表\",{\"1\":{\"629\":1}}],[\"是一个string\",{\"1\":{\"622\":1}}],[\"是一个开源的使用\",{\"1\":{\"603\":1}}],[\"是一个\",{\"1\":{\"410\":1,\"825\":1}}],[\"是一个操作\",{\"1\":{\"388\":1}}],[\"是一个集合接口\",{\"1\":{\"388\":1}}],[\"是一个快速\",{\"1\":{\"313\":1}}],[\"是一个简单快速的编译器\",{\"1\":{\"283\":1}}],[\"是一个静态方法\",{\"1\":{\"183\":1}}],[\"是一个抽象类\",{\"1\":{\"182\":1}}],[\"是一个接口\",{\"1\":{\"94\":1,\"756\":1,\"1090\":1}}],[\"是一个把大任务分割成若干个小任务\",{\"1\":{\"49\":1}}],[\"是一个泛型\",{\"1\":{\"33\":1}}],[\"是自己的就表示没有竞争\",{\"1\":{\"88\":1}}],[\"是之前获得过锁\",{\"1\":{\"85\":1}}],[\"是实现分组交换的关键\",{\"1\":{\"960\":1}}],[\"是实现自动配置的入口\",{\"1\":{\"771\":1}}],[\"是实现了基于动态数组的数据结构\",{\"1\":{\"393\":1}}],[\"是实现了\",{\"1\":{\"391\":1}}],[\"是实现\",{\"1\":{\"82\":1}}],[\"是乐观锁的一种实现方式\",{\"1\":{\"219\":1}}],[\"是乐观锁的一种实现\",{\"1\":{\"81\":1}}],[\"是什么\",{\"0\":{\"75\":1,\"76\":1}}],[\"是修改\",{\"1\":{\"72\":1}}],[\"是否区分大小写\",{\"1\":{\"1188\":1}}],[\"是否存在\",{\"1\":{\"807\":1}}],[\"是否存在多个线程修改一个共享资源\",{\"1\":{\"48\":1}}],[\"是否依赖servlet容器\",{\"1\":{\"759\":1}}],[\"是否正常运行\",{\"1\":{\"677\":1}}],[\"是否正确\",{\"1\":{\"490\":1}}],[\"是否过期以及对主从库的判断\",{\"1\":{\"664\":1}}],[\"是否已过期\",{\"1\":{\"632\":1}}],[\"是否在做\",{\"1\":{\"623\":1}}],[\"是否大于\",{\"1\":{\"623\":1}}],[\"是否完整\",{\"1\":{\"578\":2}}],[\"是否排序等因素进行综合判断\",{\"1\":{\"536\":1}}],[\"是否符合\",{\"1\":{\"490\":1}}],[\"是否有该表的查询条件\",{\"1\":{\"490\":1}}],[\"是否执行过\",{\"1\":{\"490\":1}}],[\"是否允许为空\",{\"1\":{\"462\":1}}],[\"是否被声明为final等等\",{\"1\":{\"287\":1}}],[\"是否被执行死刑\",{\"1\":{\"236\":1}}],[\"是否定义为abstract类型\",{\"1\":{\"287\":1}}],[\"是否定义为public类型\",{\"1\":{\"287\":1}}],[\"是否为查询的\",{\"1\":{\"398\":1}}],[\"是否为\",{\"1\":{\"96\":1}}],[\"是否是多线程环境\",{\"1\":{\"48\":1}}],[\"是由两个进程组成的\",{\"1\":{\"833\":1}}],[\"是由参数sync\",{\"1\":{\"571\":1}}],[\"是由于程序设计不完善而出现的问题\",{\"1\":{\"384\":1}}],[\"是由\",{\"1\":{\"41\":1}}],[\"是由threadlocal\",{\"1\":{\"39\":1}}],[\"是把线程和任务分开了\",{\"1\":{\"32\":1}}],[\"是把线程和任务合并在了一起\",{\"1\":{\"32\":1}}],[\"是任务对象\",{\"1\":{\"31\":1}}],[\"是程序的一次执行过程\",{\"1\":{\"139\":1}}],[\"是程序执行的最小单位\",{\"1\":{\"30\":1}}],[\"是程序运行和系统资源分配的基本单位\",{\"1\":{\"28\":1,\"139\":1}}],[\"是比进程更小的能独立运行的单元\",{\"1\":{\"28\":1,\"139\":1}}],[\"是\",{\"1\":{\"28\":1,\"35\":2,\"37\":2,\"42\":1,\"43\":2,\"94\":2,\"109\":1,\"139\":1,\"299\":1,\"367\":1,\"368\":2,\"370\":1,\"381\":1,\"393\":1,\"406\":3,\"427\":2,\"428\":1,\"491\":1,\"619\":1,\"624\":1,\"625\":1,\"628\":1,\"641\":1,\"648\":1,\"672\":1,\"717\":1,\"752\":1,\"754\":1,\"820\":1,\"840\":1,\"871\":1,\"878\":1,\"982\":1,\"1098\":1,\"1099\":1,\"1100\":1}}],[\"是进程的一个实体\",{\"1\":{\"28\":1,\"139\":1}}],[\"与持久化存储\",{\"1\":{\"1239\":1}}],[\"与ip地址按位与\",{\"1\":{\"989\":1}}],[\"与ip协议配套使用的还有三个协议\",{\"1\":{\"983\":1}}],[\"与要查找的数的次最高位比较并接着进入相应的文件再查找\",{\"1\":{\"901\":1}}],[\"与要查找的数的最高位比较并接着进入相应的文件再查找\",{\"1\":{\"901\":1}}],[\"与o\",{\"1\":{\"899\":1}}],[\"与方案1类似\",{\"1\":{\"895\":1}}],[\"与文件系统不同的是\",{\"1\":{\"818\":1}}],[\"与云计算的天然集成\",{\"1\":{\"768\":1}}],[\"与用户的交互\",{\"1\":{\"754\":1}}],[\"与程序代码的耦合\",{\"1\":{\"746\":1}}],[\"与beanfactoryaware\",{\"1\":{\"733\":1}}],[\"与普通的我们理解的\",{\"1\":{\"685\":1}}],[\"与微服务的治理类似\",{\"1\":{\"585\":1}}],[\"与整表扫描没有区别\",{\"1\":{\"541\":1}}],[\"与指定commit一致\",{\"1\":{\"453\":1}}],[\"与指定的远程分支建立追踪关系\",{\"1\":{\"451\":1}}],[\"与上一次commit保持一致\",{\"1\":{\"453\":2}}],[\"与读写锁的异同\",{\"1\":{\"411\":1}}],[\"与原来计算的\",{\"1\":{\"406\":1}}],[\"与哈希表中元素数量比较\",{\"1\":{\"397\":1}}],[\"与创建对象的个数无关\",{\"1\":{\"352\":1}}],[\"与泛型相关的信息会被擦除掉\",{\"1\":{\"345\":1}}],[\"与静态集合类类似\",{\"1\":{\"304\":1}}],[\"与class文件中其他的数据项目要求严格的顺序\",{\"1\":{\"291\":1}}],[\"与classloader\",{\"0\":{\"183\":1}}],[\"与字段表集合相对应地\",{\"1\":{\"290\":1}}],[\"与之前启动的服务器\",{\"1\":{\"820\":2}}],[\"与之关系不大的部分是横切关注点\",{\"1\":{\"719\":1}}],[\"与之相反\",{\"1\":{\"275\":1}}],[\"与之对应的是聚合量\",{\"1\":{\"202\":1}}],[\"与g1至少有着三处不同\",{\"1\":{\"267\":1}}],[\"与堆内存的映射关系等\",{\"1\":{\"249\":1}}],[\"与其相邻的数据也会很快被访问到\",{\"1\":{\"543\":1}}],[\"与其他收集器不同\",{\"1\":{\"257\":1}}],[\"与其他收集器的单线程相比\",{\"1\":{\"254\":1}}],[\"与其他几种引用都不同\",{\"1\":{\"235\":1}}],[\"与其作用刚好相反\",{\"1\":{\"24\":1}}],[\"与缓冲区\",{\"1\":{\"209\":1}}],[\"与操作系统交互\",{\"1\":{\"197\":1}}],[\"与java环境外的交互\",{\"1\":{\"197\":1}}],[\"与jvm实现的内存布局无关\",{\"1\":{\"172\":1}}],[\"与虚拟机栈所发挥的作用是非常相似的\",{\"1\":{\"197\":1}}],[\"与管道\",{\"1\":{\"149\":1}}],[\"与此对应的\",{\"1\":{\"128\":1}}],[\"与共享模式相关\",{\"1\":{\"111\":1}}],[\"与\",{\"0\":{\"297\":1,\"377\":1,\"393\":1,\"480\":1,\"481\":1,\"483\":1,\"573\":1,\"749\":1,\"796\":1,\"1259\":1},\"1\":{\"35\":1,\"111\":1,\"126\":1,\"129\":1,\"136\":1,\"393\":1,\"428\":1,\"429\":2,\"441\":1,\"617\":1,\"624\":1,\"746\":1,\"931\":5,\"943\":1,\"1217\":1,\"1249\":1,\"1259\":1}}],[\"与线程的根本区别\",{\"1\":{\"28\":1,\"139\":1}}],[\"进阶\",{\"0\":{\"1134\":1}}],[\"进而逼近甚至达到数据库可承载活跃连接数的阈值\",{\"1\":{\"584\":1}}],[\"进而达到读写在\",{\"1\":{\"72\":1}}],[\"进来的\",{\"1\":{\"412\":1}}],[\"进制表示是\",{\"1\":{\"405\":1}}],[\"进行全局内容查询\",{\"1\":{\"1209\":1}}],[\"进行全量同步\",{\"1\":{\"655\":1}}],[\"进行预测\",{\"0\":{\"1145\":1}}],[\"进行预编译\",{\"1\":{\"597\":1}}],[\"进行分词\",{\"1\":{\"1209\":1}}],[\"进行分级查询\",{\"1\":{\"1031\":1}}],[\"进行分配担保\",{\"1\":{\"245\":1}}],[\"进行ip分片前的数据包\",{\"1\":{\"982\":1}}],[\"进行寻址和路由将数据从一个设备传输到另一个设备\",{\"1\":{\"961\":1}}],[\"进行删除操作的一端称为队头\",{\"1\":{\"941\":1}}],[\"进行插入操作的一端称为队尾\",{\"1\":{\"941\":1}}],[\"进行数据插入和删除操作的一端称为栈顶\",{\"1\":{\"940\":1}}],[\"进行划分小文件的方法\",{\"1\":{\"900\":1}}],[\"进行容灾与扩容时\",{\"1\":{\"880\":1}}],[\"进行哈希映射得到一个结果后\",{\"1\":{\"880\":1}}],[\"进行取模运算的结果值想象成一个\",{\"1\":{\"880\":1}}],[\"进行取模运算\",{\"1\":{\"880\":1}}],[\"进行比较\",{\"1\":{\"878\":1}}],[\"进行负载服务器分配\",{\"1\":{\"869\":1}}],[\"进行中的事务状态可以恢复\",{\"1\":{\"863\":1}}],[\"进行热部署操作\",{\"1\":{\"834\":1}}],[\"进行心跳检测\",{\"1\":{\"802\":1}}],[\"进行自动配置\",{\"1\":{\"772\":1}}],[\"进行解析\",{\"1\":{\"755\":2}}],[\"进行处理\",{\"1\":{\"735\":1}}],[\"进行增量同步\",{\"1\":{\"655\":1}}],[\"进行运算\",{\"1\":{\"645\":1}}],[\"进行缩短操作时\",{\"1\":{\"624\":1}}],[\"进行空间扩展时\",{\"1\":{\"624\":1}}],[\"进行字符修改时\",{\"1\":{\"624\":1}}],[\"进行存储的时候\",{\"1\":{\"606\":1}}],[\"进行存储\",{\"1\":{\"603\":1}}],[\"进行相应调整之后\",{\"1\":{\"562\":1}}],[\"进行更细致的分析\",{\"1\":{\"558\":1}}],[\"进行查询\",{\"1\":{\"553\":1}}],[\"进行查找\",{\"1\":{\"551\":1}}],[\"进行查找操作时\",{\"1\":{\"538\":1}}],[\"进行搜索\",{\"1\":{\"548\":1}}],[\"进行了优化\",{\"1\":{\"495\":1}}],[\"进行了一个锁升级优化过程\",{\"1\":{\"409\":1}}],[\"进行用户的身份认证\",{\"1\":{\"490\":1}}],[\"进行合并\",{\"1\":{\"485\":2}}],[\"进行排序\",{\"1\":{\"484\":1}}],[\"进行锁的竞争和等待\",{\"1\":{\"410\":1}}],[\"进行通信\",{\"1\":{\"380\":1}}],[\"进行交互\",{\"1\":{\"379\":1}}],[\"进行操作\",{\"1\":{\"377\":1}}],[\"进行缓存的刷新\",{\"1\":{\"640\":1}}],[\"进行缓存预热\",{\"1\":{\"640\":1}}],[\"进行缓存\",{\"1\":{\"368\":1}}],[\"进行\",{\"1\":{\"301\":1,\"657\":1,\"900\":1,\"938\":1}}],[\"进行一次抢锁\",{\"1\":{\"114\":1}}],[\"进行轻量级加锁时\",{\"1\":{\"89\":1}}],[\"进行对应的实际测试就可以得到最合适的选择\",{\"1\":{\"57\":1}}],[\"进行判断\",{\"1\":{\"46\":1,\"553\":1}}],[\"进行编写\",{\"1\":{\"18\":1}}],[\"进入项目路径\",{\"1\":{\"1144\":1}}],[\"进入syn\",{\"1\":{\"1022\":1}}],[\"进入listen状态\",{\"1\":{\"1022\":1}}],[\"进入old区的年龄\",{\"1\":{\"322\":1}}],[\"进入内核态\",{\"1\":{\"134\":1}}],[\"进入阻塞\",{\"1\":{\"105\":1}}],[\"进入重量级锁解锁流程\",{\"1\":{\"87\":1}}],[\"进入锁膨胀\",{\"1\":{\"87\":1,\"89\":1}}],[\"进入方法\",{\"1\":{\"38\":2}}],[\"进入\",{\"1\":{\"37\":1,\"63\":1,\"1136\":1}}],[\"进程则很快启动新的\",{\"1\":{\"834\":1}}],[\"进程重启后\",{\"1\":{\"674\":1}}],[\"进程调用\",{\"1\":{\"668\":1}}],[\"进程调度算法\",{\"0\":{\"150\":1}}],[\"进程发送\",{\"1\":{\"657\":1}}],[\"进程发送一个\",{\"1\":{\"657\":1}}],[\"进程同意\",{\"1\":{\"657\":1}}],[\"进程向下线的\",{\"1\":{\"657\":1}}],[\"进程标记为客观下线\",{\"1\":{\"657\":1}}],[\"进程标记为主观下线\",{\"1\":{\"657\":1}}],[\"进程会以每\",{\"1\":{\"657\":1}}],[\"进程要以每秒一次的频率确认\",{\"1\":{\"657\":1}}],[\"进程以每秒钟一次的频率向整个集群中的\",{\"1\":{\"657\":1}}],[\"进程执行\",{\"1\":{\"647\":1}}],[\"进程执行用户态代码所使用的的时间\",{\"1\":{\"331\":1}}],[\"进程内存中\",{\"1\":{\"568\":1}}],[\"进程管理\",{\"0\":{\"436\":1}}],[\"进程在内核态消耗的时间\",{\"1\":{\"331\":1}}],[\"进程在执行过程中拥有独立的内存单元\",{\"1\":{\"28\":1,\"139\":1}}],[\"进程id\",{\"1\":{\"253\":1}}],[\"进程按照cpu使用率排序\",{\"1\":{\"201\":1}}],[\"进程线性地址空间里的页面不必常驻内存\",{\"1\":{\"159\":1}}],[\"进程线程区别\",{\"0\":{\"28\":1}}],[\"进程对它们完成状态收集工作\",{\"1\":{\"151\":1}}],[\"进程号为\",{\"1\":{\"151\":1}}],[\"进程间通信\",{\"1\":{\"149\":1}}],[\"进程间通信方式\",{\"0\":{\"149\":1}}],[\"进程间切换有较大的开销\",{\"1\":{\"28\":1,\"139\":1}}],[\"进程运行中出现了故障\",{\"1\":{\"148\":1}}],[\"进程申请资源\",{\"1\":{\"148\":1}}],[\"进程正在从系统中消失\",{\"1\":{\"148\":1}}],[\"进程正在等待某一事件而暂停运行\",{\"1\":{\"148\":1}}],[\"进程正在处理器上运行\",{\"1\":{\"148\":1}}],[\"进程正在被创建\",{\"1\":{\"148\":1}}],[\"进程已处于准备运行状态\",{\"1\":{\"148\":1}}],[\"进程的状态转换\",{\"0\":{\"148\":1}}],[\"进程的组成\",{\"1\":{\"136\":1}}],[\"进程切换\",{\"0\":{\"147\":1}}],[\"进程切换分两步\",{\"1\":{\"145\":1}}],[\"进程相关\",{\"0\":{\"146\":1}}],[\"进程是是动态的\",{\"1\":{\"139\":1}}],[\"进程所属用户\",{\"1\":{\"136\":1}}],[\"进程存在的唯一标识\",{\"1\":{\"136\":1}}],[\"进程控制块\",{\"1\":{\"156\":1}}],[\"进程控制\",{\"1\":{\"135\":1}}],[\"进程有自己独立的地址空间\",{\"1\":{\"28\":1,\"139\":1}}],[\"进程与线程的区别\",{\"1\":{\"28\":1,\"139\":1}}],[\"进程\",{\"0\":{\"139\":1},\"1\":{\"28\":1,\"139\":1,\"144\":1,\"150\":3,\"151\":1,\"416\":1,\"647\":1,\"657\":1,\"834\":1}}],[\"hundsun\",{\"1\":{\"1264\":1}}],[\"human\",{\"1\":{\"277\":7,\"1035\":1}}],[\"hfc网\",{\"1\":{\"968\":1}}],[\"h1和h2\",{\"1\":{\"884\":1}}],[\"hw\",{\"0\":{\"855\":1},\"1\":{\"855\":1}}],[\"hystrix\",{\"1\":{\"642\":1}}],[\"hypothesis\",{\"1\":{\"239\":3}}],[\"h>\",{\"1\":{\"1168\":1}}],[\"h>中部分函数\",{\"1\":{\"624\":1}}],[\"h>库中所有的函数\",{\"1\":{\"624\":1}}],[\"httponly\",{\"1\":{\"1061\":3}}],[\"httpservletrequest\",{\"1\":{\"1090\":2}}],[\"httpsessionlistener抽象接口\",{\"1\":{\"759\":1}}],[\"https\",{\"0\":{\"1043\":1,\"1045\":1,\"1046\":1,\"1048\":1},\"1\":{\"1044\":5,\"1045\":1,\"1046\":1,\"1048\":3,\"1061\":2,\"1143\":6,\"1170\":1,\"1179\":1,\"1197\":3}}],[\"http2\",{\"1\":{\"1042\":5}}],[\"http1\",{\"1\":{\"1042\":2}}],[\"http方法与状态码\",{\"0\":{\"1040\":1}}],[\"http响应\",{\"1\":{\"1038\":1}}],[\"http请求\",{\"1\":{\"1038\":1}}],[\"http的首部字段\",{\"0\":{\"1039\":1}}],[\"http的报文结构\",{\"0\":{\"1038\":1}}],[\"http的默认端口号是80\",{\"1\":{\"1036\":1}}],[\"http是无状态的\",{\"1\":{\"1037\":1}}],[\"http是面向事务\",{\"1\":{\"1037\":1}}],[\"http本身是无连接的\",{\"1\":{\"1037\":1}}],[\"http协议定义了浏览器怎样向万维网服务器请求文档\",{\"1\":{\"1037\":1}}],[\"httpmessageconveter\",{\"1\":{\"755\":1}}],[\"http\",{\"0\":{\"805\":1,\"806\":1,\"1037\":1,\"1042\":1,\"1048\":1},\"1\":{\"685\":2,\"734\":3,\"805\":4,\"806\":2,\"824\":1,\"825\":8,\"959\":3,\"962\":1,\"1029\":3,\"1036\":1,\"1038\":2,\"1039\":1,\"1040\":2,\"1041\":3,\"1042\":9,\"1044\":1,\"1047\":1,\"1048\":2,\"1061\":2,\"1184\":1,\"1271\":6}}],[\"ht\",{\"1\":{\"623\":3}}],[\"html>\",{\"1\":{\"1038\":1}}],[\"html与xml的对比\",{\"1\":{\"1035\":1}}],[\"html不是应用层的协议\",{\"1\":{\"1035\":1}}],[\"html超文本标记语言\",{\"1\":{\"1035\":1}}],[\"html\",{\"0\":{\"21\":1,\"1035\":1,\"1206\":1},\"1\":{\"26\":2,\"559\":1,\"825\":1,\"1206\":3}}],[\"h查看\",{\"1\":{\"562\":1}}],[\"hibernatetemplate\",{\"1\":{\"742\":1}}],[\"hibernate\",{\"0\":{\"749\":1},\"1\":{\"607\":1,\"717\":1,\"749\":3}}],[\"history\",{\"1\":{\"486\":2}}],[\"high\",{\"1\":{\"368\":1,\"855\":1,\"935\":21,\"936\":15}}],[\"h\",{\"1\":{\"404\":2,\"405\":3,\"426\":1,\"441\":1,\"1144\":2,\"1168\":1,\"1192\":1}}],[\"h<lines>\",{\"1\":{\"312\":1}}],[\"hpjmeter\",{\"1\":{\"271\":1,\"332\":1}}],[\"hp\",{\"1\":{\"201\":1}}],[\"helper\",{\"1\":{\"934\":6}}],[\"help\",{\"1\":{\"823\":1}}],[\"helloworld\",{\"1\":{\"183\":1}}],[\"hello\",{\"1\":{\"31\":2,\"39\":1,\"277\":5,\"478\":1}}],[\"heartbeat\",{\"1\":{\"879\":1}}],[\"head\",{\"1\":{\"428\":2,\"449\":3,\"955\":8,\"1038\":1,\"1040\":1,\"1041\":2}}],[\"header\",{\"1\":{\"392\":3,\"630\":1}}],[\"heapify\",{\"1\":{\"937\":2}}],[\"heapinsert\",{\"1\":{\"937\":3}}],[\"heapsort\",{\"1\":{\"937\":1}}],[\"heapfy\",{\"1\":{\"937\":1}}],[\"heapdumppath=<path>\",{\"1\":{\"324\":1}}],[\"heap分析工具\",{\"1\":{\"313\":1}}],[\"heap\",{\"1\":{\"200\":1,\"203\":1,\"297\":1}}],[\"hooks\",{\"0\":{\"1161\":1},\"1\":{\"1155\":1,\"1161\":1,\"1163\":1}}],[\"hosts\",{\"1\":{\"1124\":1}}],[\"host\",{\"0\":{\"1124\":1},\"1\":{\"1038\":2,\"1039\":1,\"1184\":1}}],[\"host权限表\",{\"1\":{\"458\":1}}],[\"home\",{\"1\":{\"176\":1,\"416\":3}}],[\"home>\",{\"1\":{\"176\":1,\"177\":1}}],[\"hotspot默认采用混合模式\",{\"1\":{\"283\":1}}],[\"hotspot的垃圾收集器\",{\"1\":{\"260\":1}}],[\"hotspot的算法细节\",{\"0\":{\"248\":1}}],[\"hotspot虚拟机的许多收集器中都有使用到写屏障\",{\"1\":{\"250\":1}}],[\"hotspot虚拟机下\",{\"1\":{\"247\":1}}],[\"hotspot虚拟机里面关注吞吐量的parallel\",{\"1\":{\"246\":1}}],[\"hotspot虚拟机默认eden和survivor的大小比例是8∶1\",{\"1\":{\"245\":1}}],[\"hotspot主要使用第二种方式进行对象访问\",{\"1\":{\"230\":1}}],[\"hotspot并未使用\",{\"1\":{\"202\":1}}],[\"hotspot编译器能够分析出一个新的对象的引用的使用范围\",{\"1\":{\"202\":1}}],[\"hotspot\",{\"1\":{\"88\":1,\"193\":1,\"224\":1,\"227\":1}}],[\"hrrn\",{\"1\":{\"150\":1}}],[\"href=\",{\"1\":{\"26\":1}}],[\"has\",{\"1\":{\"1098\":1,\"1144\":1}}],[\"hasnext\",{\"1\":{\"951\":1,\"952\":1,\"953\":1,\"954\":1}}],[\"hashing指的是将一个哈希表分成长度相等的两半\",{\"1\":{\"884\":1}}],[\"hashing中的d是多个的意思\",{\"1\":{\"884\":1}}],[\"hashing\",{\"1\":{\"884\":3}}],[\"hash函数选择\",{\"1\":{\"884\":1}}],[\"hash统计\",{\"1\":{\"881\":1,\"892\":1,\"894\":1,\"895\":1,\"896\":1,\"897\":1}}],[\"hash映射\",{\"1\":{\"881\":1,\"892\":1,\"894\":1,\"895\":1,\"896\":1,\"897\":1}}],[\"hash等算法的基础上\",{\"1\":{\"869\":1}}],[\"hash切分\",{\"1\":{\"587\":1,\"588\":1}}],[\"hashset\",{\"0\":{\"413\":1},\"1\":{\"342\":1,\"413\":6}}],[\"hashentry\",{\"1\":{\"129\":4,\"130\":1}}],[\"hashtable\",{\"0\":{\"407\":1},\"1\":{\"129\":2,\"407\":4,\"409\":1}}],[\"hashmap的\",{\"1\":{\"413\":1}}],[\"hashmap+双向链表\",{\"1\":{\"412\":1}}],[\"hashmap\",{\"0\":{\"395\":1,\"396\":1,\"399\":1,\"400\":1,\"404\":1,\"407\":1,\"408\":1,\"409\":1,\"957\":1},\"1\":{\"108\":1,\"128\":3,\"129\":3,\"342\":1,\"369\":1,\"396\":3,\"399\":4,\"404\":3,\"405\":3,\"406\":1,\"407\":4,\"408\":7,\"409\":1,\"410\":2,\"412\":2,\"413\":5,\"414\":1,\"537\":1,\"607\":2,\"645\":1,\"729\":1,\"891\":1,\"893\":1,\"1091\":1}}],[\"hashcode\",{\"0\":{\"341\":1,\"342\":1,\"405\":1},\"1\":{\"88\":4,\"131\":2,\"341\":2,\"342\":4,\"350\":5,\"369\":1,\"405\":4}}],[\"hash\",{\"0\":{\"47\":1,\"405\":1,\"406\":1,\"615\":1,\"622\":1,\"884\":1},\"1\":{\"88\":1,\"98\":1,\"144\":1,\"341\":2,\"342\":3,\"350\":1,\"369\":1,\"396\":2,\"397\":1,\"398\":3,\"400\":3,\"404\":5,\"405\":4,\"406\":3,\"410\":1,\"412\":1,\"494\":1,\"537\":2,\"541\":2,\"610\":1,\"616\":1,\"622\":15,\"623\":5,\"637\":2,\"645\":2,\"679\":2,\"681\":9,\"684\":1,\"812\":1,\"832\":2,\"880\":1,\"891\":1,\"892\":2,\"894\":1,\"895\":3,\"896\":2}}],[\"having是从前面筛选的字段再筛选\",{\"1\":{\"481\":1}}],[\"having只能用于\",{\"1\":{\"481\":1}}],[\"having\",{\"0\":{\"481\":1},\"1\":{\"481\":1,\"487\":2}}],[\"hard\",{\"1\":{\"427\":1,\"453\":2,\"568\":1}}],[\"handleparam\",{\"1\":{\"1242\":1}}],[\"handlepromotionfailure\",{\"1\":{\"220\":1}}],[\"handle\",{\"1\":{\"245\":1,\"1242\":1}}],[\"handlerinterceptor\",{\"1\":{\"759\":2}}],[\"handlerinterceptor接口\",{\"1\":{\"759\":1}}],[\"handlerinterceptoradapter类\",{\"1\":{\"759\":1}}],[\"handleradapter\",{\"1\":{\"755\":1,\"756\":1}}],[\"handlerexecutionchain\",{\"1\":{\"755\":1}}],[\"handlermapping\",{\"1\":{\"755\":2,\"756\":1}}],[\"handler\",{\"0\":{\"60\":1},\"1\":{\"58\":5,\"349\":3,\"611\":1,\"755\":9,\"756\":2}}],[\"happens\",{\"0\":{\"75\":1,\"77\":1,\"102\":1},\"1\":{\"67\":1,\"75\":10,\"77\":1,\"102\":7}}],[\"lmdb\",{\"1\":{\"1144\":1}}],[\"lcp开始协商一些配置选项\",{\"1\":{\"975\":1}}],[\"l+j\",{\"1\":{\"934\":1}}],[\"lvalue\",{\"1\":{\"804\":2}}],[\"lpush\",{\"1\":{\"705\":1}}],[\"lua\",{\"1\":{\"610\":1}}],[\"ll\",{\"1\":{\"443\":2}}],[\"lname\",{\"1\":{\"537\":1}}],[\"ln\",{\"1\":{\"427\":1}}],[\"ls2\",{\"1\":{\"823\":1}}],[\"ls\",{\"0\":{\"419\":1,\"442\":1},\"1\":{\"416\":1,\"418\":1,\"419\":1,\"442\":3,\"823\":1}}],[\"lt\",{\"1\":{\"381\":4}}],[\"l\",{\"1\":{\"312\":1,\"419\":1,\"430\":1,\"441\":1,\"443\":2,\"804\":3,\"934\":11,\"953\":1,\"1190\":1}}],[\"latest\",{\"1\":{\"1177\":1,\"1212\":1}}],[\"lambda\",{\"1\":{\"1089\":1}}],[\"layer\",{\"1\":{\"1047\":1,\"1062\":2}}],[\"last\",{\"1\":{\"940\":1,\"1038\":1}}],[\"largest\",{\"1\":{\"937\":7}}],[\"lag\",{\"1\":{\"853\":1}}],[\"launcher$appclassloader来实现\",{\"1\":{\"178\":1}}],[\"launcher$extclassloader中以java代码的形式实现的\",{\"1\":{\"177\":1}}],[\"language\",{\"1\":{\"1038\":2,\"1039\":1,\"1148\":1}}],[\"lang\",{\"1\":{\"85\":1,\"126\":1,\"168\":2,\"173\":1,\"174\":2,\"176\":1,\"179\":1,\"182\":2,\"184\":2,\"200\":1,\"237\":1,\"278\":2,\"348\":2,\"385\":5,\"390\":1,\"725\":1,\"1075\":1}}],[\"lfu\",{\"1\":{\"160\":1,\"633\":1,\"706\":2}}],[\"lru\",{\"1\":{\"160\":1,\"495\":1,\"633\":1,\"636\":2,\"706\":2}}],[\"light\",{\"1\":{\"1035\":1}}],[\"lifetime\",{\"1\":{\"1027\":1}}],[\"lifo\",{\"1\":{\"940\":1}}],[\"lished\",{\"1\":{\"1022\":1}}],[\"listener\",{\"1\":{\"822\":3}}],[\"list列表中事务id最小的id\",{\"1\":{\"499\":1}}],[\"list<\",{\"1\":{\"345\":2}}],[\"list\",{\"0\":{\"618\":1},\"1\":{\"108\":1,\"304\":3,\"345\":3,\"388\":1,\"391\":1,\"392\":2,\"418\":1,\"446\":1,\"499\":1,\"603\":1,\"610\":1,\"616\":1,\"618\":2,\"626\":1,\"637\":2,\"908\":1}}],[\"like\",{\"1\":{\"533\":1,\"534\":1,\"553\":1,\"557\":1,\"745\":2}}],[\"limit\",{\"0\":{\"486\":1},\"1\":{\"200\":1,\"297\":1,\"484\":1,\"486\":6,\"487\":1,\"499\":2,\"535\":1,\"753\":1}}],[\"library\",{\"1\":{\"416\":1,\"715\":1}}],[\"lib\",{\"1\":{\"176\":1,\"177\":1,\"416\":2,\"434\":1,\"1144\":1,\"1177\":3}}],[\"lib目录\",{\"1\":{\"176\":1}}],[\"linenumbertable属性\",{\"1\":{\"292\":1}}],[\"line\",{\"1\":{\"72\":1}}],[\"linux系统下可以在tomcat\",{\"1\":{\"317\":1}}],[\"linux\",{\"0\":{\"415\":1,\"427\":1,\"438\":1,\"441\":1},\"1\":{\"62\":1,\"354\":1,\"380\":1,\"381\":1,\"416\":6,\"426\":1,\"427\":3,\"428\":1,\"430\":1,\"438\":1,\"440\":1,\"442\":1,\"701\":1,\"1167\":1}}],[\"linklayer\",{\"1\":{\"961\":1}}],[\"linklistinput\",{\"1\":{\"955\":1}}],[\"linknode\",{\"1\":{\"955\":7}}],[\"linkedhashmap\",{\"0\":{\"412\":1,\"414\":1},\"1\":{\"412\":5,\"414\":2}}],[\"linkedlist通常作为栈或队列使用\",{\"1\":{\"394\":1}}],[\"linkedlist<>\",{\"1\":{\"394\":3}}],[\"linkedlist等等\",{\"1\":{\"304\":1}}],[\"linkedlist\",{\"0\":{\"392\":1,\"393\":1},\"1\":{\"108\":1,\"391\":4,\"392\":5,\"393\":8,\"618\":2}}],[\"linkedtransferqueue\",{\"1\":{\"62\":1}}],[\"linkedblockingdeque\",{\"1\":{\"62\":1}}],[\"linkedblockingdeque<runnable>\",{\"1\":{\"59\":1}}],[\"linkedblockingqueue\",{\"1\":{\"56\":2,\"62\":1}}],[\"link\",{\"1\":{\"26\":2,\"421\":1,\"427\":3}}],[\"le表示单词的平准长度\",{\"1\":{\"899\":1}}],[\"leo\",{\"0\":{\"855\":1},\"1\":{\"855\":1}}],[\"learning\",{\"0\":{\"1180\":1,\"1214\":1,\"1262\":1},\"1\":{\"1213\":1}}],[\"leading\",{\"1\":{\"820\":1}}],[\"leader选举\",{\"0\":{\"877\":1}}],[\"leader挂了\",{\"1\":{\"866\":1}}],[\"leader写入就返回\",{\"1\":{\"866\":1}}],[\"leader发生故障之后\",{\"1\":{\"855\":1}}],[\"leader发生故障的时候\",{\"1\":{\"845\":1}}],[\"leader故障\",{\"1\":{\"855\":1}}],[\"leader维护了一个动态的isr\",{\"1\":{\"853\":1}}],[\"leader\",{\"1\":{\"819\":1,\"820\":9,\"845\":1,\"870\":1,\"874\":5,\"875\":5,\"876\":5,\"877\":7,\"878\":8}}],[\"leastactive\",{\"1\":{\"812\":1}}],[\"least\",{\"1\":{\"633\":2,\"856\":2}}],[\"leak\",{\"1\":{\"45\":1}}],[\"len=nums\",{\"1\":{\"936\":1}}],[\"lenth用于记录前一个\",{\"1\":{\"627\":1}}],[\"len\",{\"1\":{\"624\":5,\"626\":1,\"1087\":1}}],[\"length<2\",{\"1\":{\"930\":1}}],[\"length\",{\"1\":{\"404\":7,\"405\":1,\"628\":2,\"630\":1,\"911\":1,\"912\":2,\"913\":1,\"930\":3,\"931\":2,\"932\":2,\"933\":4,\"934\":3,\"935\":3,\"936\":3,\"937\":3,\"955\":3,\"956\":2,\"1038\":2}}],[\"level\",{\"1\":{\"630\":1}}],[\"level来记录\",{\"1\":{\"572\":1}}],[\"level模式也被做了优化\",{\"1\":{\"572\":1}}],[\"left+1\",{\"1\":{\"935\":1}}],[\"left>=right\",{\"1\":{\"935\":1}}],[\"left也由此而来\",{\"1\":{\"884\":1}}],[\"left\",{\"1\":{\"485\":1,\"884\":3,\"908\":6,\"911\":5,\"912\":12,\"913\":6,\"935\":6,\"937\":8,\"956\":1,\"1012\":1}}],[\"less\",{\"0\":{\"23\":1,\"429\":1,\"1165\":1},\"1\":{\"23\":1,\"428\":1,\"429\":2,\"1148\":2}}],[\"looking\",{\"1\":{\"820\":3}}],[\"lost\",{\"1\":{\"521\":1}}],[\"lost+found\",{\"1\":{\"416\":1}}],[\"low<high\",{\"1\":{\"936\":3}}],[\"low>=high\",{\"1\":{\"936\":1}}],[\"low>high\",{\"1\":{\"935\":1}}],[\"low++\",{\"1\":{\"935\":1,\"936\":1}}],[\"low\",{\"1\":{\"499\":1,\"510\":1,\"935\":28,\"936\":18}}],[\"locate\",{\"1\":{\"434\":1}}],[\"locale\",{\"1\":{\"1190\":1}}],[\"localhost\",{\"1\":{\"1038\":1,\"1178\":1}}],[\"localvariabletable及localvariabletypetable属性\",{\"1\":{\"292\":1}}],[\"locals数据项中确定了该方法所需分配的局部变量表的最大容量\",{\"1\":{\"192\":1}}],[\"lock退化为间隙锁\",{\"1\":{\"515\":1}}],[\"lock退化为行锁\",{\"1\":{\"515\":1}}],[\"lock的原因\",{\"1\":{\"506\":1}}],[\"lock的方式对数据行进行加锁\",{\"1\":{\"505\":1}}],[\"lock是行锁和间隙锁的组合\",{\"1\":{\"505\":1}}],[\"lock+gap\",{\"1\":{\"505\":1}}],[\"lock锁\",{\"1\":{\"504\":1}}],[\"locking\",{\"1\":{\"491\":1}}],[\"lockinterruptibly\",{\"1\":{\"125\":1}}],[\"lock接口是java中对锁操作行为的统一规范\",{\"1\":{\"95\":1}}],[\"locksupport\",{\"1\":{\"38\":6,\"62\":1}}],[\"lock\",{\"0\":{\"94\":1,\"503\":1,\"504\":1,\"505\":1},\"1\":{\"38\":4,\"73\":2,\"74\":1,\"75\":1,\"81\":1,\"94\":5,\"96\":1,\"102\":1,\"114\":1,\"126\":10,\"144\":1,\"294\":1,\"295\":1,\"296\":8,\"500\":1,\"501\":1,\"505\":4,\"506\":3,\"508\":1,\"509\":1,\"510\":3,\"514\":1,\"515\":2,\"516\":2,\"517\":5,\"523\":1,\"559\":1,\"668\":2}}],[\"loaded\",{\"1\":{\"782\":1}}],[\"loader\",{\"1\":{\"175\":4,\"181\":1,\"349\":2}}],[\"loadfactor=used\",{\"1\":{\"623\":1}}],[\"load过高\",{\"1\":{\"307\":1}}],[\"loadclass\",{\"0\":{\"183\":1},\"1\":{\"168\":1,\"182\":1,\"183\":2,\"184\":1,\"185\":1}}],[\"load\",{\"1\":{\"73\":2,\"74\":1,\"294\":1,\"295\":1}}],[\"long\",{\"1\":{\"58\":1,\"61\":1,\"126\":1,\"192\":1,\"350\":2,\"368\":1,\"557\":1,\"566\":2,\"617\":1,\"701\":1,\"949\":2,\"953\":3,\"1177\":1,\"1190\":1}}],[\"logk\",{\"1\":{\"893\":3}}],[\"log文件\",{\"1\":{\"846\":1}}],[\"log文件大小超过1g的时候\",{\"1\":{\"846\":1}}],[\"log太大了怎么办\",{\"1\":{\"846\":1}}],[\"log=\",{\"1\":{\"701\":1}}],[\"log=1\",{\"1\":{\"557\":1}}],[\"log留出空间可以继续写\",{\"1\":{\"594\":1}}],[\"log写满了\",{\"1\":{\"594\":1}}],[\"log主要节省的是随机写磁盘的io消耗\",{\"1\":{\"575\":1}}],[\"log和change\",{\"0\":{\"575\":1}}],[\"log是循环写的\",{\"1\":{\"573\":1}}],[\"log是物理日志\",{\"1\":{\"573\":1}}],[\"log是innodb引擎特有的\",{\"1\":{\"573\":1}}],[\"log的三种格式\",{\"0\":{\"572\":1}}],[\"log记载着数据修改前的信息\",{\"1\":{\"519\":1}}],[\"log⽇志来保证\",{\"1\":{\"519\":1}}],[\"log中存放的是真实的数据\",{\"1\":{\"846\":1}}],[\"log中记录下来\",{\"1\":{\"568\":1}}],[\"log中\",{\"1\":{\"499\":1}}],[\"log里面\",{\"1\":{\"489\":1,\"569\":1}}],[\"logging\",{\"1\":{\"489\":1,\"569\":1}}],[\"logs\",{\"1\":{\"270\":1}}],[\"logn\",{\"0\":{\"934\":1,\"935\":1,\"937\":1},\"1\":{\"130\":1,\"401\":1,\"612\":1,\"630\":2,\"901\":1,\"916\":2,\"934\":1,\"937\":2}}],[\"log\",{\"0\":{\"443\":1,\"568\":1,\"570\":1,\"571\":1,\"573\":2,\"577\":1},\"1\":{\"31\":2,\"270\":1,\"332\":1,\"416\":1,\"424\":1,\"443\":2,\"449\":8,\"469\":3,\"470\":2,\"488\":1,\"489\":5,\"493\":1,\"499\":1,\"519\":2,\"559\":2,\"563\":1,\"566\":5,\"567\":4,\"568\":25,\"570\":2,\"571\":1,\"575\":2,\"577\":1,\"578\":9,\"580\":3,\"581\":2,\"582\":2,\"701\":1,\"855\":1,\"875\":4,\"1177\":6}}],[\"mf\",{\"1\":{\"987\":1}}],[\"m1\",{\"1\":{\"986\":3}}],[\"m2\",{\"1\":{\"986\":2}}],[\"mtu\",{\"0\":{\"982\":1},\"1\":{\"982\":4}}],[\"mtbf\",{\"1\":{\"879\":3}}],[\"m=low+\",{\"1\":{\"936\":1}}],[\"mq会立即推送给消费者\",{\"1\":{\"843\":1}}],[\"mq将接收到的消息\",{\"1\":{\"843\":1}}],[\"mq属于主动方\",{\"1\":{\"843\":1}}],[\"mq主动将消息推送给消费者\",{\"1\":{\"843\":1}}],[\"mq接收到消息\",{\"1\":{\"843\":1}}],[\"mq挂了整个系统就挂了\",{\"1\":{\"841\":1}}],[\"mq的缺点\",{\"0\":{\"841\":1}}],[\"mq\",{\"0\":{\"839\":1,\"840\":1},\"1\":{\"840\":3,\"1242\":1}}],[\"mget\",{\"1\":{\"678\":2}}],[\"msie5\",{\"1\":{\"1038\":1}}],[\"msl\",{\"1\":{\"1027\":1}}],[\"mss\",{\"0\":{\"982\":1},\"1\":{\"982\":3}}],[\"ms参数设定\",{\"1\":{\"853\":1}}],[\"mset\",{\"1\":{\"678\":2}}],[\"msg\",{\"1\":{\"304\":1}}],[\"msg使用完之后就没用了\",{\"1\":{\"304\":1}}],[\"multiline\",{\"1\":{\"1190\":1}}],[\"multilineinput\",{\"1\":{\"951\":1}}],[\"multiply\",{\"1\":{\"804\":5}}],[\"multi\",{\"1\":{\"665\":5}}],[\"mutex\",{\"1\":{\"142\":1}}],[\"md\",{\"0\":{\"1206\":1},\"1\":{\"1206\":2}}],[\"mdl\",{\"0\":{\"511\":1},\"1\":{\"511\":5}}],[\"md5\",{\"1\":{\"477\":1,\"891\":1}}],[\"mbytes\",{\"1\":{\"441\":1}}],[\"mp\",{\"1\":{\"422\":1}}],[\"mkdir\",{\"0\":{\"422\":1},\"1\":{\"418\":1,\"420\":2,\"422\":3,\"1177\":3}}],[\"mnt\",{\"1\":{\"416\":1}}],[\"mvc是一种设计模式\",{\"1\":{\"754\":1}}],[\"mvc是一个基于java的实现了mvc设计模式的请求驱动类型的轻量级web框架\",{\"1\":{\"754\":1}}],[\"mvc\",{\"1\":{\"729\":1,\"748\":3,\"754\":2,\"770\":2,\"772\":1}}],[\"mvc框架\",{\"1\":{\"717\":1}}],[\"mvcc的好处\",{\"1\":{\"499\":1}}],[\"mvcc的本质就是对比版本\",{\"1\":{\"499\":1}}],[\"mvcc其实就是靠\",{\"1\":{\"499\":1}}],[\"mvcc主要是为了提高数据库并发性能\",{\"1\":{\"499\":1}}],[\"mvcc多版本并发控制⭐\",{\"0\":{\"499\":1}}],[\"mvcc\",{\"1\":{\"491\":1,\"493\":1,\"499\":1,\"505\":1,\"519\":1,\"523\":2,\"570\":1}}],[\"mv\",{\"0\":{\"425\":1},\"1\":{\"416\":1,\"418\":1,\"425\":2,\"447\":1}}],[\"mlocate\",{\"1\":{\"434\":2}}],[\"mlocal\",{\"1\":{\"39\":5}}],[\"mlvv\",{\"1\":{\"312\":1}}],[\"mirrors\",{\"1\":{\"1143\":3,\"1184\":2}}],[\"midsummer\",{\"1\":{\"1202\":1}}],[\"mid\",{\"1\":{\"911\":7,\"912\":7,\"913\":7,\"934\":9}}],[\"mightcontain\",{\"1\":{\"882\":5}}],[\"missbe\",{\"1\":{\"795\":1,\"796\":1,\"800\":2}}],[\"misc\",{\"1\":{\"177\":1,\"178\":1}}],[\"milliseconds\",{\"1\":{\"657\":1,\"677\":1}}],[\"minindex\",{\"1\":{\"931\":5}}],[\"min\",{\"1\":{\"708\":1}}],[\"minutes\",{\"1\":{\"642\":1}}],[\"minor\",{\"0\":{\"329\":1},\"1\":{\"220\":3,\"240\":1,\"411\":1}}],[\"mips的机器同时间可以执行40万条指令\",{\"1\":{\"543\":1}}],[\"mixedlevel\",{\"1\":{\"572\":1}}],[\"mixed\",{\"1\":{\"240\":1,\"263\":1,\"566\":1}}],[\"myblog\",{\"1\":{\"1177\":4,\"1178\":1}}],[\"mybaits\",{\"1\":{\"753\":1}}],[\"mybatis作为数据对象的持久化引擎\",{\"1\":{\"761\":1}}],[\"mybatis\",{\"0\":{\"749\":1,\"752\":1,\"753\":1},\"1\":{\"597\":1,\"607\":1,\"746\":3,\"749\":3,\"752\":3,\"753\":2,\"776\":1,\"1117\":1,\"1242\":1}}],[\"mypow\",{\"1\":{\"949\":1}}],[\"myquicksort\",{\"1\":{\"936\":4}}],[\"myid\",{\"1\":{\"820\":1}}],[\"myisam索引缓存\",{\"1\":{\"1177\":1}}],[\"myisam引擎使用b+tree作为索引结构\",{\"1\":{\"547\":1}}],[\"myisam存储引擎中\",{\"1\":{\"547\":1}}],[\"myisam\",{\"0\":{\"492\":1,\"493\":1},\"1\":{\"488\":1,\"493\":1,\"547\":1,\"577\":2}}],[\"my\",{\"1\":{\"701\":2,\"1177\":3,\"1178\":1}}],[\"mycat\",{\"1\":{\"586\":1}}],[\"mycallable\",{\"1\":{\"31\":3}}],[\"mysqld\",{\"1\":{\"1177\":1}}],[\"mysql提供了相应的函数来把字符串格式的ip转换成整数inet\",{\"1\":{\"997\":1}}],[\"mysql在保存变长的字符串时\",{\"1\":{\"997\":1}}],[\"mysql在真正开始执行语句之前\",{\"1\":{\"536\":1}}],[\"mysql正常关闭的时候\",{\"1\":{\"594\":1}}],[\"mysql认为系统\",{\"1\":{\"594\":1}}],[\"mysql底层是通过数据页存储的\",{\"1\":{\"585\":1}}],[\"mysql会根据执行的每一条具体的sql语句来区分对待记录的日志形式\",{\"1\":{\"572\":1}}],[\"mysql会一直向右匹配直到遇到范围查询\",{\"1\":{\"533\":1}}],[\"mysql的复制\",{\"1\":{\"571\":1}}],[\"mysqlbinlog\",{\"1\":{\"566\":1}}],[\"mysql是支持前缀索引的\",{\"1\":{\"554\":1}}],[\"mysql选错索引是因为没能准确判断出扫描行数\",{\"1\":{\"536\":1}}],[\"mysql中innodb\",{\"1\":{\"536\":1}}],[\"mysql觉得全表扫描更快时\",{\"1\":{\"534\":1}}],[\"mysql才会去使用索引\",{\"1\":{\"532\":1}}],[\"mysql默认是b+树\",{\"1\":{\"528\":1}}],[\"mysql默认采用\",{\"1\":{\"522\":1}}],[\"mysql45讲\",{\"1\":{\"525\":1}}],[\"mysql做了优化\",{\"1\":{\"501\":1}}],[\"mysql缓冲池\",{\"1\":{\"495\":1}}],[\"mysql>\",{\"1\":{\"489\":1,\"517\":2,\"553\":1}}],[\"mysql基础架构⭐\",{\"0\":{\"488\":1}}],[\"mysql数据库支持单向\",{\"1\":{\"469\":1,\"580\":1}}],[\"mysql关闭\",{\"1\":{\"459\":1}}],[\"mysql启动\",{\"1\":{\"459\":1}}],[\"mysql服务器通过权限表控制用户对数据库的访问\",{\"1\":{\"458\":1}}],[\"mysql\",{\"0\":{\"454\":1,\"458\":1,\"487\":1,\"557\":1,\"566\":1,\"567\":1,\"699\":1,\"1116\":1,\"1176\":1},\"1\":{\"348\":1,\"458\":1,\"459\":4,\"464\":1,\"475\":3,\"480\":2,\"484\":3,\"488\":2,\"489\":1,\"490\":7,\"491\":1,\"500\":1,\"508\":1,\"509\":1,\"511\":1,\"516\":1,\"517\":1,\"525\":1,\"526\":1,\"533\":1,\"534\":1,\"536\":1,\"537\":2,\"538\":1,\"553\":1,\"556\":1,\"559\":2,\"561\":2,\"562\":1,\"565\":1,\"566\":1,\"568\":1,\"577\":3,\"578\":2,\"649\":1,\"668\":1,\"687\":1,\"741\":1,\"807\":1,\"1117\":3,\"1177\":22,\"1178\":3}}],[\"myj\",{\"1\":{\"183\":1,\"743\":1,\"745\":2}}],[\"m\",{\"1\":{\"102\":2,\"261\":1,\"312\":1,\"394\":2,\"422\":2,\"448\":3,\"476\":3,\"645\":1,\"647\":2,\"880\":2,\"919\":3,\"923\":1,\"935\":7,\"936\":6,\"1057\":5,\"1126\":1,\"1127\":1,\"1144\":1,\"1190\":2}}],[\"meight\",{\"1\":{\"1035\":1}}],[\"median\",{\"1\":{\"891\":1}}],[\"mediumint\",{\"1\":{\"472\":1}}],[\"mean\",{\"1\":{\"879\":1}}],[\"mechine\",{\"1\":{\"878\":1}}],[\"member\",{\"1\":{\"620\":3}}],[\"memcache\",{\"1\":{\"610\":1}}],[\"memcached\",{\"0\":{\"610\":1},\"1\":{\"610\":5,\"637\":1}}],[\"memecache\",{\"1\":{\"495\":1,\"610\":1}}],[\"memoryleak\",{\"1\":{\"304\":1}}],[\"memory\",{\"0\":{\"494\":1},\"1\":{\"45\":2,\"66\":1,\"199\":1,\"209\":1,\"294\":1,\"297\":1,\"337\":2,\"488\":1,\"494\":5,\"558\":1}}],[\"mergesort\",{\"1\":{\"934\":1}}],[\"merge\",{\"1\":{\"451\":1,\"574\":1,\"934\":2,\"938\":2,\"1126\":1,\"1127\":1}}],[\"messagesize表示消息内容data的大小\",{\"1\":{\"847\":1}}],[\"messagesize\",{\"0\":{\"847\":1},\"1\":{\"847\":1}}],[\"message\",{\"1\":{\"448\":3,\"673\":1,\"840\":1}}],[\"mesi\",{\"1\":{\"72\":2,\"296\":1}}],[\"meta\",{\"1\":{\"771\":1}}],[\"metadata\",{\"1\":{\"292\":1}}],[\"metaspace的大小\",{\"1\":{\"323\":1}}],[\"metaspacesize\",{\"1\":{\"203\":1,\"323\":1}}],[\"metaspace\",{\"1\":{\"203\":1}}],[\"method方法\",{\"1\":{\"733\":1}}],[\"method属性\",{\"1\":{\"733\":1}}],[\"method是当前调度方法也可以说是真实对象的方法\",{\"1\":{\"725\":1}}],[\"methodparameters属性\",{\"1\":{\"292\":1}}],[\"method\",{\"1\":{\"197\":2,\"348\":2,\"349\":4}}],[\"methodhandle实例最后的解析结果为ref\",{\"1\":{\"174\":1}}],[\"menu\",{\"1\":{\"26\":2}}],[\"macth\",{\"1\":{\"1188\":1}}],[\"mac地址\",{\"1\":{\"981\":1}}],[\"mac帧的fcs字段的检验范围不包括前同步码和帧开始定界符\",{\"1\":{\"980\":1}}],[\"mac帧的信息马上要来啦\",{\"1\":{\"980\":1}}],[\"mac帧的格式\",{\"0\":{\"980\":1}}],[\"mac子层就会在数据字段的后面加入一个整数字节的填充字段\",{\"1\":{\"980\":1}}],[\"mac\",{\"0\":{\"981\":1},\"1\":{\"961\":2,\"981\":5,\"986\":5}}],[\"machine\",{\"1\":{\"335\":1}}],[\"maven只会引用引用路径最短的jar\",{\"1\":{\"798\":1}}],[\"maven会把直接引用和简洁引用的jar包都下载到本地\",{\"1\":{\"796\":1}}],[\"maven通过坐标在仓库中找到项目所需的jar包\",{\"1\":{\"795\":1}}],[\"maven首先从本地仓库中寻找项目所需的jar包\",{\"1\":{\"794\":1}}],[\"maven官方提供的远程仓库\",{\"1\":{\"794\":1}}],[\"maven本地的jar包仓库\",{\"1\":{\"794\":1}}],[\"maven仓库用来存放maven管理的所有jar包\",{\"1\":{\"794\":1}}],[\"maven安装完成之后\",{\"1\":{\"793\":1}}],[\"maven基本命令\",{\"0\":{\"793\":1}}],[\"maven的目录结构\",{\"0\":{\"792\":1}}],[\"maven依赖\",{\"1\":{\"776\":1}}],[\"maven\",{\"0\":{\"774\":1,\"1265\":1},\"1\":{\"774\":1,\"781\":1,\"790\":2,\"1136\":4}}],[\"master进程发送信号给\",{\"1\":{\"837\":1}}],[\"master进程可以管理worker进程\",{\"1\":{\"830\":1}}],[\"master的不会变的原因\",{\"1\":{\"837\":1}}],[\"master会立刻感知到\",{\"1\":{\"830\":1}}],[\"master有多少个slave就会创建多少个binlog\",{\"1\":{\"469\":1,\"580\":1}}],[\"master推送最新修改\",{\"1\":{\"452\":1}}],[\"master\",{\"0\":{\"830\":1,\"834\":1},\"1\":{\"452\":1,\"469\":1,\"580\":1,\"655\":10,\"656\":6,\"657\":23,\"659\":9,\"660\":1,\"661\":10,\"662\":7,\"664\":1,\"675\":3,\"676\":3,\"677\":17,\"678\":1,\"683\":7,\"803\":1,\"816\":1,\"833\":1,\"834\":1,\"1144\":2}}],[\"master第一次推送\",{\"1\":{\"452\":1}}],[\"make\",{\"1\":{\"418\":1,\"1168\":1,\"1170\":1}}],[\"matching\",{\"1\":{\"1190\":1}}],[\"match\",{\"0\":{\"1188\":1},\"1\":{\"1188\":2}}],[\"matrix\",{\"1\":{\"954\":2}}],[\"mater\",{\"0\":{\"833\":1}}],[\"mathrm\",{\"1\":{\"1012\":9}}],[\"math\",{\"1\":{\"642\":1,\"919\":1,\"935\":1,\"949\":1}}],[\"mat\",{\"1\":{\"313\":1}}],[\"mandatory\",{\"1\":{\"740\":1}}],[\"manipulation\",{\"1\":{\"720\":1}}],[\"man\",{\"1\":{\"277\":7,\"418\":2}}],[\"major\",{\"1\":{\"240\":1,\"243\":1,\"411\":1}}],[\"malloc\",{\"1\":{\"153\":1}}],[\"markdown\",{\"1\":{\"689\":1,\"1133\":2,\"1134\":4,\"1204\":1,\"1206\":1}}],[\"mark\",{\"0\":{\"84\":1},\"1\":{\"84\":1,\"85\":1,\"86\":1,\"87\":3,\"88\":2,\"89\":1,\"259\":1}}],[\"maxdirectmemorysize\",{\"1\":{\"323\":1}}],[\"maxtenuringthreshold=15\",{\"1\":{\"322\":1}}],[\"maxnewsize=1024m\",{\"1\":{\"322\":1}}],[\"maxheapsize\",{\"1\":{\"315\":1,\"322\":1}}],[\"maxgcpausemillis\",{\"1\":{\"257\":1,\"262\":1}}],[\"maxmetaspacesize\",{\"1\":{\"203\":1,\"323\":1}}],[\"maximum\",{\"1\":{\"96\":1,\"972\":1,\"982\":2,\"1027\":1}}],[\"maximumpoolsize\",{\"1\":{\"58\":8}}],[\"max\",{\"1\":{\"56\":1,\"617\":1,\"619\":1,\"622\":2,\"853\":1,\"1177\":2}}],[\"mapstruct\",{\"0\":{\"1248\":1},\"1\":{\"1249\":2,\"1259\":1}}],[\"map等统计每个文件中出现的词以及相应的频率\",{\"1\":{\"894\":1}}],[\"map进行频率统计\",{\"1\":{\"892\":1}}],[\"map即可模拟实现这个2bit\",{\"1\":{\"883\":1}}],[\"map扩展一下\",{\"1\":{\"883\":1}}],[\"map的扩展\",{\"1\":{\"883\":1}}],[\"mapreduce\",{\"0\":{\"891\":1},\"1\":{\"881\":1,\"891\":1}}],[\"mapper注解\",{\"1\":{\"776\":1}}],[\"mapper\",{\"0\":{\"762\":1},\"1\":{\"761\":1,\"1117\":1,\"1255\":1,\"1256\":1}}],[\"mappingtarget\",{\"1\":{\"1257\":1}}],[\"mapping\",{\"0\":{\"1257\":1},\"1\":{\"588\":1,\"747\":1,\"1255\":1,\"1256\":1}}],[\"map<k\",{\"1\":{\"408\":1}}],[\"map结构是为了让每个线程可以关联多个\",{\"1\":{\"299\":1}}],[\"map\",{\"1\":{\"39\":6,\"41\":3,\"42\":3,\"43\":2,\"108\":1,\"342\":1,\"388\":1,\"391\":3,\"399\":2,\"407\":1,\"409\":1,\"410\":2,\"412\":1,\"413\":4,\"608\":1,\"609\":1,\"883\":1,\"891\":1,\"892\":1,\"895\":3,\"898\":1,\"957\":1,\"1260\":1}}],[\"main方法运行\",{\"1\":{\"767\":1}}],[\"main的参数\",{\"1\":{\"312\":1}}],[\"main\",{\"1\":{\"31\":1,\"51\":1,\"98\":1,\"174\":1,\"227\":1,\"277\":1,\"294\":1,\"337\":1,\"781\":1,\"822\":1,\"935\":1,\"951\":1,\"952\":2,\"953\":1,\"955\":1,\"956\":1,\"1077\":2,\"1082\":1,\"1143\":1,\"1266\":3}}],[\"mount\",{\"1\":{\"1177\":3}}],[\"moudlandview\",{\"1\":{\"770\":1}}],[\"mon\",{\"1\":{\"1038\":1}}],[\"monitor被翻译为监视器或者说管程\",{\"1\":{\"85\":1}}],[\"monitorexit\",{\"1\":{\"82\":4}}],[\"monitorenter\",{\"1\":{\"82\":3}}],[\"monitor\",{\"0\":{\"85\":1},\"1\":{\"38\":4,\"82\":1,\"85\":3,\"89\":4,\"109\":2}}],[\"mozila\",{\"1\":{\"1038\":1}}],[\"most\",{\"1\":{\"856\":1}}],[\"more\",{\"0\":{\"429\":1},\"1\":{\"428\":3,\"429\":2,\"987\":1}}],[\"move\",{\"1\":{\"418\":1}}],[\"moved\",{\"1\":{\"131\":1}}],[\"modal\",{\"1\":{\"1157\":1}}],[\"mod\",{\"1\":{\"923\":1}}],[\"modified\",{\"1\":{\"1038\":1}}],[\"modifier\",{\"1\":{\"26\":3}}],[\"modify\",{\"1\":{\"521\":1}}],[\"modules\",{\"0\":{\"1212\":1},\"1\":{\"882\":1,\"1212\":2}}],[\"modules>\",{\"1\":{\"799\":1}}],[\"module>\",{\"1\":{\"799\":2}}],[\"modulepackages和modulemainclass三个属性用于支持java模块化相关功能\",{\"1\":{\"292\":1}}],[\"module\",{\"1\":{\"292\":1,\"882\":2,\"1144\":2,\"1190\":1,\"1212\":1}}],[\"models\",{\"1\":{\"1144\":1}}],[\"modelandview\",{\"1\":{\"755\":3}}],[\"model\",{\"1\":{\"748\":2,\"754\":2,\"755\":2,\"1144\":1}}],[\"modefailure\",{\"1\":{\"259\":1}}],[\"mode\",{\"1\":{\"256\":1,\"500\":1,\"501\":1,\"509\":1,\"514\":1,\"559\":1}}],[\"modcount\",{\"1\":{\"129\":1}}],[\"mc\",{\"1\":{\"31\":2}}],[\"时勾选\",{\"1\":{\"1144\":1}}],[\"时序图\",{\"1\":{\"1094\":1,\"1271\":1}}],[\"时序性\",{\"1\":{\"873\":1}}],[\"时会遇到数据映射错位的问题\",{\"1\":{\"1117\":1}}],[\"时会使用\",{\"1\":{\"1033\":1}}],[\"时会发生对应的指令\",{\"1\":{\"379\":1}}],[\"时分复用tdm\",{\"1\":{\"967\":1}}],[\"时长为timeout\",{\"1\":{\"858\":1}}],[\"时才会执行\",{\"1\":{\"759\":2}}],[\"时刻整个数据库的一个快照\",{\"1\":{\"647\":1}}],[\"时也会自动触发\",{\"1\":{\"647\":1}}],[\"时不要进入一个误区\",{\"1\":{\"637\":1}}],[\"时执行一次\",{\"1\":{\"623\":1}}],[\"时的一个占位符而存在\",{\"1\":{\"413\":1}}],[\"时只会改变句柄中的实例数据指针\",{\"1\":{\"230\":1}}],[\"时⽣成的\",{\"1\":{\"203\":1}}],[\"时钟置换算法也叫最近未用算法\",{\"1\":{\"160\":1}}],[\"时钟\",{\"1\":{\"160\":1}}],[\"时被阻塞\",{\"1\":{\"120\":1}}],[\"时出现的问题\",{\"1\":{\"71\":1}}],[\"时间图\",{\"1\":{\"1094\":1}}],[\"时间的设置通常是两个小时\",{\"1\":{\"1028\":1}}],[\"时间等待\",{\"1\":{\"1026\":1}}],[\"时间到后\",{\"1\":{\"1004\":1}}],[\"时间超过\",{\"1\":{\"993\":1}}],[\"时间与可用性\",{\"0\":{\"879\":1}}],[\"时间并且至少有\",{\"1\":{\"672\":1}}],[\"时间过长\",{\"1\":{\"643\":1}}],[\"时间进行查找\",{\"1\":{\"537\":1}}],[\"时间戳回送回答\",{\"1\":{\"1007\":1}}],[\"时间戳请求和回答\",{\"1\":{\"993\":1}}],[\"时间戳\",{\"1\":{\"475\":1,\"1007\":1}}],[\"时间戳转换为日期\",{\"1\":{\"475\":1}}],[\"时间戳相同\",{\"1\":{\"475\":1}}],[\"时间和日期\",{\"0\":{\"475\":1}}],[\"时间复杂度为o\",{\"1\":{\"901\":1}}],[\"时间复杂度为n\",{\"1\":{\"893\":1}}],[\"时间复杂度是o\",{\"1\":{\"899\":2}}],[\"时间复杂度是\",{\"1\":{\"627\":1}}],[\"时间复杂度访问和插入\",{\"1\":{\"408\":1}}],[\"时间复杂度\",{\"1\":{\"381\":3,\"902\":1,\"930\":1,\"931\":1,\"932\":1,\"934\":1,\"937\":1}}],[\"时间间隔到了\",{\"1\":{\"350\":1}}],[\"时间比初始标记略长\",{\"1\":{\"259\":1}}],[\"时间片轮转\",{\"1\":{\"150\":1}}],[\"时间片用完\",{\"1\":{\"144\":1}}],[\"时间结束\",{\"1\":{\"38\":3}}],[\"时间\",{\"1\":{\"35\":1,\"91\":1,\"377\":1,\"440\":1,\"1027\":1,\"1060\":1}}],[\"时代意味着多个线程可以通过运行\",{\"1\":{\"30\":1}}],[\"时\",{\"1\":{\"26\":1,\"58\":1,\"69\":1,\"96\":1,\"174\":1,\"184\":1,\"368\":1,\"381\":1,\"396\":1,\"398\":1,\"399\":1,\"401\":1,\"410\":1,\"468\":1,\"485\":1,\"619\":1,\"623\":1,\"632\":1,\"657\":1,\"659\":1,\"817\":1,\"878\":1,\"880\":1,\"882\":2,\"896\":1,\"938\":1,\"973\":1,\"1015\":1,\"1039\":1,\"1091\":1,\"1117\":1,\"1124\":1}}],[\"前向纠错\",{\"1\":{\"1042\":1}}],[\"前同步码作用是使接收器的适配器在接收mac帧时能迅速调整其时钟频率\",{\"1\":{\"980\":1}}],[\"前序遍历\",{\"1\":{\"908\":1}}],[\"前\",{\"1\":{\"907\":1}}],[\"前端神器\",{\"1\":{\"1152\":1}}],[\"前端测绘\",{\"1\":{\"1130\":1}}],[\"前端控制器dispatcherservlet\",{\"1\":{\"755\":1}}],[\"前端控制器servelt\",{\"1\":{\"755\":1}}],[\"前端控制器\",{\"1\":{\"755\":1,\"756\":1}}],[\"前端编译器\",{\"0\":{\"282\":1}}],[\"前置通知\",{\"1\":{\"722\":1}}],[\"前如果\",{\"1\":{\"665\":1}}],[\"前进指针\",{\"1\":{\"630\":1}}],[\"前进指针和跨度\",{\"1\":{\"630\":1}}],[\"前者是\",{\"1\":{\"1048\":1}}],[\"前者是一个全局性的过程\",{\"1\":{\"1019\":1}}],[\"前者是日志文件\",{\"1\":{\"575\":1}}],[\"前者在获取失败时抛出异常\",{\"1\":{\"736\":1}}],[\"前者与类型直接关联\",{\"1\":{\"274\":1}}],[\"前缀索引\",{\"0\":{\"554\":1},\"1\":{\"548\":1}}],[\"前缀指令在执行指令期间\",{\"1\":{\"296\":1}}],[\"前缀指令会引起处理器缓存回写到内存中\",{\"1\":{\"296\":1}}],[\"前缀指令引发的两件事情\",{\"1\":{\"296\":1}}],[\"前缀指令\",{\"1\":{\"296\":1}}],[\"前导模糊查询不会使用索引\",{\"1\":{\"535\":1}}],[\"前开后闭区间\",{\"1\":{\"505\":1}}],[\"前驱表和后驱表\",{\"1\":{\"392\":1}}],[\"前后元素是通过链表中指针建立关联\",{\"1\":{\"391\":1}}],[\"前后加上内存屏障\",{\"1\":{\"78\":1}}],[\"前提是装有\",{\"1\":{\"336\":1}}],[\"前对变量的写\",{\"1\":{\"102\":2}}],[\"前面介绍的工厂方法模式中考虑的是一类产品的生产\",{\"1\":{\"1079\":1}}],[\"前面介绍的几种进程调度的算法都有一定的局限性\",{\"1\":{\"150\":1}}],[\"前面已经排好序了\",{\"1\":{\"932\":1}}],[\"前面的题中已经讲到了\",{\"1\":{\"899\":1}}],[\"前面的操作\",{\"1\":{\"75\":1,\"102\":1}}],[\"前面这里我们就完成bean的实例化\",{\"1\":{\"733\":1}}],[\"前面提到\",{\"1\":{\"681\":1}}],[\"前面4条调用指令\",{\"1\":{\"274\":1}}],[\"前面要加上双连字符\",{\"1\":{\"26\":1}}],[\"前面要加上双下划线\",{\"1\":{\"26\":1}}],[\"前言\",{\"0\":{\"1\":1}}],[\"eof\",{\"1\":{\"1177\":2}}],[\"eot时\",{\"1\":{\"973\":1}}],[\"edu\",{\"1\":{\"1143\":4}}],[\"eden区和from\",{\"1\":{\"242\":1}}],[\"eden\",{\"1\":{\"219\":1}}],[\"esc\",{\"1\":{\"973\":1}}],[\"escape\",{\"1\":{\"202\":1}}],[\"everything\",{\"1\":{\"964\":1}}],[\"everysec\",{\"1\":{\"650\":2,\"707\":1,\"708\":1}}],[\"events\",{\"1\":{\"1218\":1}}],[\"eventually\",{\"1\":{\"871\":1}}],[\"event\",{\"1\":{\"381\":1,\"611\":1}}],[\"ehcache\",{\"1\":{\"607\":3,\"642\":1}}],[\"e6\",{\"1\":{\"559\":6}}],[\"e8\",{\"1\":{\"559\":8}}],[\"e9\",{\"1\":{\"559\":1}}],[\"e4\",{\"1\":{\"559\":8}}],[\"e7\",{\"1\":{\"559\":4}}],[\"e5\",{\"1\":{\"559\":5}}],[\"eq\",{\"1\":{\"556\":1,\"702\":1}}],[\"equals\",{\"0\":{\"340\":1,\"341\":1,\"342\":1},\"1\":{\"340\":5,\"341\":2,\"342\":4,\"350\":6,\"396\":2,\"400\":2,\"408\":1,\"1260\":1}}],[\"emit\",{\"1\":{\"1162\":1}}],[\"embedded\",{\"1\":{\"1139\":1,\"1266\":1}}],[\"embstr编码\",{\"1\":{\"617\":1}}],[\"emoji\",{\"1\":{\"1134\":1}}],[\"empty\",{\"1\":{\"908\":3}}],[\"email\",{\"1\":{\"446\":2,\"554\":2,\"1202\":1}}],[\"emulator\",{\"1\":{\"18\":1}}],[\"ef|grep\",{\"1\":{\"830\":1}}],[\"ef\",{\"1\":{\"436\":1,\"559\":2}}],[\"each\",{\"1\":{\"391\":7,\"891\":1}}],[\"ear\",{\"1\":{\"168\":1}}],[\"etc\",{\"1\":{\"416\":7,\"1124\":1,\"1177\":1}}],[\"et\",{\"1\":{\"381\":5,\"613\":1}}],[\"epoll+master\",{\"1\":{\"830\":1}}],[\"epoll多路复用\",{\"0\":{\"829\":1}}],[\"epoll\",{\"0\":{\"612\":1},\"1\":{\"381\":19,\"612\":5,\"613\":4}}],[\"echart\",{\"1\":{\"1163\":1}}],[\"echarts\",{\"1\":{\"1163\":1}}],[\"eclipse\",{\"1\":{\"282\":1}}],[\"ecj\",{\"1\":{\"282\":1}}],[\"enum<e>\",{\"1\":{\"1247\":1,\"1260\":1}}],[\"enumerationfactory\",{\"1\":{\"1247\":1}}],[\"enumset\",{\"1\":{\"1260\":1}}],[\"enumset<e>\",{\"1\":{\"1260\":1}}],[\"enumsdata\",{\"1\":{\"1159\":2}}],[\"enumsingleton\",{\"1\":{\"1070\":2}}],[\"enum\",{\"1\":{\"1070\":2,\"1261\":2}}],[\"encoding\",{\"1\":{\"1038\":3,\"1039\":1,\"1212\":1}}],[\"env\",{\"1\":{\"1186\":1}}],[\"envname\",{\"1\":{\"1182\":2}}],[\"envs\",{\"1\":{\"1144\":1}}],[\"envelopes\",{\"1\":{\"938\":1}}],[\"environment\",{\"1\":{\"335\":1}}],[\"enable\",{\"1\":{\"863\":1,\"866\":1}}],[\"enableautoconfiguration会帮助springboot应用把所有符合\",{\"1\":{\"771\":1}}],[\"enableautoconfiguration\",{\"1\":{\"771\":3,\"777\":1}}],[\"end\",{\"1\":{\"855\":1}}],[\"enrty\",{\"1\":{\"623\":1}}],[\"engine\",{\"1\":{\"700\":1,\"1177\":1}}],[\"engine层逻辑日志\",{\"1\":{\"570\":1}}],[\"engine层物理日志\",{\"1\":{\"568\":1}}],[\"engine执行时加载本地方法库\",{\"1\":{\"197\":1}}],[\"entity\",{\"0\":{\"1230\":1,\"1243\":1},\"1\":{\"1217\":2,\"1245\":4}}],[\"entries\",{\"1\":{\"619\":1,\"622\":1}}],[\"entry<k\",{\"1\":{\"399\":2}}],[\"entryset\",{\"1\":{\"391\":1}}],[\"entry\",{\"1\":{\"42\":2,\"45\":4,\"47\":1,\"301\":7,\"395\":1,\"396\":4,\"399\":1,\"412\":2,\"614\":1,\"627\":4,\"628\":8,\"875\":8,\"878\":10}}],[\"entrylist\",{\"1\":{\"37\":1,\"85\":2,\"89\":2,\"109\":1}}],[\"enter\",{\"1\":{\"429\":1,\"1178\":1,\"1202\":1}}],[\"e\",{\"1\":{\"98\":2,\"413\":3,\"426\":2,\"446\":1,\"818\":2,\"823\":1,\"1177\":1,\"1247\":1,\"1260\":4}}],[\"example\",{\"1\":{\"891\":1}}],[\"exactly\",{\"1\":{\"856\":1}}],[\"exactlyonce\",{\"0\":{\"856\":1}}],[\"ex\",{\"1\":{\"705\":1}}],[\"exists会对外查询的表每一行进行循环匹配\",{\"1\":{\"482\":1}}],[\"exists\",{\"0\":{\"482\":1},\"1\":{\"482\":1,\"560\":1,\"601\":1,\"669\":1}}],[\"exit\",{\"1\":{\"459\":1}}],[\"exfat\",{\"1\":{\"442\":1}}],[\"exec\",{\"1\":{\"665\":7,\"1177\":1,\"1178\":1}}],[\"executeupdate\",{\"1\":{\"745\":2}}],[\"execute\",{\"0\":{\"61\":1},\"1\":{\"61\":1,\"430\":2}}],[\"executor\",{\"1\":{\"59\":1}}],[\"executors\",{\"1\":{\"56\":1,\"59\":1}}],[\"executorservice\",{\"1\":{\"56\":2}}],[\"executionexception\",{\"1\":{\"31\":1}}],[\"exe\",{\"1\":{\"313\":2,\"1192\":1}}],[\"expression=\",{\"1\":{\"1255\":1,\"1256\":1}}],[\"expression\",{\"0\":{\"1193\":1}}],[\"experiments\",{\"1\":{\"1144\":1}}],[\"expect\",{\"1\":{\"110\":2}}],[\"expires\",{\"1\":{\"632\":1,\"1038\":1}}],[\"expire\",{\"1\":{\"603\":1,\"632\":1,\"642\":1,\"668\":1}}],[\"explain\",{\"0\":{\"556\":1},\"1\":{\"556\":2,\"558\":1,\"559\":1,\"702\":1}}],[\"expungestaleentry\",{\"1\":{\"301\":2}}],[\"extra\",{\"1\":{\"556\":1,\"702\":1}}],[\"extend\",{\"1\":{\"355\":1}}],[\"extends关键字\",{\"1\":{\"288\":1}}],[\"extends\",{\"1\":{\"277\":2,\"345\":3,\"1247\":1,\"1260\":2}}],[\"extension\",{\"1\":{\"175\":1}}],[\"ext\",{\"1\":{\"177\":1}}],[\"ext目录中\",{\"1\":{\"177\":1}}],[\"exclusions>\",{\"1\":{\"796\":1}}],[\"exclusion>\",{\"1\":{\"796\":1}}],[\"exclusive\",{\"0\":{\"113\":1}}],[\"exclude\",{\"1\":{\"777\":1}}],[\"excludepathpatterns\",{\"1\":{\"759\":1}}],[\"excel\",{\"1\":{\"1108\":1}}],[\"exception\",{\"0\":{\"384\":1},\"1\":{\"384\":2}}],[\"exceptions属性\",{\"1\":{\"292\":1}}],[\"exceeded\",{\"1\":{\"96\":1,\"200\":1,\"297\":1}}],[\"exchange\",{\"1\":{\"127\":2}}],[\"exchanger\",{\"0\":{\"127\":1},\"1\":{\"127\":1}}],[\"error\",{\"0\":{\"384\":1},\"1\":{\"96\":1,\"384\":2,\"566\":1,\"645\":1,\"755\":1,\"1144\":1,\"1168\":1,\"1178\":1,\"1212\":2}}],[\"electiontimeout<<mtbf\",{\"1\":{\"879\":1}}],[\"electiontimeout\",{\"1\":{\"879\":3}}],[\"electionelapsed\",{\"1\":{\"877\":1}}],[\"elementaref\",{\"1\":{\"1155\":2}}],[\"element2\",{\"1\":{\"26\":2}}],[\"element1\",{\"1\":{\"26\":1}}],[\"element\",{\"1\":{\"26\":5,\"630\":2}}],[\"else\",{\"1\":{\"96\":1,\"911\":2,\"912\":2,\"913\":2,\"930\":1,\"933\":1,\"936\":2,\"955\":1,\"1077\":3,\"1088\":1}}],[\"<filtering>false<\",{\"1\":{\"1266\":3}}],[\"<file>\",{\"1\":{\"325\":1}}],[\"<directory>src\",{\"1\":{\"1266\":3}}],[\"<dependencies>\",{\"1\":{\"800\":1}}],[\"<dependencymanagement>\",{\"1\":{\"800\":1}}],[\"<dependency>\",{\"1\":{\"776\":1,\"795\":1,\"800\":1,\"882\":1}}],[\"<resource>\",{\"1\":{\"1266\":3}}],[\"<resources>\",{\"1\":{\"1266\":2}}],[\"<repo>\",{\"1\":{\"1197\":3}}],[\"<e\",{\"1\":{\"1247\":1,\"1260\":2}}],[\"<exclusion>\",{\"1\":{\"796\":1}}],[\"<exclusions>\",{\"1\":{\"796\":1}}],[\"<username>\",{\"1\":{\"1197\":3}}],[\"<openssl\",{\"1\":{\"1168\":1}}],[\"<option>=<number>\",{\"1\":{\"316\":1}}],[\"<option>表示禁用option属性\",{\"1\":{\"316\":1}}],[\"<option>\",{\"1\":{\"312\":1}}],[\"<1\",{\"1\":{\"1140\":1}}],[\"<冲突文件路径>\",{\"1\":{\"1126\":1}}],[\"<build>\",{\"1\":{\"1266\":2}}],[\"<body>响应体<\",{\"1\":{\"1038\":1}}],[\"<bean\",{\"1\":{\"713\":1,\"734\":1,\"736\":1}}],[\"<html>\",{\"1\":{\"1038\":1}}],[\"<hostid>\",{\"1\":{\"312\":1}}],[\"<路径>\",{\"1\":{\"1036\":2}}],[\"<端口>\",{\"1\":{\"1036\":2}}],[\"<主机>\",{\"1\":{\"1036\":2}}],[\"<主机号>\",{\"1\":{\"984\":1,\"989\":1,\"991\":1}}],[\"<协议>\",{\"1\":{\"1036\":1}}],[\"<网络前缀>\",{\"1\":{\"991\":1}}],[\"<网络号>\",{\"1\":{\"984\":1,\"989\":1}}],[\"<子网号>\",{\"1\":{\"989\":1}}],[\"<<<\",{\"1\":{\"943\":1}}],[\"<<\",{\"1\":{\"879\":2,\"943\":1,\"1177\":1}}],[\"<module>web\",{\"1\":{\"799\":2}}],[\"<modules>\",{\"1\":{\"799\":1}}],[\"<parent>\",{\"1\":{\"800\":2}}],[\"<packaging>pom<\",{\"1\":{\"796\":1,\"800\":1}}],[\"<packaging>jar<\",{\"1\":{\"795\":1}}],[\"<plugin>\",{\"1\":{\"790\":2}}],[\"<plugins>\",{\"1\":{\"790\":1}}],[\"<groupid>com\",{\"1\":{\"882\":1}}],[\"<groupid>cn\",{\"1\":{\"795\":1,\"796\":1,\"800\":2}}],[\"<groupid>父pom所在项目的groupid<\",{\"1\":{\"800\":1}}],[\"<groupid>org\",{\"1\":{\"776\":1,\"790\":2}}],[\"<target>1\",{\"1\":{\"790\":1}}],[\"<version>28\",{\"1\":{\"882\":1}}],[\"<version>父pom所在项目的版本号<\",{\"1\":{\"800\":1}}],[\"<version>1\",{\"1\":{\"776\":1,\"795\":1,\"796\":1,\"800\":2}}],[\"<vmid>\",{\"1\":{\"312\":1}}],[\"<索引名称>\",{\"1\":{\"527\":1}}],[\"<进程关键字>\",{\"1\":{\"436\":1}}],[\"<文件名>\",{\"1\":{\"434\":1}}],[\"<被查找的字符串>\",{\"1\":{\"434\":1}}],[\"<name><pid>设置boolean类型参数\",{\"1\":{\"317\":1}}],[\"<name>=<string>\",{\"1\":{\"316\":1}}],[\"<nav>\",{\"1\":{\"26\":1}}],[\"<configuration>\",{\"1\":{\"790\":1}}],[\"<count>\",{\"1\":{\"312\":1}}],[\"<clinit>\",{\"1\":{\"173\":4}}],[\"<include>\",{\"1\":{\"1266\":5}}],[\"<includes>\",{\"1\":{\"1266\":3}}],[\"<interval>\",{\"1\":{\"312\":1}}],[\"<init>\",{\"1\":{\"223\":1}}],[\"<script>\",{\"1\":{\"1162\":1}}],[\"<script\",{\"1\":{\"1162\":1}}],[\"<source>1\",{\"1\":{\"790\":1}}],[\"<span\",{\"1\":{\"58\":1,\"96\":1,\"118\":1,\"131\":1}}],[\"<style>标签加上\",{\"1\":{\"24\":1}}],[\"<=povit\",{\"1\":{\"936\":1}}],[\"<=array\",{\"1\":{\"935\":1}}],[\"<=target\",{\"1\":{\"913\":1}}],[\"<=\",{\"1\":{\"58\":1,\"368\":2,\"911\":1,\"912\":1,\"913\":1,\"934\":4,\"935\":1}}],[\"<\",{\"0\":{\"933\":1},\"1\":{\"58\":4,\"96\":1,\"118\":1,\"131\":1,\"153\":1,\"175\":3,\"345\":3,\"533\":1,\"556\":1,\"703\":1,\"776\":1,\"790\":4,\"795\":1,\"796\":2,\"799\":1,\"800\":5,\"804\":1,\"820\":1,\"882\":1,\"911\":1,\"912\":1,\"913\":2,\"930\":2,\"931\":2,\"932\":2,\"933\":4,\"934\":3,\"935\":4,\"937\":4,\"953\":1,\"954\":1,\"955\":2,\"956\":2,\"1038\":1,\"1266\":10}}],[\"<artifactid>guava<\",{\"1\":{\"882\":1}}],[\"<artifactid>父pom所在项目的artifactid<\",{\"1\":{\"800\":1}}],[\"<artifactid>resource\",{\"1\":{\"795\":1,\"796\":1,\"800\":2}}],[\"<artifactid>spring\",{\"1\":{\"790\":1}}],[\"<artifactid>maven\",{\"1\":{\"790\":1}}],[\"<artifactid>mybatis\",{\"1\":{\"776\":1}}],[\"<a\",{\"1\":{\"26\":1}}],[\"<li>\",{\"1\":{\"26\":1}}],[\"块区域\",{\"1\":{\"224\":1}}],[\"块\",{\"1\":{\"26\":1,\"173\":1}}],[\"b两个请求\",{\"1\":{\"1042\":1}}],[\"b两个文件\",{\"0\":{\"896\":1}}],[\"b进入last\",{\"1\":{\"1026\":1}}],[\"b进入estab\",{\"1\":{\"1022\":1}}],[\"b在等a的数据\",{\"1\":{\"1015\":1}}],[\"b>0\",{\"1\":{\"949\":1}}],[\"bot\",{\"0\":{\"1206\":1},\"1\":{\"1115\":1}}],[\"body>\",{\"1\":{\"1038\":1}}],[\"bound\",{\"1\":{\"912\":1,\"913\":1}}],[\"boot项目中\",{\"1\":{\"784\":1}}],[\"boot<\",{\"1\":{\"776\":1,\"790\":1}}],[\"boot还为我们做了很多默认配置\",{\"1\":{\"772\":1}}],[\"boot就能自动扫描并加载相应的模块\",{\"1\":{\"772\":1}}],[\"boot中的一个非常重要的概念\",{\"1\":{\"772\":1}}],[\"boot在发布它的第一个版本时没有这个功能\",{\"1\":{\"769\":1}}],[\"boot上的更改\",{\"1\":{\"769\":1}}],[\"boot有一个开发工具\",{\"1\":{\"769\":1}}],[\"boot来简化spring应用开发\",{\"1\":{\"767\":1}}],[\"boot\",{\"0\":{\"774\":1,\"777\":1,\"778\":1,\"779\":1,\"780\":1,\"781\":1,\"783\":1,\"788\":1},\"1\":{\"176\":1,\"416\":3,\"769\":2,\"770\":2,\"771\":1,\"772\":1,\"774\":7,\"776\":1,\"777\":1,\"778\":2,\"779\":1,\"782\":1,\"783\":2,\"789\":1,\"790\":2,\"1117\":1}}],[\"bootstrap\",{\"1\":{\"175\":1,\"783\":2}}],[\"boolean\",{\"1\":{\"96\":3,\"110\":1,\"184\":1,\"316\":1,\"368\":1,\"413\":1,\"930\":1}}],[\"b文件共同的url\",{\"0\":{\"896\":1}}],[\"break\",{\"1\":{\"930\":1,\"933\":1,\"937\":1}}],[\"brokers\",{\"1\":{\"861\":1}}],[\"broker发送ack之前\",{\"1\":{\"854\":1}}],[\"broker接收到还没有写入磁盘就已经返回\",{\"1\":{\"854\":1}}],[\"broker\",{\"1\":{\"845\":1,\"856\":1,\"861\":9}}],[\"broadcasttime<<electiontimeout\",{\"1\":{\"879\":1}}],[\"broadcasttime\",{\"1\":{\"879\":3}}],[\"broadcast\",{\"1\":{\"813\":1}}],[\"branch\",{\"1\":{\"449\":2,\"450\":1,\"451\":21,\"452\":2}}],[\"b的时候\",{\"1\":{\"718\":1}}],[\"b的时候必须自己去创建\",{\"1\":{\"718\":1}}],[\"bw\",{\"1\":{\"630\":1}}],[\"bgrewriteof\",{\"1\":{\"651\":1}}],[\"bgasve\",{\"1\":{\"647\":1}}],[\"bgwriteof\",{\"1\":{\"623\":1}}],[\"bgsave\",{\"1\":{\"623\":3,\"647\":11,\"655\":2,\"662\":1}}],[\"bf\",{\"1\":{\"559\":1}}],[\"bc\",{\"1\":{\"559\":2}}],[\"b999\",{\"1\":{\"896\":1}}],[\"b9\",{\"1\":{\"559\":3}}],[\"bb\",{\"1\":{\"559\":1}}],[\"b8\",{\"1\":{\"559\":3}}],[\"b7\",{\"1\":{\"559\":1}}],[\"b2\",{\"1\":{\"559\":1}}],[\"b5\",{\"1\":{\"559\":2}}],[\"b3\",{\"1\":{\"559\":1}}],[\"b1\",{\"1\":{\"559\":1,\"896\":1}}],[\"b0\",{\"1\":{\"559\":1}}],[\"b|\",{\"1\":{\"551\":1}}],[\"b=2\",{\"1\":{\"533\":1}}],[\"b+所有关键字数据地址都存储在叶子节点上\",{\"1\":{\"541\":1}}],[\"b+\",{\"0\":{\"538\":1,\"539\":1},\"1\":{\"537\":1,\"538\":4,\"539\":4,\"541\":3,\"549\":1,\"555\":1}}],[\"b+树的非叶子结点不存储数据\",{\"1\":{\"920\":1}}],[\"b+树的层级更少\",{\"1\":{\"541\":1}}],[\"b+树特别适合带范围的查找\",{\"1\":{\"920\":1}}],[\"b+树最主要的区别在于非叶子结点是否存储数据的问题\",{\"1\":{\"920\":1}}],[\"b+树才支持\",{\"1\":{\"916\":1}}],[\"b+树索引\",{\"1\":{\"548\":1}}],[\"b+树\",{\"0\":{\"920\":1},\"1\":{\"548\":1}}],[\"b+树叶子结点数目是确定的吗\",{\"0\":{\"542\":1}}],[\"b+树所有叶子节点构成了一个有序链表\",{\"1\":{\"541\":1}}],[\"b+树所有的叶子节点数据构成了一个有序链表\",{\"1\":{\"541\":1}}],[\"b+树遍历整棵树只需要遍历所有的叶子节点即可\",{\"1\":{\"541\":1}}],[\"b+树全节点遍历更快\",{\"1\":{\"541\":1}}],[\"b+树天然具备排序功能\",{\"1\":{\"541\":1}}],[\"b+树查询速度更稳定\",{\"1\":{\"541\":1}}],[\"b+树和其它的比较\",{\"0\":{\"540\":1}}],[\"b+树和hash\",{\"1\":{\"528\":1}}],[\"b+树中存的都是数据表中的字段值\",{\"1\":{\"533\":1}}],[\"b+tree\",{\"1\":{\"494\":1,\"537\":1}}],[\"b树\",{\"1\":{\"528\":1}}],[\"by以及聚合函数的问题\",{\"1\":{\"589\":1}}],[\"by子句中的列\",{\"1\":{\"487\":1}}],[\"by\",{\"0\":{\"484\":1},\"1\":{\"484\":1,\"485\":4,\"487\":2,\"560\":1,\"584\":2,\"589\":1,\"703\":2}}],[\"byteserializer\",{\"1\":{\"867\":1}}],[\"bytes\",{\"1\":{\"442\":1}}],[\"byte\",{\"1\":{\"368\":2,\"467\":1}}],[\"bytecode\",{\"1\":{\"281\":1,\"720\":1}}],[\"blog\",{\"1\":{\"1143\":2}}],[\"bloomfilter\",{\"1\":{\"882\":1}}],[\"bloomfilter<integer>\",{\"1\":{\"882\":1}}],[\"bloom\",{\"1\":{\"881\":1,\"883\":1}}],[\"blocking\",{\"1\":{\"829\":1}}],[\"blockingqueue\",{\"1\":{\"108\":1}}],[\"blockingqueue<runnable>\",{\"1\":{\"58\":1}}],[\"blocked\",{\"1\":{\"38\":1,\"89\":1}}],[\"block\",{\"1\":{\"26\":6,\"442\":1,\"558\":1,\"613\":1}}],[\"blame\",{\"1\":{\"449\":1}}],[\"bnw\",{\"1\":{\"428\":1}}],[\"bigint\",{\"1\":{\"468\":1,\"472\":1,\"601\":4}}],[\"bit=1\",{\"1\":{\"900\":1}}],[\"bitmap\",{\"0\":{\"883\":1},\"1\":{\"641\":2,\"881\":1,\"900\":3}}],[\"bit\",{\"1\":{\"406\":2,\"680\":2}}],[\"bio模型\",{\"1\":{\"829\":1}}],[\"bio\",{\"0\":{\"380\":1},\"1\":{\"380\":1}}],[\"bind\",{\"1\":{\"1177\":1}}],[\"bindingresult\",{\"1\":{\"755\":1}}],[\"binary\",{\"1\":{\"470\":1,\"581\":1,\"911\":1}}],[\"binaries\",{\"1\":{\"416\":1}}],[\"binlog文件写到一定大小后会切换到下一个\",{\"1\":{\"573\":1}}],[\"binlog是可以追加写入的\",{\"1\":{\"573\":1}}],[\"binlog是逻辑日志\",{\"1\":{\"573\":1}}],[\"binlog是mysql的server层实现的\",{\"1\":{\"573\":1}}],[\"binlog中可以不记录执行的sql语句的上下文相关的信息\",{\"1\":{\"572\":1}}],[\"binlog=1\",{\"1\":{\"582\":1}}],[\"binlog=1的时候\",{\"1\":{\"571\":1}}],[\"binlog=n\",{\"1\":{\"571\":1}}],[\"binlog=0的时候\",{\"1\":{\"571\":1}}],[\"binlog控制的\",{\"1\":{\"571\":1}}],[\"binlog的写入机制\",{\"1\":{\"571\":1}}],[\"binlog\",{\"1\":{\"469\":2,\"470\":1,\"488\":1,\"489\":3,\"563\":5,\"571\":13,\"576\":3,\"577\":2,\"578\":11,\"580\":2,\"581\":1,\"582\":3,\"649\":1,\"1177\":1}}],[\"bin\",{\"0\":{\"571\":1,\"572\":1,\"573\":1},\"1\":{\"313\":2,\"317\":1,\"416\":2,\"566\":1,\"571\":1,\"647\":1}}],[\"btrace\",{\"1\":{\"313\":1}}],[\"bundler\",{\"1\":{\"1139\":1}}],[\"bubblesort\",{\"1\":{\"930\":1}}],[\"build>\",{\"1\":{\"1266\":2}}],[\"building\",{\"1\":{\"1144\":1}}],[\"builder\",{\"1\":{\"1086\":4}}],[\"build\",{\"0\":{\"1212\":1},\"1\":{\"774\":1,\"1200\":1,\"1212\":1}}],[\"buf\",{\"1\":{\"624\":4}}],[\"bufferedreader\",{\"1\":{\"956\":1}}],[\"buffer和redo\",{\"1\":{\"575\":1}}],[\"buffer和辅助索引叶子节点的合并操作\",{\"1\":{\"496\":1}}],[\"buffer主要节省的则是随机读磁盘的io消耗\",{\"1\":{\"575\":1}}],[\"buffer记录的变更越多\",{\"1\":{\"574\":1}}],[\"buffer的页副本\",{\"1\":{\"593\":1}}],[\"buffer的维护代价\",{\"1\":{\"574\":1}}],[\"buffer的使用效果最好\",{\"1\":{\"574\":1}}],[\"buffer的使用场景\",{\"1\":{\"574\":1}}],[\"buffer的主要目的就是将记录的变更动作缓存下来\",{\"1\":{\"574\":1}}],[\"buffer在内存中有拷贝\",{\"1\":{\"574\":1}}],[\"buffer中的页写入磁盘文件\",{\"1\":{\"593\":1}}],[\"buffer中的页写入到各个表空间文件中\",{\"1\":{\"496\":1}}],[\"buffer中与这个页有关的操作\",{\"1\":{\"574\":1}}],[\"buffer中\",{\"1\":{\"574\":2,\"593\":1}}],[\"buffer再分两次\",{\"1\":{\"496\":1}}],[\"buffer对象中\",{\"1\":{\"496\":1}}],[\"buffer\",{\"0\":{\"495\":1,\"574\":1,\"575\":1},\"1\":{\"71\":1,\"72\":9,\"209\":1,\"297\":1,\"377\":1,\"379\":1,\"381\":1,\"484\":7,\"496\":3,\"555\":1,\"565\":1,\"568\":10,\"574\":7,\"594\":1,\"1177\":6}}],[\"bulk\",{\"1\":{\"565\":1}}],[\"bulitinclassloader\",{\"1\":{\"181\":1}}],[\"bug\",{\"1\":{\"515\":1}}],[\"bucketindex\",{\"1\":{\"404\":1}}],[\"backlog\",{\"1\":{\"1060\":1}}],[\"background\",{\"1\":{\"58\":1,\"96\":1,\"118\":1,\"131\":1}}],[\"banana\",{\"1\":{\"888\":2}}],[\"bash\",{\"1\":{\"1201\":1}}],[\"basicsr\",{\"1\":{\"1144\":6}}],[\"basically\",{\"1\":{\"871\":1}}],[\"based\",{\"1\":{\"1035\":1}}],[\"base+1\",{\"1\":{\"935\":1}}],[\"base>i\",{\"1\":{\"935\":1}}],[\"base<j\",{\"1\":{\"935\":1}}],[\"base=\",{\"1\":{\"935\":1}}],[\"base\",{\"0\":{\"1197\":1},\"1\":{\"871\":2,\"934\":1,\"935\":7,\"1197\":2,\"1240\":1}}],[\"base理论\",{\"0\":{\"871\":1}}],[\"basepackages\",{\"1\":{\"743\":1}}],[\"ba\",{\"1\":{\"559\":2}}],[\"bat中添加类似如下配置\",{\"1\":{\"317\":1}}],[\"barrier\",{\"1\":{\"120\":1,\"250\":1}}],[\"b\",{\"0\":{\"919\":1},\"1\":{\"75\":3,\"102\":2,\"105\":2,\"106\":1,\"355\":1,\"390\":2,\"427\":12,\"429\":2,\"450\":1,\"451\":1,\"482\":1,\"485\":2,\"514\":2,\"521\":2,\"533\":5,\"534\":1,\"538\":1,\"541\":2,\"550\":1,\"551\":3,\"559\":3,\"601\":1,\"718\":3,\"736\":1,\"798\":1,\"801\":2,\"919\":9,\"920\":1,\"947\":15,\"949\":3,\"977\":1,\"991\":1,\"1027\":2,\"1057\":3,\"1157\":2,\"1190\":6,\"1202\":1,\"1216\":1,\"1261\":6}}],[\"beta\",{\"1\":{\"1271\":1}}],[\"between\",{\"1\":{\"486\":1,\"533\":1,\"556\":1,\"560\":1,\"879\":1,\"997\":1}}],[\"bean来进行自动装配\",{\"1\":{\"773\":1}}],[\"bean容器的启动阶段\",{\"1\":{\"737\":1}}],[\"beanid\",{\"1\":{\"736\":3}}],[\"bean>\",{\"1\":{\"736\":1}}],[\"bean销毁调用方法\",{\"1\":{\"733\":1}}],[\"beanpostprocessor接口\",{\"1\":{\"737\":1}}],[\"beanpostprocessor\",{\"1\":{\"733\":1}}],[\"bean的作用域\",{\"0\":{\"734\":1}}],[\"bean的销毁\",{\"1\":{\"733\":1}}],[\"bean的实例化\",{\"1\":{\"733\":1}}],[\"bean的生命周期\",{\"0\":{\"733\":1}}],[\"bean相关\",{\"0\":{\"732\":1}}],[\"bean\",{\"0\":{\"735\":1},\"1\":{\"712\":1,\"730\":2,\"734\":7,\"735\":7,\"736\":1,\"742\":2}}],[\"beanfactory实现原理\",{\"0\":{\"737\":1}}],[\"beanfactory采用的是延迟加载形式来注入bean的\",{\"1\":{\"712\":1}}],[\"beanfactory是spring里面最底层的接口\",{\"1\":{\"712\":1}}],[\"beanfactory\",{\"1\":{\"712\":5,\"733\":1,\"742\":1}}],[\"begin\",{\"1\":{\"526\":1}}],[\"before\",{\"0\":{\"75\":1,\"77\":1,\"102\":1,\"1257\":1},\"1\":{\"67\":1,\"75\":10,\"77\":1,\"102\":7,\"412\":1,\"722\":1}}],[\"bem\",{\"0\":{\"25\":1}}],[\"就行\",{\"1\":{\"1255\":1}}],[\"就给客户端们颁发一个通行证吧\",{\"1\":{\"1051\":1}}],[\"就知道生意来了\",{\"1\":{\"1049\":1}}],[\"就无法按照正常步骤进入\",{\"1\":{\"1027\":1}}],[\"就建立新的连接了\",{\"1\":{\"1023\":1}}],[\"就释放了连接\",{\"1\":{\"1023\":1}}],[\"就执行尾部丢弃策略\",{\"1\":{\"1021\":1}}],[\"就立即发送一个报文段\",{\"1\":{\"1017\":1}}],[\"就立即提交\",{\"1\":{\"578\":1}}],[\"就把当前的缓存数据发送出去\",{\"1\":{\"1016\":1}}],[\"就把新key存储在左边的t1子表中\",{\"1\":{\"884\":1}}],[\"就组装成一个tcp报文段发送出去\",{\"1\":{\"1016\":1}}],[\"就发送一个零窗口的探测报文段\",{\"1\":{\"1015\":1}}],[\"就启动计时器\",{\"1\":{\"1015\":1}}],[\"就重新设置保活计时器\",{\"1\":{\"1028\":1}}],[\"就重新计算一次rtts\",{\"1\":{\"1012\":1}}],[\"就重传前面发送过的分组\",{\"1\":{\"1011\":1}}],[\"就重写\",{\"1\":{\"185\":1}}],[\"就丢弃该分组\",{\"1\":{\"1010\":1}}],[\"就丢弃该报文\",{\"1\":{\"1002\":1}}],[\"就丢弃该数据\",{\"1\":{\"993\":1}}],[\"就用改变路由报文把这情况告诉主机\",{\"1\":{\"993\":1}}],[\"就构成了数据链路\",{\"1\":{\"971\":1}}],[\"就构成了一个分组\",{\"1\":{\"960\":1}}],[\"就构成了链表\",{\"1\":{\"396\":1}}],[\"就和孩子交换\",{\"1\":{\"937\":1}}],[\"就说明序列有序\",{\"1\":{\"930\":1}}],[\"就去寻找下一个空的散列地址\",{\"1\":{\"924\":1}}],[\"就去做了其他操作导致\",{\"1\":{\"72\":1}}],[\"就换一个散列函数\",{\"1\":{\"924\":1}}],[\"就抓住他这个范围小来做文章\",{\"1\":{\"902\":1}}],[\"就叫做选举超时\",{\"1\":{\"877\":1}}],[\"就将已收到的数据报片丢弃\",{\"1\":{\"993\":1}}],[\"就将主机b的硬件地址写入arp高速缓存中\",{\"1\":{\"986\":1}}],[\"就将这\",{\"1\":{\"973\":1}}],[\"就将结果返回给之前的方法调用\",{\"1\":{\"804\":1}}],[\"就将还存活的对象复制到另一块去\",{\"1\":{\"245\":1}}],[\"就认为该服务已下线\",{\"1\":{\"802\":1}}],[\"就认为这个对象设计的有问题\",{\"1\":{\"88\":1}}],[\"就使用response向客户端浏览器颁发一个cookie\",{\"1\":{\"1051\":1}}],[\"就使用record\",{\"1\":{\"506\":1}}],[\"就使用谁\",{\"1\":{\"798\":1}}],[\"就线程不安全了\",{\"1\":{\"735\":1}}],[\"就太麻烦了\",{\"1\":{\"723\":1}}],[\"就没用上索引\",{\"1\":{\"702\":1}}],[\"就没有那么高效了\",{\"1\":{\"627\":1}}],[\"就没有必要写入缓存\",{\"1\":{\"606\":1}}],[\"就职期间\",{\"1\":{\"687\":1}}],[\"就成功当选\",{\"1\":{\"683\":1}}],[\"就放弃获取这个锁\",{\"1\":{\"672\":1}}],[\"就选择\",{\"1\":{\"650\":1}}],[\"就完成了\",{\"1\":{\"645\":1}}],[\"就加锁\",{\"1\":{\"643\":1}}],[\"就必须等待重传\",{\"1\":{\"1042\":1}}],[\"就必须重新到授权管理该项的域名服务器绑定信息\",{\"1\":{\"1032\":1}}],[\"就必须同时具有两个相应的ip地址\",{\"1\":{\"984\":1}}],[\"就必须减小τ与to之比\",{\"1\":{\"978\":1}}],[\"就必须采取适当措施来处理\",{\"1\":{\"973\":1}}],[\"就必须先刷到磁盘\",{\"1\":{\"594\":1}}],[\"就必须到缓冲池中申请一个数据页\",{\"1\":{\"594\":1}}],[\"就直接释放出来复用\",{\"1\":{\"594\":1}}],[\"就直接返回给执行器\",{\"1\":{\"489\":1}}],[\"就要采用可靠传输协议来纠正出现的差错\",{\"1\":{\"961\":1}}],[\"就要更改factory类的方法\",{\"1\":{\"731\":1}}],[\"就要淘汰一些数据页\",{\"1\":{\"594\":1}}],[\"就要暂存到磁盘\",{\"1\":{\"571\":1}}],[\"就要多利用内存\",{\"1\":{\"484\":1}}],[\"就采用\",{\"1\":{\"547\":1}}],[\"就采用共享模式\",{\"1\":{\"115\":1}}],[\"就相当于链表\",{\"1\":{\"541\":1}}],[\"就形成了带有顺序指针的\",{\"1\":{\"538\":1}}],[\"就得到了这个索引的基数\",{\"1\":{\"536\":1}}],[\"就停止匹配\",{\"1\":{\"533\":1}}],[\"就导致了意外的长事务\",{\"1\":{\"526\":1}}],[\"就好了\",{\"1\":{\"1159\":1}}],[\"就好像发生了幻觉一样\",{\"1\":{\"521\":1}}],[\"就好比一个级别很高的门卫一样\",{\"1\":{\"490\":1}}],[\"就准备开始执行了\",{\"1\":{\"490\":2}}],[\"就应该创建成\",{\"1\":{\"468\":1}}],[\"就可能会出现主键重复的情况\",{\"1\":{\"467\":1}}],[\"就可以考虑使用建造者模式\",{\"1\":{\"1086\":1}}],[\"就可以获取你所需要的对象\",{\"1\":{\"1077\":1}}],[\"就可以使本连接持续的时间内所产生的所有报文段都从网络中消失\",{\"1\":{\"1027\":1}}],[\"就可以使用命令git\",{\"1\":{\"452\":1}}],[\"就可以有效地提高网络的吞吐量\",{\"1\":{\"1017\":1}}],[\"就可以找到了\",{\"1\":{\"901\":1}}],[\"就可以直接利用direct\",{\"1\":{\"886\":1}}],[\"就可以很方便的解决\",{\"1\":{\"886\":1}}],[\"就可以成为\",{\"1\":{\"877\":1}}],[\"就可以重新加入isr了\",{\"1\":{\"855\":1}}],[\"就可以对所有被代理的方法进行相同的操作了\",{\"1\":{\"724\":1}}],[\"就可以利用spring\",{\"1\":{\"718\":1}}],[\"就可以放一个\",{\"1\":{\"641\":1}}],[\"就可以访问响应的\",{\"1\":{\"614\":1}}],[\"就可以知道它所对应的哈希桶的位置\",{\"1\":{\"614\":1}}],[\"就可以得出每个节点的子节点数的近似值\",{\"1\":{\"542\":1}}],[\"就可以了\",{\"1\":{\"406\":1}}],[\"就可以比较准确地定位泄漏代码的位置\",{\"1\":{\"298\":1}}],[\"就可以回收了\",{\"1\":{\"237\":1}}],[\"就可以干其他事了\",{\"1\":{\"72\":1}}],[\"就唯一确定了打标签时刻的版本\",{\"1\":{\"450\":1}}],[\"就转回链表\",{\"1\":{\"398\":1}}],[\"就扩容到原来数组的\",{\"1\":{\"392\":1}}],[\"就失去了语句的意义\",{\"1\":{\"364\":1}}],[\"就一定要重写\",{\"0\":{\"342\":1},\"1\":{\"342\":1}}],[\"就不会高度宽度塌陷\",{\"1\":{\"1163\":1}}],[\"就不会影响其他的哈希桶数组的读写\",{\"1\":{\"130\":1}}],[\"就不需要像\",{\"1\":{\"612\":1}}],[\"就不需要重新编译\",{\"1\":{\"597\":1}}],[\"就不需要移动和复制数组来进行操作了\",{\"1\":{\"393\":1}}],[\"就不用回表\",{\"1\":{\"550\":1}}],[\"就不在扩容\",{\"1\":{\"406\":1}}],[\"就不能挂掉任何一个节点了\",{\"1\":{\"819\":1}}],[\"就不能进行代理\",{\"1\":{\"727\":1}}],[\"就不能提前发现一些存在的spring的配置问题\",{\"1\":{\"712\":1}}],[\"就不能使用到索引\",{\"1\":{\"533\":1}}],[\"就不能改变\",{\"1\":{\"370\":1}}],[\"就不能修改这个对象中那些参与计算哈希值的字段了\",{\"1\":{\"304\":1}}],[\"就很合适了\",{\"1\":{\"685\":1}}],[\"就很容易遗忘\",{\"1\":{\"304\":1}}],[\"就很有可能造成内存泄漏\",{\"1\":{\"304\":1}}],[\"就很好办了\",{\"1\":{\"247\":1}}],[\"就内存占用来说\",{\"1\":{\"262\":1}}],[\"就能得到下单响应\",{\"1\":{\"840\":1}}],[\"就能维护和治理复杂的关系\",{\"1\":{\"809\":1}}],[\"就能回滚到事务之前的数据状态\",{\"1\":{\"570\":1}}],[\"就能调出以前执行过的命令\",{\"1\":{\"417\":1}}],[\"就能轻易得出哪些卡页内存块中包含跨代指针\",{\"1\":{\"249\":1}}],[\"就能表明对象还\",{\"1\":{\"45\":1}}],[\"就报oom了\",{\"1\":{\"243\":1}}],[\"就属于堆\",{\"1\":{\"203\":1}}],[\"就已经把\",{\"1\":{\"203\":1}}],[\"就算聚合根\",{\"1\":{\"1245\":1}}],[\"就算代码已经该变量的作用域\",{\"1\":{\"192\":1}}],[\"就算忘记调用\",{\"1\":{\"46\":1}}],[\"就在方法的code属性的max\",{\"1\":{\"192\":1}}],[\"就需要考虑将代码放到简单工厂中\",{\"1\":{\"1077\":1}}],[\"就需要有⼀个专⻔的层来标识⽹络中的设备\",{\"1\":{\"961\":1}}],[\"就需要有额外的空间进行分配担保\",{\"1\":{\"246\":1}}],[\"就需要在各种各样的路径和节点进⾏选择\",{\"1\":{\"961\":1}}],[\"就需要我们进行迁移数据\",{\"1\":{\"880\":1}}],[\"就需要依赖其他内存区域\",{\"1\":{\"245\":1}}],[\"就需要通过对齐填充来补全\",{\"1\":{\"227\":1}}],[\"就需要自定义类的加载器来实现\",{\"1\":{\"180\":1}}],[\"就需要越多的线程\",{\"1\":{\"57\":1}}],[\"就需要越少的线程\",{\"1\":{\"57\":1}}],[\"就绪\",{\"1\":{\"148\":3,\"381\":2}}],[\"就绪状态\",{\"1\":{\"148\":1}}],[\"就少自旋甚至不自旋\",{\"1\":{\"91\":1}}],[\"就多自旋几次\",{\"1\":{\"91\":1}}],[\"就会不断重发\",{\"1\":{\"1060\":1}}],[\"就会处于\",{\"1\":{\"1025\":1}}],[\"就会重新请求连接\",{\"1\":{\"1022\":1}}],[\"就会唤醒自己\",{\"1\":{\"829\":1}}],[\"就会调用destroy\",{\"1\":{\"733\":1}}],[\"就会被标记为\",{\"1\":{\"683\":1}}],[\"就会导致锁记录一直在数据库中\",{\"1\":{\"668\":1}}],[\"就会导致内存泄漏\",{\"1\":{\"45\":1}}],[\"就会启用\",{\"1\":{\"659\":1}}],[\"就会通过发布订阅模式\",{\"1\":{\"657\":1}}],[\"就会通知标识为\",{\"1\":{\"111\":1}}],[\"就会丢失最后一次快照后的所有更改\",{\"1\":{\"649\":1}}],[\"就会丢失这一条数据\",{\"1\":{\"578\":1}}],[\"就会影响准确率\",{\"1\":{\"645\":1}}],[\"就会施行内存淘汰策略\",{\"1\":{\"635\":1}}],[\"就会造成缓冲区溢出\",{\"1\":{\"624\":1}}],[\"就会使用\",{\"1\":{\"624\":1}}],[\"就会开始扩容\",{\"1\":{\"623\":1}}],[\"就会防止出现上述的问题\",{\"1\":{\"578\":1}}],[\"就会产生数据与原库不一样\",{\"1\":{\"578\":1}}],[\"就会产生额外的开销\",{\"1\":{\"250\":1}}],[\"就会把\",{\"1\":{\"568\":1}}],[\"就会把该指令之前存在于\",{\"1\":{\"72\":1}}],[\"就会停止继续检索\",{\"1\":{\"555\":1}}],[\"就会发送\",{\"1\":{\"656\":1}}],[\"就会发现多了一些原本不存在的记录\",{\"1\":{\"521\":1}}],[\"就会发生此错误\",{\"1\":{\"200\":1}}],[\"就会出现\",{\"1\":{\"516\":1}}],[\"就会出现减号\",{\"1\":{\"430\":1}}],[\"就会去调用引擎的接口\",{\"1\":{\"490\":1}}],[\"就会返回错误信息\",{\"1\":{\"490\":1}}],[\"就会执行后续的操作\",{\"1\":{\"490\":1}}],[\"就会自动开辟一个新的页\",{\"1\":{\"466\":1}}],[\"就会询问是否覆盖\",{\"1\":{\"425\":1}}],[\"就会触发minor\",{\"1\":{\"242\":1}}],[\"就会晋升老年代\",{\"1\":{\"241\":1}}],[\"就会直接报异常\",{\"1\":{\"610\":1}}],[\"就会直接返回给客户端\",{\"1\":{\"490\":1}}],[\"就会直接返回告诉修改数据的\",{\"1\":{\"72\":1}}],[\"就会直接从缓存中取出\",{\"1\":{\"368\":1}}],[\"就会直接进入老年代\",{\"1\":{\"241\":1}}],[\"就会在回收对象的内存之前\",{\"1\":{\"235\":1}}],[\"就会创建对应的运行时常量池\",{\"1\":{\"208\":1}}],[\"就会引发该错误\",{\"1\":{\"200\":1}}],[\"就会暂停执行下一条即将要执行的指令\",{\"1\":{\"134\":1}}],[\"就会释放所有等待的线程\",{\"1\":{\"118\":1}}],[\"就会进入第二步\",{\"1\":{\"490\":1}}],[\"就会进入\",{\"1\":{\"85\":1}}],[\"就会将原本传送给\",{\"1\":{\"986\":1}}],[\"就会将自己的\",{\"1\":{\"861\":1}}],[\"就会将这个消息发送给\",{\"1\":{\"822\":1}}],[\"就会将对应的\",{\"1\":{\"683\":1}}],[\"就会将\",{\"1\":{\"85\":1,\"986\":1}}],[\"就调用t\",{\"1\":{\"51\":1}}],[\"就是做持久化\",{\"1\":{\"1242\":1}}],[\"就是只操作内存中的变量\",{\"1\":{\"1242\":1}}],[\"就是将业务拆分成多个子域\",{\"1\":{\"1221\":1}}],[\"就是将装配的控制权移到程序之外\",{\"1\":{\"185\":1}}],[\"就是http\",{\"1\":{\"1042\":1}}],[\"就是handlerexecutionchain\",{\"1\":{\"755\":1}}],[\"就是已经完成三次握手\",{\"1\":{\"1025\":1}}],[\"就是一种可行的处理办法\",{\"1\":{\"1013\":1}}],[\"就是一个\",{\"1\":{\"685\":1}}],[\"就是一个让人容易记住的有意义的名字\",{\"1\":{\"450\":1}}],[\"就是若收到的报文段无差错\",{\"1\":{\"1013\":1}}],[\"就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来\",{\"1\":{\"1006\":1}}],[\"就是光的频分复用\",{\"1\":{\"967\":1}}],[\"就是使用桶排序的算法\",{\"1\":{\"902\":1}}],[\"就是使用字符类型定义的长度即10个字符空间与20个字符空间\",{\"1\":{\"478\":1}}],[\"就是可以采用分布式计算\",{\"1\":{\"891\":1}}],[\"就是要有大量的节点\",{\"1\":{\"880\":1}}],[\"就是要像调用本地的函数一样去调远程函数\",{\"1\":{\"801\":1}}],[\"就是存储该数据的节点\",{\"1\":{\"880\":1}}],[\"就是有序的\",{\"1\":{\"865\":1}}],[\"就是需要提供\",{\"1\":{\"825\":1}}],[\"就是投票轮数\",{\"1\":{\"820\":1}}],[\"就是不支持\",{\"1\":{\"785\":1}}],[\"就是它注入进去的\",{\"1\":{\"737\":1}}],[\"就是说有\",{\"1\":{\"707\":1}}],[\"就是分布式项目开发中用到的锁\",{\"1\":{\"667\":1}}],[\"就是让我们可以用\",{\"1\":{\"614\":1}}],[\"就是为了提高数据库的并发性能\",{\"1\":{\"579\":1}}],[\"就是图中的红色部分\",{\"1\":{\"568\":1}}],[\"就是数据持久化在硬盘上\",{\"1\":{\"519\":1}}],[\"就是数组中的元素\",{\"1\":{\"396\":1}}],[\"就是上述语句里的\",{\"1\":{\"476\":1}}],[\"就是把那个打标签的时刻的历史版本取出来\",{\"1\":{\"450\":1}}],[\"就是你在电脑里能看到的目录\",{\"1\":{\"444\":1}}],[\"就是你需要用到\",{\"1\":{\"342\":1}}],[\"就是其提供有序\",{\"1\":{\"414\":1}}],[\"就是通过\",{\"1\":{\"411\":1}}],[\"就是代码中的特殊标记\",{\"1\":{\"338\":1}}],[\"就是\",{\"1\":{\"299\":2,\"424\":1,\"825\":1}}],[\"就是形同虚设\",{\"1\":{\"235\":1}}],[\"就是操作数栈\",{\"1\":{\"193\":1}}],[\"就是独占锁\",{\"1\":{\"81\":1}}],[\"就是锁总线\",{\"1\":{\"72\":1}}],[\"就是因为\",{\"1\":{\"71\":1}}],[\"就是合并这些子任务的执行结果\",{\"1\":{\"49\":1}}],[\"就是常见的普通对象的引用\",{\"1\":{\"45\":1}}],[\"就是用哪一个类去代理的\",{\"1\":{\"725\":1}}],[\"就是用\",{\"1\":{\"43\":1}}],[\"就是在ip地址中又增加一个子网号字段\",{\"1\":{\"989\":1}}],[\"就是在\",{\"1\":{\"24\":1,\"78\":1}}],[\"就只属于这个线程了\",{\"1\":{\"39\":1}}],[\"就意味着标签内的样式只对当前组件生效\",{\"1\":{\"24\":1}}],[\"和聚合根将业务逻辑和技术解耦\",{\"1\":{\"1242\":1}}],[\"和转换与另一个上下文交互\",{\"1\":{\"1222\":1}}],[\"和系统字符集不匹配\",{\"1\":{\"1178\":1}}],[\"和饮料\",{\"1\":{\"1086\":1}}],[\"和简单工厂模式中工厂负责生产所有产品相比\",{\"1\":{\"1078\":1}}],[\"和内存资源\",{\"1\":{\"1048\":1}}],[\"和内存资源达到最优的平衡效果\",{\"1\":{\"632\":1}}],[\"和报文迷走有关系\",{\"1\":{\"1027\":1}}],[\"和路由器或交换机上的硬件端口是完全不同的概念\",{\"1\":{\"1000\":1}}],[\"和mf\",{\"1\":{\"987\":1}}],[\"和mybatis框架的整合\",{\"1\":{\"761\":1}}],[\"和对等方式\",{\"1\":{\"960\":1}}],[\"和对应的query\",{\"1\":{\"895\":1}}],[\"和对象\",{\"1\":{\"718\":1}}],[\"和h2\",{\"1\":{\"884\":1}}],[\"和可用性\",{\"1\":{\"871\":1}}],[\"和transaction\",{\"1\":{\"863\":1}}],[\"和worker\",{\"1\":{\"833\":1}}],[\"和反向代理的web服务器\",{\"1\":{\"824\":1}}],[\"和逻辑时钟\",{\"1\":{\"820\":1}}],[\"和逻辑时钟数据影响集群的选举\",{\"1\":{\"820\":1}}],[\"和端口信息\",{\"1\":{\"811\":1}}],[\"和数据库交互\",{\"1\":{\"754\":1}}],[\"和数据处理层\",{\"1\":{\"748\":1}}],[\"和数组不同的是\",{\"1\":{\"627\":1}}],[\"和注解来实现数据库\",{\"1\":{\"746\":1}}],[\"和之前的jdk相同一致\",{\"1\":{\"726\":1}}],[\"和jdk代理相比多了一个methodproxy参数\",{\"1\":{\"726\":1}}],[\"和jdk实现的代理没有什么区别\",{\"1\":{\"726\":1}}],[\"和被调用者\",{\"1\":{\"715\":1}}],[\"和从节点\",{\"1\":{\"683\":1}}],[\"和从基继承的\",{\"1\":{\"356\":1}}],[\"和它的从节点\",{\"1\":{\"659\":1}}],[\"和缓存雪崩不同的是\",{\"1\":{\"643\":1}}],[\"和值\",{\"1\":{\"637\":1}}],[\"和一条链路的接口\",{\"1\":{\"984\":1}}],[\"和一些常见变量\",{\"1\":{\"622\":1}}],[\"和一个新值\",{\"1\":{\"105\":1}}],[\"和一个值\",{\"1\":{\"6\":1}}],[\"和哈希表\",{\"1\":{\"615\":1}}],[\"和spring\",{\"1\":{\"607\":1}}],[\"和survivor\",{\"1\":{\"200\":1}}],[\"和键值对读写是由一个线程来完成的\",{\"1\":{\"604\":1}}],[\"和库的\",{\"1\":{\"588\":1}}],[\"和垂直分表有一点类似\",{\"1\":{\"585\":1}}],[\"和辅助索引页子节点的\",{\"1\":{\"574\":1}}],[\"和fsync的时机\",{\"1\":{\"571\":1}}],[\"和磁盘上的日志文件\",{\"1\":{\"568\":1}}],[\"和索引\",{\"1\":{\"561\":1}}],[\"和叶子节点顺序访问指针进行实现\",{\"1\":{\"538\":1}}],[\"和表设计\",{\"1\":{\"516\":1}}],[\"和回滚\",{\"1\":{\"493\":1}}],[\"和int类型相比\",{\"1\":{\"467\":1}}],[\"和迭代器来遍历\",{\"1\":{\"391\":1}}],[\"和迭代器需要实现\",{\"1\":{\"391\":1}}],[\"和非阻塞\",{\"1\":{\"380\":1}}],[\"和非静态成员变量\",{\"1\":{\"361\":1}}],[\"和异步\",{\"1\":{\"380\":1}}],[\"和操作系统\",{\"1\":{\"378\":1}}],[\"和常量\",{\"1\":{\"362\":1}}],[\"和==是不一样的\",{\"1\":{\"350\":1}}],[\"和工具\",{\"1\":{\"335\":1}}],[\"和元数据\",{\"1\":{\"292\":1}}],[\"和其他内存消耗\",{\"1\":{\"262\":1}}],[\"和你配置的内存大小有关\",{\"1\":{\"200\":1}}],[\"和本机物理内存无关\",{\"1\":{\"200\":1}}],[\"和虚拟机实现的内存布局直接相关的\",{\"1\":{\"172\":1}}],[\"和信号量\",{\"1\":{\"142\":1}}],[\"和notify\",{\"1\":{\"141\":1}}],[\"和过程\",{\"1\":{\"137\":1}}],[\"和基于⾮阻塞\",{\"1\":{\"137\":1}}],[\"和公平锁一样都会进入到\",{\"1\":{\"114\":1}}],[\"和类型指针\",{\"1\":{\"85\":1,\"86\":1}}],[\"和线程变量副本\",{\"1\":{\"39\":1,\"41\":1}}],[\"和\",{\"0\":{\"24\":1,\"32\":1,\"33\":1,\"36\":1,\"37\":1,\"40\":1,\"77\":1,\"79\":1,\"94\":1,\"121\":1,\"136\":1,\"336\":1,\"340\":1,\"367\":1,\"384\":1,\"442\":1,\"461\":1,\"478\":1,\"482\":1,\"493\":1,\"596\":1,\"608\":1,\"610\":1,\"652\":1,\"745\":1,\"750\":1,\"806\":1,\"815\":1,\"944\":1,\"1048\":1,\"1269\":1},\"1\":{\"31\":1,\"33\":1,\"36\":2,\"48\":1,\"75\":1,\"81\":1,\"105\":1,\"117\":1,\"120\":2,\"137\":1,\"203\":3,\"215\":1,\"244\":1,\"261\":1,\"284\":1,\"295\":1,\"299\":1,\"301\":2,\"335\":1,\"345\":1,\"348\":2,\"355\":1,\"356\":1,\"364\":1,\"368\":1,\"377\":1,\"381\":2,\"383\":3,\"390\":1,\"393\":2,\"407\":2,\"408\":2,\"411\":1,\"412\":2,\"427\":5,\"442\":1,\"473\":2,\"475\":2,\"478\":1,\"484\":2,\"503\":1,\"523\":1,\"533\":1,\"560\":1,\"563\":1,\"566\":2,\"567\":1,\"578\":1,\"583\":1,\"589\":1,\"601\":1,\"606\":1,\"607\":3,\"614\":1,\"622\":2,\"623\":2,\"627\":1,\"630\":1,\"647\":2,\"653\":2,\"665\":1,\"673\":1,\"677\":1,\"696\":1,\"708\":1,\"712\":2,\"734\":1,\"743\":1,\"745\":1,\"755\":1,\"770\":2,\"774\":1,\"783\":1,\"794\":1,\"801\":1,\"803\":1,\"819\":1,\"870\":1,\"871\":1,\"874\":1,\"880\":1,\"888\":1,\"900\":1,\"986\":1,\"1003\":1,\"1041\":4,\"1042\":1,\"1048\":1,\"1060\":1,\"1083\":1,\"1117\":1,\"1162\":1,\"1163\":1,\"1190\":1,\"1210\":1,\"1238\":1}}],[\"s64w8\",{\"1\":{\"1144\":1}}],[\"s方式\",{\"1\":{\"960\":1}}],[\"ssh\",{\"0\":{\"1123\":1,\"1124\":1,\"1202\":1},\"1\":{\"1124\":1,\"1202\":4,\"1203\":1}}],[\"ssl\",{\"0\":{\"1047\":1,\"1062\":1},\"1\":{\"1045\":2,\"1047\":3,\"1048\":1,\"1062\":4,\"1168\":3}}],[\"ssl的升级版\",{\"1\":{\"1044\":1}}],[\"ssm框架是spring\",{\"1\":{\"761\":1}}],[\"ssm框架\",{\"0\":{\"760\":1}}],[\"sstf\",{\"1\":{\"163\":1}}],[\"sdk\",{\"1\":{\"678\":1,\"1090\":1,\"1144\":1}}],[\"sdown\",{\"1\":{\"657\":3}}],[\"sdshdr\",{\"1\":{\"624\":1}}],[\"sds\",{\"0\":{\"624\":1},\"1\":{\"617\":5,\"624\":15}}],[\"skiplist\",{\"0\":{\"630\":1}}],[\"skiplist+hash\",{\"1\":{\"620\":1}}],[\"small\",{\"1\":{\"622\":1}}],[\"smallint\",{\"1\":{\"472\":1}}],[\"s读\",{\"1\":{\"523\":1}}],[\"s锁\",{\"1\":{\"509\":2}}],[\"snapshot<\",{\"1\":{\"795\":1,\"796\":1,\"800\":2}}],[\"snapshotting\",{\"1\":{\"647\":1}}],[\"snailclimb\",{\"1\":{\"713\":1,\"734\":1}}],[\"sn\",{\"1\":{\"449\":1}}],[\"srx8\",{\"1\":{\"1144\":1}}],[\"sr\",{\"1\":{\"277\":3}}],[\"sass\",{\"1\":{\"1139\":1,\"1210\":1}}],[\"salve\",{\"1\":{\"655\":1,\"661\":1,\"677\":1}}],[\"save和bgsave命令都可以手动触发\",{\"1\":{\"647\":1}}],[\"save\",{\"1\":{\"647\":7,\"708\":3,\"1242\":2}}],[\"savedb\",{\"1\":{\"304\":1}}],[\"safe是指\",{\"1\":{\"577\":1}}],[\"safe\",{\"1\":{\"568\":1,\"577\":3}}],[\"sayhello\",{\"1\":{\"277\":5}}],[\"satb\",{\"0\":{\"251\":1}}],[\"s系统的服务端上\",{\"1\":{\"259\":1}}],[\"something\",{\"1\":{\"1077\":2}}],[\"solution\",{\"1\":{\"933\":1,\"935\":1}}],[\"sourceservice\",{\"1\":{\"1256\":1,\"1257\":2}}],[\"source=\",{\"1\":{\"1177\":3}}],[\"source>\",{\"1\":{\"790\":1}}],[\"source3\",{\"1\":{\"423\":1,\"425\":1}}],[\"source2\",{\"1\":{\"423\":1,\"425\":1,\"1255\":2}}],[\"source1\",{\"1\":{\"423\":1,\"425\":1,\"1255\":3,\"1256\":3}}],[\"source\",{\"1\":{\"423\":1,\"425\":2,\"1144\":1,\"1249\":1}}],[\"sourcefile属性用于记录生成这个class文件的源码文件名称\",{\"1\":{\"292\":1}}],[\"sourcefile及sourcedebugextension属性\",{\"1\":{\"292\":1}}],[\"sortarray\",{\"1\":{\"935\":1}}],[\"sortprocess\",{\"1\":{\"934\":4}}],[\"sortedset\",{\"1\":{\"620\":1}}],[\"sorted\",{\"0\":{\"620\":1}}],[\"sort\",{\"0\":{\"938\":1},\"1\":{\"390\":2,\"484\":7,\"933\":1,\"935\":4,\"938\":1,\"1177\":1}}],[\"soft\",{\"1\":{\"871\":1}}],[\"softreference\",{\"1\":{\"235\":1}}],[\"sof\",{\"1\":{\"297\":1}}],[\"sockets\",{\"1\":{\"1047\":1}}],[\"socket\",{\"1\":{\"149\":1,\"611\":3,\"612\":8,\"613\":3,\"685\":1,\"804\":1,\"1062\":1}}],[\"sbin\",{\"1\":{\"416\":1,\"837\":1}}],[\"sb是一个方法内部变量\",{\"1\":{\"202\":1}}],[\"sb\",{\"1\":{\"202\":8}}],[\"s2\",{\"1\":{\"202\":4}}],[\"s1\",{\"1\":{\"202\":4}}],[\"s\",{\"1\":{\"197\":1,\"426\":2,\"449\":2,\"500\":1,\"501\":1,\"509\":2,\"514\":3,\"523\":1,\"733\":2,\"736\":1,\"818\":2,\"823\":1,\"834\":1,\"837\":1,\"850\":2,\"952\":2,\"1012\":3,\"1190\":1,\"1260\":2,\"1261\":4}}],[\"such\",{\"1\":{\"1144\":1,\"1168\":1}}],[\"support\",{\"1\":{\"1148\":1}}],[\"supported\",{\"1\":{\"740\":1}}],[\"supports\",{\"1\":{\"740\":1}}],[\"superresolution\",{\"1\":{\"1144\":2}}],[\"supervisor\",{\"1\":{\"674\":1}}],[\"super\",{\"0\":{\"364\":1},\"1\":{\"345\":2,\"355\":1,\"364\":5}}],[\"summit\",{\"1\":{\"687\":2,\"696\":1}}],[\"subcribe\",{\"1\":{\"673\":1}}],[\"subscribe\",{\"1\":{\"673\":1}}],[\"sub\",{\"1\":{\"673\":3,\"1090\":1}}],[\"subquery\",{\"1\":{\"556\":1}}],[\"submit\",{\"0\":{\"61\":1},\"1\":{\"61\":1}}],[\"survivorratio=8\",{\"1\":{\"322\":1}}],[\"survivor0\",{\"1\":{\"260\":1}}],[\"survivor区\",{\"1\":{\"242\":1}}],[\"survivor区的存活对象会被复制到to\",{\"1\":{\"242\":1}}],[\"survivor\",{\"1\":{\"200\":1}}],[\"sunyuan0627\",{\"1\":{\"1143\":1}}],[\"sunion\",{\"1\":{\"678\":1}}],[\"sun的解释器是用c实现的\",{\"1\":{\"197\":1}}],[\"sun\",{\"1\":{\"197\":1}}],[\"slimsearchplugin\",{\"1\":{\"1209\":1}}],[\"slimsearch\",{\"1\":{\"1139\":1,\"1209\":1}}],[\"slow\",{\"1\":{\"557\":1,\"566\":1,\"701\":2,\"1177\":3}}],[\"slot被复用之前\",{\"1\":{\"192\":1}}],[\"slot\",{\"1\":{\"192\":1,\"301\":2,\"659\":3,\"660\":1,\"678\":4,\"682\":1,\"684\":1}}],[\"slaves\",{\"1\":{\"656\":2}}],[\"slave\",{\"1\":{\"582\":2,\"655\":12,\"656\":7,\"657\":5,\"659\":5,\"660\":2,\"661\":8,\"662\":8,\"675\":2,\"676\":2,\"677\":6,\"678\":4,\"683\":5}}],[\"slaver\",{\"1\":{\"469\":1,\"580\":1}}],[\"slateslot\",{\"1\":{\"301\":1}}],[\"sl\",{\"1\":{\"443\":1}}],[\"sleep\",{\"0\":{\"35\":1,\"37\":1},\"1\":{\"35\":5,\"37\":2,\"38\":1,\"98\":1,\"144\":1}}],[\"scss\",{\"1\":{\"1210\":2}}],[\"script\",{\"0\":{\"1162\":1},\"1\":{\"1161\":1}}],[\"sc\",{\"1\":{\"736\":2,\"951\":4,\"952\":3,\"953\":5,\"954\":6}}],[\"scope\",{\"1\":{\"713\":1,\"734\":2}}],[\"scope=\",{\"1\":{\"713\":1,\"734\":1}}],[\"scoped>\",{\"1\":{\"24\":1}}],[\"scoped\",{\"0\":{\"24\":1},\"1\":{\"24\":1}}],[\"score\",{\"1\":{\"620\":2,\"630\":2,\"703\":3}}],[\"scavenge加parallel\",{\"1\":{\"258\":1}}],[\"scavenge收集器的老年代版本\",{\"1\":{\"258\":1}}],[\"scavenge收集器的目标则是达到一个可控制的吞吐量\",{\"1\":{\"257\":1}}],[\"scavenge收集器提供了两个参数用于精确控制吞吐量\",{\"1\":{\"257\":1}}],[\"scavenge收集器搭配使用\",{\"1\":{\"256\":1}}],[\"scavenge收集器是基于标记\",{\"1\":{\"246\":1}}],[\"scavenge\",{\"0\":{\"257\":1},\"1\":{\"252\":1}}],[\"scanner类默认的分隔符就是空格\",{\"1\":{\"951\":1}}],[\"scanner\",{\"1\":{\"951\":3,\"952\":2,\"953\":3,\"954\":2,\"955\":5}}],[\"scan\",{\"1\":{\"163\":1}}],[\"sjf\",{\"1\":{\"150\":1}}],[\"swinir\",{\"1\":{\"1144\":4}}],[\"switch\",{\"1\":{\"144\":2,\"1088\":1,\"1261\":2}}],[\"sw\",{\"1\":{\"481\":2}}],[\"sweep\",{\"1\":{\"259\":1}}],[\"swap\",{\"0\":{\"105\":1},\"1\":{\"931\":2,\"932\":2,\"933\":2,\"935\":3,\"937\":5}}],[\"shellsort\",{\"1\":{\"933\":2}}],[\"shenandoah使用转发指针和读屏障来实现并发整理\",{\"1\":{\"267\":1}}],[\"shenandoah像是g1的下一代继承者\",{\"1\":{\"267\":1}}],[\"shenandoah是第一款不由oracle开发的\",{\"1\":{\"267\":1}}],[\"shenandoah采用原始快照的方式\",{\"1\":{\"251\":1}}],[\"shenandoah\",{\"0\":{\"267\":1},\"1\":{\"249\":1}}],[\"sharding\",{\"1\":{\"586\":1,\"678\":1}}],[\"share\",{\"0\":{\"115\":1},\"1\":{\"416\":1,\"418\":3,\"500\":1,\"501\":1,\"509\":1,\"514\":1,\"559\":1}}],[\"show\",{\"0\":{\"558\":1},\"1\":{\"449\":3,\"450\":1,\"452\":1,\"459\":1,\"527\":1,\"557\":3,\"558\":2,\"700\":1,\"701\":1,\"1143\":1}}],[\"shortstat\",{\"1\":{\"449\":1}}],[\"shortlog\",{\"1\":{\"449\":1}}],[\"short\",{\"1\":{\"368\":1,\"1190\":1}}],[\"sh中添加类似如下配置\",{\"1\":{\"317\":1}}],[\"shutdownnow\",{\"1\":{\"59\":3}}],[\"shutdown\",{\"1\":{\"59\":4,\"63\":1,\"647\":1}}],[\"simple\",{\"1\":{\"1143\":1,\"1184\":1}}],[\"simplefactory\",{\"1\":{\"1077\":6}}],[\"simplie\",{\"1\":{\"556\":1}}],[\"size>60\",{\"1\":{\"938\":1}}],[\"size<60\",{\"1\":{\"938\":1}}],[\"size设置的过大\",{\"1\":{\"645\":1}}],[\"sizemask\",{\"1\":{\"623\":2}}],[\"size用于控制单个线程内binlog\",{\"1\":{\"571\":1}}],[\"size\",{\"0\":{\"404\":1},\"1\":{\"129\":1,\"297\":1,\"498\":1,\"565\":1,\"568\":1,\"623\":2,\"708\":1,\"937\":8,\"956\":1,\"982\":1,\"1144\":1,\"1177\":7}}],[\"signal\",{\"1\":{\"111\":3,\"126\":2,\"149\":1}}],[\"singletonenum\",{\"1\":{\"1070\":3}}],[\"singletonholder\",{\"1\":{\"1069\":2}}],[\"singleton与prototype的区别\",{\"1\":{\"713\":1,\"734\":1}}],[\"singleton\",{\"1\":{\"101\":9,\"713\":2,\"714\":1,\"734\":3,\"1066\":11,\"1067\":17,\"1068\":12,\"1069\":6}}],[\"specified\",{\"1\":{\"1266\":1}}],[\"sp11b\",{\"1\":{\"1261\":2}}],[\"sp11a\",{\"1\":{\"1261\":2}}],[\"sp11enum==null\",{\"1\":{\"1261\":1}}],[\"sp11enum\",{\"1\":{\"1261\":3}}],[\"sp11enumeration<string>\",{\"1\":{\"1261\":1}}],[\"sp11enunm\",{\"1\":{\"1261\":4}}],[\"sp11\",{\"0\":{\"1259\":1},\"1\":{\"1249\":1,\"1259\":2,\"1261\":6}}],[\"split\",{\"1\":{\"952\":1,\"955\":1}}],[\"space\",{\"1\":{\"200\":1}}],[\"span>0\",{\"1\":{\"96\":1}}],[\"span>\",{\"1\":{\"58\":1,\"118\":1,\"131\":1}}],[\"spingboot是否可以使用xml配置\",{\"0\":{\"787\":1}}],[\"spi就是提供这样的一个机制\",{\"1\":{\"185\":1}}],[\"spi\",{\"1\":{\"185\":3}}],[\"springcloud\",{\"0\":{\"815\":1},\"1\":{\"815\":1}}],[\"springconfig\",{\"1\":{\"743\":1}}],[\"spring组件扫描\",{\"1\":{\"777\":1}}],[\"springmodules\",{\"1\":{\"770\":1}}],[\"springmvc配置拦截器直接实现\",{\"1\":{\"759\":1}}],[\"springmvc的注解\",{\"1\":{\"743\":1}}],[\"springmvc\",{\"0\":{\"755\":1,\"756\":1,\"757\":1,\"758\":1},\"1\":{\"742\":1,\"761\":1,\"770\":1}}],[\"spring最重要的特征是依赖注入\",{\"1\":{\"770\":1}}],[\"spring最主要的两个特性就是aop和ioc\",{\"1\":{\"712\":1}}],[\"springframework\",{\"1\":{\"769\":1,\"790\":1}}],[\"spring提供了一种使用controlleradvice处理异常的非常有用的方法\",{\"1\":{\"791\":1}}],[\"spring提供了一个扩展的切口\",{\"1\":{\"737\":1}}],[\"spring提供的支持\",{\"1\":{\"759\":1}}],[\"spring5\",{\"1\":{\"743\":1}}],[\"spring的事务\",{\"0\":{\"738\":1}}],[\"spring的依赖注入都是发生在abstractbeanfactory的getbean里\",{\"1\":{\"713\":1}}],[\"spring容器初始化时\",{\"1\":{\"736\":1}}],[\"spring初始化时\",{\"1\":{\"736\":2}}],[\"spring上下文对实例化的bean进行配置\",{\"1\":{\"733\":1}}],[\"springaop与aspectj\",{\"0\":{\"720\":1}}],[\"spring会在适当的时候制造一个connection\",{\"1\":{\"718\":1}}],[\"spring我们就只需要告诉spring\",{\"1\":{\"718\":1}}],[\"spring来控制\",{\"1\":{\"718\":1}}],[\"springioc解决的是对象管理和对象依赖问题\",{\"1\":{\"718\":1}}],[\"spring框架的优势\",{\"0\":{\"717\":1}}],[\"spring中bean还有下面几种作用域\",{\"1\":{\"713\":1}}],[\"spring中bean的默认作用域就是singleton\",{\"1\":{\"713\":1}}],[\"spring中用到了哪些设计模式\",{\"0\":{\"711\":1}}],[\"spring使用工厂模式可以通过\",{\"1\":{\"712\":1}}],[\"springboot的jar无法被其他项目依赖\",{\"1\":{\"790\":1}}],[\"springboot的配置加载顺序\",{\"0\":{\"784\":1}}],[\"springboot项目最终打包的jar是可执行的jar\",{\"1\":{\"790\":1}}],[\"springboot打成的jar和普通的jar有什么区别\",{\"0\":{\"790\":1}}],[\"springboot推荐使用java配置而非xml配置\",{\"1\":{\"787\":1}}],[\"springboot集成mybatis的过程\",{\"0\":{\"776\":1}}],[\"springboot默认读取配置文件为application\",{\"1\":{\"775\":1}}],[\"springboot读取配置文件的方式\",{\"0\":{\"775\":1}}],[\"springbootconfiguration\",{\"1\":{\"771\":1,\"777\":1}}],[\"springbootapplication\",{\"1\":{\"771\":1,\"777\":2}}],[\"springboot有哪些优点\",{\"0\":{\"768\":1}}],[\"springboot\",{\"0\":{\"782\":1},\"1\":{\"685\":1,\"687\":1,\"770\":1,\"774\":1}}],[\"spring\",{\"0\":{\"43\":1,\"742\":1,\"774\":1,\"777\":1,\"778\":1,\"779\":1,\"780\":1,\"781\":1,\"783\":1,\"788\":2,\"1263\":1},\"1\":{\"40\":1,\"43\":2,\"349\":1,\"607\":4,\"687\":1,\"715\":1,\"717\":7,\"718\":2,\"720\":5,\"724\":1,\"725\":3,\"726\":1,\"729\":1,\"734\":2,\"735\":4,\"736\":5,\"739\":1,\"742\":6,\"754\":1,\"755\":3,\"767\":1,\"769\":3,\"770\":6,\"771\":2,\"772\":2,\"774\":7,\"776\":2,\"777\":1,\"782\":2,\"783\":2,\"788\":1,\"1117\":1}}],[\"syn攻击\",{\"0\":{\"1060\":1}}],[\"syn报文是用来同步的\",{\"1\":{\"1024\":1}}],[\"syn报文\",{\"1\":{\"1022\":1}}],[\"syn报文段不能携带数据\",{\"1\":{\"1022\":1}}],[\"syn+ack\",{\"1\":{\"1022\":2}}],[\"syn\",{\"1\":{\"1022\":1,\"1025\":2,\"1054\":2,\"1060\":14}}],[\"syn置1就表示这是一个连接请求或连接接受报文\",{\"1\":{\"1007\":1}}],[\"sync\",{\"1\":{\"563\":3,\"571\":5,\"582\":1,\"655\":2,\"656\":1,\"853\":2,\"1177\":1}}],[\"sync继承aqs提供释放资源的实现\",{\"1\":{\"95\":1}}],[\"synchronousqueue\",{\"1\":{\"56\":1,\"62\":1}}],[\"synchronizedmap\",{\"1\":{\"409\":2}}],[\"synchronized可以同时满足jmm的三大特性\",{\"1\":{\"295\":1}}],[\"synchronized关键字\",{\"1\":{\"295\":1}}],[\"synchronized\",{\"0\":{\"40\":1,\"79\":1,\"82\":1,\"83\":1,\"86\":1,\"90\":1,\"94\":1},\"1\":{\"35\":3,\"36\":1,\"38\":1,\"40\":1,\"48\":1,\"67\":1,\"68\":1,\"69\":1,\"71\":8,\"75\":2,\"79\":5,\"81\":2,\"82\":4,\"83\":1,\"85\":4,\"86\":1,\"87\":2,\"89\":1,\"94\":4,\"96\":3,\"98\":4,\"101\":1,\"102\":1,\"104\":2,\"105\":1,\"117\":1,\"126\":1,\"128\":1,\"131\":4,\"142\":1,\"144\":1,\"295\":1,\"393\":1,\"409\":3,\"410\":1,\"1067\":2,\"1068\":1}}],[\"symbolic\",{\"1\":{\"427\":2}}],[\"sysconfig\",{\"1\":{\"416\":1}}],[\"sys\",{\"1\":{\"331\":1}}],[\"system32\",{\"1\":{\"1124\":1}}],[\"systempath\",{\"1\":{\"797\":1}}],[\"system\",{\"1\":{\"31\":1,\"39\":1,\"98\":2,\"277\":3,\"797\":1,\"882\":4,\"908\":3,\"935\":1,\"951\":2,\"952\":2,\"953\":2,\"954\":1,\"955\":3,\"1082\":2,\"1090\":1}}],[\"sychronized\",{\"1\":{\"81\":1}}],[\"styles\",{\"1\":{\"1210\":2}}],[\"style\",{\"1\":{\"1210\":1}}],[\"style=\",{\"1\":{\"58\":1,\"96\":1,\"118\":1,\"131\":1}}],[\"studio\",{\"0\":{\"1149\":1},\"1\":{\"1144\":1,\"1148\":1}}],[\"student\",{\"1\":{\"1100\":1}}],[\"sticky\",{\"1\":{\"1052\":1}}],[\"stdm帧不是固定分配时隙\",{\"1\":{\"967\":1}}],[\"stmt\",{\"1\":{\"745\":2}}],[\"st\",{\"1\":{\"703\":1}}],[\"stream\",{\"1\":{\"1260\":1}}],[\"strategy\",{\"1\":{\"1088\":2}}],[\"strs\",{\"1\":{\"952\":2}}],[\"str\",{\"1\":{\"952\":2,\"955\":2}}],[\"strcat\",{\"1\":{\"624\":1}}],[\"struct\",{\"1\":{\"624\":1}}],[\"strong\",{\"1\":{\"239\":1}}],[\"strongreference\",{\"1\":{\"235\":1}}],[\"stringutils\",{\"1\":{\"1261\":1}}],[\"stringserializer\",{\"1\":{\"867\":1}}],[\"stringtable为什么要调整\",{\"0\":{\"207\":1}}],[\"stringbuffer\",{\"0\":{\"371\":1},\"1\":{\"202\":7}}],[\"string\",{\"0\":{\"367\":1,\"369\":1,\"370\":1,\"617\":1},\"1\":{\"31\":1,\"39\":1,\"98\":1,\"182\":2,\"183\":1,\"184\":1,\"202\":5,\"227\":2,\"234\":1,\"277\":1,\"304\":1,\"345\":1,\"367\":1,\"369\":6,\"616\":1,\"617\":1,\"622\":1,\"637\":1,\"733\":2,\"745\":1,\"755\":1,\"935\":1,\"951\":1,\"952\":4,\"953\":2,\"955\":3,\"956\":1,\"1077\":2,\"1082\":1,\"1091\":1,\"1188\":2,\"1231\":1,\"1260\":2,\"1261\":8}}],[\"step5\",{\"0\":{\"223\":1}}],[\"step4\",{\"0\":{\"222\":1}}],[\"step3\",{\"0\":{\"173\":1,\"221\":1}}],[\"step2\",{\"0\":{\"169\":1,\"215\":1}}],[\"step1\",{\"0\":{\"168\":1,\"214\":1}}],[\"storage\",{\"1\":{\"1177\":1}}],[\"store\",{\"1\":{\"71\":1,\"72\":8,\"73\":2,\"74\":2,\"294\":1,\"295\":1}}],[\"stop\",{\"1\":{\"59\":1,\"63\":1,\"254\":1,\"255\":1,\"259\":1,\"459\":1,\"774\":1,\"1177\":1}}],[\"star\",{\"1\":{\"688\":1}}],[\"starter<\",{\"1\":{\"776\":1}}],[\"starter\",{\"0\":{\"779\":1},\"1\":{\"772\":1,\"778\":1,\"789\":1}}],[\"starter相当于模块\",{\"1\":{\"772\":1}}],[\"starter是spring\",{\"1\":{\"772\":1}}],[\"starters自动依赖与版本控制\",{\"1\":{\"768\":1}}],[\"start用来设置堆空间的初始内存大小和\",{\"1\":{\"199\":1}}],[\"start\",{\"0\":{\"34\":1},\"1\":{\"31\":3,\"34\":1,\"75\":1,\"98\":2,\"102\":2,\"459\":1,\"526\":1,\"774\":1}}],[\"standby\",{\"1\":{\"660\":1,\"678\":1}}],[\"stash\",{\"1\":{\"453\":2}}],[\"stage\",{\"1\":{\"444\":1,\"1121\":1}}],[\"staleslot\",{\"1\":{\"301\":3}}],[\"stack2\",{\"1\":{\"908\":2}}],[\"stack1\",{\"1\":{\"908\":2}}],[\"stack=new\",{\"1\":{\"908\":1}}],[\"stack<treenode>\",{\"1\":{\"908\":5}}],[\"stack<t>\",{\"1\":{\"394\":2}}],[\"stack<>\",{\"1\":{\"394\":1,\"908\":5}}],[\"stackoverflowerror\",{\"1\":{\"384\":1}}],[\"stackoverflow\",{\"0\":{\"297\":1}}],[\"stack中登记native方法\",{\"1\":{\"197\":1}}],[\"stacks\",{\"1\":{\"197\":1}}],[\"stacks数据项中设定的最大值\",{\"1\":{\"193\":1}}],[\"stacks数据项之中\",{\"1\":{\"193\":1}}],[\"stack\",{\"0\":{\"394\":1},\"1\":{\"193\":1,\"394\":2,\"908\":14,\"955\":1,\"956\":1}}],[\"station\",{\"1\":{\"1082\":2}}],[\"staticdispatch\",{\"1\":{\"277\":3}}],[\"static\",{\"0\":{\"352\":1,\"358\":1,\"360\":1},\"1\":{\"31\":1,\"39\":1,\"98\":3,\"101\":2,\"171\":1,\"173\":1,\"202\":2,\"227\":1,\"277\":3,\"304\":1,\"349\":1,\"352\":3,\"358\":3,\"360\":2,\"362\":2,\"368\":1,\"404\":1,\"405\":1,\"730\":1,\"930\":1,\"931\":2,\"932\":2,\"933\":1,\"934\":3,\"935\":2,\"937\":4,\"951\":1,\"952\":1,\"953\":1,\"955\":2,\"956\":1,\"1066\":5,\"1067\":6,\"1068\":2,\"1069\":3,\"1070\":2,\"1077\":2,\"1082\":1,\"1260\":2,\"1261\":2}}],[\"stat\",{\"1\":{\"449\":1,\"823\":1}}],[\"status\",{\"1\":{\"449\":2,\"700\":1,\"1126\":1}}],[\"statement无法完成主从复制的操作\",{\"1\":{\"572\":1}}],[\"statement\",{\"0\":{\"745\":1},\"1\":{\"566\":2,\"572\":1,\"745\":3,\"746\":1}}],[\"statement和resultset进行显式关闭\",{\"1\":{\"304\":1}}],[\"stateoffset\",{\"1\":{\"110\":1}}],[\"state可用于记录共享线程的数量\",{\"1\":{\"110\":1,\"111\":1}}],[\"state状态\",{\"1\":{\"96\":1}}],[\"state<\",{\"1\":{\"96\":1}}],[\"state\",{\"1\":{\"78\":1,\"81\":1,\"96\":1,\"109\":1,\"110\":3,\"111\":1,\"114\":1,\"115\":1,\"118\":6,\"125\":1,\"871\":1,\"878\":1,\"1271\":1}}],[\"sever\",{\"1\":{\"1240\":1}}],[\"sevlet\",{\"1\":{\"825\":1}}],[\"semantic\",{\"1\":{\"1206\":1}}],[\"semaphore\",{\"0\":{\"117\":1},\"1\":{\"109\":1,\"115\":3,\"117\":4,\"142\":1,\"149\":1}}],[\"semver\",{\"1\":{\"1140\":1}}],[\"sell\",{\"1\":{\"1082\":5,\"1083\":1,\"1084\":1}}],[\"selltickets\",{\"1\":{\"1082\":3,\"1083\":1}}],[\"selectxxx\",{\"1\":{\"1117\":1}}],[\"selective\",{\"1\":{\"1013\":1}}],[\"selectsort\",{\"1\":{\"931\":1}}],[\"select模型之上\",{\"1\":{\"829\":1}}],[\"select模型\",{\"1\":{\"829\":2}}],[\"select\",{\"1\":{\"381\":5,\"480\":1,\"481\":3,\"482\":2,\"484\":1,\"485\":4,\"486\":5,\"487\":1,\"490\":2,\"499\":1,\"500\":2,\"501\":4,\"509\":2,\"514\":2,\"517\":2,\"523\":1,\"537\":1,\"553\":1,\"555\":1,\"556\":3,\"559\":3,\"560\":1,\"601\":1,\"612\":3,\"703\":2,\"745\":2,\"807\":1,\"1119\":2}}],[\"selector\",{\"1\":{\"24\":2,\"377\":1,\"380\":1}}],[\"sent\",{\"1\":{\"1022\":1}}],[\"sentinel\",{\"0\":{\"676\":1},\"1\":{\"642\":2,\"657\":14,\"676\":8,\"677\":14}}],[\"sequence\",{\"1\":{\"1271\":1}}],[\"seq\",{\"1\":{\"1004\":3}}],[\"seqnumber>做缓存\",{\"1\":{\"856\":1}}],[\"segament\",{\"1\":{\"410\":4}}],[\"segment\",{\"0\":{\"848\":1},\"1\":{\"128\":4,\"129\":11,\"130\":2,\"982\":1,\"1027\":1}}],[\"servletrequest\",{\"1\":{\"1090\":2}}],[\"servlet\",{\"1\":{\"825\":1}}],[\"servletsession\",{\"1\":{\"759\":1}}],[\"servlet提供的支持\",{\"1\":{\"759\":1}}],[\"servletcontextlistener抽象接口\",{\"1\":{\"759\":1}}],[\"servletcontext\",{\"1\":{\"736\":3,\"759\":1}}],[\"serverside\",{\"1\":{\"1206\":1}}],[\"serversocket\",{\"1\":{\"377\":1}}],[\"server端都只会持久化一条数据\",{\"1\":{\"856\":1}}],[\"server层面进行的\",{\"1\":{\"501\":1}}],[\"server\",{\"0\":{\"490\":1},\"1\":{\"255\":1,\"452\":1,\"457\":1,\"488\":2,\"603\":1,\"661\":2,\"673\":3,\"801\":2,\"825\":8,\"1038\":1,\"1177\":2}}],[\"service层这两个层次都可以单独开发\",{\"1\":{\"766\":1}}],[\"service层又要在controller层之下\",{\"1\":{\"763\":1}}],[\"service层主要负责业务模块的逻辑应用设计\",{\"1\":{\"763\":1}}],[\"service层\",{\"0\":{\"763\":1}}],[\"services中的配置信息\",{\"1\":{\"185\":1}}],[\"services文件夹查找文件\",{\"1\":{\"185\":1}}],[\"serviceloader类\",{\"1\":{\"185\":1}}],[\"service\",{\"1\":{\"185\":2,\"735\":1,\"736\":1,\"743\":1,\"959\":1,\"1029\":1}}],[\"serializable\",{\"1\":{\"344\":1,\"392\":2,\"408\":1,\"522\":2,\"741\":1}}],[\"serial收集器\",{\"0\":{\"254\":1}}],[\"serial语义的意思是\",{\"1\":{\"76\":1}}],[\"serial\",{\"0\":{\"76\":1,\"77\":1,\"256\":1},\"1\":{\"76\":3,\"77\":1,\"216\":1,\"254\":2,\"255\":1,\"256\":1}}],[\"security\",{\"1\":{\"1062\":1}}],[\"security依赖项\",{\"1\":{\"789\":1}}],[\"secure\",{\"1\":{\"1047\":1,\"1062\":1}}],[\"second\",{\"1\":{\"449\":1}}],[\"seconds自动释放锁\",{\"1\":{\"669\":1}}],[\"seconds\",{\"1\":{\"59\":1}}],[\"section\",{\"1\":{\"142\":1}}],[\"setting\",{\"1\":{\"1202\":1}}],[\"settings\",{\"1\":{\"1199\":1,\"1200\":1}}],[\"setter\",{\"1\":{\"355\":1,\"730\":5}}],[\"setup>\",{\"1\":{\"1162\":1}}],[\"setup\",{\"0\":{\"1162\":1},\"1\":{\"1148\":1,\"1161\":1}}],[\"set1\",{\"1\":{\"1144\":2}}],[\"setint\",{\"1\":{\"745\":1}}],[\"setapplicationcontext\",{\"1\":{\"733\":1}}],[\"setbeanfactory同样作用\",{\"1\":{\"733\":1}}],[\"setbeanfactory\",{\"1\":{\"733\":2}}],[\"setcallback\",{\"1\":{\"726\":1}}],[\"setnx\",{\"1\":{\"603\":1,\"668\":2,\"669\":1,\"807\":1}}],[\"setstring\",{\"1\":{\"745\":1}}],[\"setstate\",{\"1\":{\"96\":2,\"110\":2}}],[\"setsuperclass\",{\"1\":{\"726\":1}}],[\"setsize\",{\"1\":{\"381\":1}}],[\"setexclusiveownerthread\",{\"1\":{\"96\":1}}],[\"set\",{\"0\":{\"619\":1,\"620\":1},\"1\":{\"39\":2,\"46\":1,\"299\":1,\"300\":1,\"317\":1,\"342\":1,\"348\":1,\"355\":1,\"388\":1,\"391\":1,\"393\":1,\"451\":1,\"489\":1,\"526\":3,\"557\":2,\"559\":1,\"603\":1,\"610\":1,\"616\":1,\"619\":4,\"625\":1,\"632\":1,\"637\":3,\"642\":1,\"669\":1,\"701\":1,\"705\":2,\"729\":1,\"823\":1,\"853\":1,\"891\":1,\"896\":2,\"1038\":1,\"1143\":2,\"1177\":1}}],[\"session无法跨域\",{\"1\":{\"1052\":1}}],[\"session有一个缺陷\",{\"1\":{\"1052\":1}}],[\"session相当于程序在服务器上建立的一份客户档案\",{\"1\":{\"1052\":1}}],[\"session是另一种记录客户状态的机制\",{\"1\":{\"1052\":1}}],[\"session内有效\",{\"1\":{\"713\":1}}],[\"session\",{\"0\":{\"1050\":1,\"1052\":1},\"1\":{\"39\":2,\"44\":2,\"559\":3,\"562\":1,\"713\":1,\"734\":3,\"1050\":1}}],[\"search扫描整个字符串并返回第一个成功的匹配\",{\"1\":{\"1189\":1}}],[\"search<\",{\"1\":{\"795\":2,\"796\":2,\"800\":4}}],[\"search\",{\"0\":{\"1189\":1},\"1\":{\"26\":1,\"911\":1}}],[\"sqlsession\",{\"1\":{\"752\":3}}],[\"sql生成和statement创建\",{\"1\":{\"748\":1}}],[\"sql预编译是指数据库驱动在发送sql语句和参数给dbms之前会对sql语句进行编译\",{\"1\":{\"597\":1}}],[\"sql预编译\",{\"0\":{\"597\":1}}],[\"sql占位符替换字符串时会带上单引号\",{\"1\":{\"596\":1}}],[\"sql注入攻击指的是通过构建特殊的输入作为参数传入web应用程序\",{\"1\":{\"595\":1}}],[\"sql注入\",{\"0\":{\"595\":1}}],[\"sql效率低\",{\"1\":{\"584\":1}}],[\"sql优化\",{\"1\":{\"584\":1}}],[\"sql问题\",{\"1\":{\"584\":1}}],[\"sql写法优化\",{\"1\":{\"564\":1}}],[\"sql的性能瓶颈\",{\"1\":{\"558\":1}}],[\"sql会走聚簇索引的全扫描进行过滤\",{\"1\":{\"501\":1}}],[\"sql是需要在id\",{\"1\":{\"501\":2}}],[\"sql语句类型\",{\"1\":{\"483\":1}}],[\"sql约束有哪几种\",{\"0\":{\"460\":1}}],[\"sql\",{\"0\":{\"13\":1,\"457\":1,\"489\":1,\"560\":1,\"701\":1,\"703\":1,\"1118\":1},\"1\":{\"456\":1,\"457\":2,\"461\":4,\"470\":1,\"489\":3,\"490\":4,\"499\":2,\"501\":3,\"503\":1,\"516\":6,\"518\":1,\"524\":1,\"528\":1,\"557\":4,\"558\":6,\"559\":3,\"560\":3,\"561\":1,\"562\":3,\"566\":4,\"581\":1,\"582\":5,\"596\":4,\"597\":2,\"606\":1,\"643\":1,\"744\":1,\"745\":8,\"746\":10,\"749\":6,\"750\":4,\"753\":2}}],[\"28000\",{\"1\":{\"1178\":1}}],[\"2核服务器建议4\",{\"1\":{\"1177\":1}}],[\"2时续约失败\",{\"1\":{\"1049\":1}}],[\"2时\",{\"1\":{\"1049\":1}}],[\"2进行了二进制分帧\",{\"1\":{\"1042\":1}}],[\"2连接请求发起多重请求\",{\"1\":{\"1042\":1}}],[\"2xx\",{\"1\":{\"1040\":1}}],[\"2x版本开始\",{\"1\":{\"498\":1}}],[\"23\",{\"1\":{\"1038\":1}}],[\"2m\",{\"1\":{\"1177\":2}}],[\"2msl\",{\"1\":{\"1026\":1,\"1027\":1}}],[\"2mb\",{\"1\":{\"717\":1}}],[\"2=8\",{\"1\":{\"1019\":1}}],[\"2f\",{\"1\":{\"953\":1}}],[\"26\",{\"1\":{\"952\":1}}],[\"26208\",{\"1\":{\"539\":1}}],[\"2i+2\",{\"1\":{\"937\":1}}],[\"2i+1\",{\"1\":{\"937\":1}}],[\"2g\",{\"1\":{\"895\":1}}],[\"2表示出现2次及以上\",{\"1\":{\"883\":1}}],[\"2+1\",{\"1\":{\"877\":1,\"900\":1}}],[\"2<\",{\"1\":{\"776\":1}}],[\"2n+1\",{\"1\":{\"676\":1}}],[\"2s\",{\"1\":{\"672\":1}}],[\"2的\",{\"1\":{\"539\":1}}],[\"29\",{\"1\":{\"533\":2,\"612\":2}}],[\"22\",{\"0\":{\"1124\":1},\"1\":{\"475\":1,\"565\":2}}],[\"24\",{\"1\":{\"452\":1,\"472\":1}}],[\"2147483648~2147483647\",{\"1\":{\"405\":1}}],[\"2^32^4byte\",{\"1\":{\"901\":1}}],[\"2^32=4g\",{\"1\":{\"892\":1}}],[\"2^32\",{\"1\":{\"681\":1,\"880\":3,\"996\":1}}],[\"2^32bit\",{\"1\":{\"901\":1}}],[\"2^32b\",{\"1\":{\"156\":1}}],[\"2^n\",{\"1\":{\"404\":1,\"623\":2}}],[\"25ms\",{\"1\":{\"840\":1}}],[\"253\",{\"1\":{\"628\":1}}],[\"250\",{\"1\":{\"628\":2}}],[\"254\",{\"1\":{\"627\":2,\"628\":3}}],[\"255字节\",{\"0\":{\"893\":1}}],[\"255\",{\"1\":{\"476\":1}}],[\"25\",{\"1\":{\"399\":1}}],[\"2加入\",{\"1\":{\"185\":1}}],[\"20250106\",{\"0\":{\"1206\":1}}],[\"2023\",{\"1\":{\"687\":1}}],[\"2014\",{\"1\":{\"533\":2}}],[\"20gb\",{\"1\":{\"525\":1}}],[\"2038\",{\"1\":{\"475\":1}}],[\"200\",{\"1\":{\"1038\":1,\"1040\":1}}],[\"200gb\",{\"1\":{\"525\":1}}],[\"2008\",{\"1\":{\"475\":1}}],[\"200m\",{\"1\":{\"411\":1}}],[\"2000\",{\"1\":{\"98\":1,\"262\":1}}],[\"2048\",{\"1\":{\"381\":1,\"836\":1}}],[\"20\",{\"0\":{\"478\":1},\"1\":{\"88\":2,\"478\":1,\"559\":1,\"606\":1,\"632\":2,\"804\":1,\"982\":2}}],[\"2\",{\"0\":{\"22\":1,\"23\":1,\"24\":2,\"226\":1,\"230\":1,\"278\":1,\"308\":1,\"377\":1,\"384\":1,\"389\":1,\"404\":1,\"830\":1,\"893\":1,\"901\":1,\"918\":2,\"947\":1,\"1042\":1,\"1097\":1,\"1125\":1,\"1131\":1,\"1141\":1,\"1149\":1,\"1150\":1,\"1151\":2,\"1152\":1,\"1158\":1,\"1183\":1,\"1184\":1,\"1185\":2,\"1187\":1,\"1188\":1,\"1189\":2,\"1190\":1,\"1198\":1,\"1201\":1,\"1202\":1,\"1203\":2,\"1210\":1,\"1217\":1,\"1218\":1,\"1219\":2,\"1222\":1,\"1224\":1,\"1225\":1,\"1226\":2,\"1227\":1,\"1229\":1,\"1237\":1,\"1238\":1,\"1239\":2,\"1240\":2,\"1243\":1,\"1246\":1,\"1252\":1,\"1256\":1,\"1258\":1,\"1259\":1,\"1260\":1,\"1261\":2,\"1270\":1,\"1271\":1,\"1274\":1},\"1\":{\"57\":1,\"85\":4,\"98\":2,\"101\":4,\"111\":1,\"137\":3,\"198\":1,\"227\":1,\"235\":1,\"237\":1,\"284\":1,\"304\":1,\"350\":2,\"367\":1,\"383\":1,\"399\":1,\"404\":1,\"405\":2,\"407\":2,\"411\":1,\"426\":1,\"433\":1,\"485\":1,\"490\":1,\"531\":1,\"532\":1,\"541\":1,\"543\":1,\"553\":1,\"563\":1,\"568\":1,\"607\":1,\"615\":5,\"618\":2,\"623\":1,\"626\":1,\"632\":1,\"651\":1,\"653\":1,\"655\":1,\"660\":1,\"663\":2,\"665\":3,\"668\":1,\"672\":1,\"716\":1,\"745\":1,\"759\":1,\"770\":1,\"774\":1,\"778\":1,\"781\":1,\"782\":1,\"819\":1,\"820\":13,\"822\":1,\"836\":3,\"882\":3,\"883\":1,\"884\":2,\"886\":1,\"888\":4,\"900\":2,\"901\":2,\"911\":1,\"912\":1,\"913\":1,\"918\":2,\"919\":3,\"921\":9,\"930\":2,\"931\":4,\"932\":1,\"933\":4,\"934\":1,\"935\":3,\"936\":1,\"937\":8,\"938\":1,\"943\":2,\"948\":1,\"951\":1,\"952\":1,\"953\":2,\"955\":2,\"956\":5,\"961\":1,\"968\":1,\"975\":1,\"979\":1,\"986\":1,\"1019\":1,\"1042\":3,\"1066\":2,\"1077\":2,\"1139\":5,\"1140\":2,\"1148\":2,\"1150\":1,\"1162\":1,\"1167\":1,\"1170\":4,\"1177\":2,\"1184\":1,\"1212\":1}}],[\"17\",{\"1\":{\"1139\":1}}],[\"17ms\",{\"1\":{\"543\":1}}],[\"1的header带有大量信息\",{\"1\":{\"1042\":1}}],[\"1版本还引入了管道机制\",{\"1\":{\"1042\":1}}],[\"1版本中的持续连接就弥补了这个缺点\",{\"1\":{\"1042\":1}}],[\"1xx\",{\"1\":{\"1040\":1}}],[\"130181974\",{\"1\":{\"1143\":1}}],[\"13\",{\"1\":{\"1038\":1,\"1094\":1,\"1139\":1,\"1140\":1,\"1148\":1,\"1212\":1}}],[\"1变0\",{\"1\":{\"974\":1}}],[\"142653359\",{\"1\":{\"1143\":1}}],[\"140\",{\"1\":{\"1124\":1}}],[\"14\",{\"1\":{\"953\":1}}],[\"1次大的循环\",{\"1\":{\"930\":1}}],[\"15\",{\"1\":{\"919\":1,\"953\":2,\"997\":1}}],[\"1501\",{\"1\":{\"1013\":1}}],[\"1500没收到\",{\"1\":{\"1013\":1}}],[\"1500\",{\"1\":{\"882\":2,\"982\":2}}],[\"150～300ms\",{\"1\":{\"879\":1}}],[\"1表示出现一次\",{\"1\":{\"883\":1}}],[\"1表示从磁盘复制到页面缓存\",{\"1\":{\"850\":1}}],[\"1个partition只能被1个consumer消费\",{\"1\":{\"865\":1}}],[\"1w\",{\"1\":{\"840\":1}}],[\"1~5\",{\"1\":{\"820\":1}}],[\"1~3\",{\"1\":{\"539\":1}}],[\"1~32mb之间\",{\"1\":{\"262\":1}}],[\"1s\",{\"1\":{\"672\":1}}],[\"1m\",{\"1\":{\"671\":1,\"1177\":1}}],[\"1mb\",{\"1\":{\"610\":1}}],[\"1k\",{\"1\":{\"539\":3}}],[\"18\",{\"1\":{\"473\":2,\"1139\":2}}],[\"1=15\",{\"1\":{\"405\":1}}],[\"1gb\",{\"1\":{\"610\":1}}],[\"1g\",{\"1\":{\"381\":1}}],[\"125\",{\"1\":{\"1012\":1}}],[\"12h\",{\"1\":{\"689\":1}}],[\"120\",{\"1\":{\"543\":1}}],[\"127\",{\"1\":{\"368\":7,\"1192\":1}}],[\"128\",{\"1\":{\"368\":6,\"996\":1}}],[\"12\",{\"1\":{\"156\":1,\"399\":2,\"1038\":1}}],[\"123\",{\"1\":{\"31\":1}}],[\"16m\",{\"1\":{\"1177\":2}}],[\"16383\",{\"1\":{\"659\":3,\"680\":1}}],[\"1638\",{\"1\":{\"539\":3}}],[\"1638个指针记录\",{\"1\":{\"539\":1}}],[\"16384\",{\"1\":{\"539\":1,\"659\":1,\"679\":1,\"680\":2}}],[\"16k\",{\"1\":{\"498\":1}}],[\"16\",{\"1\":{\"125\":2,\"399\":4,\"405\":5,\"407\":1,\"472\":1,\"475\":1,\"539\":4,\"631\":1,\"680\":2}}],[\"1990\",{\"1\":{\"872\":1}}],[\"1970\",{\"1\":{\"475\":2}}],[\"19\",{\"1\":{\"88\":1,\"559\":1,\"935\":1}}],[\"113\",{\"1\":{\"1124\":1}}],[\"112\",{\"1\":{\"1038\":1}}],[\"11无意义\",{\"1\":{\"900\":1}}],[\"11版本的kafka\",{\"1\":{\"856\":1}}],[\"11版本的kafka之前\",{\"1\":{\"856\":1}}],[\"11\",{\"1\":{\"84\":1,\"407\":1,\"472\":1,\"501\":1,\"565\":2}}],[\"1045\",{\"1\":{\"1178\":1}}],[\"101\",{\"1\":{\"1040\":1}}],[\"1010101010\",{\"1\":{\"335\":1}}],[\"1023\",{\"1\":{\"1000\":1}}],[\"1024\",{\"1\":{\"156\":4,\"381\":1,\"836\":3,\"892\":2,\"1000\":1}}],[\"10保持不变\",{\"1\":{\"900\":1}}],[\"10表示多次\",{\"1\":{\"900\":1}}],[\"10表示10个消费者各自读取一次页面缓存\",{\"1\":{\"850\":1}}],[\"10的结果将\",{\"1\":{\"895\":1}}],[\"10的这个记录上\",{\"1\":{\"501\":2}}],[\"10=40次\",{\"1\":{\"850\":1}}],[\"10w\",{\"1\":{\"840\":1}}],[\"10s\",{\"1\":{\"517\":1,\"566\":1}}],[\"10这条记录上加x锁即可\",{\"1\":{\"501\":2}}],[\"10765\",{\"1\":{\"201\":1}}],[\"10\",{\"0\":{\"414\":1,\"476\":2,\"478\":1},\"1\":{\"84\":1,\"156\":2,\"381\":1,\"404\":1,\"428\":1,\"476\":3,\"477\":2,\"478\":4,\"486\":1,\"501\":5,\"517\":1,\"539\":2,\"623\":1,\"657\":2,\"677\":1,\"703\":1,\"708\":1,\"804\":1,\"893\":2,\"919\":2,\"935\":1,\"951\":1,\"952\":1,\"1028\":1,\"1144\":1,\"1162\":1,\"1168\":1}}],[\"100个\",{\"1\":{\"891\":1}}],[\"100就够了\",{\"1\":{\"651\":1}}],[\"100~1000\",{\"1\":{\"563\":1,\"571\":1}}],[\"1000收到了\",{\"1\":{\"1013\":1}}],[\"1000万字符串\",{\"1\":{\"890\":1}}],[\"10000\",{\"1\":{\"708\":1,\"745\":1}}],[\"10000~20000的分到第二个库\",{\"1\":{\"587\":1}}],[\"100001\",{\"1\":{\"559\":2}}],[\"1000001\",{\"1\":{\"486\":1}}],[\"1000000\",{\"1\":{\"486\":1}}],[\"100000\",{\"1\":{\"486\":1}}],[\"1000\",{\"1\":{\"475\":1,\"484\":3,\"486\":1,\"660\":1,\"678\":1,\"896\":1,\"919\":1}}],[\"100w个数中找最大的前100个数\",{\"1\":{\"885\":1}}],[\"100w\",{\"1\":{\"464\":1}}],[\"100ms\",{\"1\":{\"632\":1}}],[\"100m\",{\"1\":{\"411\":1}}],[\"1001000\",{\"1\":{\"486\":1}}],[\"1001\",{\"1\":{\"227\":1,\"919\":1,\"1013\":1}}],[\"100\",{\"1\":{\"46\":1,\"368\":2,\"481\":2,\"486\":3,\"642\":1,\"651\":2,\"882\":1,\"951\":1,\"1177\":1}}],[\"1+n\",{\"1\":{\"310\":1}}],[\"1+\",{\"1\":{\"57\":1}}],[\"1\",{\"0\":{\"21\":1,\"23\":1,\"225\":1,\"229\":1,\"277\":1,\"307\":1,\"376\":1,\"383\":1,\"388\":1,\"829\":1,\"892\":1,\"900\":1,\"902\":1,\"946\":1,\"948\":1,\"1042\":3,\"1096\":1,\"1109\":1,\"1110\":2,\"1111\":3,\"1122\":1,\"1130\":1,\"1134\":1,\"1139\":1,\"1140\":2,\"1147\":1,\"1148\":2,\"1149\":1,\"1150\":2,\"1151\":1,\"1152\":1,\"1154\":1,\"1181\":1,\"1182\":2,\"1183\":1,\"1184\":2,\"1185\":1,\"1186\":1,\"1188\":1,\"1196\":1,\"1197\":2,\"1198\":1,\"1199\":1,\"1200\":1,\"1202\":1,\"1209\":1,\"1215\":1,\"1216\":2,\"1217\":1,\"1218\":2,\"1219\":1,\"1220\":1,\"1221\":2,\"1222\":1,\"1223\":1,\"1225\":1,\"1236\":1,\"1238\":1,\"1240\":1,\"1242\":1,\"1245\":1,\"1250\":1,\"1251\":2,\"1252\":1,\"1253\":1,\"1254\":1,\"1255\":2,\"1256\":1,\"1257\":1,\"1259\":1,\"1260\":2,\"1261\":1,\"1268\":1,\"1269\":2,\"1270\":1,\"1273\":1},\"1\":{\"56\":1,\"57\":1,\"58\":1,\"82\":2,\"85\":1,\"87\":1,\"89\":3,\"96\":2,\"98\":3,\"101\":2,\"111\":2,\"128\":2,\"130\":1,\"131\":1,\"134\":1,\"137\":2,\"151\":1,\"160\":3,\"185\":1,\"198\":1,\"199\":1,\"209\":1,\"227\":1,\"233\":2,\"235\":1,\"237\":1,\"245\":1,\"260\":1,\"304\":1,\"310\":1,\"350\":2,\"381\":2,\"383\":1,\"390\":1,\"392\":1,\"394\":2,\"401\":1,\"404\":3,\"405\":1,\"406\":5,\"407\":1,\"408\":1,\"411\":1,\"426\":1,\"433\":1,\"464\":1,\"475\":2,\"485\":1,\"486\":4,\"489\":1,\"498\":1,\"517\":6,\"523\":1,\"531\":1,\"532\":1,\"535\":2,\"537\":2,\"541\":1,\"559\":4,\"563\":1,\"568\":2,\"573\":1,\"582\":1,\"607\":1,\"612\":2,\"614\":1,\"615\":7,\"622\":1,\"623\":10,\"624\":2,\"626\":2,\"627\":2,\"628\":1,\"630\":3,\"632\":3,\"641\":1,\"645\":3,\"651\":1,\"653\":1,\"657\":3,\"659\":8,\"660\":1,\"665\":4,\"668\":2,\"672\":1,\"708\":1,\"716\":1,\"745\":1,\"770\":1,\"774\":1,\"778\":1,\"781\":1,\"782\":1,\"807\":1,\"820\":10,\"854\":2,\"856\":1,\"882\":7,\"888\":3,\"901\":2,\"911\":4,\"912\":5,\"913\":5,\"916\":1,\"919\":2,\"921\":1,\"930\":7,\"931\":13,\"932\":4,\"934\":5,\"935\":7,\"936\":2,\"937\":10,\"938\":2,\"942\":1,\"943\":1,\"946\":3,\"948\":1,\"949\":6,\"951\":4,\"952\":1,\"955\":2,\"956\":4,\"961\":1,\"968\":1,\"973\":3,\"975\":1,\"979\":1,\"986\":1,\"1012\":1,\"1013\":1,\"1026\":1,\"1038\":4,\"1042\":9,\"1066\":2,\"1077\":4,\"1139\":2,\"1140\":6,\"1148\":1,\"1162\":1,\"1177\":2,\"1192\":1,\"1212\":2}}],[\"centos\",{\"1\":{\"1167\":1}}],[\"ceil\",{\"1\":{\"919\":1}}],[\"cb\",{\"1\":{\"1144\":1}}],[\"cwnd不再进行指数级增长\",{\"1\":{\"1019\":1}}],[\"cwnd<ssthresh时\",{\"1\":{\"1019\":1}}],[\"cwnd\",{\"1\":{\"1019\":1}}],[\"c类地址以及划分子网的概念\",{\"1\":{\"991\":1}}],[\"cmake\",{\"0\":{\"1168\":1},\"1\":{\"1168\":1}}],[\"cmd\",{\"1\":{\"875\":1}}],[\"cmd>\",{\"1\":{\"875\":1,\"878\":1}}],[\"cms收集器就非常符合这类应用的需求\",{\"1\":{\"259\":1}}],[\"cms收集器\",{\"0\":{\"259\":1}}],[\"cms等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间\",{\"1\":{\"257\":1}}],[\"cmsremove了\",{\"1\":{\"252\":1}}],[\"cms是基于增量更新来做并发标记\",{\"1\":{\"251\":1}}],[\"cms会进行一次标记\",{\"1\":{\"246\":1}}],[\"cms\",{\"1\":{\"217\":1,\"255\":1,\"259\":1,\"261\":3}}],[\"c系统处理成功\",{\"1\":{\"841\":1}}],[\"ci\",{\"0\":{\"1198\":1},\"1\":{\"1177\":1}}],[\"cird把网络前缀都相同的连续的ip地址组成一个\",{\"1\":{\"991\":1}}],[\"cidr使用32位的地址掩码\",{\"1\":{\"991\":1}}],[\"cidr地址\",{\"1\":{\"991\":1}}],[\"cidr还使用斜线记法\",{\"1\":{\"991\":1}}],[\"cidr消除了传统的a\",{\"1\":{\"991\":1}}],[\"cid和c\",{\"1\":{\"751\":1}}],[\"city=\",{\"1\":{\"484\":4}}],[\"city\",{\"1\":{\"484\":9}}],[\"cglib动态代理是通过继承的方式\",{\"1\":{\"727\":1}}],[\"cglib动态代理即使被代理的类没有实现接口\",{\"1\":{\"727\":1}}],[\"cglib动态代理\",{\"0\":{\"726\":1}}],[\"cglib代理\",{\"1\":{\"724\":1}}],[\"cglib是通过继承的方式实现动态代理\",{\"1\":{\"715\":1}}],[\"cglib\",{\"0\":{\"1084\":1},\"1\":{\"715\":1,\"725\":1,\"726\":1,\"1084\":2}}],[\"ccf\",{\"1\":{\"687\":1}}],[\"c=3\",{\"1\":{\"533\":1}}],[\"c=c+1\",{\"1\":{\"489\":1,\"559\":1}}],[\"c>3\",{\"1\":{\"533\":1}}],[\"czvf\",{\"1\":{\"437\":1}}],[\"check\",{\"1\":{\"651\":1,\"1144\":1}}],[\"checkout\",{\"1\":{\"450\":1,\"451\":3,\"453\":3,\"1126\":2,\"1127\":1}}],[\"cherry\",{\"1\":{\"451\":1}}],[\"chmod\",{\"0\":{\"433\":1},\"1\":{\"433\":5}}],[\"chown\",{\"0\":{\"432\":1},\"1\":{\"432\":2}}],[\"chgrp\",{\"0\":{\"431\":1},\"1\":{\"431\":1}}],[\"change\",{\"0\":{\"574\":1},\"1\":{\"418\":1,\"555\":1,\"574\":4}}],[\"channelpool\",{\"1\":{\"804\":1}}],[\"channel退订给定的频道\",{\"1\":{\"673\":1}}],[\"channels\",{\"1\":{\"379\":1,\"1143\":3}}],[\"channel\",{\"0\":{\"379\":1},\"1\":{\"209\":1,\"377\":1,\"379\":5,\"380\":3,\"673\":5,\"804\":3,\"1143\":1}}],[\"chart\",{\"1\":{\"1163\":1}}],[\"charset\",{\"1\":{\"601\":1,\"1039\":1}}],[\"character\",{\"1\":{\"368\":1,\"1177\":1}}],[\"char\",{\"0\":{\"367\":1,\"477\":1},\"1\":{\"367\":2,\"477\":5,\"624\":1}}],[\"cp\",{\"0\":{\"423\":1},\"1\":{\"418\":1,\"423\":2,\"870\":1}}],[\"cpu率先出现瓶颈\",{\"1\":{\"584\":1}}],[\"cpu瓶颈\",{\"1\":{\"584\":1,\"585\":1}}],[\"cpu多核环境下的硬件优势\",{\"1\":{\"261\":1}}],[\"cpu2\",{\"1\":{\"72\":5}}],[\"cpu100\",{\"0\":{\"201\":1}}],[\"cpu1\",{\"1\":{\"72\":2}}],[\"cpu\",{\"0\":{\"72\":1,\"562\":1},\"1\":{\"28\":1,\"30\":2,\"35\":6,\"57\":6,\"64\":6,\"71\":1,\"72\":29,\"78\":1,\"81\":1,\"86\":2,\"91\":3,\"100\":1,\"134\":10,\"136\":1,\"139\":2,\"144\":5,\"148\":1,\"150\":2,\"296\":1,\"307\":1,\"377\":1,\"379\":2,\"440\":1,\"473\":1,\"535\":1,\"558\":3,\"562\":2,\"583\":1,\"604\":1,\"632\":3,\"674\":2,\"835\":4,\"1001\":1,\"1048\":1,\"1145\":1}}],[\"cd\",{\"0\":{\"420\":1},\"1\":{\"418\":2,\"420\":5,\"1144\":2,\"1170\":1}}],[\"ctrl+z\",{\"1\":{\"417\":1}}],[\"ctrl+x+u\",{\"1\":{\"417\":1}}],[\"ctrl+t\",{\"1\":{\"417\":1}}],[\"ctrl+r\",{\"1\":{\"417\":1}}],[\"ctrl+y\",{\"1\":{\"417\":1}}],[\"ctrl+k\",{\"1\":{\"417\":1}}],[\"ctrl+u\",{\"1\":{\"417\":1}}],[\"ctrl+e\",{\"1\":{\"417\":1}}],[\"ctrl+a\",{\"1\":{\"417\":1}}],[\"ctrl+l\",{\"1\":{\"417\":1}}],[\"ctrl+q\",{\"1\":{\"417\":1}}],[\"ctrl+s\",{\"1\":{\"417\":1}}],[\"ctrl+d\",{\"1\":{\"417\":1}}],[\"ctrl+c\",{\"1\":{\"417\":1}}],[\"ctrl\",{\"0\":{\"417\":1},\"1\":{\"429\":1}}],[\"ctl\",{\"1\":{\"381\":1,\"612\":1}}],[\"c++\",{\"0\":{\"336\":1},\"1\":{\"336\":1,\"1144\":1}}],[\"c++实现\",{\"1\":{\"85\":1}}],[\"c2也被称为server\",{\"1\":{\"283\":1}}],[\"c2编译器\",{\"1\":{\"283\":1}}],[\"c1083\",{\"1\":{\"1144\":1}}],[\"c1也被称为client\",{\"1\":{\"283\":1}}],[\"c1编译器\",{\"1\":{\"283\":1}}],[\"cut\",{\"1\":{\"1209\":1}}],[\"cudnn\",{\"1\":{\"1145\":1}}],[\"cuda\",{\"1\":{\"1145\":1}}],[\"cusno\",{\"1\":{\"587\":1}}],[\"cust\",{\"1\":{\"227\":1}}],[\"customer\",{\"1\":{\"227\":4,\"587\":1}}],[\"cube|rollup\",{\"1\":{\"487\":1}}],[\"currentthread\",{\"1\":{\"96\":1,\"98\":1,\"182\":1}}],[\"current\",{\"1\":{\"96\":1,\"259\":1,\"601\":1}}],[\"crqs\",{\"1\":{\"1238\":1}}],[\"crc校验\",{\"0\":{\"969\":1}}],[\"crc16\",{\"1\":{\"659\":1,\"679\":1,\"680\":2}}],[\"crud\",{\"1\":{\"746\":1,\"754\":1}}],[\"crontab\",{\"1\":{\"674\":1}}],[\"crawler<\",{\"1\":{\"799\":1}}],[\"crash\",{\"1\":{\"577\":4,\"672\":1}}],[\"craetestringbuffer\",{\"1\":{\"202\":1}}],[\"createutenumeration\",{\"1\":{\"1247\":1}}],[\"createdtime\",{\"1\":{\"1117\":1}}],[\"created\",{\"1\":{\"1117\":1}}],[\"createproduct\",{\"1\":{\"1077\":2}}],[\"createstatementz\",{\"1\":{\"745\":1}}],[\"createstringbuffer\",{\"1\":{\"202\":1}}],[\"create\",{\"1\":{\"501\":1,\"527\":1,\"533\":1,\"601\":1,\"823\":1,\"882\":1,\"1144\":2}}],[\"critical\",{\"1\":{\"142\":1}}],[\"c5\",{\"1\":{\"201\":1}}],[\"csdn\",{\"1\":{\"1143\":2,\"1240\":1}}],[\"cs\",{\"1\":{\"801\":1}}],[\"cscan\",{\"1\":{\"163\":1}}],[\"css\",{\"0\":{\"22\":1},\"1\":{\"754\":1,\"959\":1,\"1029\":1,\"1210\":1}}],[\"cyclic\",{\"1\":{\"120\":1}}],[\"cyclicbarrier\",{\"0\":{\"120\":1,\"121\":1},\"1\":{\"115\":2,\"120\":5,\"121\":3}}],[\"cyclibarrier\",{\"1\":{\"120\":1}}],[\"clean\",{\"1\":{\"793\":1}}],[\"clear\",{\"1\":{\"301\":2}}],[\"cluster\",{\"0\":{\"678\":1},\"1\":{\"610\":1,\"642\":2,\"659\":4,\"660\":2,\"678\":3,\"679\":1,\"819\":2}}],[\"clust\",{\"1\":{\"546\":1}}],[\"cli\",{\"1\":{\"434\":1,\"706\":1,\"1138\":1,\"1139\":1,\"1144\":1,\"1192\":1}}],[\"client\",{\"1\":{\"254\":1,\"647\":1,\"661\":1,\"672\":6,\"673\":2,\"678\":1,\"801\":1,\"804\":1,\"817\":3,\"1060\":1,\"1077\":3,\"1082\":1,\"1083\":1,\"1090\":1}}],[\"closed\",{\"1\":{\"1027\":1}}],[\"cloud\",{\"0\":{\"1263\":1},\"1\":{\"736\":1,\"783\":1,\"1143\":1,\"1167\":1}}],[\"clonenotsupportedexception\",{\"1\":{\"350\":1}}],[\"clone\",{\"1\":{\"343\":2,\"350\":2,\"445\":1,\"1202\":1}}],[\"cloneable\",{\"1\":{\"343\":2,\"350\":1,\"392\":2,\"408\":1}}],[\"clock\",{\"1\":{\"160\":2}}],[\"cl\",{\"1\":{\"183\":2}}],[\"clazz\",{\"1\":{\"182\":1,\"1247\":1,\"1260\":3}}],[\"classicalsr\",{\"1\":{\"1144\":1}}],[\"classes\",{\"1\":{\"790\":1}}],[\"classpathxmlapplication\",{\"1\":{\"712\":1}}],[\"class<e>\",{\"1\":{\"1247\":1,\"1260\":1}}],[\"class<\",{\"1\":{\"349\":1}}],[\"classcastexception\",{\"1\":{\"345\":1,\"385\":1}}],[\"class的newinstance\",{\"1\":{\"212\":1}}],[\"class的实例\",{\"1\":{\"182\":2}}],[\"class文件格式也扩展了module\",{\"1\":{\"292\":1}}],[\"class文件格式采用一种类似于c语言结构体的伪结构来存储数据\",{\"1\":{\"284\":1}}],[\"class文件\",{\"1\":{\"291\":1}}],[\"class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式\",{\"1\":{\"290\":1}}],[\"class文件结构\",{\"0\":{\"284\":1}}],[\"class文件中由这三项数据来确定该类型的继承关系\",{\"1\":{\"288\":1}}],[\"class文件中许多指令不包含操作数\",{\"1\":{\"280\":1}}],[\"class文件中除了有类的版本\",{\"1\":{\"208\":1}}],[\"class文件是一组以8个字节为基础单位的二进制流\",{\"1\":{\"280\":1,\"284\":1}}],[\"class文件的常量池中存有大量的符号引用\",{\"1\":{\"194\":1}}],[\"classname\",{\"1\":{\"183\":1}}],[\"classloader类\",{\"0\":{\"182\":1}}],[\"classloader\",{\"1\":{\"176\":1,\"179\":1,\"181\":1,\"182\":2,\"183\":2,\"184\":1,\"185\":3,\"349\":3,\"1075\":1}}],[\"class对象没有在任何地方被引用\",{\"1\":{\"237\":1}}],[\"class对象\",{\"1\":{\"168\":2}}],[\"class\",{\"0\":{\"183\":1,\"339\":2},\"1\":{\"31\":1,\"83\":1,\"98\":1,\"101\":2,\"109\":1,\"170\":1,\"174\":1,\"175\":4,\"176\":1,\"178\":1,\"183\":1,\"227\":2,\"277\":3,\"288\":2,\"304\":2,\"335\":1,\"339\":4,\"348\":9,\"356\":4,\"703\":3,\"743\":1,\"777\":1,\"933\":2,\"935\":2,\"938\":1,\"951\":1,\"952\":1,\"953\":1,\"955\":2,\"956\":2,\"1066\":2,\"1067\":4,\"1068\":2,\"1069\":2,\"1070\":1,\"1075\":1,\"1077\":6,\"1082\":3,\"1083\":1,\"1247\":1,\"1261\":3,\"1271\":1}}],[\"class=\",{\"1\":{\"26\":1,\"713\":1,\"734\":1,\"736\":1}}],[\"clh\",{\"1\":{\"109\":1,\"110\":3}}],[\"copilot\",{\"0\":{\"1152\":1}}],[\"copyonwrite\",{\"1\":{\"411\":3}}],[\"copyonwritearraylist\",{\"0\":{\"411\":1},\"1\":{\"108\":1,\"393\":1}}],[\"copy\",{\"1\":{\"411\":1,\"418\":1,\"647\":1}}],[\"coordinationrepository\",{\"1\":{\"1242\":3}}],[\"coordinator还负责将事务信息写入内部的一个topic中\",{\"1\":{\"863\":1}}],[\"coordinator交互获得transaction\",{\"1\":{\"863\":1}}],[\"coordinator\",{\"1\":{\"863\":1}}],[\"cookie实际上是一小段的文本信息\",{\"1\":{\"1051\":1}}],[\"cookie\",{\"0\":{\"1050\":1,\"1051\":1,\"1061\":1},\"1\":{\"1038\":1,\"1039\":4,\"1050\":1,\"1060\":1,\"1061\":10}}],[\"cout输出到文件中\",{\"1\":{\"895\":1}}],[\"counterparty\",{\"1\":{\"1240\":1}}],[\"countdown\",{\"1\":{\"118\":1}}],[\"countdownlatch\",{\"0\":{\"118\":1,\"119\":1,\"121\":1},\"1\":{\"115\":3,\"118\":3,\"119\":2,\"120\":4,\"121\":3}}],[\"countdownlacth\",{\"1\":{\"109\":1}}],[\"count\",{\"1\":{\"96\":1,\"118\":2,\"129\":1,\"563\":1,\"801\":1,\"891\":1,\"895\":2}}],[\"cow\",{\"1\":{\"411\":2,\"647\":2}}],[\"cola\",{\"1\":{\"1226\":2}}],[\"collation\",{\"1\":{\"1177\":1}}],[\"collections\",{\"0\":{\"388\":1},\"1\":{\"388\":1,\"409\":2}}],[\"collection\",{\"0\":{\"388\":1},\"1\":{\"350\":1,\"388\":1,\"391\":4}}],[\"column\",{\"1\":{\"514\":2}}],[\"columns\",{\"1\":{\"458\":2}}],[\"color\",{\"1\":{\"58\":1,\"96\":1,\"118\":1,\"131\":1,\"201\":1}}],[\"command\",{\"1\":{\"1238\":1}}],[\"commentid\",{\"1\":{\"601\":3}}],[\"comments\",{\"1\":{\"601\":4}}],[\"commitindex\",{\"1\":{\"875\":1}}],[\"committed\",{\"1\":{\"522\":2,\"741\":2,\"878\":1}}],[\"commit隔离级别下\",{\"1\":{\"499\":1}}],[\"commit和repeatable\",{\"1\":{\"499\":1}}],[\"commit状态\",{\"1\":{\"489\":1}}],[\"commit\",{\"1\":{\"448\":6,\"449\":3,\"450\":3,\"451\":2,\"453\":5,\"489\":1,\"493\":1,\"526\":1,\"563\":3,\"568\":1,\"578\":1,\"582\":2,\"1126\":1,\"1127\":1,\"1177\":1}}],[\"commit一共两步呢\",{\"1\":{\"447\":1}}],[\"communication\",{\"1\":{\"149\":1}}],[\"computed\",{\"1\":{\"1156\":2,\"1163\":1}}],[\"compatible\",{\"1\":{\"1038\":1}}],[\"comparable\",{\"0\":{\"390\":1},\"1\":{\"390\":3,\"412\":1,\"933\":2}}],[\"comparator<int\",{\"1\":{\"394\":1}}],[\"comparator<integer>\",{\"1\":{\"390\":1,\"938\":1}}],[\"comparator\",{\"0\":{\"390\":1},\"1\":{\"62\":1,\"390\":3,\"412\":3,\"1089\":1}}],[\"compareandswapint\",{\"1\":{\"110\":1}}],[\"compareandsetstate\",{\"1\":{\"110\":1}}],[\"compareandsetstate进行操作\",{\"1\":{\"110\":1}}],[\"compare\",{\"0\":{\"105\":1},\"1\":{\"390\":1,\"394\":1,\"938\":1}}],[\"compareto\",{\"1\":{\"62\":1,\"408\":1,\"933\":1}}],[\"compile\",{\"1\":{\"793\":1,\"797\":1}}],[\"compiler\",{\"1\":{\"282\":1,\"283\":2,\"790\":1}}],[\"componentmodel=spring\",{\"1\":{\"1255\":1,\"1256\":1}}],[\"componentscan\",{\"1\":{\"743\":1,\"771\":1,\"777\":1}}],[\"component\",{\"1\":{\"743\":1,\"1085\":1,\"1271\":1}}],[\"composition\",{\"0\":{\"1099\":1},\"1\":{\"184\":1}}],[\"compressedclassspacesize\",{\"1\":{\"323\":1}}],[\"com\",{\"0\":{\"1124\":1},\"1\":{\"183\":1,\"348\":1,\"736\":1,\"743\":1,\"1124\":2,\"1170\":2,\"1184\":2,\"1197\":1,\"1202\":2,\"1271\":6}}],[\"code==null\",{\"1\":{\"1260\":1}}],[\"codeof\",{\"1\":{\"1247\":1,\"1260\":1,\"1261\":1}}],[\"code属性用于描述代码\",{\"1\":{\"292\":1}}],[\"code属性是class文件中最重要的一个属性\",{\"1\":{\"292\":1}}],[\"code属性出现在方法表的属性集合之中\",{\"1\":{\"292\":1}}],[\"code属性\",{\"0\":{\"292\":1}}],[\"code\",{\"0\":{\"1149\":1,\"1204\":1},\"1\":{\"88\":1,\"290\":1,\"292\":1,\"350\":1,\"715\":1,\"743\":1,\"1148\":1,\"1151\":1,\"1204\":1,\"1260\":8,\"1261\":5}}],[\"convertor\",{\"1\":{\"1259\":1}}],[\"connnet\",{\"1\":{\"1003\":1}}],[\"connect\",{\"0\":{\"1124\":1},\"1\":{\"745\":2,\"822\":2,\"1003\":5,\"1040\":1}}],[\"connections\",{\"1\":{\"1177\":1}}],[\"connection才能正常运行\",{\"1\":{\"718\":1}}],[\"connection\",{\"0\":{\"1124\":1},\"1\":{\"43\":2,\"799\":1,\"1038\":2,\"1039\":1,\"1042\":1}}],[\"conf\",{\"1\":{\"707\":1,\"824\":1}}],[\"configure\",{\"1\":{\"1266\":1}}],[\"configuration>\",{\"1\":{\"790\":1}}],[\"configuration和\",{\"1\":{\"773\":1}}],[\"configuration配置都加载到当前springboot创建的ioc容器\",{\"1\":{\"771\":1}}],[\"configuration\",{\"1\":{\"743\":1,\"777\":1}}],[\"config或者nacos中回用到它\",{\"1\":{\"783\":1}}],[\"config>来配置\",{\"1\":{\"728\":1}}],[\"config\",{\"1\":{\"446\":4,\"1143\":5,\"1177\":3,\"1178\":1,\"1202\":3,\"1208\":1}}],[\"consumer事务\",{\"0\":{\"864\":1}}],[\"consumer默认将offset保存在kafka一个内置的topic中\",{\"1\":{\"860\":1}}],[\"consumer默认将offset保存在zookeeper中\",{\"1\":{\"860\":1}}],[\"consumer恢复以后\",{\"1\":{\"860\":1}}],[\"consumer会等待一段时间之后再返回\",{\"1\":{\"858\":1}}],[\"consumer采用pull的方式来从broker中读取数据\",{\"1\":{\"858\":1}}],[\"consumer\",{\"0\":{\"860\":1},\"1\":{\"801\":2,\"802\":2,\"803\":1,\"845\":2,\"859\":2,\"860\":2,\"861\":2}}],[\"consistency\",{\"1\":{\"519\":1,\"870\":1}}],[\"consistenthash\",{\"1\":{\"812\":1}}],[\"consistent\",{\"1\":{\"501\":2,\"871\":1}}],[\"const\",{\"1\":{\"556\":1,\"702\":1,\"1159\":1}}],[\"constructbinarytree\",{\"1\":{\"956\":1}}],[\"constructor\",{\"1\":{\"348\":2,\"356\":1}}],[\"constructor的newinstance\",{\"1\":{\"212\":1}}],[\"constraint\",{\"1\":{\"462\":1}}],[\"constantvalue属性\",{\"1\":{\"292\":1}}],[\"constant\",{\"1\":{\"208\":1}}],[\"contributor\",{\"1\":{\"1202\":1}}],[\"controler\",{\"1\":{\"754\":1}}],[\"control\",{\"1\":{\"748\":1,\"1038\":1}}],[\"controller层\",{\"0\":{\"764\":1}}],[\"controller分离\",{\"1\":{\"754\":1}}],[\"controller\",{\"1\":{\"338\":1,\"735\":1,\"742\":1,\"743\":1,\"754\":1,\"755\":1,\"759\":1,\"766\":1}}],[\"contains\",{\"1\":{\"1099\":1}}],[\"container\",{\"1\":{\"801\":1,\"1163\":1}}],[\"content\",{\"1\":{\"601\":2,\"1038\":4}}],[\"contextloader\",{\"1\":{\"736\":2}}],[\"context\",{\"1\":{\"144\":2,\"185\":1,\"736\":3,\"1088\":1,\"1256\":1,\"1257\":1}}],[\"concurrency\",{\"1\":{\"1177\":1}}],[\"concurrentskiplistmap\",{\"1\":{\"108\":1}}],[\"concurrentlinkedqueue\",{\"1\":{\"108\":1}}],[\"concurrent\",{\"1\":{\"103\":1,\"108\":1,\"259\":1,\"492\":1}}],[\"concurrenthashmap了\",{\"1\":{\"607\":1}}],[\"concurrenthashmap\",{\"0\":{\"128\":1,\"129\":1,\"130\":1,\"410\":1},\"1\":{\"78\":1,\"108\":1,\"128\":3,\"129\":3,\"409\":1,\"410\":4,\"607\":1}}],[\"concrete\",{\"1\":{\"1086\":1,\"1088\":1}}],[\"concretedecorator\",{\"1\":{\"1085\":1}}],[\"concretecomponent\",{\"1\":{\"1085\":1}}],[\"concreterfactory\",{\"1\":{\"1079\":1}}],[\"concreteproduct2\",{\"1\":{\"1077\":3}}],[\"concreteproduct1\",{\"1\":{\"1077\":3}}],[\"concreteproduct\",{\"1\":{\"1077\":3}}],[\"concgcthreads\",{\"1\":{\"262\":1}}],[\"con\",{\"1\":{\"259\":1}}],[\"conda镜像源\",{\"1\":{\"1143\":1}}],[\"conda\",{\"0\":{\"1111\":1,\"1182\":1},\"1\":{\"1143\":6,\"1144\":3,\"1182\":2,\"1186\":1}}],[\"conditon\",{\"1\":{\"126\":2}}],[\"conditionsignal\",{\"1\":{\"126\":1}}],[\"conditionalwait\",{\"1\":{\"126\":1}}],[\"condition\",{\"0\":{\"126\":1},\"1\":{\"94\":1,\"103\":1,\"111\":5,\"120\":1,\"126\":3,\"141\":1,\"556\":1}}],[\"cond\",{\"1\":{\"62\":1}}],[\"corepoolsize\",{\"1\":{\"58\":8}}],[\"ca\",{\"1\":{\"1045\":1,\"1048\":1,\"1057\":2}}],[\"ca机构有自己的私钥对数字证书加密\",{\"1\":{\"1044\":1}}],[\"cannot\",{\"0\":{\"1212\":1},\"1\":{\"1212\":1}}],[\"canonical\",{\"1\":{\"891\":1}}],[\"candidate\",{\"1\":{\"874\":3,\"876\":3,\"877\":5,\"878\":2}}],[\"cancelled\",{\"1\":{\"111\":1}}],[\"capture\",{\"0\":{\"1130\":1}}],[\"cap\",{\"1\":{\"871\":2}}],[\"cap理论\",{\"0\":{\"870\":1}}],[\"caffeine\",{\"1\":{\"607\":3}}],[\"cat\",{\"1\":{\"416\":1,\"428\":3,\"1177\":1}}],[\"catalina\",{\"1\":{\"317\":1}}],[\"catch\",{\"1\":{\"98\":1,\"346\":1,\"383\":6}}],[\"card\",{\"0\":{\"247\":1},\"1\":{\"247\":1,\"249\":1}}],[\"cache两者的话比较像\",{\"1\":{\"607\":1}}],[\"cache来说\",{\"1\":{\"607\":1}}],[\"cache这三者是使用的比较多的本地缓存框架\",{\"1\":{\"607\":1}}],[\"cache所占内存的大小\",{\"1\":{\"571\":1}}],[\"cached\",{\"1\":{\"447\":1,\"449\":1}}],[\"cache\",{\"0\":{\"608\":1},\"1\":{\"72\":1,\"368\":1,\"568\":4,\"571\":7,\"607\":5,\"745\":2,\"752\":2,\"1038\":1,\"1060\":1}}],[\"caseaggregate\",{\"1\":{\"1242\":2}}],[\"case\",{\"1\":{\"934\":1,\"1088\":1,\"1190\":1,\"1261\":4,\"1271\":1}}],[\"cas来实现\",{\"1\":{\"513\":1}}],[\"cashing\",{\"1\":{\"193\":1}}],[\"cas+失败重试\",{\"1\":{\"219\":1}}],[\"cas+synchronized\",{\"0\":{\"131\":1}}],[\"cas+版本号\",{\"0\":{\"103\":1}}],[\"cas操作\",{\"1\":{\"110\":1}}],[\"cas\",{\"0\":{\"104\":1,\"105\":1,\"106\":1},\"1\":{\"48\":1,\"68\":1,\"81\":4,\"87\":2,\"88\":3,\"89\":2,\"96\":2,\"103\":2,\"104\":1,\"105\":4,\"106\":2,\"110\":1,\"113\":1,\"114\":4,\"118\":2,\"123\":1,\"128\":1,\"131\":1,\"142\":1,\"144\":2,\"219\":2,\"409\":1,\"410\":1}}],[\"callback\",{\"1\":{\"381\":1}}],[\"callerrunspolicy\",{\"1\":{\"60\":1}}],[\"call\",{\"1\":{\"31\":1,\"33\":1,\"801\":1,\"804\":2}}],[\"callable<integer>\",{\"1\":{\"31\":1}}],[\"callable\",{\"0\":{\"33\":1},\"1\":{\"31\":1,\"33\":1}}],[\"cnf\",{\"1\":{\"701\":1,\"1177\":3,\"1178\":1}}],[\"cn\",{\"1\":{\"26\":1,\"1038\":1,\"1143\":4}}],[\"c\",{\"1\":{\"18\":1,\"75\":2,\"81\":1,\"96\":6,\"102\":2,\"201\":1,\"336\":1,\"347\":1,\"367\":1,\"426\":1,\"533\":3,\"550\":1,\"551\":3,\"559\":4,\"573\":1,\"624\":7,\"687\":1,\"841\":1,\"870\":1,\"871\":1,\"954\":3,\"960\":1,\"977\":1,\"1006\":1,\"1124\":1,\"1143\":1,\"1144\":2,\"1157\":2,\"1168\":1,\"1202\":2}}],[\"并进行相应的空值保护\",{\"1\":{\"1259\":1}}],[\"并进入\",{\"1\":{\"1060\":1}}],[\"并触发向\",{\"1\":{\"1127\":1}}],[\"并用对应的图形类表示\",{\"1\":{\"1095\":1}}],[\"并用最小的代价去执行语句\",{\"1\":{\"536\":1}}],[\"并委派给不同的对象对这些算法进行管理\",{\"1\":{\"1088\":1}}],[\"并给具体构件对象添加附加的责任\",{\"1\":{\"1085\":1}}],[\"并包含具体构件的实例\",{\"1\":{\"1085\":1}}],[\"并包括指定文件的新变化\",{\"1\":{\"448\":1}}],[\"并封装成头帧和数据帧\",{\"1\":{\"1042\":1}}],[\"并列的数据之间用逗号\",{\"1\":{\"1035\":1}}],[\"并列出属于该终端机的程序的状况\",{\"1\":{\"426\":1}}],[\"并减少因特网上的\",{\"1\":{\"1032\":1}}],[\"并停止发送数据\",{\"1\":{\"1026\":1}}],[\"并向对应的服务器发送一个request报文\",{\"1\":{\"1049\":1}}],[\"并向根域名服务器发送查询请求\",{\"1\":{\"1031\":1}}],[\"并向发送方通知当前的窗口大小\",{\"1\":{\"1018\":1}}],[\"并向源点发送参数问题报文\",{\"1\":{\"993\":1}}],[\"并向源点发送时间超过报文\",{\"1\":{\"993\":1}}],[\"并引入拥塞控制和数据可靠性控制机制\",{\"1\":{\"1004\":1}}],[\"并按此地址存储该记录\",{\"1\":{\"922\":1}}],[\"并按照\",{\"1\":{\"484\":1}}],[\"并排序\",{\"1\":{\"900\":1}}],[\"并假设它们就是我们要找的最大的k个数\",{\"1\":{\"893\":1}}],[\"并立刻开始下一次选举\",{\"1\":{\"876\":1}}],[\"并处理相应的业务逻辑\",{\"1\":{\"755\":1}}],[\"并可重用\",{\"1\":{\"746\":1}}],[\"并从创建中处理这些对象的整个生命周期\",{\"1\":{\"718\":1}}],[\"并覆盖其中特定方法并添加增强代码\",{\"1\":{\"715\":1}}],[\"并有利于未来的可拓展性和可维护性\",{\"1\":{\"715\":1}}],[\"并正在客户环境部署\",{\"1\":{\"694\":1}}],[\"并确定此数据在环上的位置\",{\"1\":{\"681\":1}}],[\"并提供一个创建对象的通用接口\",{\"1\":{\"1076\":1}}],[\"并提供复制和故障转移功能\",{\"1\":{\"678\":1}}],[\"并提供了unix\",{\"1\":{\"475\":1}}],[\"并创建一个发送缓冲区记录从当前开始执行的所有写命令\",{\"1\":{\"662\":1}}],[\"并保存applicationcontext\",{\"1\":{\"736\":1}}],[\"并保存\",{\"1\":{\"662\":1}}],[\"并执行主数据库缓冲区的写命令\",{\"1\":{\"655\":1}}],[\"并执行相对应的处理\",{\"1\":{\"338\":1}}],[\"并使用该\",{\"1\":{\"1042\":1}}],[\"并使用该值寻找对应的记录指针\",{\"1\":{\"537\":1}}],[\"并使用缓冲区记录此后执行的所有写命令\",{\"1\":{\"655\":1}}],[\"并设置热点数据永不过期\",{\"1\":{\"642\":1}}],[\"并清除其中已过期的\",{\"1\":{\"632\":1}}],[\"并清空\",{\"1\":{\"571\":1}}],[\"并赋值给\",{\"1\":{\"623\":1}}],[\"并以二进制的形式保存在磁盘中\",{\"1\":{\"571\":1}}],[\"并显示\",{\"1\":{\"558\":1}}],[\"并通过\",{\"1\":{\"491\":1,\"759\":1}}],[\"并通知\",{\"1\":{\"72\":1}}],[\"并通知其他\",{\"1\":{\"72\":1}}],[\"并写入从服务器的中继日志\",{\"1\":{\"470\":1,\"581\":1}}],[\"并与本地分支合并\",{\"1\":{\"452\":1}}],[\"并命名\",{\"1\":{\"452\":1}}],[\"并切换到该分支\",{\"1\":{\"451\":1}}],[\"并调用\",{\"1\":{\"406\":1}}],[\"并对它们采用二进制格式的编码\",{\"1\":{\"1042\":1}}],[\"并对\",{\"1\":{\"389\":1}}],[\"并对数据进行校验\",{\"1\":{\"165\":1}}],[\"并复制其内容\",{\"1\":{\"343\":1}}],[\"并标记这些指针分别在哪些卡页的范围之内\",{\"1\":{\"265\":1}}],[\"并行调用多个服务器\",{\"1\":{\"813\":1}}],[\"并行的事务提交的时候\",{\"1\":{\"568\":1}}],[\"并行性\",{\"1\":{\"261\":1}}],[\"并行与并发\",{\"1\":{\"261\":1}}],[\"并具有大堆的应用程序提供解决方案\",{\"1\":{\"261\":1}}],[\"并发能力强\",{\"1\":{\"824\":1}}],[\"并发和流量等瓶颈的时候\",{\"1\":{\"678\":1}}],[\"并发事务的问题⭐\",{\"0\":{\"521\":1}}],[\"并发访问数据库时\",{\"1\":{\"519\":1}}],[\"并发量大时\",{\"1\":{\"840\":1}}],[\"并发量与数据吞吐量\",{\"1\":{\"655\":1,\"661\":1}}],[\"并发量很大\",{\"1\":{\"643\":1}}],[\"并发量\",{\"1\":{\"310\":1,\"584\":1}}],[\"并发重映射\",{\"1\":{\"268\":1}}],[\"并发重分配\",{\"1\":{\"268\":1}}],[\"并发预备重分配\",{\"1\":{\"268\":1}}],[\"并发性\",{\"1\":{\"261\":1,\"873\":1}}],[\"并发收集\",{\"1\":{\"259\":1}}],[\"并发清除\",{\"1\":{\"259\":1}}],[\"并发标记\",{\"1\":{\"259\":1,\"264\":1,\"268\":1}}],[\"并发的可达性分析\",{\"0\":{\"251\":1}}],[\"并发问题产生的三大根源\",{\"1\":{\"65\":1}}],[\"并更新内存\",{\"1\":{\"489\":1,\"569\":1}}],[\"并更新工作区\",{\"1\":{\"451\":1}}],[\"并更新列表上的记录\",{\"1\":{\"217\":1}}],[\"并更新其\",{\"1\":{\"147\":1}}],[\"并无法让系统再来加载并重定义这个类\",{\"1\":{\"187\":1}}],[\"并没有提供其他诸如过期时间之类的功能\",{\"1\":{\"607\":1}}],[\"并没有记录该数据\",{\"1\":{\"578\":1}}],[\"并没有返回\",{\"1\":{\"383\":1}}],[\"并没有做任何细节的要求\",{\"1\":{\"208\":1}}],[\"并没有指定字节流从哪里\",{\"1\":{\"168\":1}}],[\"并没有采用分段锁的策略\",{\"1\":{\"128\":1}}],[\"并将每个算法封装起来\",{\"1\":{\"1088\":1}}],[\"并将创建对象的工厂方法设计为静态方法时\",{\"1\":{\"1080\":1}}],[\"并将结果作为一个\",{\"1\":{\"1042\":1}}],[\"并将结果返回\",{\"1\":{\"487\":1}}],[\"并将处理结果及相应的视图返回给浏览器\",{\"1\":{\"959\":1,\"1029\":1}}],[\"并将这两类分别写入到两个文件中\",{\"1\":{\"901\":2}}],[\"并将虚拟节点映射到实际节点\",{\"1\":{\"880\":1}}],[\"并将producer获得的pid\",{\"1\":{\"863\":1}}],[\"并将log文件高于hw的部分截取掉\",{\"1\":{\"855\":1}}],[\"并将该请求跳转\",{\"1\":{\"754\":1}}],[\"并将其存储到数组的第一个索引位置\",{\"1\":{\"1087\":1}}],[\"并将其作为代理对象的内部成员属性\",{\"1\":{\"1083\":1}}],[\"并将其余\",{\"1\":{\"676\":1}}],[\"并将其他的\",{\"1\":{\"657\":1,\"675\":1}}],[\"并将其实例化产生代理对象\",{\"1\":{\"349\":1}}],[\"并将相应的binlog内容推送给slave节点\",{\"1\":{\"469\":1,\"580\":1}}],[\"并将扫描过的页面访问位都置为\",{\"1\":{\"160\":1}}],[\"并将扫描过的页面置为\",{\"1\":{\"160\":1}}],[\"并将对象头中的\",{\"1\":{\"87\":1}}],[\"并避免竞争条件\",{\"1\":{\"149\":1}}],[\"并由网际控制报文协议icmp发送端口不可达差错控制报文\",{\"1\":{\"1002\":1}}],[\"并由目的主机发送终点不可达差错报告报文\",{\"1\":{\"994\":1}}],[\"并由spring创建实例和管理各个实例之间的依赖关系\",{\"1\":{\"712\":1}}],[\"并由服务加载器读取配置文件\",{\"1\":{\"185\":1}}],[\"并由\",{\"1\":{\"151\":1}}],[\"并由消息队列标识符标识\",{\"1\":{\"149\":1}}],[\"并由操作系统代为完成\",{\"1\":{\"135\":1}}],[\"并在自己的事务中运行\",{\"1\":{\"740\":1}}],[\"并在发送期间继续记录被执行的写命令\",{\"1\":{\"655\":1}}],[\"并在一致性上做得比较好\",{\"1\":{\"643\":1}}],[\"并在进程退出时输出当前内存各区域分配情况\",{\"1\":{\"325\":1}}],[\"并在稍后由一条由虚拟机自动建立的\",{\"1\":{\"236\":1}}],[\"并在单线程中维持多个任务间的切换\",{\"1\":{\"144\":1}}],[\"并在任务重新调度执行时再次加载进来\",{\"1\":{\"144\":1}}],[\"并在此等待\",{\"1\":{\"126\":1}}],[\"并恢复另一个线程的状态\",{\"1\":{\"144\":1}}],[\"并等待另一资源\",{\"1\":{\"98\":1}}],[\"并不执行故障转移\",{\"1\":{\"676\":1}}],[\"并不再阻塞父进程\",{\"1\":{\"647\":1}}],[\"并不直接写磁盘\",{\"1\":{\"496\":1}}],[\"并不一定能得出键值对相等\",{\"1\":{\"341\":1}}],[\"并不能保证数据不丢失或者不重复\",{\"1\":{\"855\":1}}],[\"并不能保证操作的原子性\",{\"1\":{\"295\":1}}],[\"并不能解决分布式系统所有问题\",{\"1\":{\"815\":1}}],[\"并不能精确地知道满足这个条件的记录有多少条\",{\"1\":{\"536\":1}}],[\"并不能直接在\",{\"1\":{\"18\":1}}],[\"并不会被master进程处理\",{\"1\":{\"830\":1}}],[\"并不会覆盖以前的日志\",{\"1\":{\"573\":1}}],[\"并不会立即将数据页的更新落地到磁盘\",{\"1\":{\"559\":1}}],[\"并不会受到程序运行期变量数据的影响\",{\"1\":{\"191\":1}}],[\"并不会执行类的初始化\",{\"1\":{\"183\":1}}],[\"并不是\",{\"1\":{\"622\":1}}],[\"并不是直接刷入磁盘\",{\"1\":{\"593\":1}}],[\"并不是所有的修改都会以row\",{\"1\":{\"572\":1}}],[\"并不是马上写入磁盘\",{\"1\":{\"568\":1}}],[\"并不是数据本身\",{\"1\":{\"547\":1}}],[\"并不是对象本身\",{\"1\":{\"351\":1}}],[\"并不是存在\",{\"1\":{\"299\":1}}],[\"并不是虚拟机运行时数据区的一部分\",{\"1\":{\"209\":1}}],[\"并不是一个具有强制性约束力的模型\",{\"1\":{\"184\":1}}],[\"并不是说前一个操作发生在后一个操作前面\",{\"1\":{\"75\":1}}],[\"并不属于其他任何文件系统\",{\"1\":{\"149\":1}}],[\"并把伪造的报文发给对方\",{\"1\":{\"1054\":1}}],[\"并把这个分配出去的ip进行登记\",{\"1\":{\"1049\":1}}],[\"并把这个方法的符号引用写到main\",{\"1\":{\"277\":1}}],[\"并把窗口设置为1个字节\",{\"1\":{\"1018\":1}}],[\"并把100个词及相应的频率存入文件\",{\"1\":{\"894\":1}}],[\"并把信息传递给这些节点\",{\"1\":{\"684\":1}}],[\"并把\",{\"1\":{\"489\":1}}],[\"并把光标移到下个字符\",{\"1\":{\"417\":1}}],[\"并把数据\",{\"1\":{\"73\":1}}],[\"并把自己的状态从修改变成独占\",{\"1\":{\"72\":1}}],[\"并且没有任何性能影响和空间的浪费\",{\"1\":{\"1069\":1}}],[\"并且没有发生\",{\"1\":{\"295\":1}}],[\"并且每次用于每次发送请求\",{\"1\":{\"1053\":1}}],[\"并且每个代理类的实例都关联到了一个\",{\"1\":{\"349\":1}}],[\"并且发送给服务器\",{\"1\":{\"1044\":1}}],[\"并且只会装载一次\",{\"1\":{\"1070\":1}}],[\"并且只在从缓存中找不到名字时才使用域名服务器\",{\"1\":{\"1032\":1}}],[\"并且只存在于内存中\",{\"1\":{\"149\":1}}],[\"并且动态变化\",{\"1\":{\"1019\":1}}],[\"并且此处完全不可以使用重发机制\",{\"1\":{\"1001\":1}}],[\"并且n比较小\",{\"1\":{\"885\":1}}],[\"并且我们可以容忍误判的概率为0\",{\"1\":{\"882\":1}}],[\"并且向客户端返回执行结果\",{\"1\":{\"878\":1}}],[\"并且开始进行一次选举以选出一个新的\",{\"1\":{\"877\":1}}],[\"并且刷新自己的\",{\"1\":{\"877\":1}}],[\"并且c\",{\"1\":{\"798\":1}}],[\"并且添加安全配置\",{\"1\":{\"789\":1}}],[\"并且spring\",{\"1\":{\"772\":1}}],[\"并且由于ioc利用了java反射机制\",{\"1\":{\"731\":1}}],[\"并且重新编译布署\",{\"1\":{\"731\":1}}],[\"并且把应用业务逻辑和系统服务分开\",{\"1\":{\"717\":1}}],[\"并且相关槽所属的键值对也会从源节点被移动到目标节点\",{\"1\":{\"682\":1}}],[\"并且需要让其他从库节点去复制新主库节点\",{\"1\":{\"675\":1}}],[\"并且需要多个比较规则之间频繁切换\",{\"1\":{\"390\":1}}],[\"并且提供数据持久化和备份策略\",{\"1\":{\"675\":1}}],[\"并且试着获取下一个\",{\"1\":{\"672\":1}}],[\"并且不会被中途打断\",{\"1\":{\"665\":1}}],[\"并且不允许访问外围设备\",{\"1\":{\"134\":1}}],[\"并且数量达到一定值时\",{\"1\":{\"657\":1}}],[\"并且数组长度\",{\"1\":{\"398\":1}}],[\"并且具备长度可变\",{\"1\":{\"625\":1}}],[\"并且服务器没有执行\",{\"1\":{\"623\":1}}],[\"并且元素数量不超过\",{\"1\":{\"619\":1}}],[\"并且元素大小小于\",{\"1\":{\"618\":1}}],[\"并且大小在\",{\"1\":{\"617\":1}}],[\"并且可以将缓存的数据持久化到本地磁盘中\",{\"1\":{\"607\":1}}],[\"并且可以限制同一时刻访问此资源的最大线程数量\",{\"1\":{\"142\":1}}],[\"并且是访问百度的日志中的ip取出来\",{\"1\":{\"892\":1}}],[\"并且是采用\",{\"1\":{\"576\":1}}],[\"并且是离那个数最近的数字\",{\"1\":{\"404\":1}}],[\"并且事务无法进一步执行\",{\"1\":{\"520\":1}}],[\"并且降低了并发性\",{\"1\":{\"513\":1}}],[\"并且增加了死锁的机会\",{\"1\":{\"513\":1}}],[\"并且会以next\",{\"1\":{\"505\":1}}],[\"并且根据\",{\"1\":{\"469\":1,\"580\":1}}],[\"并且减少数据冗余\",{\"1\":{\"463\":1}}],[\"并且应用到当前分支\",{\"1\":{\"453\":1}}],[\"并且各自把各自的提交推送到服务器仓库里\",{\"1\":{\"452\":1}}],[\"并且能够保证读线程间不阻塞\",{\"1\":{\"411\":1}}],[\"并且能被当前版本的虚拟机处理\",{\"1\":{\"170\":1}}],[\"并且防止\",{\"1\":{\"410\":1}}],[\"并且实现了\",{\"1\":{\"392\":1}}],[\"并且多线程处理多个连接\",{\"1\":{\"377\":1}}],[\"并且插入与删除也比较频繁\",{\"1\":{\"374\":1}}],[\"并且继承是多态的前提\",{\"1\":{\"355\":1}}],[\"并且将这个改名放入暂存区\",{\"1\":{\"447\":1}}],[\"并且将这次删除放入暂存区\",{\"1\":{\"447\":1}}],[\"并且将此\",{\"1\":{\"301\":1}}],[\"并且将共享资源设置为锁定状态\",{\"1\":{\"110\":1}}],[\"并且扩展时无法申请到足够的内存\",{\"1\":{\"297\":1}}],[\"并且最终的静态类型是在编译期可知的\",{\"1\":{\"277\":1}}],[\"并且修改tams指针的值\",{\"1\":{\"264\":1}}],[\"并且检查这个符号引用代表的类是否已被加载\",{\"1\":{\"214\":1}}],[\"并且出现这种错误之后的表现形式还会有几种\",{\"1\":{\"200\":1}}],[\"并且堆也无法再扩展时\",{\"1\":{\"199\":1}}],[\"并且在寻找合适位置插入时\",{\"1\":{\"466\":1}}],[\"并且在尝试扩展的时候无法申请到足够的内存\",{\"1\":{\"190\":1}}],[\"并且在准备赋值时仍为\",{\"1\":{\"106\":1}}],[\"并且严格限制代码对本地系统资源的访问\",{\"1\":{\"186\":1}}],[\"并且这个映射表还经常动态更新\",{\"1\":{\"986\":1}}],[\"并且这个\",{\"1\":{\"804\":1}}],[\"并且这个类可以在运行时才加载进来\",{\"1\":{\"348\":1}}],[\"并且这个方法句柄对应的类没有进行过初始化\",{\"1\":{\"174\":1}}],[\"并且这种死锁很难被发现\",{\"1\":{\"173\":1}}],[\"并且返回中途不处理任何请求\",{\"1\":{\"163\":1}}],[\"并且占用\",{\"1\":{\"134\":1}}],[\"并且也便于对过早通知的处理\",{\"1\":{\"122\":1}}],[\"并且新实例化的对象也是不可偏向的\",{\"1\":{\"88\":1}}],[\"并且写入到方法表的code属性之中\",{\"1\":{\"191\":1}}],[\"并且写\",{\"1\":{\"78\":1}}],[\"并且\",{\"1\":{\"71\":1,\"131\":1,\"414\":1,\"456\":1,\"607\":1,\"610\":1,\"624\":1,\"685\":1,\"882\":1,\"1042\":1}}],[\"并且仅执行1次\",{\"1\":{\"39\":1}}],[\"并返回\",{\"1\":{\"96\":1}}],[\"并返回等待执行任务的列表\",{\"1\":{\"59\":1}}],[\"并返回移除后数组的新长度\",{\"1\":{\"6\":1}}],[\"并获取其threadlocalmap\",{\"1\":{\"39\":1}}],[\"并获取当前线程的threadlocalmap若不为空\",{\"1\":{\"39\":1}}],[\"ddd\",{\"0\":{\"1214\":1,\"1228\":1,\"1235\":1,\"1236\":1},\"1\":{\"1213\":1,\"1217\":2,\"1236\":2,\"1240\":3,\"1242\":1,\"1243\":1,\"1249\":1}}],[\"dddlearning\",{\"0\":{\"1213\":1}}],[\"ddl\",{\"1\":{\"483\":2,\"501\":1,\"511\":1,\"566\":1}}],[\"dnf\",{\"1\":{\"1167\":1,\"1168\":2}}],[\"dns劫持\",{\"0\":{\"1059\":1},\"1\":{\"1059\":1}}],[\"dns使用udp还是tcp\",{\"0\":{\"1033\":1}}],[\"dns域名服务器根据域名的层级\",{\"1\":{\"1031\":1}}],[\"dns\",{\"1\":{\"603\":1,\"959\":2,\"1029\":2,\"1032\":2,\"1033\":2,\"1124\":1}}],[\"dhpc服务器一看源ip都是0的请求\",{\"1\":{\"1049\":1}}],[\"dhcp收到报文后\",{\"1\":{\"1049\":1}}],[\"dhcp回答报文叫做提供\",{\"1\":{\"1049\":1}}],[\"dhcp服务器首先在其数据库中查找该主机的配置信息\",{\"1\":{\"1049\":1}}],[\"dhcp服务器处理同首次分配ip地址的流程\",{\"1\":{\"1049\":1}}],[\"dhcp中继代理收到请求后\",{\"1\":{\"1049\":1}}],[\"dhcp采用客户服务器方式\",{\"1\":{\"1049\":1}}],[\"dhcp报文是udp用户数据报的数据\",{\"1\":{\"1049\":1}}],[\"d系统处理失败\",{\"1\":{\"841\":1}}],[\"d三个系统发消息数据\",{\"1\":{\"841\":1}}],[\"d的顺序可以任意调整\",{\"1\":{\"533\":1}}],[\"d是用不到索引的\",{\"1\":{\"533\":1}}],[\"d=4\",{\"1\":{\"533\":1}}],[\"dml\",{\"1\":{\"483\":1,\"501\":1,\"511\":1,\"566\":1}}],[\"dma\",{\"1\":{\"379\":3}}],[\"driven\",{\"1\":{\"1213\":1}}],[\"drivers\",{\"1\":{\"1124\":1}}],[\"driver\",{\"1\":{\"348\":1}}],[\"drivermanager\",{\"1\":{\"182\":1}}],[\"drawer\",{\"1\":{\"1157\":1}}],[\"drop\",{\"0\":{\"483\":1},\"1\":{\"483\":1,\"527\":1}}],[\"dr\",{\"1\":{\"451\":1}}],[\"dao层首先设计的是接口\",{\"1\":{\"762\":1}}],[\"dao层\",{\"0\":{\"762\":1},\"1\":{\"766\":1}}],[\"dao\",{\"1\":{\"735\":1}}],[\"dateformat\",{\"1\":{\"1077\":1}}],[\"date\",{\"1\":{\"601\":2,\"1038\":1}}],[\"datetime\",{\"1\":{\"475\":4}}],[\"datasour\",{\"1\":{\"1266\":1}}],[\"datasourceautoconfiguration\",{\"1\":{\"777\":1}}],[\"datasource\",{\"1\":{\"43\":1,\"1266\":1}}],[\"datasets\",{\"1\":{\"1144\":1}}],[\"data为message的具体内容\",{\"1\":{\"847\":1}}],[\"database\",{\"0\":{\"647\":1}}],[\"databases\",{\"1\":{\"459\":1}}],[\"data\",{\"0\":{\"847\":1},\"1\":{\"538\":1,\"541\":1,\"847\":1,\"961\":1,\"1177\":2}}],[\"day\",{\"1\":{\"449\":1}}],[\"df2k\",{\"1\":{\"1144\":1}}],[\"df\",{\"1\":{\"441\":3,\"987\":1}}],[\"dba\",{\"1\":{\"576\":1}}],[\"db权限表\",{\"1\":{\"458\":1}}],[\"dbs\",{\"0\":{\"457\":1},\"1\":{\"457\":1}}],[\"dbms不需要再次编译\",{\"1\":{\"597\":1}}],[\"dbms\",{\"0\":{\"457\":1},\"1\":{\"457\":1}}],[\"db\",{\"0\":{\"457\":1},\"1\":{\"434\":1,\"457\":1,\"458\":2,\"499\":2,\"643\":2}}],[\"dll\",{\"1\":{\"416\":1}}],[\"d\",{\"1\":{\"416\":2,\"419\":1,\"430\":1,\"450\":1,\"451\":1,\"501\":2,\"533\":2,\"550\":1,\"884\":1,\"1012\":1,\"1144\":1,\"1190\":4}}],[\"dubbo\",{\"0\":{\"809\":1,\"810\":1,\"811\":1,\"812\":1,\"814\":1,\"815\":1},\"1\":{\"809\":1,\"812\":1,\"814\":2,\"815\":2}}],[\"durabilily\",{\"1\":{\"519\":1}}],[\"du\",{\"0\":{\"442\":1},\"1\":{\"441\":3,\"442\":3}}],[\"duque<t>\",{\"1\":{\"394\":2}}],[\"duque\",{\"1\":{\"394\":3}}],[\"dump线程\",{\"1\":{\"469\":1,\"580\":1}}],[\"dump\",{\"1\":{\"324\":1,\"469\":1,\"580\":1,\"647\":1}}],[\"dump出堆文件\",{\"1\":{\"308\":1}}],[\"domainservice\",{\"0\":{\"1242\":1},\"1\":{\"1245\":1}}],[\"domainobject\",{\"1\":{\"1217\":1}}],[\"domain\",{\"0\":{\"1239\":1},\"1\":{\"1213\":1,\"1218\":1,\"1221\":3}}],[\"dom4j\",{\"1\":{\"729\":1}}],[\"dotall\",{\"1\":{\"1190\":1}}],[\"dotnet\",{\"1\":{\"18\":1}}],[\"do\",{\"1\":{\"1077\":2,\"1117\":1,\"1217\":1}}],[\"don\",{\"1\":{\"987\":1}}],[\"dofilter\",{\"1\":{\"759\":1}}],[\"down\",{\"1\":{\"649\":1,\"657\":1,\"677\":1}}],[\"docs\",{\"1\":{\"1179\":1,\"1198\":1,\"1200\":1,\"1206\":1}}],[\"docker\",{\"0\":{\"1175\":1,\"1176\":1,\"1179\":1},\"1\":{\"1177\":7,\"1178\":1,\"1179\":1}}],[\"doc\",{\"1\":{\"418\":2}}],[\"documents\",{\"1\":{\"891\":1}}],[\"document\",{\"1\":{\"338\":1}}],[\"double\",{\"1\":{\"192\":1,\"368\":1,\"473\":2,\"496\":2,\"755\":1,\"949\":3}}],[\"diagram\",{\"1\":{\"1271\":6}}],[\"div2k\",{\"1\":{\"1144\":1}}],[\"di是如何实现的\",{\"1\":{\"718\":1}}],[\"di其实是控制反转的实现方式\",{\"1\":{\"718\":1}}],[\"di\",{\"1\":{\"718\":1,\"770\":1}}],[\"dictentry\",{\"1\":{\"623\":3}}],[\"dicthashtable\",{\"1\":{\"623\":1}}],[\"dictht\",{\"1\":{\"622\":3,\"623\":17}}],[\"dicttype\",{\"1\":{\"622\":1}}],[\"dict\",{\"0\":{\"623\":1},\"1\":{\"619\":2,\"620\":1,\"622\":2,\"623\":8}}],[\"dictionary\",{\"1\":{\"407\":1,\"603\":1}}],[\"different\",{\"1\":{\"891\":1}}],[\"diff\",{\"1\":{\"449\":5}}],[\"dirty\",{\"1\":{\"521\":1}}],[\"dir\",{\"1\":{\"447\":1}}],[\"director\",{\"1\":{\"1086\":1}}],[\"directory>\",{\"1\":{\"1266\":3}}],[\"directory找到数据行\",{\"1\":{\"547\":1}}],[\"directory\",{\"1\":{\"418\":4,\"423\":1,\"425\":1,\"444\":3,\"1121\":3,\"1144\":1,\"1168\":1}}],[\"direct\",{\"1\":{\"209\":1}}],[\"dirs系统变量所指定的路径中所有的类库\",{\"1\":{\"177\":1}}],[\"distclean\",{\"1\":{\"1168\":1}}],[\"distinct\",{\"1\":{\"487\":1}}],[\"disposablebean接口\",{\"1\":{\"737\":1}}],[\"dispatcherservelet\",{\"1\":{\"770\":1}}],[\"dispatcherservlet\",{\"1\":{\"755\":5,\"756\":1,\"759\":2}}],[\"dispatch\",{\"1\":{\"193\":1}}],[\"disk\",{\"1\":{\"441\":2,\"442\":1,\"568\":1}}],[\"discard\",{\"1\":{\"665\":3}}],[\"discardpolicy\",{\"1\":{\"60\":1}}],[\"discardoldestpolicy\",{\"1\":{\"60\":1}}],[\"dcl\",{\"0\":{\"101\":1,\"714\":1},\"1\":{\"71\":1}}],[\"deactivate\",{\"1\":{\"1182\":1}}],[\"deadline\",{\"1\":{\"691\":1}}],[\"deadlock\",{\"1\":{\"98\":2,\"516\":1}}],[\"deadlockdemo\",{\"1\":{\"98\":2}}],[\"denied\",{\"1\":{\"1178\":2}}],[\"details\",{\"1\":{\"1143\":2}}],[\"detect\",{\"1\":{\"516\":1}}],[\"decorator\",{\"1\":{\"1085\":1}}],[\"decimal\",{\"1\":{\"473\":5}}],[\"defineexpose\",{\"1\":{\"1155\":1,\"1163\":1}}],[\"deflate\",{\"1\":{\"1038\":1}}],[\"default\",{\"1\":{\"362\":1,\"601\":1,\"741\":1,\"1139\":1,\"1177\":1,\"1257\":1,\"1261\":2}}],[\"deployment\",{\"1\":{\"1200\":1}}],[\"dependencies>\",{\"1\":{\"800\":1}}],[\"dependencies\",{\"1\":{\"779\":1}}],[\"dependencies项目依赖\",{\"1\":{\"778\":1}}],[\"dependencymanagement>\",{\"1\":{\"800\":1}}],[\"dependency>\",{\"1\":{\"776\":1,\"795\":1,\"800\":1,\"882\":1}}],[\"dependency\",{\"0\":{\"1096\":1},\"1\":{\"718\":1}}],[\"deprecated\",{\"1\":{\"338\":1}}],[\"derived\",{\"1\":{\"556\":1}}],[\"del\",{\"1\":{\"668\":1,\"669\":1}}],[\"delayed不同之处在于\",{\"1\":{\"565\":1}}],[\"delayed\",{\"1\":{\"565\":1}}],[\"delay\",{\"1\":{\"492\":1,\"563\":2}}],[\"delayqueue\",{\"1\":{\"56\":1,\"62\":1}}],[\"delete操作时\",{\"1\":{\"469\":1,\"580\":1}}],[\"delete\",{\"0\":{\"483\":1},\"1\":{\"451\":1,\"483\":1,\"501\":3,\"516\":1,\"823\":1,\"1040\":1,\"1041\":2}}],[\"design\",{\"1\":{\"1148\":1,\"1213\":1}}],[\"design5\",{\"1\":{\"1148\":1}}],[\"destroy\",{\"1\":{\"759\":1}}],[\"destination\",{\"1\":{\"423\":2,\"425\":2}}],[\"desktop\",{\"1\":{\"559\":1,\"1144\":2}}],[\"describe\",{\"1\":{\"1260\":1}}],[\"description\",{\"1\":{\"1190\":1}}],[\"descriptor\",{\"1\":{\"289\":1,\"290\":1}}],[\"desc\",{\"1\":{\"459\":1,\"703\":1,\"1261\":2}}],[\"devdependencies\",{\"1\":{\"1139\":1}}],[\"devilzcl\",{\"1\":{\"1091\":4}}],[\"devil\",{\"1\":{\"818\":2}}],[\"device\",{\"1\":{\"416\":1}}],[\"devtools模块完全满足开发人员的需求\",{\"1\":{\"769\":1}}],[\"devtools\",{\"1\":{\"769\":2,\"782\":1}}],[\"dev\",{\"1\":{\"416\":1,\"1126\":6,\"1127\":5}}],[\"development\",{\"1\":{\"335\":1}}],[\"deque\",{\"0\":{\"394\":1}}],[\"demo\",{\"1\":{\"98\":1,\"317\":1}}],[\"debug\",{\"1\":{\"31\":2,\"647\":1}}],[\"debian>>deepin\",{\"1\":{\"18\":1}}],[\"deeplearning\",{\"1\":{\"1108\":1}}],[\"deep\",{\"0\":{\"24\":1},\"1\":{\"24\":2,\"1157\":1}}],[\"82\",{\"1\":{\"1124\":1}}],[\"8时\",{\"1\":{\"1049\":1}}],[\"8位最多99\",{\"1\":{\"883\":1}}],[\"8<\",{\"1\":{\"790\":2}}],[\"8进行编码\",{\"1\":{\"779\":1}}],[\"8m\",{\"1\":{\"565\":1,\"1177\":1}}],[\"85\",{\"1\":{\"559\":1}}],[\"89\",{\"1\":{\"559\":1}}],[\"8c\",{\"1\":{\"559\":3}}],[\"88\",{\"1\":{\"559\":3}}],[\"80\",{\"1\":{\"559\":2,\"606\":1,\"824\":1,\"1048\":1}}],[\"8080\",{\"1\":{\"435\":1}}],[\"87\",{\"1\":{\"559\":1}}],[\"8784\",{\"1\":{\"537\":1}}],[\"81\",{\"1\":{\"559\":1,\"1139\":1}}],[\"84\",{\"1\":{\"559\":2}}],[\"8f\",{\"1\":{\"559\":3}}],[\"8k\",{\"1\":{\"498\":1}}],[\"8编码构成字符串值\",{\"1\":{\"284\":1}}],[\"8个字节的无符号数\",{\"1\":{\"284\":1}}],[\"8gb之间\",{\"1\":{\"262\":1}}],[\"8的默认收集器\",{\"1\":{\"257\":1}}],[\"8及之后\",{\"1\":{\"204\":1}}],[\"8\",{\"0\":{\"131\":1,\"412\":1,\"706\":1,\"899\":1},\"1\":{\"18\":1,\"59\":1,\"73\":1,\"74\":1,\"128\":2,\"130\":3,\"131\":1,\"227\":3,\"294\":1,\"304\":1,\"322\":1,\"350\":1,\"362\":2,\"398\":1,\"401\":1,\"468\":1,\"472\":1,\"475\":1,\"476\":1,\"490\":1,\"617\":1,\"655\":1,\"663\":2,\"779\":1,\"935\":1,\"951\":1,\"952\":1,\"1162\":1,\"1170\":4}}],[\"4xx\",{\"1\":{\"1040\":1}}],[\"42\",{\"1\":{\"1038\":1}}],[\"42928704\",{\"1\":{\"539\":1}}],[\"49151\",{\"1\":{\"1000\":2}}],[\"48\",{\"1\":{\"981\":1,\"1144\":1}}],[\"43\",{\"1\":{\"951\":1}}],[\"4byte=\",{\"1\":{\"903\":1}}],[\"4mb\",{\"1\":{\"892\":1}}],[\"443\",{\"1\":{\"1044\":1,\"1048\":1,\"1201\":1,\"1202\":1}}],[\"44\",{\"1\":{\"617\":1}}],[\"4k\",{\"1\":{\"539\":1}}],[\"4kb\",{\"1\":{\"153\":1,\"156\":2}}],[\"4左右\",{\"1\":{\"262\":1}}],[\"4中新加入了nio\",{\"1\":{\"209\":1}}],[\"4g内存大概可以表示340亿bit\",{\"1\":{\"896\":1}}],[\"4g\",{\"1\":{\"156\":1,\"1042\":1}}],[\"4gb\",{\"1\":{\"156\":1}}],[\"400\",{\"1\":{\"1040\":1}}],[\"404\",{\"1\":{\"1040\":1,\"1275\":1}}],[\"403\",{\"1\":{\"1040\":1}}],[\"4096\",{\"1\":{\"442\":1,\"1202\":1}}],[\"4096b\",{\"1\":{\"156\":2}}],[\"40\",{\"1\":{\"88\":1,\"405\":2}}],[\"4\",{\"0\":{\"55\":1,\"381\":1,\"386\":1,\"391\":1,\"895\":1,\"918\":1,\"949\":1,\"1099\":1,\"1164\":1,\"1200\":1,\"1231\":1,\"1235\":1,\"1236\":1,\"1237\":1,\"1238\":1,\"1239\":1,\"1240\":1,\"1241\":1,\"1242\":1,\"1243\":1,\"1254\":1,\"1255\":1,\"1256\":1},\"1\":{\"18\":1,\"56\":1,\"60\":1,\"160\":1,\"163\":1,\"198\":1,\"235\":1,\"259\":1,\"284\":1,\"304\":1,\"315\":1,\"322\":1,\"350\":2,\"383\":2,\"405\":1,\"433\":1,\"442\":2,\"475\":1,\"484\":2,\"485\":1,\"531\":1,\"532\":1,\"539\":1,\"541\":1,\"543\":1,\"611\":1,\"632\":1,\"636\":1,\"651\":1,\"653\":2,\"672\":1,\"774\":1,\"801\":1,\"820\":5,\"836\":5,\"880\":2,\"918\":2,\"919\":1,\"921\":4,\"935\":2,\"938\":2,\"947\":1,\"952\":1,\"955\":2,\"956\":2,\"961\":1,\"986\":1,\"1019\":1,\"1038\":1,\"1094\":2,\"1124\":1,\"1162\":1,\"1177\":1}}],[\"ng\",{\"1\":{\"1144\":3}}],[\"nginx重启之后\",{\"0\":{\"837\":1}}],[\"nginx原理\",{\"0\":{\"833\":1}}],[\"nginx会立刻剥夺执行权\",{\"1\":{\"831\":1}}],[\"nginx引入了一种比线程更小的概念\",{\"1\":{\"831\":1}}],[\"nginx命令可以看到有两个nginx进程\",{\"1\":{\"830\":1}}],[\"nginx高性能原因\",{\"0\":{\"828\":1}}],[\"nginx不仅可以反向代理\",{\"1\":{\"827\":1}}],[\"nginx的主要特征\",{\"0\":{\"827\":1}}],[\"nginx也可以通过模块开发来提供应用功能\",{\"1\":{\"825\":1}}],[\"nginx常用做静态内容服务和代理服务器\",{\"1\":{\"825\":1}}],[\"nginx与tomcat的区别\",{\"0\":{\"825\":1}}],[\"nginx\",{\"0\":{\"824\":1,\"832\":1},\"1\":{\"824\":2,\"825\":2,\"827\":1,\"832\":1,\"833\":1,\"834\":2,\"835\":1,\"836\":1,\"837\":1}}],[\"n个数据报\",{\"1\":{\"1019\":1}}],[\"n是整数\",{\"1\":{\"1007\":1}}],[\"nt5\",{\"1\":{\"1038\":1}}],[\"ntoa\",{\"1\":{\"997\":1}}],[\"ntfs\",{\"1\":{\"442\":1}}],[\"n<0\",{\"1\":{\"949\":1}}],[\"n==0\",{\"1\":{\"949\":1}}],[\"n+\",{\"1\":{\"930\":1}}],[\"n+1\",{\"1\":{\"489\":1}}],[\"n^2\",{\"0\":{\"930\":1,\"931\":1,\"932\":1,\"933\":1},\"1\":{\"930\":1,\"931\":1,\"932\":1,\"933\":1}}],[\"n为1000万\",{\"1\":{\"893\":1}}],[\"n的大小比较小的情况\",{\"1\":{\"885\":1}}],[\"nx\",{\"1\":{\"705\":1}}],[\"n>=1\",{\"1\":{\"676\":1}}],[\"n>1\",{\"1\":{\"571\":1}}],[\"nlogn\",{\"1\":{\"937\":2}}],[\"nlogk\",{\"1\":{\"893\":1}}],[\"nlg10\",{\"1\":{\"899\":2}}],[\"nle\",{\"1\":{\"899\":2}}],[\"nl\",{\"1\":{\"428\":2}}],[\"nagle算法\",{\"0\":{\"1017\":1}}],[\"nagle\",{\"1\":{\"1006\":1,\"1017\":1}}],[\"nat地址转换表举例\",{\"1\":{\"995\":1}}],[\"nat\",{\"0\":{\"995\":1},\"1\":{\"995\":2}}],[\"native\",{\"1\":{\"197\":2,\"234\":1,\"297\":1,\"393\":1}}],[\"namespace\",{\"1\":{\"752\":1}}],[\"name和age建立了联合索引\",{\"1\":{\"553\":1}}],[\"name\",{\"1\":{\"182\":2,\"227\":2,\"289\":1,\"290\":1,\"424\":1,\"426\":1,\"445\":1,\"446\":2,\"449\":1,\"451\":4,\"452\":2,\"481\":2,\"484\":9,\"485\":4,\"501\":2,\"510\":4,\"527\":3,\"553\":3,\"703\":2,\"745\":2,\"1035\":2,\"1177\":1,\"1190\":2,\"1202\":1,\"1255\":1,\"1256\":1}}],[\"nru\",{\"1\":{\"160\":2}}],[\"nio或者non\",{\"1\":{\"829\":1}}],[\"nio\",{\"0\":{\"377\":2,\"380\":1},\"1\":{\"138\":1,\"297\":1,\"377\":6,\"379\":1,\"380\":2}}],[\"n\",{\"0\":{\"934\":1,\"935\":1,\"937\":1,\"948\":2},\"1\":{\"96\":2,\"121\":1,\"130\":1,\"310\":1,\"381\":2,\"394\":2,\"401\":1,\"406\":1,\"426\":1,\"428\":2,\"429\":2,\"434\":1,\"435\":1,\"477\":2,\"489\":1,\"536\":1,\"558\":2,\"571\":2,\"622\":1,\"624\":4,\"627\":1,\"628\":1,\"630\":1,\"647\":2,\"877\":1,\"891\":1,\"893\":5,\"901\":1,\"902\":1,\"919\":2,\"927\":3,\"930\":6,\"931\":9,\"932\":3,\"934\":2,\"937\":1,\"943\":4,\"946\":2,\"948\":3,\"949\":2,\"951\":2,\"953\":3,\"1144\":2}}],[\"noevication\",{\"1\":{\"706\":1}}],[\"noeviction\",{\"1\":{\"636\":1}}],[\"no\",{\"1\":{\"563\":1,\"613\":1,\"650\":2,\"707\":1,\"1144\":2,\"1168\":1,\"1266\":1}}],[\"none\",{\"1\":{\"1188\":2}}],[\"non\",{\"1\":{\"203\":1}}],[\"nonfairtryacquire\",{\"1\":{\"96\":1}}],[\"nonfairsync和fairsync是基于sync扩展的子类\",{\"1\":{\"95\":1}}],[\"nodejs\",{\"0\":{\"1212\":1},\"1\":{\"1139\":1,\"1209\":1,\"1212\":3}}],[\"nodes\",{\"1\":{\"638\":1}}],[\"node<k\",{\"1\":{\"399\":1}}],[\"node\",{\"0\":{\"1212\":2},\"1\":{\"110\":1,\"111\":1,\"130\":2,\"131\":1,\"395\":1,\"399\":1,\"406\":1,\"410\":1,\"412\":1,\"908\":6,\"956\":4,\"1139\":1,\"1212\":5}}],[\"notation\",{\"1\":{\"1035\":1}}],[\"notify方法也依赖于monitor对象\",{\"1\":{\"85\":1}}],[\"notifyall\",{\"1\":{\"37\":1,\"38\":2,\"350\":3}}],[\"notify\",{\"0\":{\"36\":1},\"1\":{\"35\":2,\"36\":3,\"37\":1,\"38\":2,\"85\":1,\"88\":3,\"94\":1,\"126\":1,\"350\":3,\"801\":1}}],[\"not\",{\"1\":{\"18\":1,\"160\":1,\"560\":1,\"601\":4,\"669\":1,\"740\":1,\"1266\":1,\"1275\":1}}],[\"numpy\",{\"1\":{\"1108\":1}}],[\"numpartitions\",{\"1\":{\"867\":2}}],[\"number\",{\"1\":{\"428\":3,\"481\":2,\"703\":1,\"856\":1}}],[\"numberformatexception\",{\"1\":{\"385\":1}}],[\"num++会让\",{\"1\":{\"383\":1}}],[\"num\",{\"1\":{\"383\":2,\"900\":3}}],[\"nums=new\",{\"1\":{\"951\":1}}],[\"nums\",{\"1\":{\"6\":1,\"911\":5,\"912\":7,\"913\":6,\"933\":5,\"935\":35,\"936\":24,\"951\":2,\"953\":2}}],[\"nullpointerexception\",{\"1\":{\"58\":1,\"385\":1}}],[\"null\",{\"1\":{\"46\":3,\"58\":3,\"85\":1,\"87\":2,\"89\":1,\"96\":2,\"101\":4,\"102\":1,\"300\":1,\"301\":1,\"368\":1,\"398\":1,\"399\":1,\"407\":3,\"412\":3,\"517\":1,\"535\":5,\"547\":1,\"556\":1,\"601\":3,\"619\":1,\"626\":1,\"641\":4,\"664\":2,\"702\":1,\"908\":5,\"921\":1,\"927\":1,\"930\":1,\"932\":1,\"934\":1,\"937\":1,\"955\":2,\"956\":5,\"1035\":1,\"1067\":4,\"1068\":4,\"1091\":2,\"1155\":1,\"1260\":2,\"1261\":2}}],[\"nested\",{\"1\":{\"740\":1}}],[\"never\",{\"1\":{\"740\":1}}],[\"network\",{\"1\":{\"995\":1}}],[\"netty\",{\"0\":{\"685\":1},\"1\":{\"685\":5,\"804\":1,\"814\":1}}],[\"netstat\",{\"1\":{\"426\":2,\"435\":3}}],[\"net\",{\"1\":{\"181\":1,\"459\":2,\"1143\":2}}],[\"netframework\",{\"1\":{\"18\":1}}],[\"nextlong\",{\"1\":{\"953\":2}}],[\"nextline\",{\"1\":{\"952\":1,\"954\":1}}],[\"nextint\",{\"1\":{\"951\":5,\"953\":1,\"954\":3}}],[\"next\",{\"0\":{\"505\":1},\"1\":{\"491\":1,\"505\":2,\"515\":3,\"523\":1,\"622\":1,\"626\":1,\"955\":6,\"957\":1}}],[\"next都由\",{\"1\":{\"130\":1}}],[\"nextc\",{\"1\":{\"96\":3}}],[\"need\",{\"1\":{\"98\":2}}],[\"newproduct\",{\"1\":{\"1079\":1}}],[\"newproxyinstance\",{\"1\":{\"349\":3,\"725\":1,\"1083\":1}}],[\"newratio=4\",{\"1\":{\"322\":1}}],[\"newinvokespecial四种类型的方法句柄\",{\"1\":{\"174\":1}}],[\"newinstance\",{\"1\":{\"174\":1,\"349\":1,\"356\":2}}],[\"newcondition\",{\"1\":{\"125\":1,\"126\":1}}],[\"newcachedthreadpool\",{\"1\":{\"56\":2}}],[\"news\",{\"1\":{\"601\":1}}],[\"newsid=\",{\"1\":{\"601\":1}}],[\"newsid\",{\"1\":{\"601\":8}}],[\"newsize=1024m\",{\"1\":{\"322\":1}}],[\"newsinglethreadexecutor\",{\"1\":{\"56\":1}}],[\"newstate\",{\"1\":{\"110\":2}}],[\"newscheduledthreadpool\",{\"1\":{\"56\":1}}],[\"newfixedthreadpool\",{\"1\":{\"56\":1}}],[\"new\",{\"0\":{\"399\":1},\"1\":{\"31\":6,\"38\":1,\"39\":2,\"58\":2,\"59\":2,\"81\":1,\"96\":2,\"98\":7,\"101\":2,\"126\":1,\"148\":1,\"174\":2,\"202\":2,\"209\":1,\"212\":1,\"223\":1,\"227\":2,\"277\":3,\"304\":2,\"368\":4,\"390\":1,\"394\":7,\"714\":1,\"729\":1,\"736\":1,\"740\":1,\"908\":4,\"934\":1,\"938\":1,\"951\":1,\"952\":1,\"953\":2,\"954\":2,\"955\":4,\"956\":2,\"1066\":2,\"1067\":4,\"1068\":2,\"1069\":1,\"1076\":1,\"1077\":7,\"1082\":2,\"1083\":1,\"1260\":1,\"1261\":2}}],[\"a还是得接收\",{\"1\":{\"1026\":1}}],[\"a到b向的连接就释放了\",{\"1\":{\"1026\":1}}],[\"a收到b的确认后\",{\"1\":{\"1026\":1}}],[\"a将不再等待包3的计时器\",{\"1\":{\"1019\":1}}],[\"aqm\",{\"1\":{\"1019\":1}}],[\"aqs\",{\"0\":{\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"116\":1},\"1\":{\"78\":1,\"81\":3,\"94\":1,\"109\":3,\"110\":5,\"111\":1,\"112\":1,\"115\":2,\"118\":1,\"120\":2,\"125\":1,\"131\":1}}],[\"ai\",{\"1\":{\"919\":2,\"1255\":1}}],[\"aio\",{\"0\":{\"380\":1},\"1\":{\"380\":1}}],[\"a0\",{\"1\":{\"919\":1}}],[\"a0vsb0\",{\"1\":{\"896\":1}}],[\"avg=sc\",{\"1\":{\"951\":1}}],[\"avl\",{\"0\":{\"916\":1},\"1\":{\"916\":1}}],[\"available\",{\"1\":{\"871\":1}}],[\"availability\",{\"1\":{\"870\":1}}],[\"a999vsb999\",{\"1\":{\"896\":1}}],[\"a999\",{\"1\":{\"896\":1}}],[\"a系统处理完业务\",{\"1\":{\"841\":1}}],[\"a需要依赖\",{\"1\":{\"718\":1}}],[\"a不需要知道\",{\"1\":{\"718\":1}}],[\"a中需要一个connection\",{\"1\":{\"718\":1}}],[\"aof即可\",{\"1\":{\"651\":1}}],[\"aof持久化文件\",{\"1\":{\"649\":1}}],[\"aof\",{\"0\":{\"649\":1,\"650\":1,\"651\":1,\"652\":1,\"707\":1},\"1\":{\"646\":1,\"647\":2,\"648\":1,\"649\":3,\"650\":3,\"651\":16,\"652\":5,\"653\":9,\"708\":3}}],[\"aop实现的四种方式\",{\"0\":{\"728\":1}}],[\"aop中的代理说是由aop框架动态生成的一个对象\",{\"1\":{\"724\":1}}],[\"aop代理的两种方式\",{\"0\":{\"724\":1}}],[\"aop相关术语\",{\"1\":{\"721\":1}}],[\"aop的基本概念\",{\"0\":{\"721\":1}}],[\"aop的区别\",{\"0\":{\"720\":1}}],[\"aop的底层是动态代理技术\",{\"1\":{\"718\":1}}],[\"aop就是在方法前后增加非业务代码\",{\"1\":{\"718\":1}}],[\"aop就会使用cglib来动态代理目标类\",{\"1\":{\"715\":1}}],[\"aop是基于动态代理的\",{\"1\":{\"715\":1}}],[\"aop\",{\"0\":{\"718\":1,\"722\":1},\"1\":{\"349\":1,\"715\":1,\"717\":1,\"718\":2,\"719\":2,\"720\":7,\"725\":5,\"726\":2,\"742\":2,\"1083\":1}}],[\"autoconfigurationimportselector\",{\"1\":{\"771\":1}}],[\"autocommit=1\",{\"1\":{\"526\":1}}],[\"autocommit=0\",{\"1\":{\"526\":2}}],[\"autowired配合使用\",{\"1\":{\"743\":1}}],[\"autowired\",{\"1\":{\"743\":1}}],[\"autoproxy>来配置\",{\"1\":{\"728\":1}}],[\"auto\",{\"1\":{\"601\":1}}],[\"a7\",{\"1\":{\"559\":1}}],[\"a1vsb1\",{\"1\":{\"896\":1}}],[\"a1\",{\"1\":{\"559\":2,\"896\":1,\"919\":1}}],[\"a5\",{\"1\":{\"559\":2}}],[\"aa\",{\"1\":{\"559\":1}}],[\"a8\",{\"1\":{\"559\":1}}],[\"ae\",{\"1\":{\"559\":3}}],[\"af\",{\"1\":{\"559\":3}}],[\"aftermapping\",{\"1\":{\"1257\":2}}],[\"aftercompletion\",{\"1\":{\"759\":1}}],[\"after\",{\"0\":{\"1257\":1},\"1\":{\"412\":1,\"657\":1,\"677\":1,\"722\":3}}],[\"a245\",{\"1\":{\"559\":1}}],[\"a2\",{\"1\":{\"559\":2}}],[\"a=2\",{\"1\":{\"533\":1}}],[\"aggregate\",{\"0\":{\"1243\":1}}],[\"aggregation\",{\"0\":{\"1098\":1}}],[\"ago\",{\"1\":{\"449\":1}}],[\"agent\",{\"1\":{\"1038\":2,\"1039\":1}}],[\"age=10\",{\"1\":{\"553\":1}}],[\"age\",{\"1\":{\"124\":1,\"484\":4,\"553\":3}}],[\"amend\",{\"1\":{\"448\":2}}],[\"ahead\",{\"1\":{\"489\":1,\"569\":1}}],[\"ahskm\",{\"1\":{\"441\":1}}],[\"ahikhtm\",{\"1\":{\"441\":1}}],[\"aliyun\",{\"1\":{\"1184\":2}}],[\"alibaba\",{\"1\":{\"1167\":1}}],[\"alive\",{\"1\":{\"1038\":1,\"1039\":1,\"1042\":1}}],[\"alias\",{\"1\":{\"510\":2}}],[\"alpha\",{\"1\":{\"1012\":2}}],[\"always\",{\"1\":{\"650\":2,\"707\":1}}],[\"alter\",{\"1\":{\"501\":1,\"527\":1,\"554\":2}}],[\"alert\",{\"1\":{\"462\":1}}],[\"allenums\",{\"1\":{\"1260\":2}}],[\"allof\",{\"1\":{\"1260\":1}}],[\"allowed\",{\"1\":{\"1177\":1}}],[\"allocate\",{\"1\":{\"378\":1}}],[\"allkeys\",{\"1\":{\"636\":2,\"706\":3}}],[\"all\",{\"0\":{\"480\":1},\"1\":{\"433\":1,\"452\":1,\"480\":1,\"485\":3,\"556\":1,\"702\":1,\"856\":1}}],[\"al\",{\"1\":{\"419\":1}}],[\"adapter\",{\"1\":{\"1092\":1,\"1222\":1}}],[\"adaptee\",{\"1\":{\"1092\":1}}],[\"adsl技术\",{\"1\":{\"968\":1}}],[\"advice\",{\"1\":{\"721\":3,\"728\":1,\"742\":1}}],[\"ad\",{\"1\":{\"559\":1}}],[\"administrator\",{\"1\":{\"559\":1}}],[\"adfilprsu\",{\"1\":{\"423\":1}}],[\"addr\",{\"1\":{\"886\":1}}],[\"addressing\",{\"1\":{\"884\":1}}],[\"address\",{\"1\":{\"446\":1,\"995\":1,\"1177\":1}}],[\"addpathpatterns\",{\"1\":{\"759\":1}}],[\"add\",{\"1\":{\"304\":1,\"393\":1,\"413\":1,\"447\":4,\"452\":2,\"462\":1,\"527\":1,\"554\":2,\"645\":1,\"908\":1,\"1126\":1,\"1127\":1,\"1143\":3,\"1212\":1}}],[\"adodb\",{\"1\":{\"18\":1}}],[\"attrs\",{\"1\":{\"1162\":1}}],[\"attributeerror\",{\"1\":{\"1144\":1}}],[\"attribute\",{\"1\":{\"736\":1,\"1144\":1,\"1266\":1}}],[\"attributes\",{\"1\":{\"289\":1,\"290\":1}}],[\"aton\",{\"1\":{\"997\":1}}],[\"atomicity\",{\"1\":{\"519\":1}}],[\"atomicstampedreference\",{\"1\":{\"106\":1}}],[\"atomic\",{\"1\":{\"68\":1,\"103\":1,\"144\":1}}],[\"at\",{\"1\":{\"563\":1,\"568\":1,\"582\":2,\"856\":3,\"1177\":1}}],[\"apache\",{\"1\":{\"790\":1,\"825\":2,\"1038\":1,\"1179\":1}}],[\"appdata\",{\"1\":{\"1143\":1}}],[\"appearances\",{\"1\":{\"891\":1}}],[\"appendonly\",{\"1\":{\"707\":1,\"708\":1}}],[\"appendfsync\",{\"1\":{\"650\":3,\"708\":1}}],[\"append\",{\"0\":{\"371\":1,\"649\":1},\"1\":{\"202\":4,\"707\":1}}],[\"app跑在里面的东西\",{\"1\":{\"825\":1}}],[\"appnedfsync\",{\"1\":{\"707\":1}}],[\"applicationobjectsupport\",{\"1\":{\"736\":1}}],[\"applicationcontext加载的\",{\"1\":{\"783\":1}}],[\"applicationcontextaware\",{\"1\":{\"736\":1}}],[\"applicationcontext的三个实现类\",{\"1\":{\"712\":1}}],[\"applicationcontext的对比\",{\"1\":{\"712\":1}}],[\"applicationcontext在容器启动时\",{\"1\":{\"712\":1}}],[\"applicationcontext接口作为beanfactory的子类\",{\"1\":{\"712\":1}}],[\"applicationcontext\",{\"1\":{\"712\":4,\"733\":1,\"736\":10,\"742\":1}}],[\"application\",{\"0\":{\"1238\":1},\"1\":{\"175\":1,\"736\":1,\"783\":2,\"825\":1,\"891\":1}}],[\"applet\",{\"1\":{\"168\":1}}],[\"api\",{\"1\":{\"32\":1,\"184\":1,\"379\":2,\"489\":1,\"603\":1,\"607\":1,\"624\":1,\"637\":1,\"691\":1,\"717\":1,\"806\":1}}],[\"await\",{\"1\":{\"118\":4,\"126\":2,\"1159\":1}}],[\"abs\",{\"1\":{\"949\":1}}],[\"abstractproduct\",{\"1\":{\"1079\":1}}],[\"abstractfactory\",{\"1\":{\"1079\":1}}],[\"abstractmap\",{\"1\":{\"407\":1}}],[\"abstractmethoderror异常\",{\"1\":{\"278\":1}}],[\"abstract\",{\"1\":{\"109\":1,\"362\":2}}],[\"abstractqueuedsynchronizer\",{\"1\":{\"109\":2}}],[\"abc\",{\"1\":{\"477\":1}}],[\"abentv\",{\"1\":{\"428\":1}}],[\"aba\",{\"0\":{\"106\":1},\"1\":{\"106\":3}}],[\"abortpolicy\",{\"1\":{\"60\":1}}],[\"acm\",{\"0\":{\"950\":1}}],[\"ack报文段可以携带数据\",{\"1\":{\"1022\":1}}],[\"ack\",{\"1\":{\"1004\":3,\"1013\":1,\"1022\":2,\"1026\":4,\"1027\":5}}],[\"ack=1\",{\"1\":{\"866\":1,\"1022\":1}}],[\"ack=0不重试\",{\"1\":{\"866\":1}}],[\"ack=all\",{\"1\":{\"866\":1}}],[\"ack机制\",{\"0\":{\"854\":1}}],[\"activity\",{\"1\":{\"1271\":1}}],[\"activate\",{\"1\":{\"1144\":1,\"1182\":1}}],[\"active\",{\"1\":{\"26\":1}}],[\"actions\",{\"1\":{\"1198\":1,\"1199\":1}}],[\"action\",{\"0\":{\"1199\":1},\"1\":{\"759\":1,\"1115\":1,\"1199\":1}}],[\"ac2\",{\"1\":{\"736\":2}}],[\"ac1\",{\"1\":{\"736\":2}}],[\"ac\",{\"1\":{\"736\":2,\"1026\":1}}],[\"acid被打破\",{\"1\":{\"585\":1}}],[\"acid\",{\"0\":{\"519\":1},\"1\":{\"456\":1,\"519\":1,\"522\":1,\"741\":1}}],[\"acquire方法之外\",{\"1\":{\"117\":1}}],[\"acquire\",{\"1\":{\"117\":3}}],[\"acquireshared\",{\"1\":{\"123\":1}}],[\"acquires\",{\"1\":{\"96\":2}}],[\"accept\",{\"1\":{\"377\":1,\"1038\":5,\"1039\":4}}],[\"access\",{\"1\":{\"289\":1,\"290\":1,\"1178\":2}}],[\"acct\",{\"1\":{\"227\":2}}],[\"account\",{\"1\":{\"227\":2}}],[\"acc\",{\"1\":{\"82\":1}}],[\"async\",{\"1\":{\"1159\":2}}],[\"association\",{\"0\":{\"1097\":1}}],[\"assigned\",{\"1\":{\"853\":1}}],[\"assign\",{\"1\":{\"73\":2,\"74\":1,\"294\":1,\"295\":1}}],[\"aspect\",{\"1\":{\"721\":3}}],[\"aspectj的注解来标识通知及切入点\",{\"1\":{\"728\":1}}],[\"aspectj\",{\"1\":{\"720\":6,\"725\":1,\"728\":1}}],[\"ascii\",{\"1\":{\"426\":1,\"1190\":2}}],[\"as\",{\"0\":{\"76\":1,\"77\":1},\"1\":{\"76\":3,\"77\":1,\"510\":2,\"601\":2,\"703\":2}}],[\"archive\",{\"1\":{\"1170\":1}}],[\"arq\",{\"0\":{\"1011\":1},\"1\":{\"1009\":1,\"1011\":3}}],[\"arp进程先在本局域网上广播发送一个arp请求分组\",{\"1\":{\"986\":1}}],[\"arp在最下面是因为ip要经常使用这个协议\",{\"1\":{\"983\":1}}],[\"arp\",{\"1\":{\"961\":1,\"986\":4}}],[\"arp协议\",{\"1\":{\"959\":1,\"1029\":1}}],[\"arr\",{\"1\":{\"930\":11,\"931\":21,\"932\":12,\"933\":14,\"934\":19,\"935\":16,\"937\":24,\"955\":3}}],[\"arrayinput\",{\"1\":{\"953\":1}}],[\"array\",{\"1\":{\"935\":12,\"1035\":1}}],[\"arrayduque<>\",{\"1\":{\"394\":1}}],[\"arraydeque通常作为栈或队列使用\",{\"1\":{\"394\":1}}],[\"arraycopy\",{\"1\":{\"393\":1}}],[\"arrays\",{\"0\":{\"938\":1},\"1\":{\"390\":1,\"938\":1,\"951\":1,\"953\":1}}],[\"arraylist\",{\"0\":{\"392\":1,\"393\":1},\"1\":{\"304\":1,\"391\":7,\"392\":2,\"393\":11}}],[\"arrayblockingqueue\",{\"1\":{\"62\":1}}],[\"ar\",{\"0\":{\"853\":1},\"1\":{\"853\":1}}],[\"article\",{\"1\":{\"1143\":2}}],[\"artifactid\",{\"1\":{\"795\":1}}],[\"artifactid>\",{\"1\":{\"776\":1,\"790\":2,\"795\":1,\"796\":1,\"800\":3,\"882\":1}}],[\"arthas\",{\"1\":{\"313\":1}}],[\"around\",{\"1\":{\"722\":1}}],[\"args就是调度方法的参数\",{\"1\":{\"725\":1}}],[\"args\",{\"1\":{\"31\":1,\"98\":1,\"227\":1,\"277\":1,\"349\":2,\"935\":1,\"951\":1,\"952\":1,\"953\":1,\"955\":1,\"956\":1,\"1077\":2,\"1082\":1}}],[\"a>\",{\"1\":{\"26\":1}}],[\"ananconda\",{\"1\":{\"1186\":1}}],[\"anaconda3\",{\"1\":{\"1144\":1}}],[\"anaconda\",{\"0\":{\"1110\":1},\"1\":{\"1143\":3}}],[\"analysis\",{\"1\":{\"202\":1}}],[\"ant\",{\"1\":{\"1148\":2}}],[\"antvg2\",{\"1\":{\"687\":1}}],[\"antdv\",{\"1\":{\"687\":1}}],[\"ansic\",{\"1\":{\"603\":1}}],[\"ansi\",{\"1\":{\"475\":1}}],[\"anp|grep\",{\"1\":{\"435\":1}}],[\"anp\",{\"1\":{\"435\":1}}],[\"and\",{\"0\":{\"105\":1},\"1\":{\"486\":3,\"533\":5,\"553\":2,\"601\":1,\"745\":2,\"997\":1,\"1200\":1,\"1202\":1,\"1266\":1}}],[\"an\",{\"1\":{\"18\":1,\"919\":1}}],[\"a\",{\"1\":{\"18\":3,\"72\":3,\"75\":3,\"102\":2,\"105\":2,\"106\":3,\"335\":1,\"355\":2,\"367\":1,\"390\":2,\"419\":1,\"423\":1,\"426\":4,\"427\":11,\"433\":3,\"435\":1,\"441\":1,\"448\":1,\"451\":1,\"482\":1,\"485\":2,\"509\":4,\"514\":1,\"521\":3,\"533\":5,\"551\":4,\"559\":2,\"601\":9,\"683\":6,\"718\":4,\"798\":1,\"801\":2,\"807\":1,\"870\":1,\"871\":1,\"888\":2,\"891\":2,\"947\":14,\"949\":2,\"977\":1,\"1022\":1,\"1027\":2,\"1057\":1,\"1098\":1,\"1099\":1,\"1100\":1,\"1155\":1,\"1157\":1,\"1190\":1,\"1216\":1,\"1261\":6,\"1266\":1}}],[\"项目应用\",{\"0\":{\"1258\":1}}],[\"项目搭建\",{\"0\":{\"1147\":1}}],[\"项目配置文件\",{\"1\":{\"788\":1}}],[\"项目吗\",{\"0\":{\"788\":1}}],[\"项目的自动化配置\",{\"1\":{\"783\":1}}],[\"项目的启动注解是\",{\"1\":{\"771\":1}}],[\"项目组件封装的时候\",{\"1\":{\"695\":1}}],[\"项目中我会封装一些公共组件\",{\"1\":{\"692\":1}}],[\"项目初期没有前端\",{\"1\":{\"690\":1}}],[\"项目已进入试用\",{\"1\":{\"689\":1}}],[\"项目已进入客户环境部署\",{\"1\":{\"689\":1}}],[\"项目和\",{\"1\":{\"689\":1}}],[\"项目得以成功运行\",{\"1\":{\"18\":1}}],[\"项目\",{\"1\":{\"18\":1,\"1202\":1}}],[\"的地址\",{\"1\":{\"1270\":1}}],[\"的地址找到\",{\"1\":{\"89\":1}}],[\"的东西\",{\"1\":{\"1219\":1}}],[\"的教程去装https\",{\"1\":{\"1170\":1}}],[\"的宽高问题\",{\"1\":{\"1163\":1}}],[\"的版本\",{\"1\":{\"1140\":1}}],[\"的版本锁定在2\",{\"1\":{\"1139\":1}}],[\"的版本库里存了很多东西\",{\"1\":{\"444\":1}}],[\"的版本库\",{\"1\":{\"444\":1}}],[\"的修改推送到远端\",{\"1\":{\"1127\":1}}],[\"的合并\",{\"1\":{\"1127\":1}}],[\"的合并冲突\",{\"1\":{\"1126\":1}}],[\"的合理设计来提高\",{\"1\":{\"678\":1}}],[\"的域名被污染\",{\"1\":{\"1124\":1}}],[\"的四个工作区域\",{\"1\":{\"1121\":1}}],[\"的自增索引作为主键\",{\"1\":{\"1117\":1}}],[\"的自增索引为主键\",{\"1\":{\"1117\":1}}],[\"的自然顺序或者comprator\",{\"1\":{\"412\":1}}],[\"的典型应用\",{\"1\":{\"1090\":1}}],[\"的模式\",{\"1\":{\"1085\":1}}],[\"的产品\",{\"1\":{\"1079\":1}}],[\"的公钥发送给了了\",{\"1\":{\"1057\":1}}],[\"的多路数据流\",{\"1\":{\"1042\":1}}],[\"的多路复⽤只会阻塞在\",{\"1\":{\"137\":1}}],[\"的名称中虽然带有javascript\",{\"1\":{\"1035\":1}}],[\"的整体过程分为证书验证和数据传输阶段\",{\"1\":{\"1044\":1}}],[\"的整个过程是既使用\",{\"1\":{\"1033\":1}}],[\"的整数幂\",{\"1\":{\"405\":1}}],[\"的整数次方\",{\"0\":{\"404\":1},\"1\":{\"399\":1}}],[\"的拥塞控制采用了四种算法\",{\"1\":{\"1019\":1}}],[\"的接收端只允许发送端发送接收端缓冲区能接纳的数据\",{\"1\":{\"1009\":1}}],[\"的接收端会丢弃重复的数据\",{\"1\":{\"1009\":1}}],[\"的接口和抽象类\",{\"1\":{\"362\":1}}],[\"的重要功能转移到用户空间来实现\",{\"1\":{\"1004\":1}}],[\"的包\",{\"1\":{\"1004\":1}}],[\"的更小\",{\"1\":{\"996\":1}}],[\"的更新操作\",{\"1\":{\"608\":1}}],[\"的路由表相比\",{\"1\":{\"996\":1}}],[\"的路径名\",{\"1\":{\"427\":1}}],[\"的转发\",{\"1\":{\"986\":1}}],[\"的最小值\",{\"1\":{\"982\":1}}],[\"的最左前缀匹配特性\",{\"1\":{\"534\":1}}],[\"的次幂\",{\"1\":{\"948\":1}}],[\"的次数取决于树的高度\",{\"1\":{\"916\":1}}],[\"的特性\",{\"1\":{\"941\":1}}],[\"的特点\",{\"1\":{\"380\":2}}],[\"的父节点是\",{\"1\":{\"937\":1}}],[\"的父类构成的\",{\"1\":{\"345\":1}}],[\"的左孩子的下标是\",{\"1\":{\"937\":1}}],[\"的算法\",{\"1\":{\"933\":1}}],[\"的算法对计算后得出一个结果\",{\"1\":{\"659\":1}}],[\"的散列函数公式\",{\"1\":{\"923\":1}}],[\"的关系\",{\"1\":{\"1098\":1,\"1100\":1}}],[\"的关系来实现的\",{\"1\":{\"184\":1}}],[\"的关键字\",{\"1\":{\"920\":1}}],[\"的个数\",{\"1\":{\"919\":1}}],[\"的范围为\",{\"1\":{\"919\":1}}],[\"的总量是有限的\",{\"1\":{\"895\":1}}],[\"的技巧上\",{\"0\":{\"886\":1}}],[\"的思想\",{\"0\":{\"886\":1},\"1\":{\"892\":1}}],[\"的要求之一就是安全性不依赖于时间\",{\"1\":{\"879\":1}}],[\"的信息\",{\"1\":{\"878\":1}}],[\"的有效信息\",{\"1\":{\"877\":1}}],[\"的有序可以按两种顺序排列\",{\"1\":{\"414\":1}}],[\"的有序性也是在其保护的代码块中\",{\"1\":{\"71\":1}}],[\"的选举\",{\"1\":{\"877\":1}}],[\"的请求都能使用额外的参数\",{\"1\":{\"1041\":1}}],[\"的请求\",{\"1\":{\"874\":1,\"1044\":1}}],[\"的心跳和日志同步数据\",{\"1\":{\"874\":1}}],[\"的读请求都能得到一致性的结果\",{\"1\":{\"870\":1}}],[\"的读操作压力\",{\"1\":{\"656\":1}}],[\"的不同\",{\"1\":{\"861\":1}}],[\"的不足\",{\"0\":{\"119\":1}}],[\"的幂等性实现\",{\"1\":{\"856\":1}}],[\"的幂次数\",{\"1\":{\"404\":1}}],[\"的背后\",{\"1\":{\"825\":1}}],[\"的注册监听器列表中将注册的监听事件添加到列表中\",{\"1\":{\"822\":1}}],[\"的注解实现缓存的话\",{\"1\":{\"607\":1}}],[\"的监听原理是什么\",{\"0\":{\"822\":1}}],[\"的监视器方法\",{\"1\":{\"126\":1}}],[\"的编号大\",{\"1\":{\"820\":1}}],[\"的编号最大\",{\"1\":{\"820\":1}}],[\"的编译器\",{\"1\":{\"283\":1}}],[\"的投票数并没有大于集群半数\",{\"1\":{\"820\":1}}],[\"的部署方式有哪几种\",{\"0\":{\"819\":1}}],[\"的动态代理技术\",{\"1\":{\"804\":1}}],[\"的服务员可以根据顾客的要求\",{\"1\":{\"1086\":1}}],[\"的服务注册流程\",{\"0\":{\"811\":1}}],[\"的服务列表\",{\"1\":{\"802\":1}}],[\"的服务器和客户端\",{\"1\":{\"685\":1}}],[\"的情况\",{\"1\":{\"802\":1}}],[\"的情况下\",{\"1\":{\"630\":1,\"852\":1,\"1067\":1}}],[\"的配置信息\",{\"1\":{\"771\":1}}],[\"的控制器是不是单例模式\",{\"0\":{\"757\":1}}],[\"的入参过程中\",{\"1\":{\"755\":1}}],[\"的简称\",{\"1\":{\"754\":1}}],[\"的增强或通知\",{\"1\":{\"742\":1}}],[\"的增删未必就是比\",{\"1\":{\"393\":1}}],[\"的几个连接数\",{\"0\":{\"836\":1}}],[\"的几种方式\",{\"1\":{\"736\":1}}],[\"的几款垃圾收集器都展现出了面向全区域收集设计的思想\",{\"1\":{\"240\":1}}],[\"的创建\",{\"1\":{\"713\":1}}],[\"的概念\",{\"1\":{\"679\":1}}],[\"的客观下线状态就会变成主观下线\",{\"1\":{\"677\":1}}],[\"的确进入了主观下线状态\",{\"1\":{\"677\":2}}],[\"的奇数个\",{\"1\":{\"676\":1}}],[\"的节点数量要满足\",{\"1\":{\"676\":1}}],[\"的生存时间\",{\"1\":{\"669\":1}}],[\"的生命周期跟\",{\"1\":{\"45\":1}}],[\"的过期时间\",{\"1\":{\"668\":1}}],[\"的过程了\",{\"1\":{\"894\":1}}],[\"的过程\",{\"1\":{\"718\":1}}],[\"的过程最终\",{\"1\":{\"623\":1}}],[\"的过程中线程会释放锁\",{\"1\":{\"35\":1}}],[\"的连接\",{\"1\":{\"662\":1,\"868\":1}}],[\"的连接和同步请求\",{\"1\":{\"656\":1}}],[\"的角色提升\",{\"1\":{\"660\":1,\"678\":1}}],[\"的从节点有对节点做主观下线操作\",{\"1\":{\"676\":1}}],[\"的从节点\",{\"1\":{\"659\":1}}],[\"的每一个节点上\",{\"1\":{\"659\":1}}],[\"的每⼀⼩块区域形成\",{\"1\":{\"247\":1}}],[\"的分页插件工具\",{\"1\":{\"753\":1}}],[\"的分布式锁有什么缺陷\",{\"0\":{\"670\":1}}],[\"的分布式存储\",{\"1\":{\"659\":1,\"678\":1}}],[\"的分段锁机制实现线程安全\",{\"1\":{\"130\":1}}],[\"的哨兵模式基本已经可以实现高可用\",{\"1\":{\"659\":1,\"678\":1}}],[\"的主观下线状态就会被移除\",{\"1\":{\"677\":1}}],[\"的主从复制\",{\"0\":{\"661\":1}}],[\"的主节点和从节点中的数据是一样的\",{\"1\":{\"656\":1}}],[\"的主键索引与辅助键索引的区别就是\",{\"1\":{\"547\":1}}],[\"的同步压力\",{\"1\":{\"656\":1}}],[\"的快\",{\"1\":{\"648\":1}}],[\"的快捷方式\",{\"1\":{\"427\":1}}],[\"的操作都采用\",{\"1\":{\"647\":1}}],[\"的操作来减少\",{\"1\":{\"118\":1}}],[\"的原则\",{\"1\":{\"940\":1}}],[\"的原理\",{\"1\":{\"647\":1}}],[\"的原因\",{\"1\":{\"606\":1}}],[\"的原因是为了将\",{\"1\":{\"342\":1}}],[\"的持久化文件\",{\"1\":{\"651\":1}}],[\"的持久化文件越来越大怎么办\",{\"1\":{\"651\":1}}],[\"的持久化\",{\"0\":{\"646\":1}}],[\"的级别\",{\"1\":{\"645\":1}}],[\"的位置就是倒数第\",{\"1\":{\"927\":1}}],[\"的位置进行判断时此时instance不为空\",{\"1\":{\"714\":1}}],[\"的位置进行判断时此时\",{\"1\":{\"101\":1}}],[\"的位移更新却是一个非常频繁的操作\",{\"1\":{\"860\":1}}],[\"的位向量或位列表\",{\"1\":{\"645\":1}}],[\"的高性能轻量级的\",{\"1\":{\"809\":1}}],[\"的高可用\",{\"1\":{\"642\":1,\"655\":1,\"661\":1}}],[\"的高效在于不需要加锁\",{\"1\":{\"129\":1}}],[\"的直接拦截\",{\"1\":{\"641\":1}}],[\"的底层实现\",{\"1\":{\"626\":1}}],[\"的底层主要采用字典\",{\"1\":{\"622\":1}}],[\"的定义\",{\"1\":{\"624\":1}}],[\"的所有\",{\"1\":{\"677\":1}}],[\"的所有数据都\",{\"1\":{\"623\":1}}],[\"的所有者\",{\"1\":{\"85\":1}}],[\"的键值对数组上\",{\"1\":{\"623\":1}}],[\"的添加\",{\"1\":{\"622\":1}}],[\"的映射表\",{\"1\":{\"622\":1}}],[\"的标志\",{\"1\":{\"622\":1}}],[\"的系统调用次数\",{\"1\":{\"613\":1}}],[\"的销毁而结束\",{\"1\":{\"609\":1}}],[\"的缓存\",{\"0\":{\"752\":1}}],[\"的缓存是深拷贝还是浅拷贝\",{\"0\":{\"608\":1}}],[\"的缓存状态是正确的\",{\"1\":{\"72\":1}}],[\"的使用心得\",{\"1\":{\"1249\":1}}],[\"的使用方式很像\",{\"1\":{\"607\":1}}],[\"的使用情况\",{\"1\":{\"562\":1}}],[\"的业务集中在\",{\"1\":{\"606\":1}}],[\"的其他功能比如持久化\",{\"1\":{\"604\":1}}],[\"的网络\",{\"1\":{\"604\":1}}],[\"的性能瓶颈不在于\",{\"1\":{\"604\":1}}],[\"的页为\",{\"1\":{\"591\":1}}],[\"的执行效率\",{\"1\":{\"582\":1}}],[\"的执行者是内核线程\",{\"1\":{\"380\":1}}],[\"的执行者是\",{\"1\":{\"380\":1}}],[\"的处理能力\",{\"1\":{\"674\":1}}],[\"的处理\",{\"1\":{\"636\":1}}],[\"的处理过程如下\",{\"1\":{\"578\":1}}],[\"的处理机制了\",{\"1\":{\"578\":1}}],[\"的优点是速度快\",{\"1\":{\"1001\":1}}],[\"的优点是支持嵌套\",{\"1\":{\"23\":1}}],[\"的优缺点\",{\"0\":{\"648\":1}}],[\"的优化机制\",{\"1\":{\"555\":1}}],[\"的格式\",{\"1\":{\"548\":1}}],[\"的格式都有严格规定\",{\"1\":{\"208\":1}}],[\"的唯一索引\",{\"1\":{\"547\":1,\"556\":1}}],[\"的唯一区别就是判断条件中多了对同步队列中当前节点是否有前驱节点的判断\",{\"1\":{\"96\":1}}],[\"的隐式的聚簇索引\",{\"1\":{\"546\":1}}],[\"的查询会与\",{\"1\":{\"623\":1}}],[\"的查询优化器会帮你优化成索引可以识别的形式\",{\"1\":{\"533\":1}}],[\"的查找\",{\"1\":{\"537\":1}}],[\"的哈希值\",{\"1\":{\"537\":1,\"679\":1}}],[\"的列做统计和查询优化很麻烦\",{\"1\":{\"535\":1}}],[\"的索引\",{\"1\":{\"533\":1}}],[\"的索引则都可以用到\",{\"1\":{\"533\":1}}],[\"的命令\",{\"1\":{\"526\":1}}],[\"的事务启动方式有以下几种\",{\"1\":{\"526\":1}}],[\"的库\",{\"1\":{\"525\":1}}],[\"的隔离级别\",{\"1\":{\"522\":1,\"741\":1}}],[\"的并发性\",{\"1\":{\"604\":1}}],[\"的并发读写场景中\",{\"1\":{\"516\":1}}],[\"的并发效率低\",{\"1\":{\"129\":1}}],[\"的策略是\",{\"1\":{\"655\":1}}],[\"的策略\",{\"1\":{\"513\":1}}],[\"的三种写回策略\",{\"0\":{\"650\":1}}],[\"的三种行级锁⭐\",{\"0\":{\"502\":1}}],[\"的三个参数的组合\",{\"1\":{\"430\":1}}],[\"的表的生命周期很短\",{\"1\":{\"494\":1}}],[\"的语法\",{\"1\":{\"490\":1}}],[\"的全称是\",{\"1\":{\"489\":1,\"569\":1}}],[\"的全部约束要求\",{\"1\":{\"170\":1}}],[\"的长度不能超过mtu的值\",{\"1\":{\"987\":1}}],[\"的长度\",{\"1\":{\"478\":1,\"627\":1,\"637\":1}}],[\"的涵义最多存放\",{\"1\":{\"478\":1}}],[\"的计算比浮点类型需要更高的代价\",{\"1\":{\"473\":1}}],[\"的计数器提供\",{\"1\":{\"121\":1}}],[\"的行\",{\"1\":{\"468\":1}}],[\"的暂存区\",{\"1\":{\"444\":1}}],[\"的管道命令是\",{\"1\":{\"438\":1}}],[\"的字符串\",{\"1\":{\"624\":1}}],[\"的字符中\",{\"1\":{\"430\":1}}],[\"的字段数据差分到扩展表\",{\"1\":{\"585\":1}}],[\"的字面意思是可循环使用\",{\"1\":{\"120\":1}}],[\"的倒着写\",{\"1\":{\"428\":1}}],[\"的软链接\",{\"1\":{\"427\":1}}],[\"的功能\",{\"1\":{\"427\":1,\"429\":2,\"825\":1}}],[\"的目录项\",{\"1\":{\"427\":1}}],[\"的目录项中的\",{\"1\":{\"427\":4}}],[\"的目的是传送实体主体内容\",{\"1\":{\"1041\":1}}],[\"的目的是\",{\"1\":{\"101\":1,\"1068\":1}}],[\"的硬链接\",{\"1\":{\"427\":1}}],[\"的意思\",{\"1\":{\"423\":1,\"424\":1}}],[\"的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作\",{\"1\":{\"254\":1}}],[\"的上一级目录的意思\",{\"1\":{\"420\":1}}],[\"的文件系统中\",{\"1\":{\"427\":1}}],[\"的文件\",{\"1\":{\"419\":1,\"442\":1}}],[\"的外部设备\",{\"1\":{\"416\":1}}],[\"的缩写\",{\"1\":{\"416\":5}}],[\"的比较\",{\"1\":{\"412\":1}}],[\"的顺序\",{\"1\":{\"414\":2}}],[\"的顺序进行排序\",{\"1\":{\"412\":1}}],[\"的顺序就是获取许可证的顺序\",{\"1\":{\"117\":1}}],[\"的倍数\",{\"1\":{\"407\":1}}],[\"的数字签名\",{\"1\":{\"1057\":1}}],[\"的数表示\",{\"1\":{\"680\":1}}],[\"的数量\",{\"1\":{\"637\":1}}],[\"的数据报\",{\"1\":{\"993\":1}}],[\"的数据传给\",{\"1\":{\"986\":1}}],[\"的数据\",{\"1\":{\"771\":1}}],[\"的数据节点做失败判定分为主观下线和客观下线两种\",{\"1\":{\"676\":1}}],[\"的数据结构降低外层键的数量\",{\"1\":{\"637\":1}}],[\"的数据只增不减\",{\"1\":{\"623\":1}}],[\"的数据重新映射到哈希表\",{\"1\":{\"615\":1}}],[\"的数据上\",{\"1\":{\"606\":1}}],[\"的数据块中存放的只是\",{\"1\":{\"427\":1}}],[\"的数组长度要取\",{\"1\":{\"405\":1}}],[\"的数值范围是\",{\"1\":{\"368\":1}}],[\"的大小超出一定限制后\",{\"1\":{\"622\":1}}],[\"的大小为\",{\"1\":{\"399\":1}}],[\"的大小然后求和\",{\"1\":{\"129\":1}}],[\"的复制移动速度的如果数据量有百万级的时\",{\"1\":{\"393\":1}}],[\"的消息会被分成多个分区并将其分布在多个\",{\"1\":{\"861\":1}}],[\"的消息会附带sequence\",{\"1\":{\"856\":1}}],[\"的消息传递方式\",{\"1\":{\"381\":1}}],[\"的消耗情况\",{\"1\":{\"558\":1}}],[\"的消耗主要是在移动和复制上\",{\"1\":{\"393\":1}}],[\"的消耗主要是在遍历上\",{\"1\":{\"393\":1}}],[\"的前端开发\",{\"1\":{\"687\":1}}],[\"的前提是\",{\"1\":{\"404\":1}}],[\"的前提下\",{\"1\":{\"45\":1}}],[\"的前驱表项是链表中的最后一个元素\",{\"1\":{\"392\":1}}],[\"的后继表项是链表中的第一个元素\",{\"1\":{\"392\":1}}],[\"的指针进行遍历\",{\"1\":{\"391\":1}}],[\"的遍历速度是要慢于\",{\"1\":{\"393\":1}}],[\"的遍历效率比较\",{\"1\":{\"391\":1}}],[\"的遍历链表\",{\"1\":{\"130\":1}}],[\"的例子\",{\"1\":{\"390\":1}}],[\"的回调机制来激活该\",{\"1\":{\"381\":1}}],[\"的就绪通知方式\",{\"1\":{\"381\":1}}],[\"的返回值小于请求值\",{\"1\":{\"381\":1}}],[\"的返回值等手段检测线程是否已经终止执行\",{\"1\":{\"75\":1,\"102\":1}}],[\"的能力\",{\"1\":{\"379\":1,\"577\":1}}],[\"的源码如下所示\",{\"1\":{\"368\":1}}],[\"的源码中定义了\",{\"1\":{\"38\":1}}],[\"的八种基本数据类型之一\",{\"1\":{\"368\":1}}],[\"的初始化时会执行\",{\"1\":{\"352\":1}}],[\"的初衷就是来屏蔽掉各种硬件和操作系统的内存访问差异\",{\"1\":{\"337\":1}}],[\"的平台无关性\",{\"0\":{\"337\":1}}],[\"的类的对象\",{\"1\":{\"1090\":1}}],[\"的类型的\",{\"1\":{\"345\":1}}],[\"的类不支持多继承\",{\"1\":{\"336\":1}}],[\"的类是单继承的\",{\"1\":{\"336\":1}}],[\"的类名\",{\"1\":{\"26\":1}}],[\"的记录的\",{\"1\":{\"807\":1}}],[\"的记录\",{\"1\":{\"300\":1,\"501\":2}}],[\"的弱引用\",{\"1\":{\"300\":1}}],[\"的堆内存\",{\"1\":{\"297\":1}}],[\"的变量执行写操作\",{\"1\":{\"296\":1}}],[\"的属性里面\",{\"1\":{\"290\":1}}],[\"的含义\",{\"1\":{\"286\":1}}],[\"的额外内存来维持收集器工作\",{\"1\":{\"265\":1}}],[\"的卡表结构\",{\"1\":{\"265\":1}}],[\"的垃圾回收时间\",{\"1\":{\"263\":1}}],[\"的另一个大优势\",{\"1\":{\"261\":1}}],[\"的java堆被活动数据占用\",{\"1\":{\"261\":1}}],[\"的full\",{\"1\":{\"259\":1}}],[\"的空间\",{\"1\":{\"246\":1}}],[\"的集合\",{\"1\":{\"236\":1}}],[\"的i\",{\"1\":{\"209\":1}}],[\"的本质是将接口实现类的全限定名配置在文件中\",{\"1\":{\"185\":1}}],[\"的代码实践中\",{\"1\":{\"1236\":1}}],[\"的代码\",{\"1\":{\"185\":1}}],[\"的核心配置文件是\",{\"1\":{\"783\":1}}],[\"的核心配置文件有哪几个\",{\"0\":{\"783\":1}}],[\"的核心注解\",{\"1\":{\"777\":1}}],[\"的核心注解是哪个\",{\"0\":{\"777\":1}}],[\"的核心组件\",{\"0\":{\"756\":1}}],[\"的核心\",{\"1\":{\"184\":1,\"1217\":1}}],[\"的核数\",{\"1\":{\"64\":1}}],[\"的规则\",{\"1\":{\"168\":1}}],[\"的形式缓存在内存中\",{\"1\":{\"490\":1}}],[\"的形式存在\",{\"1\":{\"381\":1}}],[\"的形式\",{\"1\":{\"156\":1,\"576\":1}}],[\"的零拷贝与传统的文件\",{\"1\":{\"138\":1}}],[\"的状态变量\",{\"1\":{\"1019\":1}}],[\"的状态\",{\"1\":{\"381\":1}}],[\"的状态我们称之为内核态\",{\"1\":{\"134\":1}}],[\"的状态和外观\",{\"1\":{\"26\":1}}],[\"的线程可以把一个\",{\"1\":{\"835\":1}}],[\"的线程安全\",{\"1\":{\"735\":1}}],[\"的线程安全问题\",{\"0\":{\"409\":1}}],[\"的线程模型\",{\"0\":{\"685\":1}}],[\"的线程仅有一个\",{\"1\":{\"582\":1}}],[\"的线程不安全和\",{\"1\":{\"129\":1}}],[\"的线程有可能在进入到可执行状态后马上又被执行\",{\"1\":{\"35\":1}}],[\"的一种数据结构\",{\"1\":{\"840\":1}}],[\"的一种实现\",{\"1\":{\"125\":1}}],[\"的一来一回\",{\"1\":{\"836\":1}}],[\"的一个设计思想\",{\"1\":{\"484\":1}}],[\"的一个关键字\",{\"1\":{\"94\":1}}],[\"的屏障\",{\"1\":{\"120\":1}}],[\"的获取与释放方式即可\",{\"1\":{\"115\":1}}],[\"的结果相比\",{\"1\":{\"406\":1}}],[\"的结点\",{\"1\":{\"111\":1}}],[\"的结构和\",{\"1\":{\"129\":1}}],[\"的结构\",{\"0\":{\"42\":1},\"1\":{\"622\":1,\"627\":1}}],[\"的成员变量\",{\"1\":{\"111\":1}}],[\"的阻塞队列\",{\"1\":{\"109\":1}}],[\"的问题了\",{\"1\":{\"1202\":1}}],[\"的问题在于需要配置大量的参数\",{\"1\":{\"770\":1}}],[\"的问题\",{\"0\":{\"106\":1},\"1\":{\"297\":1,\"495\":1,\"612\":1,\"1042\":1}}],[\"的写入策略\",{\"1\":{\"568\":1}}],[\"的写入机制\",{\"1\":{\"568\":1}}],[\"的写盘次数\",{\"1\":{\"563\":1}}],[\"的写时复制机制\",{\"1\":{\"411\":1}}],[\"的写\",{\"1\":{\"102\":1}}],[\"的构造法中会初始化一个\",{\"1\":{\"413\":1}}],[\"的构造函数来初始化成员变量\",{\"1\":{\"101\":1,\"1068\":1}}],[\"的构造方法\",{\"1\":{\"58\":1}}],[\"的锁打断机制\",{\"1\":{\"98\":1}}],[\"的锁记录\",{\"1\":{\"87\":1}}],[\"的实现\",{\"1\":{\"1231\":1}}],[\"的实现是依赖于\",{\"1\":{\"413\":1}}],[\"的实现是基于\",{\"1\":{\"120\":1}}],[\"的实现原理\",{\"0\":{\"413\":1}}],[\"的实现类\",{\"1\":{\"94\":1}}],[\"的实现方式\",{\"0\":{\"56\":1}}],[\"的时机\",{\"1\":{\"1163\":1}}],[\"的时间内查找到更前的一次操作时使用栈\",{\"1\":{\"942\":1}}],[\"的时间复杂度内完成了对该海量数据的处理\",{\"1\":{\"893\":1}}],[\"的时间复杂度来快速查找到键值对\",{\"1\":{\"614\":1}}],[\"的时间\",{\"1\":{\"672\":1,\"1026\":1}}],[\"的时间用来做gc并且回收\",{\"1\":{\"297\":1}}],[\"的时间单位\",{\"1\":{\"58\":1}}],[\"的时候没有等待\",{\"1\":{\"1212\":1}}],[\"的时候没有加锁\",{\"1\":{\"410\":1}}],[\"的时候会报错\",{\"1\":{\"1201\":1}}],[\"的时候就会执行invoke\",{\"1\":{\"725\":1}}],[\"的时候才会将链表改为红黑树\",{\"1\":{\"401\":1}}],[\"的时候一定要把它的\",{\"1\":{\"381\":1}}],[\"的时候只需要去\",{\"1\":{\"247\":1}}],[\"的时候\",{\"1\":{\"88\":1,\"368\":1,\"410\":2,\"511\":1,\"558\":1,\"568\":3,\"571\":1,\"594\":1,\"632\":1,\"669\":1,\"770\":1,\"1033\":1}}],[\"的对应关系也都是由\",{\"1\":{\"861\":1}}],[\"的对应表\",{\"1\":{\"804\":1}}],[\"的对象写出\",{\"1\":{\"344\":1}}],[\"的对象了\",{\"1\":{\"247\":1}}],[\"的对象包括下面几种\",{\"1\":{\"234\":1}}],[\"的对象作为起点\",{\"1\":{\"234\":1}}],[\"的对象就是不可能再被使用的\",{\"1\":{\"233\":1}}],[\"的对象又有机会重新偏向线程\",{\"1\":{\"88\":1}}],[\"的对比\",{\"0\":{\"40\":1}}],[\"的作用在于分离系统中的各种关注点\",{\"1\":{\"719\":1}}],[\"的作用是保证读写的正确性\",{\"1\":{\"511\":1}}],[\"的作用是什么\",{\"0\":{\"74\":1}}],[\"的作用\",{\"0\":{\"352\":1},\"1\":{\"364\":1}}],[\"的作者发现\",{\"1\":{\"88\":1}}],[\"的值是无效的\",{\"1\":{\"1156\":1}}],[\"的值是作为\",{\"1\":{\"413\":1}}],[\"的值先存到povit中\",{\"1\":{\"935\":1}}],[\"的值对\",{\"1\":{\"680\":1}}],[\"的值\",{\"1\":{\"563\":1,\"680\":1}}],[\"的值回到原表中取出\",{\"1\":{\"484\":1}}],[\"的值不满足查询条件为止\",{\"1\":{\"484\":1}}],[\"的值都是存储在\",{\"1\":{\"413\":1}}],[\"的值为\",{\"1\":{\"383\":1}}],[\"的值恢复给对象头\",{\"1\":{\"87\":1,\"89\":1}}],[\"的值还没写到主存\",{\"1\":{\"72\":1}}],[\"的mark\",{\"1\":{\"85\":1}}],[\"的基础\",{\"1\":{\"82\":1}}],[\"的内容为<term\",{\"1\":{\"875\":1}}],[\"的内容对从数据库做对应的操作\",{\"1\":{\"469\":1,\"580\":1}}],[\"的内存使用过大\",{\"1\":{\"660\":1}}],[\"的内存淘汰策略的选取并不会影响过期的\",{\"1\":{\"636\":1}}],[\"的内存淘汰策略有哪些\",{\"0\":{\"636\":1}}],[\"的内存\",{\"1\":{\"623\":1,\"901\":1}}],[\"的内存空间\",{\"1\":{\"617\":1}}],[\"的内存交互\",{\"0\":{\"73\":1}}],[\"的内核文件\",{\"1\":{\"416\":1}}],[\"的内部类\",{\"1\":{\"42\":1}}],[\"的内部结构\",{\"0\":{\"41\":1}}],[\"的工作效率\",{\"1\":{\"72\":1}}],[\"的响应后\",{\"1\":{\"72\":1}}],[\"的通知\",{\"1\":{\"72\":1,\"817\":1}}],[\"的区别是\",{\"1\":{\"1217\":1}}],[\"的区别就是无论操作数是正数还是负数\",{\"1\":{\"943\":1}}],[\"的区别就在于第二个步骤是否阻塞\",{\"1\":{\"380\":1}}],[\"的区别在于第一步\",{\"1\":{\"380\":1}}],[\"的区别\",{\"0\":{\"61\":1,\"79\":1,\"121\":1,\"183\":1,\"340\":1,\"346\":1,\"367\":1,\"384\":1,\"393\":1,\"478\":1,\"480\":1,\"481\":1,\"483\":1,\"493\":1,\"573\":1,\"652\":1,\"749\":1,\"1048\":1}}],[\"的参数存储在请求的实体主体中\",{\"1\":{\"1041\":1}}],[\"的参数是以查询字符串出现在\",{\"1\":{\"1041\":1}}],[\"的参数中设置enable\",{\"1\":{\"856\":1}}],[\"的参数\",{\"0\":{\"58\":1}}],[\"的任一方法时会被清除\",{\"1\":{\"46\":1}}],[\"的话使用的更多一点\",{\"1\":{\"607\":1}}],[\"的话相比于其他两者更加重量\",{\"1\":{\"607\":1}}],[\"的话索引变成\",{\"1\":{\"406\":1}}],[\"的话索引不变\",{\"1\":{\"406\":1}}],[\"的话会报错\",{\"1\":{\"355\":1}}],[\"的话\",{\"1\":{\"46\":1,\"118\":1,\"870\":1}}],[\"的应用层协议\",{\"1\":{\"1037\":1}}],[\"的应用程序时间和10\",{\"1\":{\"263\":1}}],[\"的应用\",{\"0\":{\"44\":1}}],[\"的方案\",{\"1\":{\"668\":1}}],[\"的方式去实现记忆集\",{\"1\":{\"249\":1}}],[\"的方式\",{\"0\":{\"781\":1},\"1\":{\"40\":2,\"59\":1,\"72\":1,\"647\":1,\"830\":1}}],[\"的方法声明为聚合根的方法\",{\"1\":{\"1245\":1}}],[\"的方法能方便地从互联网上的一个站点访问另一个站点\",{\"1\":{\"1034\":1}}],[\"的方法\",{\"1\":{\"37\":1,\"39\":1,\"358\":1}}],[\"的异同\",{\"0\":{\"37\":1}}],[\"的利用率\",{\"1\":{\"30\":1}}],[\"的依赖注入\",{\"1\":{\"730\":1}}],[\"的依赖\",{\"1\":{\"18\":1}}],[\"的\",{\"0\":{\"129\":1,\"130\":1,\"404\":1,\"860\":1},\"1\":{\"18\":1,\"26\":1,\"61\":1,\"62\":1,\"78\":2,\"89\":1,\"109\":2,\"111\":1,\"118\":1,\"120\":2,\"144\":2,\"160\":1,\"349\":1,\"355\":1,\"381\":1,\"391\":1,\"398\":1,\"399\":3,\"406\":1,\"412\":2,\"413\":4,\"539\":1,\"558\":1,\"577\":1,\"603\":1,\"617\":1,\"619\":1,\"623\":4,\"624\":1,\"628\":1,\"647\":1,\"649\":1,\"673\":1,\"677\":1,\"685\":1,\"717\":1,\"730\":1,\"804\":1,\"832\":1,\"861\":1,\"878\":1,\"892\":1,\"943\":2,\"986\":1,\"1039\":1,\"1061\":1,\"1117\":1,\"1202\":2,\"1245\":1,\"1269\":1}}],[\"的认知大都来自于\",{\"1\":{\"18\":1}}],[\"的元素个数之后\",{\"1\":{\"919\":1}}],[\"的元素又是作为了\",{\"1\":{\"413\":1}}],[\"的元素\",{\"1\":{\"6\":1}}],[\"序号\",{\"1\":{\"1007\":1}}],[\"序列化器\",{\"0\":{\"867\":1},\"1\":{\"867\":2}}],[\"序列化的实现\",{\"1\":{\"344\":1}}],[\"序列化是为了解决在对象流进行读写操作时所引发的问题\",{\"1\":{\"344\":1}}],[\"序列化与反序列化\",{\"0\":{\"344\":1}}],[\"序\",{\"0\":{\"14\":1,\"16\":1,\"18\":1,\"1105\":1,\"1106\":1,\"1108\":1,\"1115\":1,\"1129\":1,\"1133\":1,\"1136\":1}}],[\"贪心\",{\"0\":{\"11\":1}}],[\"二维数组输入\",{\"0\":{\"954\":1}}],[\"二叉线索是一种特殊结构的树\",{\"1\":{\"991\":1}}],[\"二叉平衡树\",{\"0\":{\"916\":1}}],[\"二叉排序树\",{\"0\":{\"915\":1}}],[\"二叉树的高度是\",{\"1\":{\"937\":1}}],[\"二叉树\",{\"0\":{\"9\":1,\"906\":1}}],[\"二是集群节点中用作内部数据结构\",{\"1\":{\"630\":1}}],[\"二进制安全\",{\"1\":{\"624\":1}}],[\"二进制日志\",{\"1\":{\"566\":1}}],[\"二八定律\",{\"1\":{\"606\":1}}],[\"二级缓存也叫全局缓存\",{\"1\":{\"752\":1}}],[\"二级缓存\",{\"1\":{\"752\":2}}],[\"二级索引属于非聚簇索引\",{\"1\":{\"549\":1}}],[\"二级索引\",{\"1\":{\"549\":1}}],[\"二级页表中也存储着\",{\"1\":{\"156\":1}}],[\"二次写\",{\"1\":{\"496\":1}}],[\"二者使用需要权衡\",{\"1\":{\"477\":1}}],[\"二者区别\",{\"1\":{\"359\":1}}],[\"二者区别在于对类型的检查是在编译期还是在运行期\",{\"1\":{\"194\":1}}],[\"二\",{\"0\":{\"52\":1,\"188\":1,\"353\":1,\"1023\":1},\"1\":{\"1240\":1}}],[\"二分查找\",{\"0\":{\"5\":1,\"910\":1}}],[\"vpn只是在效果上和真正的专用网一样\",{\"1\":{\"995\":1}}],[\"vpn\",{\"0\":{\"995\":1},\"1\":{\"995\":1}}],[\"v4\",{\"1\":{\"882\":1}}],[\"vtable\",{\"1\":{\"687\":1}}],[\"v1\",{\"1\":{\"687\":1}}],[\"v>\",{\"1\":{\"399\":3,\"408\":1}}],[\"variables\",{\"1\":{\"557\":1}}],[\"varcahr\",{\"1\":{\"477\":1}}],[\"varchar差不多\",{\"1\":{\"477\":1}}],[\"varchar\",{\"0\":{\"478\":2},\"1\":{\"477\":2,\"478\":3}}],[\"varchar和text的区别\",{\"0\":{\"477\":1}}],[\"var\",{\"0\":{\"443\":1},\"1\":{\"416\":2,\"434\":1,\"443\":2,\"1177\":3}}],[\"var0\",{\"1\":{\"368\":5}}],[\"value来实现\",{\"1\":{\"668\":1}}],[\"values\",{\"1\":{\"565\":1}}],[\"valueof\",{\"1\":{\"368\":3}}],[\"value是一个集合\",{\"1\":{\"265\":1}}],[\"value\",{\"0\":{\"1231\":1},\"1\":{\"39\":4,\"41\":1,\"43\":1,\"45\":1,\"46\":3,\"56\":1,\"299\":1,\"300\":3,\"301\":1,\"316\":1,\"396\":1,\"398\":1,\"407\":2,\"413\":1,\"490\":2,\"603\":1,\"607\":1,\"610\":1,\"614\":2,\"619\":1,\"622\":3,\"637\":2,\"641\":1,\"642\":1,\"672\":1,\"705\":4,\"713\":1,\"734\":1,\"743\":1,\"807\":1,\"892\":1,\"893\":1,\"1035\":2,\"1156\":1,\"1218\":1,\"1260\":2}}],[\"val\",{\"1\":{\"6\":2,\"908\":4,\"955\":6,\"956\":4}}],[\"vscode\",{\"1\":{\"1148\":1,\"1149\":1}}],[\"vs\",{\"0\":{\"354\":1,\"362\":1,\"386\":1,\"388\":1,\"389\":1,\"390\":1,\"407\":1,\"408\":1,\"981\":1,\"982\":1,\"996\":1,\"1204\":1},\"1\":{\"484\":1,\"1204\":1}}],[\"vmlinuz\",{\"1\":{\"416\":1}}],[\"vm\",{\"1\":{\"313\":1,\"604\":1}}],[\"vite6\",{\"1\":{\"1148\":1}}],[\"vite\",{\"1\":{\"1139\":1,\"1148\":1}}],[\"view层因为耦合度比较高\",{\"1\":{\"766\":1}}],[\"view层\",{\"0\":{\"765\":1}}],[\"viewresolver\",{\"1\":{\"755\":4,\"756\":1,\"770\":1}}],[\"view中的重要字段分别是\",{\"1\":{\"499\":1}}],[\"view\",{\"1\":{\"499\":3,\"748\":1,\"754\":3,\"755\":1,\"756\":3}}],[\"viewer客户端工具\",{\"1\":{\"281\":1}}],[\"viewer等阅读器一个一个二进制的看\",{\"1\":{\"281\":1}}],[\"virtual\",{\"1\":{\"335\":1}}],[\"visual\",{\"0\":{\"1149\":1},\"1\":{\"313\":1,\"1144\":1,\"1148\":1}}],[\"venv\",{\"1\":{\"1170\":1}}],[\"vectree\",{\"1\":{\"956\":7}}],[\"vector\",{\"0\":{\"392\":1},\"1\":{\"108\":1,\"393\":2}}],[\"vec\",{\"1\":{\"956\":6}}],[\"version\",{\"1\":{\"795\":1}}],[\"version>\",{\"1\":{\"776\":1,\"795\":1,\"796\":1,\"800\":3,\"882\":1}}],[\"verbose\",{\"1\":{\"270\":1,\"325\":1,\"1190\":1}}],[\"v\",{\"1\":{\"105\":3,\"106\":1,\"312\":1,\"448\":1,\"452\":1,\"610\":2,\"793\":2,\"1144\":1}}],[\"vv\",{\"1\":{\"94\":1}}],[\"volar\",{\"0\":{\"1150\":1}}],[\"volar2\",{\"1\":{\"1148\":1,\"1150\":1}}],[\"volatile保证可见性\",{\"1\":{\"337\":1}}],[\"volatile关键字\",{\"0\":{\"296\":1}}],[\"volatile关键字本身就包含了禁止指令重排序的语义\",{\"1\":{\"295\":1}}],[\"volatile的特殊规则保证了新值能立即同步到主内存\",{\"1\":{\"295\":1}}],[\"volatile\",{\"0\":{\"78\":1,\"79\":1},\"1\":{\"67\":1,\"69\":2,\"71\":3,\"74\":1,\"75\":3,\"78\":7,\"79\":5,\"81\":1,\"101\":3,\"102\":3,\"105\":1,\"110\":1,\"111\":1,\"129\":1,\"130\":1,\"141\":1,\"295\":2,\"296\":1,\"337\":1,\"409\":1,\"410\":1,\"636\":3,\"706\":4,\"1068\":3}}],[\"void\",{\"1\":{\"31\":3,\"33\":1,\"39\":2,\"98\":4,\"110\":1,\"126\":2,\"227\":1,\"277\":4,\"304\":2,\"626\":1,\"930\":1,\"931\":2,\"932\":2,\"933\":3,\"934\":3,\"935\":5,\"936\":1,\"937\":4,\"951\":1,\"952\":1,\"953\":1,\"955\":1,\"956\":1,\"1077\":2,\"1082\":4,\"1257\":1}}],[\"vuepress\",{\"0\":{\"1207\":1},\"1\":{\"1115\":1,\"1134\":2,\"1139\":5,\"1200\":1,\"1208\":4,\"1209\":1,\"1210\":2}}],[\"vuepress2\",{\"1\":{\"1\":1}}],[\"vue3\",{\"1\":{\"687\":1,\"1148\":1}}],[\"vue\",{\"1\":{\"24\":1,\"689\":2,\"690\":1,\"692\":1,\"695\":1,\"696\":1,\"1134\":1,\"1139\":2,\"1148\":4,\"1150\":4,\"1151\":1,\"1157\":1,\"1159\":1,\"1163\":1}}],[\"+source2\",{\"1\":{\"1255\":1,\"1256\":1}}],[\"+4\",{\"1\":{\"1012\":1}}],[\"+=\",{\"1\":{\"952\":1}}],[\"+left\",{\"1\":{\"935\":1}}],[\"++\",{\"1\":{\"930\":1,\"931\":2,\"932\":1,\"934\":1}}],[\"+1\",{\"1\":{\"930\":1}}],[\"+o\",{\"1\":{\"893\":1}}],[\"+压缩链表\",{\"1\":{\"618\":1}}],[\"+doescapeanalysis\",{\"1\":{\"326\":1}}],[\"+disableexplicitgc\",{\"1\":{\"326\":1}}],[\"+heapdumpbeforefullgc\",{\"1\":{\"324\":1}}],[\"+heapdumponoutofmemoryerror\",{\"1\":{\"324\":1}}],[\"+|\",{\"1\":{\"317\":1}}],[\"+unlockexperimentalvmoptions使用\",{\"1\":{\"316\":1}}],[\"+unlockdiagnosticvmoptions和\",{\"1\":{\"316\":1}}],[\"+usetlab\",{\"1\":{\"326\":1}}],[\"+usecompressedclasspointers\",{\"1\":{\"323\":1}}],[\"+usecompressedoops\",{\"1\":{\"323\":1}}],[\"+useadaptivesizepolicy\",{\"1\":{\"322\":1}}],[\"+userg1gc\",{\"1\":{\"262\":1}}],[\"+useparnewgc\",{\"1\":{\"253\":1}}],[\"+xx\",{\"1\":{\"316\":1}}],[\"+<opyion>表示启动option属性\",{\"1\":{\"316\":1}}],[\"+printtlab\",{\"1\":{\"326\":1}}],[\"+printtenuringdistribution\",{\"1\":{\"322\":1}}],[\"+printvmoptions\",{\"1\":{\"319\":1}}],[\"+printflagsinitial\",{\"1\":{\"319\":1}}],[\"+printflagsfinal\",{\"1\":{\"316\":1,\"319\":1}}],[\"+printheapatgc\",{\"1\":{\"270\":1,\"325\":1}}],[\"+printgcdetails\",{\"1\":{\"317\":1,\"325\":1}}],[\"+printgcdetials\",{\"1\":{\"270\":1}}],[\"+printgcdatastamps\",{\"1\":{\"270\":1,\"325\":1}}],[\"+printgctimestamps\",{\"1\":{\"270\":1,\"325\":1}}],[\"+printgc\",{\"1\":{\"270\":1,\"325\":1}}],[\"+printcommandlineflags\",{\"1\":{\"253\":1,\"319\":1}}],[\"+\",{\"1\":{\"1\":1,\"56\":1,\"96\":2,\"98\":2,\"128\":1,\"129\":1,\"136\":2,\"219\":1,\"252\":1,\"368\":1,\"395\":2,\"406\":1,\"407\":1,\"433\":2,\"491\":1,\"548\":3,\"642\":2,\"807\":1,\"816\":1,\"836\":1,\"856\":1,\"881\":2,\"893\":1,\"911\":2,\"912\":2,\"913\":3,\"930\":3,\"934\":5,\"935\":2,\"937\":5,\"955\":1,\"956\":3,\"1012\":1}}],[\"02quickstartwithdocker\",{\"1\":{\"1179\":1}}],[\"0rc\",{\"1\":{\"1139\":1}}],[\"0rtt\",{\"1\":{\"1042\":1}}],[\"0基础上设计的协议\",{\"1\":{\"1062\":1}}],[\"0采用二进制格式传输数据\",{\"1\":{\"1042\":1}}],[\"0来说\",{\"1\":{\"1042\":1}}],[\"0版本的缺点是每请求一个文档都要进行3次握手和一个http响应报文\",{\"1\":{\"1042\":1}}],[\"0规定浏览器与服务器只保持短暂的连接\",{\"1\":{\"1042\":1}}],[\"0bject\",{\"1\":{\"1035\":1}}],[\"0变1\",{\"1\":{\"974\":1}}],[\"0时\",{\"1\":{\"948\":1}}],[\"0表示未出现\",{\"1\":{\"883\":1}}],[\"0~16383\",{\"1\":{\"679\":1}}],[\"0xfe\",{\"1\":{\"627\":1}}],[\"0x2a34\",{\"1\":{\"201\":1}}],[\"05\",{\"1\":{\"533\":2}}],[\"08\",{\"1\":{\"475\":1}}],[\"01变10\",{\"1\":{\"900\":1}}],[\"01表示出现一次\",{\"1\":{\"900\":1}}],[\"01\",{\"1\":{\"84\":1,\"475\":1,\"882\":2,\"1038\":1}}],[\"001\",{\"1\":{\"1144\":1}}],[\"00表示不存在\",{\"1\":{\"900\":1}}],[\"000\",{\"1\":{\"824\":1}}],[\"00001111\",{\"1\":{\"405\":1}}],[\"0000000010\",{\"1\":{\"476\":1}}],[\"00000000\",{\"1\":{\"405\":2}}],[\"00\",{\"1\":{\"84\":1}}],[\"0\",{\"0\":{\"3\":1,\"14\":1,\"16\":1,\"18\":1,\"1042\":3,\"1103\":1,\"1105\":1,\"1106\":1,\"1108\":1,\"1115\":1,\"1121\":1,\"1129\":1,\"1133\":1,\"1136\":1,\"1138\":1,\"1208\":1,\"1249\":1},\"1\":{\"1\":2,\"56\":1,\"58\":3,\"81\":1,\"82\":2,\"85\":1,\"89\":2,\"96\":5,\"114\":1,\"118\":4,\"123\":2,\"134\":2,\"160\":7,\"233\":1,\"336\":1,\"368\":2,\"399\":3,\"405\":1,\"406\":2,\"433\":1,\"449\":1,\"476\":1,\"490\":1,\"517\":2,\"568\":1,\"571\":1,\"582\":2,\"610\":1,\"623\":10,\"624\":3,\"641\":1,\"645\":2,\"653\":2,\"659\":3,\"660\":1,\"668\":1,\"669\":1,\"678\":1,\"680\":1,\"687\":1,\"795\":1,\"796\":1,\"800\":2,\"854\":1,\"856\":1,\"860\":1,\"879\":1,\"882\":3,\"888\":3,\"911\":1,\"912\":1,\"913\":2,\"930\":3,\"931\":3,\"932\":1,\"933\":3,\"934\":3,\"935\":3,\"936\":1,\"937\":5,\"938\":4,\"943\":2,\"946\":1,\"948\":1,\"951\":3,\"952\":1,\"953\":3,\"954\":1,\"955\":3,\"956\":3,\"973\":2,\"987\":1,\"993\":3,\"1000\":1,\"1015\":1,\"1038\":3,\"1042\":8,\"1094\":2,\"1139\":11,\"1140\":11,\"1148\":5,\"1150\":1,\"1170\":4,\"1177\":4,\"1184\":1,\"1192\":2,\"1212\":2,\"1263\":1}}]],\"version\":2}}")).map(([e,t])=>[e,It(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const r=Ct[s];e==="suggest"?self.postMessage([e,o,tt(t,r,n)]):e==="search"?self.postMessage([e,o,Z(t,r,n)]):self.postMessage({suggestions:[e,o,tt(t,r,n)],results:[e,o,Z(t,r,n)]})};
//# sourceMappingURL=index.js.map
