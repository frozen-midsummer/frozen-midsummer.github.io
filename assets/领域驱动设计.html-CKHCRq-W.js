import{_ as e,c as n,b as l,o as i}from"./app-DYAirNoF.js";const p="/assets/%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87_%E5%9F%9F_%E8%81%9A%E5%90%88_%E5%AE%9E%E4%BD%93_%E5%80%BC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB-DQbeymRx.png",s="/assets/%E5%AE%9E%E4%BD%93%E4%B8%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%85%B3%E7%B3%BB-Dl_fuhvS.png",t="/assets/project_structure-Cc_oH4cp.png",h={};function d(r,a){return i(),n("div",null,a[0]||(a[0]=[l('<h2 id="_1-战略设计" tabindex="-1"><a class="header-anchor" href="#_1-战略设计"><span>1 战略设计</span></a></h2><p>主要的过程大致包括业务场景分析、领域建模、划分边界上下文三个阶段。</p><h3 id="_1-1-业务分析" tabindex="-1"><a class="header-anchor" href="#_1-1-业务分析"><span>1.1 业务分析</span></a></h3><p>主要包括：</p><ul><li><p>用例分析法</p></li><li><p>事件风暴法</p></li><li><p>四色建模法。</p></li></ul><p>一般使用事件风暴法</p><p>事件风暴过程需要问题驱动，一般通过提问的方式来驱动交流。</p><p>事件风暴主要完成以下两个目标：</p><p>a. 分析业务中的事件，搞清楚事件发生的前因后果</p><ul><li>即什么动作会导致当前事件的发生，当前事件发生后又会有什么后果</li><li>注意不但要关注正常的业务流程，也要关注异常的业务流程</li></ul><p>b. 寻找业务逻辑和业务规则</p><ul><li>对业务涉及到的参与者、动作以及事件进行全面的梳理</li></ul><h3 id="_1-2-领域建模" tabindex="-1"><a class="header-anchor" href="#_1-2-领域建模"><span>1.2 领域建模</span></a></h3><p>领域建模是整个 DDD 的核心，DDD 领域模型可细分为两步骤：</p><p>第一步是发散，产生很多实体（entity, 与 DO 的区别是 entity 是类似充血的的对象，可以定义方法/行为）、命令、事件等领域对象（DomainObject）</p><p>第二步是收敛，我们从不同的维度对之发散的产物进行聚类形成聚合，建立最终领域模型， 这是一个收敛的过程。</p><h4 id="_1-2-1-发散阶段-领域对象分析" tabindex="-1"><a class="header-anchor" href="#_1-2-1-发散阶段-领域对象分析"><span>1.2.1 发散阶段：领域对象分析</span></a></h4><p>领域对象分析，也就是对实体、值对象（Value Object）、领域事件（Domain Events）、领域命令的分析。</p><h4 id="_1-2-2-收敛阶段-构建业务聚合" tabindex="-1"><a class="header-anchor" href="#_1-2-2-收敛阶段-构建业务聚合"><span>1.2.2 收敛阶段：构建业务聚合</span></a></h4><p>完成领域对象分析之后，我们需要构建业务聚合，想要构建聚合，那么首先就要在实体中找到聚合根。</p><p>聚合根的主要特点有：</p><ul><li><p>聚合根一定是实体，那么它具有全局唯一的标识 （<span style="color:red;">？</span>注：标识是一个类似 ID 的东西，收敛出的业务聚合内的类都继承这个聚合根实体？）</p></li><li><p>聚合根是具备生命周期的（这个后续再看解释）</p></li><li><p>聚合根需要专门的模块来进行管理（？？）</p></li></ul><h3 id="_1-3-划分边界上下文" tabindex="-1"><a class="header-anchor" href="#_1-3-划分边界上下文"><span>1.3 划分边界上下文</span></a></h3><p>得到整个业务流程中的所有聚合之后，我们需要将聚合划分到更具业务语义的上下文中</p><h4 id="_1-3-1-域的拆分" tabindex="-1"><a class="header-anchor" href="#_1-3-1-域的拆分"><span>1.3.1 域的拆分</span></a></h4><p>域是否是 domain？域和上下文的关系是什么？</p><p>就是将业务拆分成多个子域，比如电商系统可以包含商品子域、订单子域、用户子域等等。域的翻译是 domain，但此处“域的拆分”中的域是指业务进行上下文拆分之后形成的 domain/子域，<strong><em>每个子域都可以作为一个独立的微服务进行设计和开发</em></strong>，从而实现更好的业务解耦和系统扩展性。</p><p>域和上下文的关系：上下文更像是一个环境、位置的概念，域是上下文中的一块内容。</p><p>文档解释：限界上下文是业务的边界的划分，这个边界可以是一个领域或者多个领域的集合。复杂业务需要多个域编排完成一个复杂业务流程。限界上下文可以作为微服务划分的方法。其本质还是高内聚低耦合，只是限界上下文只是站在更高的层面来进行划分。如何进行划分，我的方法是一个界限上下文必须支持一个完整的业务流程，保证这个业务流程所涉及的领域都在一个限界上下文中。</p><h4 id="_1-3-2-防腐" tabindex="-1"><a class="header-anchor" href="#_1-3-2-防腐"><span>1.3.2 防腐</span></a></h4><p>一个上下文通过一些适配（adapter）和转换与另一个上下文交互。</p><h4 id="_1-3-3-限界上下文之间的映射关系" tabindex="-1"><a class="header-anchor" href="#_1-3-3-限界上下文之间的映射关系"><span>1.3.3 限界上下文之间的映射关系</span></a></h4><h2 id="_2-战略设计" tabindex="-1"><a class="header-anchor" href="#_2-战略设计"><span>2 战略设计</span></a></h2><p>经历了战略设计之后，我们构建了领域模型（先发散后收敛，构建聚合），划分了边界上下文，接下来将领域模型映射到工程结构，实现代码的开发落地。在这个阶段还有一些细节需要明确。</p><h3 id="_2-1-领域服务设计" tabindex="-1"><a class="header-anchor" href="#_2-1-领域服务设计"><span>2.1 领域服务设计</span></a></h3><p>需要哪些领域服务，领域服务依赖哪些属性，依赖哪些实体，依赖哪些值对象，这些都是需要在战术设计阶段明确下来。</p><h3 id="_2-2-领域分层" tabindex="-1"><a class="header-anchor" href="#_2-2-领域分层"><span>2.2 领域分层</span></a></h3><p>在领域分层方面，可以按照 cola 分层结构来进行，这个后面结合 cola 框架进行说明。</p><h3 id="_2-3-代码结构" tabindex="-1"><a class="header-anchor" href="#_2-3-代码结构"><span>2.3 代码结构</span></a></h3><p>当我们把领域对象进行进一步的细化之后，同时把对应的领域服务敲定之后，我们可以把这些分析后的内容映射成工程分层后的代码了。</p><h2 id="_3-ddd-基本概念" tabindex="-1"><a class="header-anchor" href="#_3-ddd-基本概念"><span>3 DDD 基本概念</span></a></h2><h3 id="_3-2-事件" tabindex="-1"><a class="header-anchor" href="#_3-2-事件"><span>3.2 事件</span></a></h3><p>一般采用 发布-订阅 模式。代码层面可以通过事件总线或消息队列间接通信。</p><h3 id="_3-3-实体-entity" tabindex="-1"><a class="header-anchor" href="#_3-3-实体-entity"><span>3.3 实体（Entity）</span></a></h3><p>实体具有唯一标识（例如审批单编号），有生命周期且具有延续性（我理解为审批单不随属性的变化而变化）。实体代码应该包括属性和行为，也就是我们说的充血模型，但是实体在复杂场景下需要编排领域服务，会导致事务过长影响性能。所以使用充血模型的时候，在行为里面只涉及业务逻辑的内存操作，不涉及过长的数据库事务。</p><h3 id="_3-4-值对象-value-object" tabindex="-1"><a class="header-anchor" href="#_3-4-值对象-value-object"><span>3.4 值对象（Value Object）</span></a></h3><p>值对象没有唯一标识，没有生命周期，不可修改，当值对象发生改变时只能替换（例如 String 的实现）。</p><h3 id="_3-5-聚合和聚合根" tabindex="-1"><a class="header-anchor" href="#_3-5-聚合和聚合根"><span>3.5 聚合和聚合根</span></a></h3><p>多个实体和值对象组成的集合叫聚合，聚合内部一定高内聚。聚合里面一定有一个实体是聚合根。</p><p>作用：保证内部实体的一致性。外部操作聚合内部的实体时，只需要操作聚合根。</p><p>聚合与领域可以是一对一的关系，也可以是一对多的关系。</p><h3 id="_3-6-限界上下文-域-聚合-实体-值对象的关系" tabindex="-1"><a class="header-anchor" href="#_3-6-限界上下文-域-聚合-实体-值对象的关系"><span>3.6 限界上下文，域，聚合，实体，值对象的关系</span></a></h3><p>领域包含限界上下文，限界上下文包含子域，子域包含聚合，聚合包含实体和值对象。</p><img src="'+p+'" width="600" height="auto" alt="限界上下文_域_聚合_实体_值对象的关系"><h3 id="_3-7-实体和事件的关系" tabindex="-1"><a class="header-anchor" href="#_3-7-实体和事件的关系"><span>3.7 实体和事件的关系</span></a></h3><p>在事件风暴中，我们会分析领域内的业务动作和行为，实体执行命令/做出行为会触发事件。</p><img src="'+s+'" width="600" height="auto" alt="实体和事件的关系"><h2 id="_4-ddd-代码实践" tabindex="-1"><a class="header-anchor" href="#_4-ddd-代码实践"><span>4 DDD 代码实践</span></a></h2><h3 id="_4-1-ddd-规范" tabindex="-1"><a class="header-anchor" href="#_4-1-ddd-规范"><span>4.1 DDD 规范</span></a></h3><p>DDD 的代码实践中，规范大于技巧，DDD 架构可以避免引入一些其他概念，系统只有域，域服务，聚合根，实体，值对象，事件来构建系统。</p><h3 id="_4-2-工程结构" tabindex="-1"><a class="header-anchor" href="#_4-2-工程结构"><span>4.2 工程结构</span></a></h3><p><img src="'+t+'" alt="图片"></p><h4 id="_4-2-1-application-模块" tabindex="-1"><a class="header-anchor" href="#_4-2-1-application-模块"><span>4.2.1 application 模块</span></a></h4><ul><li>CRQS 模式 command 和 query 分离</li><li>重点做跨域的编排工作，无业务逻辑</li></ul><h4 id="_4-2-2-domain-模块" tabindex="-1"><a class="header-anchor" href="#_4-2-2-domain-模块"><span>4.2.2 domain 模块</span></a></h4><ul><li>域服务、聚合根、值对象、领域参数、仓库（repository，与持久化存储（如数据库）交互，一般包括增删改查方法）定义</li></ul><h5 id="_4-2-2-1-聚合根" tabindex="-1"><a class="header-anchor" href="#_4-2-2-1-聚合根"><span>4.2.2.1 聚合根</span></a></h5><p>以 base-sever 中的 Counterparty 子域为例，交易对手是这个子域中的实体，但是这个子域中只有一个实体，所以没有聚合根。</p><p>以下文档中给出的聚合根实践中，实体是聚合根中的一个属性。</p><p><a href="https://blog.csdn.net/qq_45038038/article/details/135132480" target="_blank" rel="noopener noreferrer">DDD 领域驱动设计内容分享(二)：为什么需要 DDD？_领域驱动设计 ddd-CSDN 博客</a></p><h3 id="_4-3-代码示例" tabindex="-1"><a class="header-anchor" href="#_4-3-代码示例"><span>4.3 代码示例</span></a></h3><h4 id="_4-3-1-domainservice-示例" tabindex="-1"><a class="header-anchor" href="#_4-3-1-domainservice-示例"><span>4.3.1 domainService 示例</span></a></h4><ul><li><p>领域层不依赖基础层的实现：coordinationRepository 只是接口，在领域层定义好，由基础层依赖领域层实现这个接口。ps：这个已经讲的很清楚了，领域层只定义接口访问基础设施层，接口由基础设施层去实现，将业务逻辑和技术（Mybatis, redis, MQ, ...）解耦。</p></li><li><p>业务逻辑和技术解耦：域服务这层通过调用 coordinationRepository 和聚合根将业务逻辑和技术解耦。</p></li><li><p>聚合根的方法无副作用：聚合根的方法只对聚合根内部实体属性的改变，不做持久化动作，可反复测试。ps：这一点很重要，DDD 中最重要的就是规范，聚合根的方法不做持久化，放到域服务里面做持久化。</p></li><li><p>模型与数据分离：</p><ul><li><p>改变模型：caseAggregate.handle(handleParam.getFollowerValue())。ps：就是只操作内存中的变量。</p></li><li><p>改变数据：coordinationRepository.save(caseAggregate)；事务是在 save 方法上。ps：就是做持久化。</p></li></ul></li></ul><h4 id="_4-3-2-aggregate-entity-示例" tabindex="-1"><a class="header-anchor" href="#_4-3-2-aggregate-entity-示例"><span>4.3.2 Aggregate, Entity 示例</span></a></h4><p><strong>规范大于技巧：</strong> <strong><em>DDD 架构可以避免引入一些其他概念，系统只有域，域服务，聚合根，实体，值对象，事件来构建系统。</em></strong></p><h2 id="_5-f-q" tabindex="-1"><a class="header-anchor" href="#_5-f-q"><span>5 F&amp;Q</span></a></h2><h3 id="_5-1" tabindex="-1"><a class="header-anchor" href="#_5-1"><span>5.1</span></a></h3><p>聚合根怎样将聚合内的值对象和实体聚合在一起？DomainService 如何将散落的服务聚合在一起？</p><p>柏安的理解：有 ID 的 entity 就算聚合根，这个聚合根要存库，所有聚合根外的操作，都透过这个聚合根处理。</p><p>领域内的其余 Entity 都透过这个聚合根访问聚合内部。即 Entity 声明为聚合根的一个 private final 属性，Entity 的方法声明为聚合根的方法，可以抛出聚合根异常。</p><h3 id="_5-2" tabindex="-1"><a class="header-anchor" href="#_5-2"><span>5.2</span></a></h3><p>实体既然是聚合根中的一个属性，那如果只有聚合根存库的话，实体中的属性全部展开？</p>',82)]))}const c=e(h,[["render",d]]),o=JSON.parse('{"path":"/serverside/designmodel/dddlearning/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1.html","title":"DDD Learning","lang":"zh-CN","frontmatter":{"lang":"zh-CN","title":"DDD Learning","description":"DDD学习笔记","sidebar":"heading"},"headers":[{"level":2,"title":"1 战略设计","slug":"_1-战略设计","link":"#_1-战略设计","children":[{"level":3,"title":"1.1 业务分析","slug":"_1-1-业务分析","link":"#_1-1-业务分析","children":[]},{"level":3,"title":"1.2 领域建模","slug":"_1-2-领域建模","link":"#_1-2-领域建模","children":[]},{"level":3,"title":"1.3 划分边界上下文","slug":"_1-3-划分边界上下文","link":"#_1-3-划分边界上下文","children":[]}]},{"level":2,"title":"2 战略设计","slug":"_2-战略设计","link":"#_2-战略设计","children":[{"level":3,"title":"2.1 领域服务设计","slug":"_2-1-领域服务设计","link":"#_2-1-领域服务设计","children":[]},{"level":3,"title":"2.2 领域分层","slug":"_2-2-领域分层","link":"#_2-2-领域分层","children":[]},{"level":3,"title":"2.3 代码结构","slug":"_2-3-代码结构","link":"#_2-3-代码结构","children":[]}]},{"level":2,"title":"3 DDD 基本概念","slug":"_3-ddd-基本概念","link":"#_3-ddd-基本概念","children":[{"level":3,"title":"3.2 事件","slug":"_3-2-事件","link":"#_3-2-事件","children":[]},{"level":3,"title":"3.3 实体（Entity）","slug":"_3-3-实体-entity","link":"#_3-3-实体-entity","children":[]},{"level":3,"title":"3.4 值对象（Value Object）","slug":"_3-4-值对象-value-object","link":"#_3-4-值对象-value-object","children":[]},{"level":3,"title":"3.5 聚合和聚合根","slug":"_3-5-聚合和聚合根","link":"#_3-5-聚合和聚合根","children":[]},{"level":3,"title":"3.6 限界上下文，域，聚合，实体，值对象的关系","slug":"_3-6-限界上下文-域-聚合-实体-值对象的关系","link":"#_3-6-限界上下文-域-聚合-实体-值对象的关系","children":[]},{"level":3,"title":"3.7 实体和事件的关系","slug":"_3-7-实体和事件的关系","link":"#_3-7-实体和事件的关系","children":[]}]},{"level":2,"title":"4 DDD 代码实践","slug":"_4-ddd-代码实践","link":"#_4-ddd-代码实践","children":[{"level":3,"title":"4.1 DDD 规范","slug":"_4-1-ddd-规范","link":"#_4-1-ddd-规范","children":[]},{"level":3,"title":"4.2 工程结构","slug":"_4-2-工程结构","link":"#_4-2-工程结构","children":[]},{"level":3,"title":"4.3 代码示例","slug":"_4-3-代码示例","link":"#_4-3-代码示例","children":[]}]},{"level":2,"title":"5 F&Q","slug":"_5-f-q","link":"#_5-f-q","children":[{"level":3,"title":"5.1","slug":"_5-1","link":"#_5-1","children":[]},{"level":3,"title":"5.2","slug":"_5-2","link":"#_5-2","children":[]}]}],"git":{"updatedTime":1732937745000,"contributors":[{"name":"wangjiaxuan","email":"610798187@qq.com","commits":2,"url":"https://github.com/wangjiaxuan"}]},"filePathRelative":"serverside/designmodel/dddlearning/领域驱动设计.md","excerpt":"<h2>1 战略设计</h2>\\n<p>主要的过程大致包括业务场景分析、领域建模、划分边界上下文三个阶段。</p>\\n<h3>1.1 业务分析</h3>\\n<p>主要包括：</p>\\n<ul>\\n<li>\\n<p>用例分析法</p>\\n</li>\\n<li>\\n<p>事件风暴法</p>\\n</li>\\n<li>\\n<p>四色建模法。</p>\\n</li>\\n</ul>\\n<p>一般使用事件风暴法</p>\\n<p>事件风暴过程需要问题驱动，一般通过提问的方式来驱动交流。</p>\\n<p>事件风暴主要完成以下两个目标：</p>\\n<p>a. 分析业务中的事件，搞清楚事件发生的前因后果</p>\\n<ul>\\n<li>即什么动作会导致当前事件的发生，当前事件发生后又会有什么后果</li>\\n<li>注意不但要关注正常的业务流程，也要关注异常的业务流程</li>\\n</ul>"}');export{c as comp,o as data};
